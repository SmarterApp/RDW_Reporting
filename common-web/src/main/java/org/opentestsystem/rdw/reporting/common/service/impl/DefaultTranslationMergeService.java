package org.opentestsystem.rdw.reporting.common.service.impl;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.google.common.collect.Ordering;
import org.opentestsystem.rdw.reporting.common.i18n.TranslationProvider;
import org.opentestsystem.rdw.reporting.common.service.TranslationMergeService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Set;

/**
 * This will read messages from registered {@link TranslationProvider} instances.
 */
@Service
public class DefaultTranslationMergeService implements TranslationMergeService {
    private final static Logger logger = LoggerFactory.getLogger(DefaultTranslationMergeService.class);
    private final static Ordering<TranslationProvider> ProviderOrdering = Ordering
            .natural()
            .onResultOf(TranslationProvider::getOrder);

    private final List<TranslationProvider> translationProviders;
    private final ObjectMapper objectMapper;

    @Autowired
    public DefaultTranslationMergeService(final Set<TranslationProvider> translationProviders,
                                          final ObjectMapper objectMapper) {
        this.translationProviders = ProviderOrdering.sortedCopy(translationProviders);
        this.objectMapper = objectMapper;
    }

    @Override
    @Cacheable(value = "mergeTranslations", key = "#locale.toString()")
    public ObjectNode getLocaleMessages(final Locale locale) {
        final ObjectNode messages = objectMapper.createObjectNode();
        for (final TranslationProvider provider : translationProviders) {
            deepMerge(messages, provider.getMessages(locale));
        }

        return messages;
    }

    private void deepMerge(final ObjectNode target, final ObjectNode source) {
        final Iterator<String> fieldNames = source.fieldNames();
        while (fieldNames.hasNext()) {
            final String fieldName = fieldNames.next();
            final JsonNode sourceProp = source.get(fieldName);
            final JsonNode targetProp = target.get(fieldName);
            if (targetProp == null) {
                target.set(fieldName, sourceProp);
                continue;
            }

            if (targetProp.isObject() && sourceProp.isObject()) {
                deepMerge((ObjectNode)targetProp, (ObjectNode) sourceProp);
                continue;
            }

            // Just overwrite rather than merge arrays, although we shouldn't see any
            // in our translation JSON/Properties
            if (targetProp.isArray() && sourceProp.isArray()) {
                target.replace(fieldName, sourceProp);
                continue;
            }

            if (targetProp.isValueNode() && sourceProp.isValueNode()) {
                target.replace(fieldName, sourceProp);
                continue;
            }

            logger.warn("Unable to merge property: {} in {}", fieldName, source);
        }
    }
}
