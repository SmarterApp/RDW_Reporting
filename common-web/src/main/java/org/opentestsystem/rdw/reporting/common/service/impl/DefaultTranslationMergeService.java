package org.opentestsystem.rdw.reporting.common.service.impl;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.fasterxml.jackson.dataformat.javaprop.JavaPropsMapper;
import org.opentestsystem.rdw.reporting.common.configuration.TenantProperties;
import org.opentestsystem.rdw.reporting.common.i18n.TranslationService;
import org.opentestsystem.rdw.reporting.common.service.FrontendTranslationService;
import org.opentestsystem.rdw.reporting.common.service.TranslationMergeService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;
import java.util.Locale;
import java.util.Properties;

import static org.springframework.util.StringUtils.isEmpty;

/**
 * This will read messages from (in order of preference):<ol>
 *     <li>{@link TenantProperties#getTranslationLocation()}</li>
 *     <li>database translation table</li>
 * </ol>
 */
@Service
public class DefaultTranslationMergeService implements TranslationMergeService {
    private final static Logger logger = LoggerFactory.getLogger(DefaultTranslationMergeService.class);

    private final TenantProperties tenantProperties;
    private final ResourceLoader resourceLoader;
    private final ObjectMapper objectMapper;
    private final TranslationService translationService;

    public DefaultTranslationMergeService(final TenantProperties tenantProperties,
                                          final ResourceLoader resourceLoader,
                                          final ObjectMapper objectMapper,
                                          final FrontendTranslationService translationService) {
        this.tenantProperties = tenantProperties;
        this.resourceLoader = resourceLoader;
        this.objectMapper = objectMapper;
        this.translationService = translationService;
    }

    //TODO Consider application-level caching scheme - this should almost never change.
    @Override
    public ObjectNode getLocaleMessages(final Locale locale) {
        final ObjectNode messages = new ObjectNode(objectMapper.getNodeFactory());

        final Properties translationProperties = new Properties();
        translationProperties.putAll(translationService.getTranslationsByCode(locale));
        appendProperties(messages, translationProperties);

        if (isEmpty(tenantProperties.getTranslationLocation())) {
            return messages;
        }

        final Resource externalMessages = resourceLoader.getResource(getExternalLocation(locale));
        appendResource(messages, externalMessages);

        return messages;
    }

    private String getExternalLocation(final Locale locale) {
        return tenantProperties.getTranslationLocation() + locale.getLanguage() + ".json";
    }

    private void appendProperties(final ObjectNode messages, final Properties properties) {
        try {
            final JavaPropsMapper propsMapper = new JavaPropsMapper();
            final String output = propsMapper.writeValueAsString(properties);
            final ObjectNode object = (ObjectNode) propsMapper.readTree(output);
            deepMerge(messages, object);
        } catch (final IOException e) {
            logger.error("Unable to parse database translations", e);
        }
    }

    private void appendResource(final ObjectNode messages, final Resource resource) {
        if (!resource.exists()) {
            return;
        }

        try (final InputStream in = resource.getInputStream()) {
            final JsonNode resourceNode =  objectMapper.readTree(in);
            if (resourceNode.isObject()) {
                deepMerge(messages, (ObjectNode) resourceNode);
            }
        } catch (final IOException e) {
            logger.warn("Unable to open translation resource: {}", resource);
        }
    }

    private void deepMerge(final ObjectNode target, final ObjectNode source) {
        final Iterator<String> fieldNames = source.fieldNames();
        while (fieldNames.hasNext()) {
            final String fieldName = fieldNames.next();
            final JsonNode sourceProp = source.get(fieldName);
            final JsonNode targetProp = target.get(fieldName);
            if (targetProp == null) {
                target.set(fieldName, sourceProp);
                continue;
            }

            if (targetProp.isObject() && sourceProp.isObject()) {
                deepMerge((ObjectNode)targetProp, (ObjectNode) sourceProp);
                continue;
            }

            // Just overwrite rather than merge arrays, although we shouldn't see any
            // in our translation JSON/Properties
            if (targetProp.isArray() && sourceProp.isArray()) {
                target.replace(fieldName, sourceProp);
                continue;
            }

            if (targetProp.isValueNode() && sourceProp.isValueNode()) {
                target.replace(fieldName, sourceProp);
                continue;
            }

            logger.warn("Unable to merge property: {} in {}", fieldName, source);
        }
    }
}
