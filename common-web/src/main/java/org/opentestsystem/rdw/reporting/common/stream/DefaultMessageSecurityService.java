package org.opentestsystem.rdw.reporting.common.stream;

import org.opentestsystem.rdw.reporting.common.security.User;
import org.opentestsystem.rdw.reporting.common.web.security.jwt.JwtService;
import org.opentestsystem.rdw.reporting.common.web.security.jwt.support.BearerAuthorizationHeaders;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.support.MessageBuilder;

import static com.google.common.net.HttpHeaders.AUTHORIZATION;

/**
 * Default implementation of a MessageSecurityService using JWT and Bearer tokens as a message header.
 */
public class DefaultMessageSecurityService implements MessageSecurityService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultMessageSecurityService.class);

    private final JwtService jwtService;

    public DefaultMessageSecurityService(final JwtService jwtService) {
        this.jwtService = jwtService;
    }

    @Override
    public <T> Message<T> withUser(final Message<T> message, final User user) {
        final String jwt = jwtService.encode(user);
        final String bearerToken = BearerAuthorizationHeaders.create(jwt);

        return MessageBuilder.fromMessage(message)
                .setHeader(AUTHORIZATION, bearerToken)
                .build();
    }

    @Override
    public User getUser(final Message<?> message) {
        final MessageHeaders headers = message.getHeaders();
        final String header = headers.get(AUTHORIZATION) == null ? null : headers.get(AUTHORIZATION).toString();
        BearerAuthorizationHeaders.checkIsValid(header);

        try {
            return jwtService.decode(BearerAuthorizationHeaders.getToken(header));
        }
        catch (final Exception failed) {
            logger.error(
                    "An internal error occurred while trying to authenticate the user.",
                    failed);
            throw failed;
        }
    }
}
