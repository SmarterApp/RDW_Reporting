package org.opentestsystem.rdw.reporting.processor.requesthandler;

import com.google.common.collect.ImmutableMap;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.rdw.common.model.Subject;
import org.opentestsystem.rdw.reporting.common.model.Student;
import org.opentestsystem.rdw.reporting.common.report.AbstractBatchExamReportRequest;
import org.opentestsystem.rdw.reporting.common.report.AbstractExamReport;
import org.opentestsystem.rdw.reporting.common.report.ExamQueryParams;
import org.opentestsystem.rdw.reporting.common.report.ExamReportAssessmentType;
import org.opentestsystem.rdw.reporting.common.report.SchoolGradeExamReportRequest;
import org.opentestsystem.rdw.reporting.common.report.iab.IabReport;
import org.opentestsystem.rdw.reporting.common.report.iab.IabReportRepository;
import org.opentestsystem.rdw.reporting.common.report.ica.IcaReport;
import org.opentestsystem.rdw.reporting.common.report.ica.IcaReportRepository;
import org.opentestsystem.rdw.reporting.common.security.PermissionScope;
import org.opentestsystem.rdw.reporting.processor.model.StudentCompositeReport;

import java.util.HashMap;
import java.util.Map;

import static com.google.common.collect.ImmutableList.of;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyCollectionOf;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.reporting.common.security.PermissionScope.STATEWIDE;

@RunWith(MockitoJUnitRunner.class)
public class SchoolGradeReportFetcherTest {

    @Mock
    private IabReportRepository iabReportRepository;

    @Mock
    private IcaReportRepository icaReportRepository;

    @Captor
    private ArgumentCaptor<ExamQueryParams> examFilterCaptor;

    private SchoolGradeReportFetcher fetcher;

    @Before
    public void setup() {
        fetcher = new SchoolGradeReportFetcher(iabReportRepository, icaReportRepository);
    }

    @Test
    public void itShouldAcceptSchoolGradeReportRequests() {
        assertThat(fetcher.accept(mock(AbstractBatchExamReportRequest.class))).isFalse();
        assertThat(fetcher.accept(mock(SchoolGradeExamReportRequest.class))).isTrue();
    }

    @Test
    public void itShouldFetchIabReports() {
        final Map<Long, Map<Subject, IabReport>> reportsByStudent = new HashMap<>();
        reportsByStudent.put(123L, reportsBySubject(IabReport.class));

        final SchoolGradeExamReportRequest request = SchoolGradeExamReportRequest.builder()
                .schoolId(123L)
                .gradeId(7)
                .assessmentType(ExamReportAssessmentType.IAB)
                .build();

        when(iabReportRepository.findAllForStudentsByExamFilter(
                any(PermissionScope.class),
                anyCollectionOf(Long.class),
                any(ExamQueryParams.class)))
                .thenReturn(reportsByStudent);

        final Map<Long, StudentCompositeReport> results = fetcher.fetchReports(request, STATEWIDE, of(123L));
        assertThat(results).hasSize(1);
        assertThat(results.get(123L).getIabEla()).isNotNull();
        assertThat(results.get(123L).getIabMath()).isNotNull();
        assertThat(results.get(123L).getStudent()).isNotNull();

        verifyZeroInteractions(icaReportRepository);

        verify(iabReportRepository).findAllForStudentsByExamFilter(
                any(PermissionScope.class),
                anyCollectionOf(Long.class),
                examFilterCaptor.capture());

        assertThat(examFilterCaptor.getValue().getSchoolId()).isEqualTo(123);
        assertThat(examFilterCaptor.getValue().getGradeId()).isEqualTo(7);
    }

    @Test
    public void itShouldFetchIcaReports() {
        final Map<Long, Map<Subject, IcaReport>> reportsByStudent = new HashMap<>();
        reportsByStudent.put(123L, reportsBySubject(IcaReport.class));

        final SchoolGradeExamReportRequest request = SchoolGradeExamReportRequest.builder()
                .schoolId(123L)
                .gradeId(7)
                .assessmentType(ExamReportAssessmentType.ICA)
                .build();

        when(icaReportRepository.findAllForStudentsByExamFilter(
                any(PermissionScope.class),
                anyCollectionOf(Long.class),
                any(ExamQueryParams.class)))
                .thenReturn(reportsByStudent);

        final Map<Long, StudentCompositeReport> results = fetcher.fetchReports(request, STATEWIDE, of(123L));
        assertThat(results).hasSize(1);
        assertThat(results.get(123L).getIcaEla()).isNotNull();
        assertThat(results.get(123L).getIcaMath()).isNotNull();
        assertThat(results.get(123L).getStudent()).isNotNull();

        verifyZeroInteractions(iabReportRepository);

        verify(icaReportRepository).findAllForStudentsByExamFilter(
                any(PermissionScope.class),
                anyCollectionOf(Long.class),
                examFilterCaptor.capture());

        assertThat(examFilterCaptor.getValue().getSchoolId()).isEqualTo(123);
        assertThat(examFilterCaptor.getValue().getGradeId()).isEqualTo(7);
    }

    @Test
    public void itShouldFetchIcaAndIABReports() {
        final Map<Long, Map<Subject, IcaReport>> icaReportsByStudent = new HashMap<>();
        icaReportsByStudent.put(123L, reportsBySubject(IcaReport.class));
        final Map<Long, Map<Subject, IabReport>> iabReportsbyStudent = new HashMap<>();
        iabReportsbyStudent.put(123L, reportsBySubject(IabReport.class));

        final SchoolGradeExamReportRequest request = SchoolGradeExamReportRequest.builder()
                .schoolId(123L)
                .gradeId(7)
                .build();

        when(iabReportRepository.findAllForStudentsByExamFilter(
                any(PermissionScope.class),
                anyCollectionOf(Long.class),
                any(ExamQueryParams.class)))
                .thenReturn(iabReportsbyStudent);

        when(icaReportRepository.findAllForStudentsByExamFilter(
                any(PermissionScope.class),
                anyCollectionOf(Long.class),
                any(ExamQueryParams.class)))
                .thenReturn(icaReportsByStudent);

        final Map<Long, StudentCompositeReport> results = fetcher.fetchReports(request, STATEWIDE, of(123L));
        assertThat(results).hasSize(1);
        assertThat(results.get(123L).getIcaEla()).isNotNull();
        assertThat(results.get(123L).getIcaMath()).isNotNull();
        assertThat(results.get(123L).getIabEla()).isNotNull();
        assertThat(results.get(123L).getIabMath()).isNotNull();
        assertThat(results.get(123L).getStudent()).isNotNull();

        verify(icaReportRepository).findAllForStudentsByExamFilter(
                any(PermissionScope.class),
                anyCollectionOf(Long.class),
                examFilterCaptor.capture());

        assertThat(examFilterCaptor.getValue().getSchoolId()).isEqualTo(123);
        assertThat(examFilterCaptor.getValue().getGradeId()).isEqualTo(7);

        verify(iabReportRepository).findAllForStudentsByExamFilter(
                any(PermissionScope.class),
                anyCollectionOf(Long.class),
                examFilterCaptor.capture());

        assertThat(examFilterCaptor.getValue().getSchoolId()).isEqualTo(123);
        assertThat(examFilterCaptor.getValue().getGradeId()).isEqualTo(7);
    }

    private <T extends AbstractExamReport>  Map<Subject, T> reportsBySubject(final Class<T> reportClazz) {
        final Student student = Student.builder()
                .id(123L)
                .firstName("first")
                .lastName("last")
                .ssid("ssid")
                .build();

        final T mathReport = mock(reportClazz);
        when(mathReport.getStudent()).thenReturn(student);

        final T elaReport = mock(reportClazz);
        when(elaReport.getStudent()).thenReturn(student);

        return ImmutableMap.<Subject, T>builder()
                .put(Subject.MATH, mathReport)
                .put(Subject.ELA, elaReport)
                .build();
    }
}