package org.opentestsystem.rdw.reporting.processor.step;

import com.google.common.collect.ImmutableMap;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.common.model.Subject;
import org.opentestsystem.rdw.reporting.common.model.Report;
import org.opentestsystem.rdw.reporting.common.model.Student;
import org.opentestsystem.rdw.reporting.common.report.AbstractBatchExamReportRequest;
import org.opentestsystem.rdw.reporting.common.report.AbstractExamReport;
import org.opentestsystem.rdw.reporting.common.report.AbstractExamReportRequest;
import org.opentestsystem.rdw.reporting.common.report.ExamQueryParams;
import org.opentestsystem.rdw.reporting.common.report.iab.IabReport;
import org.opentestsystem.rdw.reporting.common.report.iab.IabReportRepository;
import org.opentestsystem.rdw.reporting.common.report.ica.IcaReport;
import org.opentestsystem.rdw.reporting.common.report.ica.IcaReportRepository;
import org.opentestsystem.rdw.reporting.common.security.PermissionScope;
import org.opentestsystem.rdw.reporting.processor.model.StudentCompositeReport;
import org.opentestsystem.rdw.reporting.processor.requesthandler.ExamQueryParamsParser;
import org.opentestsystem.rdw.reporting.processor.service.ReportGenerationJobParameterProvider;
import org.springframework.batch.item.ExecutionContext;

import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;

import static com.google.common.collect.ImmutableList.of;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyCollectionOf;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.reporting.common.security.PermissionScope.STATEWIDE;

@RunWith(MockitoJUnitRunner.class)
public class ReportStudentWriterTest {

    @Mock
    private ReportGenerationJobParameterProvider parameterProvider;

    @Mock
    private IabReportRepository iabReportRepository;

    @Mock
    private IcaReportRepository icaReportRepository;

    @Captor
    private ArgumentCaptor<ExamQueryParams> examFilterCaptor;

    @Captor
    private ArgumentCaptor<Collection<Long>> studentIdCaptor;

    private Map<Long, StudentCompositeReport> studentReports;
    private Set<ExamQueryParamsParser> queryParamsParsers;
    private ReportStudentWriter writer;

    @Before
    public void setup() {
        studentReports = new HashMap<>();
        queryParamsParsers = new LinkedHashSet<>();

        when(iabReportRepository.findAllForStudentsByExamFilter(any(PermissionScope.class), anyCollectionOf(Long.class), any(ExamQueryParams.class)))
                .thenReturn(new HashMap<Long, Map<Subject, IabReport>>());

        when(icaReportRepository.findAllForStudentsByExamFilter(any(PermissionScope.class), anyCollectionOf(Long.class), any(ExamQueryParams.class)))
                .thenReturn(new HashMap<Long, Map<Subject, IcaReport>>());

        final Report report = mock(Report.class);
        final AbstractExamReportRequest reportRequest = mock(AbstractBatchExamReportRequest.class);
        when(report.getReportRequest()).thenReturn(reportRequest);

        final Map<String, Object> jobParameters = new HashMap<>();
        when(parameterProvider.reportFromParameters(jobParameters)).thenReturn(report);
        when(parameterProvider.permissionScopeFromParameters(jobParameters)).thenReturn(STATEWIDE);

        writer = new ReportStudentWriter(
                studentReports, queryParamsParsers, parameterProvider, iabReportRepository, icaReportRepository,jobParameters);
    }

    @Test(expected = IllegalStateException.class)
    public void itShouldThrowIfUnableToFindAParser() {
        writer.open(mock(ExecutionContext.class));
    }

    @Test(expected = IllegalStateException.class)
    public void itShouldThrowIfUnableToFindAnAcceptingParser() {
        queryParamsParsers.add(rejecting());
        queryParamsParsers.add(rejecting());
        writer.open(mock(ExecutionContext.class));
    }

    @Test
    public void itShouldSelectTheFirstAcceptingParser() throws Exception {
        final ExamQueryParamsParser accepting = accepting();
        final ExamQueryParams params = ExamQueryParams.builder().build();
        when(accepting.parseQueryParams(any(AbstractBatchExamReportRequest.class)))
                .thenReturn(params);

        queryParamsParsers.add(rejecting());
        queryParamsParsers.add(rejecting());
        queryParamsParsers.add(accepting);
        queryParamsParsers.add(accepting());
        writer.open(mock(ExecutionContext.class));
        writer.write(of(123L));

        verify(iabReportRepository).findAllForStudentsByExamFilter(
                any(PermissionScope.class),
                studentIdCaptor.capture(),
                examFilterCaptor.capture());

        assertThat(studentIdCaptor.getValue()).containsOnly(123L);
        assertThat(examFilterCaptor.getValue()).isEqualTo(params);
    }

    @Test
    public void itShouldFetchIabReports() throws Exception {
        final Map<Long, Map<Subject, IabReport>> reportsByStudent = new HashMap<>();
        reportsByStudent.put(123L, reportsBySubject(IabReport.class));

        final ExamQueryParamsParser parser = mock(ExamQueryParamsParser.class);
        when(parser.accept(any(AbstractExamReportRequest.class))).thenReturn(true);
        final ExamQueryParams params = ExamQueryParams.builder()
                .assessmentType(AssessmentType.IAB)
                .build();
        when(parser.parseQueryParams(any(AbstractExamReportRequest.class))).thenReturn(params);
        queryParamsParsers.add(parser);

        when(iabReportRepository.findAllForStudentsByExamFilter(
                any(PermissionScope.class),
                anyCollectionOf(Long.class),
                eq(params)))
                .thenReturn(reportsByStudent);

        writer.open(mock(ExecutionContext.class));
        writer.write(of(123L));

        assertThat(studentReports).hasSize(1);
        assertThat(studentReports.get(123L).getIabEla()).isNotNull();
        assertThat(studentReports.get(123L).getIabMath()).isNotNull();
        assertThat(studentReports.get(123L).getStudent()).isNotNull();

        verifyZeroInteractions(icaReportRepository);
    }

    @Test
    public void itShouldFetchIcaReports() throws Exception {
        final Map<Long, Map<Subject, IcaReport>> reportsByStudent = new HashMap<>();
        reportsByStudent.put(123L, reportsBySubject(IcaReport.class));

        final ExamQueryParamsParser parser = mock(ExamQueryParamsParser.class);
        when(parser.accept(any(AbstractExamReportRequest.class))).thenReturn(true);
        final ExamQueryParams params = ExamQueryParams.builder()
                .assessmentType(AssessmentType.ICA)
                .build();
        when(parser.parseQueryParams(any(AbstractExamReportRequest.class))).thenReturn(params);
        queryParamsParsers.add(parser);

        when(icaReportRepository.findAllForStudentsByExamFilter(
                any(PermissionScope.class),
                anyCollectionOf(Long.class),
                any(ExamQueryParams.class)))
                .thenReturn(reportsByStudent);

        writer.open(mock(ExecutionContext.class));
        writer.write(of(123L));

        assertThat(studentReports).hasSize(1);
        assertThat(studentReports.get(123L).getIcaEla()).isNotNull();
        assertThat(studentReports.get(123L).getIcaMath()).isNotNull();
        assertThat(studentReports.get(123L).getStudent()).isNotNull();

        verifyZeroInteractions(iabReportRepository);

    }

    @Test
    public void itShouldFetchIcaAndIABReports() throws Exception {
        final Map<Long, Map<Subject, IcaReport>> icaReportsByStudent = new HashMap<>();
        icaReportsByStudent.put(123L, reportsBySubject(IcaReport.class));
        final Map<Long, Map<Subject, IabReport>> iabReportsbyStudent = new HashMap<>();
        iabReportsbyStudent.put(123L, reportsBySubject(IabReport.class));

        final ExamQueryParamsParser parser = mock(ExamQueryParamsParser.class);
        when(parser.accept(any(AbstractExamReportRequest.class))).thenReturn(true);
        final ExamQueryParams params = ExamQueryParams.builder()
                .build();
        when(parser.parseQueryParams(any(AbstractExamReportRequest.class))).thenReturn(params);
        queryParamsParsers.add(parser);

        when(iabReportRepository.findAllForStudentsByExamFilter(
                any(PermissionScope.class),
                anyCollectionOf(Long.class),
                any(ExamQueryParams.class)))
                .thenReturn(iabReportsbyStudent);

        when(icaReportRepository.findAllForStudentsByExamFilter(
                any(PermissionScope.class),
                anyCollectionOf(Long.class),
                any(ExamQueryParams.class)))
                .thenReturn(icaReportsByStudent);

        writer.open(mock(ExecutionContext.class));
        writer.write(of(123L));

        assertThat(studentReports).hasSize(1);
        assertThat(studentReports.get(123L).getIcaEla()).isNotNull();
        assertThat(studentReports.get(123L).getIcaMath()).isNotNull();
        assertThat(studentReports.get(123L).getIabEla()).isNotNull();
        assertThat(studentReports.get(123L).getIabMath()).isNotNull();
        assertThat(studentReports.get(123L).getStudent()).isNotNull();
    }

    private ExamQueryParamsParser accepting() {
        final ExamQueryParamsParser parser = mock(ExamQueryParamsParser.class);
        when(parser.accept(any(AbstractBatchExamReportRequest.class))).thenReturn(true);
        return parser;
    }

    private ExamQueryParamsParser rejecting() {
        return mock(ExamQueryParamsParser.class);
    }

    private <T extends AbstractExamReport>  Map<Subject, T> reportsBySubject(final Class<T> reportClazz) {
        final Student student = Student.builder()
                .id(123L)
                .firstName("first")
                .lastName("last")
                .ssid("ssid")
                .build();

        final T mathReport = mock(reportClazz);
        when(mathReport.getStudent()).thenReturn(student);

        final T elaReport = mock(reportClazz);
        when(elaReport.getStudent()).thenReturn(student);

        return ImmutableMap.<Subject, T>builder()
                .put(Subject.MATH, mathReport)
                .put(Subject.ELA, elaReport)
                .build();
    }
}
