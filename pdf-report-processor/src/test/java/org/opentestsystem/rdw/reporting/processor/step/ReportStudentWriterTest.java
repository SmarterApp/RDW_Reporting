package org.opentestsystem.rdw.reporting.processor.step;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.rdw.reporting.common.model.Report;
import org.opentestsystem.rdw.reporting.common.report.AbstractBatchExamReportRequest;
import org.opentestsystem.rdw.reporting.common.report.AbstractExamReportRequest;
import org.opentestsystem.rdw.reporting.processor.model.StudentCompositeReport;
import org.opentestsystem.rdw.reporting.processor.requesthandler.ReportFetcher;
import org.opentestsystem.rdw.reporting.processor.service.ReportGenerationJobParameterProvider;
import org.springframework.batch.item.ExecutionContext;

import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;

import static com.google.common.collect.ImmutableList.of;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyListOf;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.reporting.common.security.PermissionScope.STATEWIDE;

@RunWith(MockitoJUnitRunner.class)
public class ReportStudentWriterTest {

    @Mock
    private ReportGenerationJobParameterProvider parameterProvider;

    private Map<Long, StudentCompositeReport> studentReports;
    private Set<ReportFetcher> reportFetchers;
    private ReportStudentWriter writer;

    @Before
    public void setup() {
        studentReports = new HashMap<>();
        reportFetchers = new LinkedHashSet<>();

        final Report report = mock(Report.class);
        final AbstractExamReportRequest reportRequest = mock(AbstractBatchExamReportRequest.class);
        when(report.getReportRequest()).thenReturn(reportRequest);

        final Map<String, Object> jobParameters = new HashMap<>();
        when(parameterProvider.reportFromParameters(jobParameters)).thenReturn(report);
        when(parameterProvider.permissionScopeFromParameters(jobParameters)).thenReturn(STATEWIDE);

        writer = new ReportStudentWriter(studentReports, reportFetchers, parameterProvider, jobParameters);
    }

    @Test(expected = IllegalStateException.class)
    public void itShouldThrowIfUnableToFindAReportFetcher() {
        writer.open(mock(ExecutionContext.class));
    }

    @Test(expected = IllegalStateException.class)
    public void itShouldThrowIfUnableToFindAnAcceptingReportFetcher() {
        reportFetchers.add(rejecting());
        reportFetchers.add(rejecting());
        writer.open(mock(ExecutionContext.class));
    }

    @Test
    public void itShouldSelectTheFirstAcceptingReportFetcher() throws Exception {
        final ReportFetcher accepting = accepting();
        final Map<Long, StudentCompositeReport> reports = new HashMap<>();

        final StudentCompositeReport report = mock(StudentCompositeReport.class);
        reports.put(123L, report);
        when(accepting.fetchReports(
                any(AbstractBatchExamReportRequest.class),
                eq(STATEWIDE),
                anyListOf(Long.class)))
                .thenReturn(reports);

        reportFetchers.add(rejecting());
        reportFetchers.add(rejecting());
        reportFetchers.add(accepting);
        reportFetchers.add(accepting());
        writer.open(mock(ExecutionContext.class));
        writer.write(of(123L));

        assertThat(studentReports.get(123L)).isEqualTo(report);
    }

    private ReportFetcher accepting() {
        final ReportFetcher fetcher = mock(ReportFetcher.class);
        when(fetcher.accept(any(AbstractBatchExamReportRequest.class))).thenReturn(true);
        return fetcher;
    }

    private ReportFetcher rejecting() {
        return mock(ReportFetcher.class);
    }
}
