package org.opentestsystem.rdw.reporting.processor.web;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.opentestsystem.rdw.reporting.common.model.Report;
import org.opentestsystem.rdw.reporting.common.model.ReportStatus;
import org.opentestsystem.rdw.reporting.common.report.BatchExamReportRequestHolder;
import org.opentestsystem.rdw.reporting.common.report.SchoolGradeExamReportRequest;
import org.opentestsystem.rdw.reporting.common.security.PermissionScope;
import org.opentestsystem.rdw.reporting.processor.service.ReportContentService;
import org.opentestsystem.rdw.reporting.processor.service.ReportGenerator;
import org.opentestsystem.rdw.reporting.processor.service.ReportService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.web.servlet.MockMvc;

import java.io.ByteArrayInputStream;
import java.time.Instant;
import java.util.Collection;
import java.util.List;
import java.util.Optional;

import static com.amazonaws.services.s3.Headers.CONTENT_DISPOSITION;
import static com.amazonaws.services.s3.Headers.CONTENT_TYPE;
import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.hamcrest.Matchers.hasSize;
import static org.hamcrest.Matchers.startsWith;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyListOf;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.header;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@RunWith(SpringRunner.class)
@WebMvcTest(ReportController.class)
public class ReportControllerIT {

    @Autowired
    private MockMvc mvc;

    @Autowired
    private ObjectMapper objectMapper;

    @MockBean
    private ReportGenerator reportGenerator;

    @MockBean
    private ReportService service;

    @MockBean
    private ReportContentService reportContentService;

    @Captor
    private ArgumentCaptor<Collection<Long>> reportIdCaptor;

    @Test
    public void itShouldGenerateAReport() throws Exception {
        final Report report = report(123L);
        when(reportGenerator.generateReport(any(BatchExamReportRequestHolder.class)))
                .thenReturn(report);

        final BatchExamReportRequestHolder requestHolder = new BatchExamReportRequestHolder(
                (SchoolGradeExamReportRequest)report.getReportRequest(),
                PermissionScope.STATEWIDE,
                "user",
                "label"
        );

        final String serializedPayload = objectMapper.writeValueAsString(requestHolder);

        mvc.perform(post("/api/reports")
                .contentType(MediaType.APPLICATION_JSON)
                .content(serializedPayload))

                .andExpect(status().isAccepted())
                .andExpect(jsonPath("$.*", hasSize(4)))
                .andExpect(jsonPath("$.id").value(report.getId()))
                .andExpect(jsonPath("$.status").value(report.getStatus().name()))
                .andExpect(jsonPath("$.label").value(report.getLabel()))
                .andExpect(jsonPath("$.created").isNotEmpty());

        final ArgumentCaptor<BatchExamReportRequestHolder> captor = ArgumentCaptor.forClass(BatchExamReportRequestHolder.class);
        verify(reportGenerator).generateReport(captor.capture());
        final BatchExamReportRequestHolder submitted = captor.getValue();
        assertThat(submitted.getPermissionScope().isStatewide()).isTrue();
        assertThat(submitted.getLabel()).isEqualTo(requestHolder.getLabel());
        assertThat(submitted.getUser()).isEqualTo(requestHolder.getUser());
        assertThat(submitted.getRequest().getSchoolYear()).isEqualTo(requestHolder.getRequest().getSchoolYear());
    }

    @Test
    public void itShouldRetrieveAListOfReportsByUser() throws Exception {
        final List<Report> results = newArrayList(report(123L), report(456L));
        when(service.findAllByUserAndId(eq("user"), anyListOf(Long.class)))
                .thenReturn(results);

        mvc.perform(get("/api/reports")
                .param("user", "user"))

                .andExpect(status().isOk())
                .andExpect(jsonPath("$", hasSize(2)))
                .andExpect(jsonPath("$[0].id").value(123))
                .andExpect(jsonPath("$[1].id").value(456));

        verify(service).findAllByUserAndId(eq("user"), reportIdCaptor.capture());
        assertThat(reportIdCaptor.getValue()).isEmpty();
    }

    @Test
    public void itShouldRetrieveAListOfReportsByUserAndId() throws Exception {
        final List<Report> results = newArrayList(report(123L), report(456L));
        when(service.findAllByUserAndId(eq("user"), anyListOf(Long.class)))
                .thenReturn(results);

        mvc.perform(get("/api/reports")
                .param("user", "user")
                .param("id", "123", "456"))

                .andExpect(status().isOk())
                .andExpect(jsonPath("$", hasSize(2)))
                .andExpect(jsonPath("$[0].id").value(123))
                .andExpect(jsonPath("$[1].id").value(456));

        verify(service).findAllByUserAndId(eq("user"), reportIdCaptor.capture());
        assertThat(reportIdCaptor.getValue()).containsOnly(123L, 456L);
    }

    @Test
    public void itShouldRetrieveReportContents() throws Exception {
        final Report report = report(123L);
        when(service.findOneById(report.getId())).thenReturn(Optional.of(report));

        when(reportContentService.openContent(eq(report)))
                .thenAnswer((id) -> new ByteArrayInputStream("PDF CONTENTS".getBytes()));

        mvc.perform(get("/api/reports/123/content")
                .param("user", report.getUser()))
                .andExpect(status().isOk())
                .andExpect(header().string(CONTENT_TYPE, "application/pdf; charset=UTF-8"))
                .andExpect(header().string(CONTENT_DISPOSITION, startsWith("attachment;")))
                .andExpect(content().string("PDF CONTENTS"));
    }

    @Test
    public void itShouldHandleAMissingReportWhenRequestingContents() throws Exception {
        when(service.findOneById(123)).thenReturn(Optional.empty());

        mvc.perform(get("/api/reports/123/content")
                .param("user", "user"))
                .andExpect(status().isNotFound());
    }

    @Test
    public void itShouldReturnNotFoundWhenUserDoesNotMatchReportWhenRequestingContents() throws Exception {
        final Report report = report(123L);
        when(service.findOneById(123)).thenReturn(Optional.of(report));

        mvc.perform(get("/api/reports/123/content")
                .param("user", report.getUser() + "_invalid"))
                .andExpect(status().isNotFound());
    }

    private Report report(final long id) {
        final SchoolGradeExamReportRequest request = SchoolGradeExamReportRequest.builder()
                .schoolId(1L)
                .gradeId(2)
                .schoolYear(2017)
                .build();

        return Report.builder()
                .user("user")
                .status(ReportStatus.RUNNING)
                .label("my-report")
                .created(Instant.now())
                .id(id)
                .reportRequest(request)
                .build();
    }
}