package org.opentestsystem.rdw.reporting.processor.step;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Ordering;
import org.opentestsystem.rdw.reporting.common.model.Report;
import org.opentestsystem.rdw.reporting.common.report.AbstractBatchExamReportRequest;
import org.opentestsystem.rdw.reporting.common.report.AbstractExamReportRequest;
import org.opentestsystem.rdw.reporting.common.report.ExamReportOrder;
import org.opentestsystem.rdw.reporting.common.report.PrintOptions;
import org.opentestsystem.rdw.reporting.common.report.ReportViewSupport;
import org.opentestsystem.rdw.reporting.common.report.processor.HtmlToPdfProcessor;
import org.opentestsystem.rdw.reporting.common.report.processor.TemplateProcessor;
import org.opentestsystem.rdw.reporting.processor.model.StudentCompositeReport;
import org.opentestsystem.rdw.reporting.processor.service.ReportGenerationJobParameterProvider;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.InputStream;
import java.util.Iterator;
import java.util.Map;
import java.util.TreeSet;

/**
 * This Spring Batch tasklet is responsible for generating a report PDF within the context of a Job
 */
@Component
public class GeneratePdf implements Tasklet {
    private static final Logger logger = LoggerFactory.getLogger(GeneratePdf.class);

    private static final Ordering<StudentCompositeReport> StudentSSIDOrdering = Ordering.natural()
            .onResultOf(report -> report.getStudent().getSsid());

    private static final Ordering<StudentCompositeReport> StudentNameOrdering = Ordering.natural()
            .onResultOf(report -> report.getStudent().getLastName() + " " + report.getStudent().getFirstName());

    private final TemplateProcessor templateProcessor;
    private final ReportViewSupport support;
    private final Map<Long, StudentCompositeReport> studentReports;
    private final ReportGenerationJobParameterProvider parameterProvider;
    private final HtmlToPdfProcessor htmlToPdfProcessor;

    @Autowired
    public GeneratePdf(final Map<Long, StudentCompositeReport> studentReports,
                       final ReportGenerationJobParameterProvider parameterProvider,
                       final TemplateProcessor templateProcessor,
                       final ReportViewSupport support,
                       final HtmlToPdfProcessor htmlToPdfProcessor) {
        this.studentReports = studentReports;
        this.parameterProvider = parameterProvider;
        this.templateProcessor = templateProcessor;
        this.support = support;
        this.htmlToPdfProcessor = htmlToPdfProcessor;
    }

    @Override
    public RepeatStatus execute(final StepContribution contribution, final ChunkContext chunkContext) throws Exception {
        logger.info("Generating PDF for {} students", studentReports.size());

        final Report report = parameterProvider.reportFromParameters(chunkContext.getStepContext().getJobParameters());
        final TreeSet<StudentCompositeReport> orderedReports = new TreeSet<>(getOrdering(report.getReportRequest()));

        //Move reports from job storage to ordered list
        final Iterator<StudentCompositeReport> reportIterator = studentReports.values().iterator();
        while (reportIterator.hasNext()) {
            final StudentCompositeReport studentReport = reportIterator.next();
            if (studentReport.getStudent() != null) {
                orderedReports.add(studentReport);
            }
            reportIterator.remove();
        }

        final Map<String, Object> model = ImmutableMap.of(
                "studentCompositeReports", orderedReports,
                "request", report.getReportRequest(),
                "support", support);

        final byte[] html = templateProcessor.process(
                "batch-reports",
                model,
                report.getReportRequest().getLanguage());

        try (final InputStream pdfStream = htmlToPdfProcessor.process(html, (PrintOptions) report.getReportRequest().getOptions())) {
            //Temporary hack to store PDF output as a file
            //This will be sent to S3 for storage in a followup PR
//            final File tempFile = new File("/tmp/output.pdf");
//            try (final FileOutputStream output = new FileOutputStream(tempFile)) {
//                IOUtils.copy(pdfStream, output);
//            }
        }

        //TODO send to PDF generation service
        return RepeatStatus.FINISHED;
    }

    private Ordering<StudentCompositeReport> getOrdering(final AbstractExamReportRequest reportRequest) {
        ExamReportOrder order = null;
        if (reportRequest instanceof AbstractBatchExamReportRequest) {
            order = ((AbstractBatchExamReportRequest) reportRequest).getOrder();
        }
        if (order == null) {
            order = ExamReportOrder.STUDENT_NAME;
        }

        switch(order) {
            case STUDENT_SSID:
                return StudentSSIDOrdering;
            case STUDENT_NAME:
            default:
                return StudentNameOrdering;
        }
    }
}
