package org.opentestsystem.rdw.reporting.processor.step;

import com.google.common.collect.ImmutableMap;
import org.opentestsystem.rdw.common.model.Subject;
import org.opentestsystem.rdw.reporting.common.model.Report;
import org.opentestsystem.rdw.reporting.common.model.Student;
import org.opentestsystem.rdw.reporting.common.report.AbstractExamReportRequest;
import org.opentestsystem.rdw.reporting.common.report.BatchExamReportRequestHolder;
import org.opentestsystem.rdw.reporting.common.report.ExamQueryParams;
import org.opentestsystem.rdw.reporting.common.report.PrintOptions;
import org.opentestsystem.rdw.reporting.common.report.ReportViewSupport;
import org.opentestsystem.rdw.reporting.common.report.iab.IabReport;
import org.opentestsystem.rdw.reporting.common.report.iab.IabReportRepository;
import org.opentestsystem.rdw.reporting.common.report.ica.IcaReport;
import org.opentestsystem.rdw.reporting.common.report.ica.IcaReportRepository;
import org.opentestsystem.rdw.reporting.common.report.processor.HtmlToPdfProcessor;
import org.opentestsystem.rdw.reporting.common.report.processor.TemplateProcessor;
import org.opentestsystem.rdw.reporting.common.security.PermissionScope;
import org.opentestsystem.rdw.reporting.processor.model.StudentChunk;
import org.opentestsystem.rdw.reporting.processor.model.StudentCompositeReport;
import org.opentestsystem.rdw.reporting.processor.requesthandler.ExamQueryParamsParser;
import org.opentestsystem.rdw.reporting.processor.service.ReportGenerationJobParameterProvider;
import org.opentestsystem.rdw.reporting.processor.service.ReportGenerationTemporaryStorage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.batch.core.configuration.annotation.JobScope;
import org.springframework.batch.item.ExecutionContext;
import org.springframework.batch.item.ItemStream;
import org.springframework.batch.item.ItemStreamException;
import org.springframework.batch.item.ItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.retry.RetryCallback;
import org.springframework.retry.support.RetryTemplate;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.io.InputStream;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import static org.opentestsystem.rdw.common.model.AssessmentType.IAB;
import static org.opentestsystem.rdw.common.model.AssessmentType.ICA;
import static org.opentestsystem.rdw.common.model.Subject.ELA;
import static org.opentestsystem.rdw.common.model.Subject.MATH;

/**
 * This writer is responsible for delegating to the appropriate ExamQueryParamsParser
 * for the Job's {@link BatchExamReportRequestHolder#getRequest()}, retrieving
 * the report data, and writing the reports into a job-scoped student report map.
 */
@Component
@JobScope
public class ReportStudentWriter implements ItemWriter<StudentChunk>, ItemStream {
    private final static Logger logger = LoggerFactory.getLogger(ReportStudentWriter.class);

    private final Set<ExamQueryParamsParser> queryParamsParsers;
    private final ReportGenerationJobParameterProvider parameterProvider;
    private final Map<String, Object> jobParameters;
    private final IabReportRepository iabReportRepository;
    private final IcaReportRepository icaReportRepository;
    private final ReportGenerationTemporaryStorage temporaryStorage;
    private final ReportViewSupport support;
    private final TemplateProcessor templateProcessor;
    private final HtmlToPdfProcessor htmlToPdfProcessor;
    private final RetryTemplate retryTemplate;

    private AbstractExamReportRequest reportRequest;
    private PermissionScope permissionScope;
    private ExamQueryParams queryParams;
    private Report report;

    @Autowired
    public ReportStudentWriter(final Set<ExamQueryParamsParser> queryParamsParsers,
                               final ReportGenerationJobParameterProvider parameterProvider,
                               final IabReportRepository iabReportRepository,
                               final IcaReportRepository icaReportRepository,
                               final ReportGenerationTemporaryStorage temporaryStorage,
                               final ReportViewSupport support,
                               final TemplateProcessor templateProcessor,
                               final HtmlToPdfProcessor htmlToPdfProcessor,
                               final RetryTemplate retryTemplate,
                               @Value("#{jobParameters}") final Map<String, Object> jobParameters) {
        this.queryParamsParsers = queryParamsParsers;
        this.parameterProvider = parameterProvider;
        this.jobParameters = jobParameters;
        this.iabReportRepository = iabReportRepository;
        this.icaReportRepository = icaReportRepository;
        this.temporaryStorage = temporaryStorage;
        this.support = support;
        this.templateProcessor = templateProcessor;
        this.htmlToPdfProcessor = htmlToPdfProcessor;
        this.retryTemplate = retryTemplate;
    }

    @Override
    public void write(final List<? extends StudentChunk> studentChunks) throws Exception {
        if (studentChunks.size() != 1) {
            throw new IllegalStateException("Can only write 1 StudentChuck at a time. Size: " + studentChunks.size());
        }

        final StudentChunk studentChunk = studentChunks.get(0);
        logger.debug("Processing report: {} chunk: {} size: {}", report.getId(), studentChunk.getIndex(), studentChunk.getStudents().size());

        final Map<Long, StudentCompositeReport> studentReports = studentChunk.getStudents().stream()
                .collect(Collectors.toMap(
                        Student::getId,
                        student -> StudentCompositeReport.builder()
                                .student(student)
                                .build()
                ));

        appendIABReports(studentReports, permissionScope, studentReports.keySet(), queryParams);
        appendICAReports(studentReports, permissionScope, studentReports.keySet(), queryParams);
        //TODO Append Summative Reports

        final List<StudentCompositeReport> orderedReports = studentChunk.getStudents().stream()
                .map(student -> studentReports.get(student.getId()))
                .collect(Collectors.toList());

        logger.debug("Processing report: {} chunk: {} writing html", report.getId(), studentChunk.getIndex());
        final byte[] html = writeReportHtml(orderedReports);

        retryTemplate.execute((RetryCallback<Void, IOException>) retryContext -> {
            try (final InputStream pdfStream = htmlToPdfProcessor.process(html, (PrintOptions) report.getReportRequest().getOptions())) {
                //Store chunk PDF contents
                logger.debug("Processing report: {} chunk: {} writing pdf bytes", report.getId(), studentChunk.getIndex());
                temporaryStorage.writeChunk(studentChunk.getIndex(), pdfStream);
            }
            return null;
        }, retryContext -> {
            logger.warn("Unable to convert report chunk HTML to PDF report: {} chunk: {}",
                    report.getId(),
                    studentChunk.getIndex(),
                    retryContext.getLastThrowable());
            throw new IllegalStateException("Unable to convert report chunk HTML to PDF");
        });

        logger.debug("Report: {} Chunk: {} complete", report.getId(), studentChunk.getIndex());
    }

    @Override
    public void open(final ExecutionContext executionContext) throws ItemStreamException {
        report = parameterProvider.reportFromParameters(jobParameters);
        this.reportRequest = report.getReportRequest();

        final ExamQueryParamsParser parser = this.queryParamsParsers.stream()
                .filter(fetcher -> fetcher.accept(reportRequest))
                .findFirst()
                .orElseThrow(() -> new IllegalStateException("Unable to find ExamQueryParamsParser for Report: " + report.getId()));
        this.queryParams = parser.parseQueryParams(report.getReportRequest());

        this.permissionScope = parameterProvider.permissionScopeFromParameters(jobParameters);
    }

    @Override
    public void update(final ExecutionContext executionContext) throws ItemStreamException {
    }

    @Override
    public void close() throws ItemStreamException {
    }

    private void appendIABReports(final Map<Long, StudentCompositeReport> compositeReports,
                                  final PermissionScope permissionScope,
                                  final Collection<Long> studentIds,
                                  final ExamQueryParams examQueryParams) {
        if (examQueryParams.getAssessmentType() != null && examQueryParams.getAssessmentType() != IAB) {
            return;
        }

        final Map<Long, Map<Subject, IabReport>> iabReports = iabReportRepository
                .findAllForStudentsByExamFilter(
                        permissionScope,
                        studentIds,
                        examQueryParams);

        iabReports.entrySet().forEach(studentEntry ->
            compositeReports.computeIfPresent(studentEntry.getKey(), (id, compositeReport) -> StudentCompositeReport.builder()
                        .copy(compositeReport)
                        .iabEla(studentEntry.getValue().get(ELA))
                        .iabMath(studentEntry.getValue().get(MATH))
                        .build()
            )
        );
    }

    private void appendICAReports(final Map<Long, StudentCompositeReport> compositeReports,
                                  final PermissionScope permissionScope,
                                  final Collection<Long> studentIds,
                                  final ExamQueryParams examQueryParams) {
        if (examQueryParams.getAssessmentType() != null && examQueryParams.getAssessmentType() != ICA) {
            return;
        }

        final Map<Long, Map<Subject, IcaReport>> icaReports = icaReportRepository
                .findAllForStudentsByExamFilter(
                        permissionScope,
                        studentIds,
                        examQueryParams);

        icaReports.entrySet().forEach(studentEntry ->
            compositeReports.computeIfPresent(studentEntry.getKey(), (id, compositeReport) -> StudentCompositeReport.builder()
                    .copy(compositeReport)
                    .icaEla(studentEntry.getValue().get(ELA))
                    .icaMath(studentEntry.getValue().get(MATH))
                    .build()
            )
        );
    }

    private byte[] writeReportHtml(final List<StudentCompositeReport> orderedReports) {
        final Map<String, Object> model = ImmutableMap.of(
                "studentCompositeReports", orderedReports,
                "request", report.getReportRequest(),
                "support", support);

        return templateProcessor.process(
                "batch-reports",
                model,
                report.getReportRequest().getLanguage());
    }
}
