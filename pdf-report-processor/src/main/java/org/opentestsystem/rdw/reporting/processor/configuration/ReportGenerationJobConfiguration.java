package org.opentestsystem.rdw.reporting.processor.configuration;

import org.opentestsystem.rdw.reporting.common.report.processor.WkhtmltopdfWebServiceHtmlToPdfProcessor;
import org.opentestsystem.rdw.reporting.processor.ReportGenerationJobExecutionListener;
import org.opentestsystem.rdw.reporting.processor.model.StudentCompositeReport;
import org.opentestsystem.rdw.reporting.processor.step.FetchStudentIds;
import org.opentestsystem.rdw.reporting.processor.step.GeneratePdf;
import org.opentestsystem.rdw.reporting.processor.step.ReportStudentReader;
import org.opentestsystem.rdw.reporting.processor.step.ReportStudentWriter;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.JobScope;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.task.TaskExecutor;

import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.LinkedBlockingQueue;

import static com.google.common.collect.Maps.newHashMap;

/**
 * This configuration is responsible for defining a report generation job.
 */
@EnableBatchProcessing
@Configuration
public class ReportGenerationJobConfiguration {

    private final JobBuilderFactory jobBuilderFactory;
    private final StepBuilderFactory stepBuilderFactory;

    @Autowired
    public ReportGenerationJobConfiguration(final JobBuilderFactory jobBuilderFactory,
                                            final StepBuilderFactory stepBuilderFactory) {
        this.jobBuilderFactory = jobBuilderFactory;
        this.stepBuilderFactory = stepBuilderFactory;
    }

    @Bean
    public Job generateReportJob(final ReportGenerationJobExecutionListener listener,
                                 final Step fetchStudentIdsStep,
                                 final Step buildReportsStep,
                                 final Step generatePdfStep) {
        try {
            return jobBuilderFactory.get("Generate Report Job")
                    .preventRestart()
                    .listener(listener)
                    .start(fetchStudentIdsStep)
                    .next(buildReportsStep)
                    .next(generatePdfStep)
                    .build();
        } catch (final Exception e) {
            return null;
        }
    }

    @Bean
    public Step fetchStudentIdsStep(final FetchStudentIds fetchStudentIds) {
        return this.stepBuilderFactory
                .get("fetchStudentIdsStep")
                .tasklet(fetchStudentIds)
                .build();
    }

    @Bean
    public Step buildReportsStep(@Qualifier("batchStepExecutor") final TaskExecutor batchStepExecutor,
                                 final ReportStudentReader reportStudentReader,
                                 final ReportStudentWriter reportStudentWriter) {
        return this.stepBuilderFactory
                .get("buildReportsStep")
                .<Long, Long>chunk(50)
                .reader(reportStudentReader)
                .writer(reportStudentWriter)
                .taskExecutor(batchStepExecutor)
                .build();
    }

    @Bean
    public Step getStudentReportsStep() {
        return null;
    }

    @Bean
    public Step generatePdfStep(final GeneratePdf generatePdf) {
        return this.stepBuilderFactory
                .get("generatePdfStep")
                .tasklet(generatePdf)
                .build();
    }

    @Bean
    @JobScope
    public BlockingQueue<Long> studentIds() {
        return new LinkedBlockingQueue<>();
    }

    @Bean
    @JobScope
    public Map<Long, StudentCompositeReport> studentReportsByExecution() {
        return new ConcurrentHashMap<>();
    }

    @Bean
    @ConfigurationProperties(prefix = "app.wkhtmltopdf.options")
    public Map<String, Object> wkhtmltopdfOptions() {
        return newHashMap();
    }

    @Autowired
    public void configure(final WkhtmltopdfWebServiceHtmlToPdfProcessor processor) {
        processor.setOptions(wkhtmltopdfOptions());
    }
}
