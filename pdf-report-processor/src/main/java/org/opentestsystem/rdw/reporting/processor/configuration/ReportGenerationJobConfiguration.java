package org.opentestsystem.rdw.reporting.processor.configuration;

import org.opentestsystem.rdw.reporting.common.report.processor.WkhtmltopdfWebServiceHtmlToPdfProcessor;
import org.opentestsystem.rdw.reporting.processor.ReportGenerationJobExecutionListener;
import org.opentestsystem.rdw.reporting.processor.model.StudentChunk;
import org.opentestsystem.rdw.reporting.processor.model.StudentCompositeReport;
import org.opentestsystem.rdw.reporting.processor.service.ReportGenerationTemporaryStorage;
import org.opentestsystem.rdw.reporting.processor.step.FetchStudents;
import org.opentestsystem.rdw.reporting.processor.step.GeneratePdf;
import org.opentestsystem.rdw.reporting.processor.step.ReportStudentReader;
import org.opentestsystem.rdw.reporting.processor.step.ReportStudentWriter;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.JobScope;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.task.TaskExecutor;
import org.springframework.retry.backoff.ExponentialBackOffPolicy;
import org.springframework.retry.policy.SimpleRetryPolicy;
import org.springframework.retry.support.RetryTemplate;

import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.LinkedBlockingQueue;

import static com.google.common.collect.Maps.newHashMap;
import static java.util.concurrent.TimeUnit.SECONDS;

/**
 * This configuration is responsible for defining a report generation job.
 */
@EnableBatchProcessing
@Configuration
public class ReportGenerationJobConfiguration {

    private final JobBuilderFactory jobBuilderFactory;
    private final StepBuilderFactory stepBuilderFactory;
    private final ReportGenerationProperties reportGenerationProperties;

    @Autowired
    public ReportGenerationJobConfiguration(final JobBuilderFactory jobBuilderFactory,
                                            final StepBuilderFactory stepBuilderFactory,
                                            final ReportGenerationProperties reportGenerationProperties) {
        this.jobBuilderFactory = jobBuilderFactory;
        this.stepBuilderFactory = stepBuilderFactory;
        this.reportGenerationProperties = reportGenerationProperties;
    }

    @Bean
    public Job generateReportJob(final ReportGenerationJobExecutionListener listener,
                                 final Step fetchStudentIdsStep,
                                 final Step buildReportsStep,
                                 final Step generatePdfStep) {
        try {
            return jobBuilderFactory.get("Generate Report Job")
                    .preventRestart()
                    .listener(listener)
                    .start(fetchStudentIdsStep)
                    .next(buildReportsStep)
                    .next(generatePdfStep)
                    .build();
        } catch (final Exception e) {
            return null;
        }
    }

    @Bean
    public Step fetchStudentIdsStep(final FetchStudents fetchStudents) {
        return this.stepBuilderFactory
                .get("fetchStudentIdsStep")
                .tasklet(fetchStudents)
                .build();
    }

    @Bean
    public Step buildReportsStep(@Qualifier("batchStepExecutor") final TaskExecutor batchStepExecutor,
                                 final ReportStudentReader reportStudentReader,
                                 final ReportStudentWriter reportStudentWriter) {
        return this.stepBuilderFactory
                .get("buildReportsStep")
                .<StudentChunk, StudentChunk>chunk(1)
                .reader(reportStudentReader)
                .writer(reportStudentWriter)
                .taskExecutor(batchStepExecutor)
                .throttleLimit(reportGenerationProperties.getStepThreads())
                .build();
    }

    @Bean
    public Step getStudentReportsStep() {
        return null;
    }

    @Bean
    public Step generatePdfStep(final GeneratePdf generatePdf) {
        return this.stepBuilderFactory
                .get("generatePdfStep")
                .tasklet(generatePdf)
                .build();
    }

    @Bean
    public RetryTemplate retryTemplate() {
        //Back-off policy from 1 second x2 per attempt
        final ExponentialBackOffPolicy backOffPolicy = new ExponentialBackOffPolicy();
        backOffPolicy.setInitialInterval(SECONDS.toMillis(1));
        backOffPolicy.setMultiplier(2);

        //Retry after 1s, 2s, 4s, 8s, ... 128s, total max retry time of 255s
        final SimpleRetryPolicy retryPolicy = new SimpleRetryPolicy(7);

        final RetryTemplate retryTemplate = new RetryTemplate();
        retryTemplate.setBackOffPolicy(backOffPolicy);
        retryTemplate.setRetryPolicy(retryPolicy);

        return new RetryTemplate();
    }

    @Bean
    @JobScope
    public BlockingQueue<StudentChunk> studentChunks() {
        return new LinkedBlockingQueue<>();
    }

    @Bean
    @JobScope
    public Map<Long, StudentCompositeReport> studentReportsByExecution() {
        return new ConcurrentHashMap<>();
    }

    @Bean(destroyMethod = "cleanup")
    @JobScope
    public ReportGenerationTemporaryStorage reportTemporaryStorage(@Value("#{jobExecution.id}") final Long executionid) {
        return new ReportGenerationTemporaryStorage(executionid, reportGenerationProperties.getTemporaryStorageUri());
    }

    @Bean
    @ConfigurationProperties(prefix = "app.wkhtmltopdf.options")
    public Map<String, Object> wkhtmltopdfOptions() {
        return newHashMap();
    }

    @Autowired
    public void configure(final WkhtmltopdfWebServiceHtmlToPdfProcessor processor) {
        processor.setOptions(wkhtmltopdfOptions());
    }
}
