package org.opentestsystem.rdw.reporting.common.multithreaded;

import org.opentestsystem.rdw.utils.YamlPropertiesConfigurator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Import;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import static com.google.common.collect.Lists.newArrayList;

/**
 * A {@link CommandLineRunner} that finds and runs all instances of {@link MultiThreadedTest}s.
 * <p>
 * It was developed to reproduce and fix MySQL deadlock exceptions.
 * Yes, there is a way to run multithreaded tests withing Spring Test framework, but the exception was not
 * reproducibles. The best guess is that it is due to the way test transactions are managed.
 * There is probably a better way of doing, but this works.
 * <p>
 * Instances of {@link MultiThreadedTest} must clean after itself. Please see {@link MultiThreadedTest#cleanUp()}
 * <p>
 * The exist status 0 indicates a success.
 * The exist status > 0 indicates a number of failed tests
 */
@EnableTransactionManagement
@Import({YamlPropertiesConfigurator.class,
        DataSourceAutoConfiguration.class})
@Component
@Profile("mtTest")
public class MultiThreadedCommandLineRunner implements CommandLineRunner {

    private static final Logger logger = LoggerFactory.getLogger(MultiThreadedCommandLineRunner.class);
    @Autowired
    private ApplicationContext appContext;

    // expected number of {@link MultiThreadedTest}s.
    @Value("${mtTest.expectedTests:1}")
    private int expectedTests;

    // number of threads to run
    @Value("${mtTest.threadCount:10}")
    private int testThreadCount;

    @Override
    public void run(String... args) throws Exception {

        final List<Integer> failed = newArrayList();
        final String[] beans = appContext.getBeanNamesForType(MultiThreadedTest.class);

        if (beans.length != expectedTests) {
            logger.error("Found {} beans, expected {}", beans.length, expectedTests);
            System.exit(1);
        }

        final ExecutorService pool = Executors.newFixedThreadPool(testThreadCount);
        // this loops because running test just once does not always reproduced the issue
        for (int i = 0; i < 20; i++) {
            for (final String test : beans) {
                logger.info("Running test for [" + test + "] with thread count =" + testThreadCount);
                final boolean passed = appContext.getBean(test, MultiThreadedTest.class).run(pool, testThreadCount);
                logger.info(test + " " + (passed ? "passed" : "failed"));

                failed.add(passed ? 0 : 1);
            }
        }

        System.exit(failed.stream().mapToInt(Integer::intValue).sum());
    }
}