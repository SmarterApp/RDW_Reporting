package org.opentestsystem.rdw.reporting.common.multithreaded;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import static com.google.common.collect.Lists.newArrayList;

/**
 * A base class for running multi-threaded testing involving jdbc
 */
public abstract class MultiThreadedTest {
    protected static final Logger logger = LoggerFactory.getLogger(MultiThreadedTest.class);

    @Autowired
    private NamedParameterJdbcTemplate jdbcTemplate;

    protected volatile boolean passed = true;

    public NamedParameterJdbcTemplate getJdbcTemplate() {
        return jdbcTemplate;
    }

    /**
     * Hook to prepare the test data if needed; base class does nothing
     */
    protected void before() {
    }

    /**
     * Each test must provide an implementation of the work done during the test
     */
    protected abstract void work();

    /**
     * Hook to teardown the test; base class does nothing
     * Note: it is important to clean up any test data created by the test
     */
    protected void after() {
    }

    /**
     * A multithreaded test runner
     *
     * @return a flag indicating a pass or fail
     */
    public boolean run(final ExecutorService pool, final int threadCount) throws InterruptedException {
        before();

        final Runnable test = newRunnable();
        final List<Callable<Object>> tasks = newArrayList();
        for (int i = 0; i < threadCount; i++) {
            tasks.add(Executors.callable(test));
        }
        pool.invokeAll(tasks);

        after();
        cleanUp();
        return passed;
    }

    protected Runnable newRunnable() {
        return () -> {
            try {
                work();
            } catch (final Exception ex) {
                logger.error(this.getClass().getSimpleName() + ": " + (ex.getMessage() == null ? ex.getClass().getSimpleName() : ex.getMessage()));
                passed = false;
            }
        };
    }

    protected void cleanUp() {
    }
}
