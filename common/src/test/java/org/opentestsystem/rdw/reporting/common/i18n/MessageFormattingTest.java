package org.opentestsystem.rdw.reporting.common.i18n;

import org.junit.BeforeClass;
import org.junit.Test;
import org.springframework.context.MessageSource;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.ResourceLoader;

import java.util.Locale;
import java.util.function.BiConsumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.IntStream;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

/**
 * This test is to ensure the content put in the i18n/en.json is formatted correctly for the expected display
 */
public class MessageFormattingTest {

    private static TranslationProvider provider;

    /**
     * The locales the bundle currently supports
     */
    private static final Locale[] supportedLocales = new Locale[]{new Locale("en"), new Locale("es"), new Locale("vi"), null};

    /**
     * Finds and extracts formatted message placeholders
     */
    private static final Pattern formattedMessagePattern = Pattern.compile("\\{(\\d+)\\}");

    /**
     * Finds anchor tags in messages
     */
    private static final Pattern anchorPattern = Pattern.compile("<a .*</a>");

    /**
     * The message source to test
     */
    private static MessageSource source;


    @BeforeClass
    public static void beforeClass() {
        final ResourceLoader resourceLoader = mock(ResourceLoader.class);
        when(resourceLoader.getResource(anyString())).thenAnswer(invocation -> {
            final String location = invocation.getArgument(0);
            return new ClassPathResource(location);
        });

        provider = new JsonResourceTranslationProvider("/i18n/", resourceLoader);
        source = new TranslationProviderMessageSource(provider);
    }

    /**
     * In property files, formatted messages require single apostrophes to be escaped by a leading single apostrophe.
     * Unformatted messages do not require escaping single apostrophes.
     * This test asserts after processing of messages, there is no instance of consecutive apostrophes in the message.
     *
     * @throws Exception
     */
    @Test
    public void itShouldNotShowConsecutiveApostrophes() throws Exception {
        eachMessage((code, message) -> {
            assertThat(message).doesNotContain("{0}");
            assertThat(message).as("Message code: %s", code).doesNotContain("''");
        });
    }

    /**
     * This test makes sure all HTML anchor tags open in new tabs with target="_blank"
     *
     * @throws Exception
     */
    @Test
    public void allLinksShouldOpenInNewTabs() throws Exception {
        eachMessage((code, message) -> {
            final Matcher matcher = anchorPattern.matcher(message);
            while (matcher.find()) {
                final String anchor = matcher.group(0);
                assertThat(anchor).contains(" target=\"_blank\" ");
            }
        });
    }

    /**
     * Calls callback on each message of each message source property file
     *
     * @param callback the method to call with each message code and message
     * @throws Exception
     */
    private void eachMessage(BiConsumer<String, String> callback) throws Exception {
        for (final Locale locale : supportedLocales) {
            for (final Object key : provider.getTranslationsByCode(locale).keySet()) {
                final String code = (String) key;
                final String message = getMessage(source, code, locale);
                callback.accept(code, message);
            }
        }
    }


    /**
     * This method returns {@link MessageSource#getMessage(String, Object[], Locale)} for the given code and locale.
     * If the message is found to contain {N} parameter placeholders the method resolves these placeholders with PARAM_N format.
     *
     * @param source the message source to use
     * @param code   the message code
     * @param locale the locale to use
     * @return
     */
    private String getMessage(final MessageSource source, final String code, final Locale locale) {

        final String unformattedMessage = source.getMessage(code, null, locale);

        final Matcher matcher = formattedMessagePattern.matcher(unformattedMessage);
        int maximumIndex = -1;
        while (matcher.find()) {
            final int index = Integer.parseInt(matcher.group(1));
            if (index > maximumIndex) {
                maximumIndex = index;
            }
        }

        return maximumIndex >= 0
                ? source.getMessage(code, IntStream.range(0, maximumIndex + 1).mapToObj(i -> "PARAM_" + i).toArray(String[]::new), locale)
                : unformattedMessage;
    }

}
