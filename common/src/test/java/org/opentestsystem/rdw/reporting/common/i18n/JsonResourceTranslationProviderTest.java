package org.opentestsystem.rdw.reporting.common.i18n;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.ResourceLoader;

import java.util.Locale;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class JsonResourceTranslationProviderTest {

    @Mock
    private ResourceLoader resourceLoader;

    private JsonResourceTranslationProvider service;

    @Before
    public void setup() {
        when(resourceLoader.getResource(anyString())).thenAnswer(invocation -> {
           final String location = invocation.getArgument(0);
           return new ClassPathResource(location);
        });

        service = new JsonResourceTranslationProvider("/test_", resourceLoader);
    }

    @Test
    public void itShouldLoadJsonAsTranslationValues() {
        final Map<String, String> translations = service.getTranslationsByCode(Locale.US);
        assertThat(translations)
                .hasSize(5)
                .containsEntry("child_A.child_A", "Value A_A")
                .containsEntry("child_A.child_B", "Value A_B")
                .containsEntry("child_B.child_A", "Value B_A")
                .containsEntry("child_C.01", "Value C_1")
                .containsEntry("child_C.02", "Value C_2");
    }

    @Test
    public void itShouldHandleAMissingJsonResource() {
        final Map<String, String> translations = service.getTranslationsByCode(Locale.KOREA);
        assertThat(translations).isEmpty();
    }
}