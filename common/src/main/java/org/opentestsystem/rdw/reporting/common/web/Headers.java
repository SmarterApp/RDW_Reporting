package org.opentestsystem.rdw.reporting.common.web;

import java.nio.charset.Charset;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;

/**
 * This class holds HTTP header support methods derived from {@link org.springframework.http.HttpHeaders}
 */
public final class Headers {

    private Headers() {
    }

    /**
     * Formats and encodes the given filename for Content-Disposition: attachment;
     *
     * @param filename the filename
     * @param charset  the charset to encode the filename with
     * @return the content disposition header
     */
    public static String formatContentDispositionAttachment(final String filename, final Charset charset) {
        return formatContentDisposition("attachment", filename, charset);
    }

    /**
     * Formats and encodes the given filename for Content-Disposition: inline;
     *
     * @param filename the filename
     * @param charset  the charset to encode the filename with
     * @return the content disposition header
     */
    public static String formatContentDispositionInline(final String filename, final Charset charset) {
        return formatContentDisposition("inline", filename, charset);
    }

    /**
     * Formats and encodes the given filename for Content-Disposition: form-data;
     *
     * @param filename the filename
     * @param charset  the charset to encode the filename with
     * @return the content disposition header
     */
    public static String formatContentDispositionFormData(final String name, final String filename, final Charset charset) {
        return formatContentDisposition("form-data; name=\"" + name + "\"", filename, charset);
    }

    /**
     * Get the value of the {@code Content-Disposition}, optionally encoding the filename using the RFC 5987.
     * <p>Only the US-ASCII, UTF-8 and ISO-8859-1 charsets are supported.
     *
     * @param prefix   either inline, attachment or form-data
     * @param filename the filename (may be {@code null})
     * @param charset  the charset used for the filename (may be {@code null})
     * @see {@link org.springframework.http.HttpHeaders#setContentDispositionFormData(String, String)} for source of derivation
     */
    private static String formatContentDisposition(final String prefix, final String filename, final Charset charset) {
        checkNotNull(prefix, "'prefix' must not be null");
        final StringBuilder builder = new StringBuilder(prefix);
        if (filename != null) {
            if (charset == null || charset.name().equals("US-ASCII")) {
                builder.append("; filename=\"");
                builder.append(filename).append('\"');
            } else {
                builder.append("; filename*=");
                builder.append(encodeHeaderFieldParam(filename, charset));
            }
        }
        return builder.toString();
    }

    /**
     * Encode the given header field param as describe in RFC 5987.
     *
     * @param input   the header field param
     * @param charset the charset of the header field param string
     * @return the encoded header field param
     * @see {@link org.springframework.http.HttpHeaders#encodeHeaderFieldParam(String, Charset)} for source of derivation
     */
    public static String encodeHeaderFieldParam(final String input, final Charset charset) {
        checkNotNull(input, "Input String should not be null");
        checkNotNull(charset, "Charset should not be null");
        if (charset.name().equals("US-ASCII")) {
            return input;
        }
        checkArgument(charset.name().equals("UTF-8") || charset.name().equals("ISO-8859-1"),
                "Charset should be UTF-8 or ISO-8859-1");
        byte[] source = input.getBytes(charset);
        int len = source.length;
        StringBuilder sb = new StringBuilder(len << 1);
        sb.append(charset.name());
        sb.append("''");
        for (byte b : source) {
            if (isRFC5987AttrChar(b)) {
                sb.append((char) b);
            } else {
                sb.append('%');
                char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));
                char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));
                sb.append(hex1);
                sb.append(hex2);
            }
        }
        return sb.toString();
    }

    /**
     * @see {@link org.springframework.http.HttpHeaders#isRFC5987AttrChar(byte)} for source of derivation
     */
    private static boolean isRFC5987AttrChar(byte c) {
        return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||
                c == '!' || c == '#' || c == '$' || c == '&' || c == '+' || c == '-' ||
                c == '.' || c == '^' || c == '_' || c == '`' || c == '|' || c == '~';
    }

}
