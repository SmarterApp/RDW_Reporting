package org.opentestsystem.rdw.reporting.common.jdbc;

import com.google.common.base.Splitter;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import org.opentestsystem.rdw.reporting.common.report.ExamFilter;
import org.opentestsystem.rdw.reporting.common.security.PermissionScope;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Collection;
import java.util.List;
import java.util.Map;

import static com.google.common.base.Strings.isNullOrEmpty;

/**
 * Holds common methods for preparing SQL queries and parsing their results
 */
public class QueryUtils {

    private static final List<Long> UNMATCHABLE_IDS = ImmutableList.of(-1L);

    private QueryUtils() {
    }

    /**
     * Returns the given collection or the given default collection if the collection is null or empty
     *
     * @param collection   the collection to test null and empty for
     * @param defaultValue the collection to return if the given collection is null or empty
     * @param <T>          the collection element type
     * @return the given collection or the given default collection if the collection is null or empty
     */
    public static <T> Collection<T> nullOrEmptyToDefault(final Collection<T> collection, final Collection<T> defaultValue) {
        if (collection == null || collection.isEmpty()) {
            return defaultValue;
        }
        return collection;
    }

    /**
     * Returns the given value or the default value if the given value is null.
     *
     * @param value         A value
     * @param defaultValue  The default value
     * @param <T>           The value type
     * @return  The value or default value if the value is null
     */
    public static <T> T nullToDefault(final T value, final T defaultValue) {
        if (value == null) {
            return defaultValue;
        }
        return value;
    }

    /**
     * Creates map of SQL query parameters for the given permission scope
     *
     * @param permissionScope the security information to prepare the SQL query parameters for
     * @return map of SQL query parameters for the given permission scope
     */
    public static Map<String, Object> getSecurityParameters(final PermissionScope permissionScope) {
        return ImmutableMap.<String, Object>builder()
                .put("statewide", permissionScope.isStatewide())
                .put("district_ids", nullOrEmptyToDefault(permissionScope.getDistrictIds(), UNMATCHABLE_IDS))
                .put("school_ids", nullOrEmptyToDefault(permissionScope.getInstitutionIds(), UNMATCHABLE_IDS))
                .build();
    }

    public static Map<String, Object> getExamFilterParameters(final ExamFilter examFilter) {
        return ImmutableMap.<String, Object>builder()
                .put("subject_id", nullToDefault(examFilter.getSubject(), -1))
                .put("assessment_type", nullToDefault(examFilter.getAssessmentType(), -1))
                .put("school_id", nullToDefault(examFilter.getSchoolId(), -1))
                .put("grade_id", nullToDefault(examFilter.getGradeId(), -1))
                .put("group_id", nullToDefault(examFilter.getGroupId(), -1))
                .put("school_year", nullToDefault(examFilter.getSchoolYear(), -1))
                .build();
    }

    /**
     * Returns the given value or null if the last column lookup resulted in a null value.
     * This is a workaround for two things: typecasting the return value of {@link ResultSet#getObject(String)} for getNullable columns
     * <ol>
     * <li>{@link ResultSet#getLong(String)} and other primitive type lookups will turn null into the default values
     * (e.g. null boolean will be false, null long will be 0)</li>
     * <li>Type casting the result of {@link ResultSet#getLong(String)} can result in type cast exceptions if the
     * database driver returns an Integer and you cast to Long.</li>
     * </ol>
     *
     * @param resultSet the row of data which will be checked for null
     * @param value     the result of the row lookup (e.g. resultSet.getLong("column_name"))
     * @param <T>       the type of the provided value
     * @return the value or null if the column lookup was null
     * @throws SQLException
     */
    public static <T> T getNullable(final ResultSet resultSet, final T value) throws SQLException {
        return resultSet.wasNull() ? null : value;
    }

    /**
     * Splits the given delimited values string with the given delimiting character.
     * If the given delimited values string is null or empty it will return null
     *
     * @param delimitedValues string of delimited values
     * @param delimiter       string delimiting the values
     * @return the delimited values split or null if the delimited values are null or empty
     */
    public static List<String> safeSplit(final String delimitedValues, final String delimiter) {
        if (isNullOrEmpty(delimitedValues)) {
            return null;
        }
        return ImmutableList.copyOf(Splitter.on(delimiter).split(delimitedValues));
    }

}
