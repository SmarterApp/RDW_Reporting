package org.opentestsystem.rdw.reporting.common.sqlbuilder;

import com.healthmarketscience.sqlbuilder.CustomCondition;
import com.healthmarketscience.sqlbuilder.CustomSql;
import com.healthmarketscience.sqlbuilder.SelectQuery;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.google.common.base.Preconditions.checkArgument;
import static org.opentestsystem.rdw.reporting.common.sqlbuilder.SqlClause.FROM;
import static org.opentestsystem.rdw.reporting.common.sqlbuilder.SqlClause.GROUP_BY;
import static org.opentestsystem.rdw.reporting.common.sqlbuilder.SqlClause.JOIN;
import static org.opentestsystem.rdw.reporting.common.sqlbuilder.SqlClause.SELECT;
import static org.opentestsystem.rdw.reporting.common.sqlbuilder.SqlClause.WHERE;

/**
 * This class is responsible for constructing sql queries from {@link SqlTemplate} defined by {@link SqlBuilderConfig}
 */
@Component
public class QueryProvider {
    private static final String DefaultTemplateName = "default";

    private final SqlBuilderConfig sqlBuilderConfig;

    /**
     * Constructor
     *
     * @param sqlBuilderConfig the {@link SqlBuilderConfig}
     */
    @Autowired
    public QueryProvider(final SqlBuilderConfig sqlBuilderConfig) {
        this.sqlBuilderConfig = sqlBuilderConfig;
    }

    /**
     * Returns a {@link SelectQuery} constructed by scanning the {@link SqlTemplate} and applying its{@link SqlTemplate#addons}
     *
     * @param templateName the {@link SqlTemplate}'s name
     * @param addons       the {@link SqlTemplate#addons}'s names
     * @return constructed {@link SelectQuery}
     */
    public SelectQuery newQuery(final String templateName, final Iterable<String> addons) {
        checkArgument(sqlBuilderConfig.getTemplates() != null && sqlBuilderConfig.getTemplates().containsKey(templateName), "unknown sql builder template name " + templateName);

        // get the specified report template, checking that it has some clauses
        final SqlTemplate template = sqlBuilderConfig.getTemplates().get(templateName);
        checkArgument(template.getClauses() != null, "missing clauses for template " + templateName);

        // get the default addons, and replace any template-specific addons
        // this allows us to easily get the addons, preferring the report template while falling back to defaults
        // (Note: shallow copy is enough to ensure map doesn't get corrupted by the overrides.)
        final Map<String, SqlTemplate> defaultAddons =
            new HashMap<>(sqlBuilderConfig.getTemplates().get(DefaultTemplateName).getAddons());
        if (template.getAddons() != null) {
            defaultAddons.putAll(template.getAddons());
        }

        // load the addon templates, checking that they are all found
        final List<SqlTemplate> addonTemplates = new ArrayList<>();
        for (final String addon : addons) {
            final SqlTemplate addonTemplate = defaultAddons.get(addon);
            checkArgument(addonTemplate != null, "missing sqlbuilder addon " + addon + " for template " + templateName);
            addonTemplates.add(addonTemplate);
        }

        // build the query
        final SelectQuery query = new SelectQuery();
        checkFrom(query, template, addonTemplates);
        addClauses(template, query);
        addonTemplates.forEach(addonTemplate -> addClauses(addonTemplate, query));

        return query;
    }

    /**
     * Returns a SQL string constructed by scanning the {@link SqlTemplate} and applying its{@link SqlTemplate#addons}
     *
     * @param templateName the {@link SqlTemplate}'s name
     * @param addons       the {@link SqlTemplate#addons}'s names
     * @return constructed SQL string
     */
    public String newQueryAsString(final String templateName, final Iterable<String> addons) {
        return newQuery(templateName, addons).toString();
    }

    private void checkFrom(final SelectQuery query, final SqlTemplate template, final Iterable<SqlTemplate> addonTemplates) {
        boolean containsFrom = template.getClauses().containsKey(FROM);
        if (containsFrom) {
            query.addCustomFromTable(template.getClauses().get(FROM));
            return;
        }

        for (final SqlTemplate addonTemplate : addonTemplates) {
            if (addonTemplate.getClauses().containsKey(FROM)) {
                query.addCustomFromTable(addonTemplate.getClauses().get(FROM));
                return;
            }
        }

        throw new IllegalArgumentException("missing FROM clause for template");
    }

    private void addClauses(final SqlTemplate template, final SelectQuery query) {
        // FROM clause is applicable to the main template only and is handled separately
        final SqlClause[] clauses = {SELECT, JOIN, WHERE, GROUP_BY};

        for (final SqlClause clause : clauses) {
            if (template.getClauses().containsKey(clause)) {
                addClause(query, clause, template.getClauses().get(clause));
            }
        }
    }

    private void addClause(final SelectQuery query, final SqlClause clause, final String clauseSql) {
        final String customSql = " " + clauseSql;
        switch (clause) {
            case SELECT:
                query.addCustomColumns(new CustomSql(customSql));
                break;
            case JOIN:
                query.addCustomJoin(customSql);
                break;
            case WHERE:
                query.addCondition(new CustomCondition(customSql));
                break;
            case GROUP_BY:
                query.addCustomGroupings(customSql);
                break;
            default:
                throw new IllegalArgumentException("unsupported request for the given clause " + clause);
        }
    }
}
