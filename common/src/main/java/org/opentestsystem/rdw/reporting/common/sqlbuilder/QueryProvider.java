package org.opentestsystem.rdw.reporting.common.sqlbuilder;

import com.healthmarketscience.sqlbuilder.CustomCondition;
import com.healthmarketscience.sqlbuilder.CustomSql;
import com.healthmarketscience.sqlbuilder.SelectQuery;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import static com.google.common.base.Preconditions.checkArgument;

/**
 * This class is responsible for constructing sql queries from {@link SqlTemplate} templates
 */
@Component
public class QueryProvider {

    private final SqlBuilderConfig sqlBuilderConfig;
    private final String SelectClause = "select";
    private final String JoinClause = "join";
    private final String WhereClause = "conditions";
    private final String GroupByClause = "grouping";
    final String[] clauseNames = {SelectClause, JoinClause, WhereClause, GroupByClause};

    /**
     * Constructor
     *
     * @param sqlBuilderConfig the {@link SqlBuilderConfig}
     */
    @Autowired
    public QueryProvider(final SqlBuilderConfig sqlBuilderConfig) {
        this.sqlBuilderConfig = sqlBuilderConfig;
    }

    /**
     * Returns a {@link SelectQuery} constructed by combing the {@link SqlTemplate} and applying its{@link SqlTemplate#addons}
     *
     * @param templateName the {@link SqlTemplate}'s name
     * @param addons       the {@link SqlTemplate#addons}'s names
     * @return constructed {@link SelectQuery}
     */
    public SelectQuery newQuery(final String templateName, final Iterable<String> addons) {
        checkArgument(sqlBuilderConfig.getTemplates() != null && sqlBuilderConfig.getTemplates().containsKey(templateName), "unknown sql builder template name " + templateName);


        final SqlTemplate template = sqlBuilderConfig.getTemplates().get(templateName);
        checkArgument(template.getClauses() != null && template.getClauses().containsKey("from"), "missing from clause for template" + templateName);

        final SelectQuery query = new SelectQuery().addCustomFromTable(template.clauses.get("from"));
        addClauses(template, query);

        for (final String addon : addons) {
            checkArgument(template.getAddons() != null && template.getAddons().containsKey(addon), "missing sqlbuilder addon template" + templateName);
            addClauses(template.getAddons().get(addon), query);
        }

        return query;
    }

    /**
     * Returns a SQL string constructed by combing the {@link SqlTemplate} and applying its{@link SqlTemplate#addons}
     *
     * @param templateName the {@link SqlTemplate}'s name
     * @param addons       the {@link SqlTemplate#addons}'s names
     * @return constructed SQL string
     */
    public String newQueryAsString(final String templateName, final Iterable<String> addons) {
        return newQuery(templateName, addons).toString();
    }

    private void addClauses(final SqlTemplate template, final SelectQuery query) {
        for (final String clause : clauseNames) {
            if (template.getClauses().containsKey(clause)) {
                addClause(query, clause, template.getClauses().get(clause));
            }
        }
    }

    private void addClause(final SelectQuery query, final String clauseName, final String clause) {
        switch (clauseName) {
            case SelectClause:
                query.addCustomColumns(new CustomSql(" " + clause));
                break;
            case JoinClause:
                query.addCustomJoin(" " + clause);
                break;
            case WhereClause:
                query.addCondition(new CustomCondition(" " + clause));
                break;
            case GroupByClause:
                query.addCustomGroupings(" " + clause);
                break;
        }
    }
}
