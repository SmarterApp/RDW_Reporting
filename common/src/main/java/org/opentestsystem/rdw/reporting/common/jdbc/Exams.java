package org.opentestsystem.rdw.reporting.common.jdbc;

import org.opentestsystem.rdw.reporting.common.model.Exam;
import org.opentestsystem.rdw.reporting.common.model.School;
import org.opentestsystem.rdw.security.Permission;
import org.opentestsystem.rdw.security.PermissionScope;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Map;

import static com.google.common.base.Preconditions.checkArgument;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.getNullable;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.safeSplit;
import static org.opentestsystem.rdw.reporting.common.security.ReportingPermission.GroupPiiRead;
import static org.opentestsystem.rdw.reporting.common.security.ReportingPermission.IndividualPiiRead;

/**
 * Holds utility methods for mapping SQL query results to the {@link Exam}
 * <p>
 * This class maps all columns defined by the sql.snippet.examColumns
 * It does not map {@link Exam#claimScaleScores}, {@link Exam#student} or writing trait data
 */
@SuppressWarnings("unchecked")
public final class Exams {

    private Exams() {
    }

    /**
     * Populate an Exam.Builder from a database result set.
     * NOTE This will populate all exams as "Non-Transfer."
     *
     * @param row     The database result set
     * @param builder The builder to populate
     * @param <A>     The exam builder concrete class
     * @return The populated exam builder
     * @throws SQLException if the columnLabel is not valid
     */
    public static <A extends Exam.Builder> A map(final ResultSet row, final A builder) throws SQLException {
        final School school = buildSchool(row);
        return (A) map(row, builder.school(school), !hasSchoolAccess(school, PermissionScope.STATEWIDE));
    }

    /**
     * Populate an Exam.Builder from a database result set.
     * NOTE this will determine if an Exam is designated as a "Transfer Exam" based upon the given
     * permissions.  If the user does not natively have access to the exam's school, it is designated
     * as a transfer exam.
     *
     * @param row         The database result set
     * @param builder     The builder to populate
     * @param permissions The map of user's permissions
     * @param <A>         The exam builder concrete class
     * @return The populated exam builder
     * @throws SQLException if the columnLabel is not valid
     */
    public static <A extends Exam.Builder> A map(final ResultSet row, final A builder, final Map<String, Permission> permissions) throws SQLException {

        final Permission individualPii = permissions.get(IndividualPiiRead);
        final Permission groupPii = permissions.get(GroupPiiRead);
        checkArgument(individualPii != null || groupPii != null, "valid permission scope is required");

        final School school = buildSchool(row);
        return (A) map(row, builder.school(school), individualPii != null ? !hasSchoolAccess(school, individualPii.getScope()) : !hasSchoolAccess(school, groupPii.getScope()));
    }

    private static School buildSchool(final ResultSet row) throws SQLException {
        return School.builder()
                .id(row.getLong("school_id"))
                .name(row.getString("school_name"))
                .districtId(row.getLong("school_district_id"))
                .districtGroupId(getNullable(row, row.getLong("school_district_group_id")))
                .schoolGroupId(getNullable(row, row.getLong("school_group_id")))
                .build();
    }

    private static <A extends Exam.Builder> A map(final ResultSet row, final A builder, final boolean transfer) throws SQLException {
        builder.id(row.getLong("id"))
                .sessionId(row.getString("session_id"))
                .dateTime(row.getTimestamp("completed_at").toInstant())
                .gradeCode(row.getString("grade_code"))
                .completenessCode(row.getString("completeness_code"))
                .administrativeConditionCode(row.getString("administration_condition_code"))
                .schoolYear(row.getInt("school_year"))
                .accommodationCodes(safeSplit(row.getString("available_accommodation_codes"), "|"))
                .scaleScore(ScaleScores.mapOverall(row))
                .transfer(transfer);

        return builder;
    }

    /**
     * Determine if the given permissions allow access to the given school.
     *
     * @param school          A school
     * @param permissionScope A permission scope
     * @return True if the permissions allow access to the given school
     */
    private static boolean hasSchoolAccess(final School school, final PermissionScope permissionScope) {
        return permissionScope.isStatewide() ||
                permissionScope.getDistrictIds().contains(school.getDistrictId()) ||
                permissionScope.getInstitutionIds().contains(school.getId()) ||
                (school.getDistrictGroupId() != null && permissionScope.getDistrictGroupIds().contains(school.getDistrictGroupId())) ||
                (school.getSchoolGroupId() != null && permissionScope.getInstitutionGroupIds().contains(school.getSchoolGroupId()));
    }
}
