package org.opentestsystem.rdw.reporting.common.report;

import com.google.common.collect.ImmutableList;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.reporting.common.model.Assessment;
import org.opentestsystem.rdw.reporting.common.model.Exam;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.MessageSource;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Locale;

import static com.google.common.collect.Lists.newArrayList;
import static java.lang.Math.toIntExact;
import static java.util.stream.Collectors.toList;

/**
 * Holds utility methods to help render the exam reports
 */
@Component
public class ReportViewSupport {

    private final MessageSource messageSource;

    @Autowired
    public ReportViewSupport(final MessageSource messageSource) {
        this.messageSource = messageSource;
    }

    /**
     * Gets a sorted list of accommodation names for the given exam and language
     *
     * @param exam   the exam for which the accommodations were available
     * @param locale the language to display the accommodations in
     * @return accommodation names sorted in natural order
     */
    public List<String> getSortedAccommodationNames(final Exam exam, final Locale locale) {
        return exam.getAccommodationCodes().stream()
                .map(value -> messageSource.getMessage(value, null, locale))
                .sorted()
                .collect(toList());
    }

    /**
     * Gets the last two digits of the given integer
     *
     * @param value the integer to get the last two digits from
     * @return the last two digits of the given integer
     */
    public String getLastTwoDigits(final int value) {
        final String nextYear = Integer.toString(value);
        return nextYear.substring(nextYear.length() - 2);
    }

    /**
     * Gets the product of {@link Math#round(double)} on the given value
     *
     * @param value the value to round
     * @return returns the product of {@link Math#round(double)} on the given value
     */
    public long round(final double value) {
        return Math.round(value);
    }

    /**
     * Gets the position and width attributes necessary for rendering a scale score graph
     *
     * @param exam       the exam to use for computing the scale score position
     * @param assessment the assessment to use for computing the cut point bar attributes
     * @return the position and width attributes necessary for rendering a scale score graph
     */
    public ScaleScoreView getScaleScoreView(final Exam exam, final Assessment assessment) {

        final List<Integer> cutPoints = assessment.getType() == AssessmentType.ICA
                ? assessment.getCutPoints()
                // Process IAB cut points for use in display
                : newArrayList(
                assessment.getCutPoints().get(0),
                // The second and third cut point are the middle cut point +/- the product of the individual exam
                // result scale score standard error * 1.5
                toIntExact(assessment.getCutPoints().get(2) - Math.round(exam.getScaleScore().getStandardError() * 1.5)),
                toIntExact(assessment.getCutPoints().get(2) + Math.round(exam.getScaleScore().getStandardError() * 1.5)),
                assessment.getCutPoints().get(4)
        );

        final int scaleScore = exam.getScaleScore().getValue();
        final int minimumScore = cutPoints.get(0);
        final int maximumScore = cutPoints.get(cutPoints.size() - 1);
        final int length = maximumScore - minimumScore;

        // the whole percent of the scale score position along the length of the graph
        final int position = getPercendRounded(scaleScore - minimumScore, length);

        final List<ScaleScoreView.Level> levels = newArrayList();
        for (int i = 1; i < cutPoints.size(); i++) {
            final int previous = cutPoints.get(i - 1) - minimumScore;
            final int current = cutPoints.get(i) - minimumScore;
            final int sumOfWidth = levels.stream().mapToInt(ScaleScoreView.Level::getWidth).sum();

            final int width = i < cutPoints.size() - 1
                    ? getPercendRounded(current - previous, length)
                    // The last bar should be the remaining percent width of the graph
                    // This will avoid rounding errors and the graph width not adding to 100 percent
                    : 100 - sumOfWidth;

            levels.add(new ScaleScoreView.Level(sumOfWidth, width));

        }
        return new ScaleScoreView(position, ImmutableList.copyOf(levels));
    }

    /**
     * Gets the percent distance covered by the given position along the given length
     * Assumes position and length are positive values
     *
     * @param position the position along the length
     * @param length   the distance
     * @return the percent distance covered by the given position along the given length
     */
    private float getPercent(final float position, final float length) {
        return (position / length) * 100f;
    }

    /**
     * Gets the percent distance covered by the given position along the given length in whole percent (0 - 100)
     * Assumes position and length are positive values
     *
     * @param position the position along the length
     * @param length   the distance
     * @return the percent distance covered by the given position along the given length in whole percent (0 - 100)
     */
    private int getPercendRounded(final float position, final float length) {
        return Math.round(getPercent(position, length));
    }

}
