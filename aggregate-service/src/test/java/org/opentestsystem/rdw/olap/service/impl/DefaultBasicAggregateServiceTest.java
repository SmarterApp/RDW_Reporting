package org.opentestsystem.rdw.olap.service.impl;

import com.google.common.collect.ImmutableSet;
import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.opentestsystem.rdw.olap.AggregateReportSettings;
import org.opentestsystem.rdw.olap.model.BasicAggregateReportResult;
import org.opentestsystem.rdw.olap.model.AggregateReportQuery;
import org.opentestsystem.rdw.olap.repository.AggregateReportRepository;
import org.opentestsystem.rdw.olap.service.AuthorizationService;
import org.opentestsystem.rdw.olap.service.BasicAggregateService;
import org.opentestsystem.rdw.olap.sqlbuilder.QueryProviderRepositoryHelper;
import org.opentestsystem.rdw.reporting.common.model.ActiveAssessment;
import org.opentestsystem.rdw.reporting.common.model.BasicAggregateReportQuery;
import org.opentestsystem.rdw.reporting.common.model.BasicAggregateRow;
import org.opentestsystem.rdw.reporting.common.model.Dimension;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.FilteredSubgroupReportQuery;
import org.opentestsystem.rdw.reporting.common.model.Measures;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.model.StudentFilters;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.springframework.core.task.TaskExecutor;

import static com.google.common.collect.ImmutableSet.of;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.common.model.AssessmentType.IAB;
import static org.opentestsystem.rdw.common.model.AssessmentType.ICA;
import static org.opentestsystem.rdw.common.model.AssessmentType.SUMMATIVE;
import static org.opentestsystem.rdw.common.model.Subject.MATH;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Ethnicity;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Gender;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Overall;

public class DefaultBasicAggregateServiceTest {
    private AggregateReportRepository repository;
    private BasicAggregateService service;
    private AuthorizationService authorizationService;
    private BasicAggregateReportQuery.Builder reportQueryBuilder;
    private QueryPoolExecutor queryPoolExecutor;
    private QueryProviderRepositoryHelper repositoryHelper;
    private User user;

    @Before
    public void setUp() {
        final AggregateReportSettings aggregateReportSettings = mock(AggregateReportSettings.class);

        repositoryHelper = mock(QueryProviderRepositoryHelper.class);
        repository = mock(AggregateReportRepository.class);
        authorizationService = mock(AuthorizationService.class);
        queryPoolExecutor = new QueryPoolExecutor();
        queryPoolExecutor.setPartitionSize(2);

        final TaskExecutor threadPoolTaskExecutor = queryPoolExecutor.threadPoolTaskExecutor();
        when(aggregateReportSettings.getStateAggregateAssessmentTypes()).thenReturn(ImmutableSet.of(SUMMATIVE.code()));

        service = new DefaultBasicAggregateService(repository, authorizationService, aggregateReportSettings, repositoryHelper, threadPoolTaskExecutor);

        reportQueryBuilder = BasicAggregateReportQuery.builder()
                .assessmentGradeCodes(of("-8"))
                .schoolIds(ImmutableSet.of(123L))
                .schoolYears(of(1999))
                .schoolIds(of(123L))
                .subjectCodes(of(MATH.code()))
                .assessmentTypeCode(IAB.code());

        user = User.builder()
                .id("id")
                .username("username")
                .password("password")
                .build();
    }

    @Test
    public void itShouldHandleBasicAggregateReportQuery() {
        assertThat(service.handles(BasicAggregateReportQuery.builder().build())).isTrue();
        assertThat(service.handles(FilteredSubgroupReportQuery.builder().build())).isFalse();
    }

    @Test(expected = NullPointerException.class)
    public void itShouldRequireNotNullQuery() {
        service.findByQuery(user, null);
    }

    @Test
    public void itShouldCallAuthorizationServiceToFindByQuery() {
        final BasicAggregateReportQuery query = reportQueryBuilder.build();
        final BasicAggregateReportResult report = BasicAggregateReportResult.builder()
                .row(reportRow(OrganizationType.School, -123L, Overall).build())
                .build();
        when(repository.findByOrganizationType(any(User.class), any(AggregateReportQuery.class), any(OrganizationType.class)))
                .thenAnswer(invocation -> {
                    return report;
                });

        assertThat(service.findByQuery(user, query)).isEqualToComparingFieldByFieldRecursively(report);
        verify(authorizationService).checkAuthorization(user, query);
    }

    @Test
    public void itShouldCallAuthorizationServiceToEstimateReportRowCount() {
        final BasicAggregateReportQuery query = reportQueryBuilder.build();
        when(repository.estimateReportRowCountByOrganizationType(any(AggregateReportQuery.class), any(OrganizationType.class))).thenReturn(10);

        assertThat(service.estimateReportRowCount(user, query)).isEqualTo(10);
        verify(authorizationService).checkAuthorization(user, query);
    }

    @Test
    public void itShouldAddOverallDimensionIfNoDimensionIsGiven() {
        final ArgumentCaptor<AggregateReportQuery> queryArgumentCaptor = ArgumentCaptor.forClass(AggregateReportQuery.class);

        final BasicAggregateReportResult emptyResult = BasicAggregateReportResult.builder().build();
        when(repository.findByOrganizationType(any(User.class), any(AggregateReportQuery.class), any(OrganizationType.class))).thenReturn(emptyResult);
        service.findByQuery(user, reportQueryBuilder.build());

        verify(repository).findByOrganizationType(eq(user), queryArgumentCaptor.capture(), eq(OrganizationType.School));
        assertThat(queryArgumentCaptor.getValue().getDimensionType()).isEqualTo(DimensionType.Overall);
    }

    @Test
    public void itShouldConvertQueryIntoMultipleOrganizationQueriesAndMergeResults() {
        final BasicAggregateReportResult stateReport = BasicAggregateReportResult.builder().row(reportRow(OrganizationType.State, -1L, Overall).build()).build();
        final BasicAggregateReportResult schoolReport = BasicAggregateReportResult.builder().row(reportRow(OrganizationType.School, -2L, Overall).build()).build();
        final BasicAggregateReportResult districtReport = BasicAggregateReportResult.builder().row(reportRow(OrganizationType.School, -3L, Overall).build()).build();

        final BasicAggregateReportQuery query = reportQueryBuilder
                .assessmentTypeCode(SUMMATIVE.code())
                .includeState(true)
                .districtIds(of(-19L, -29L))
                .dimensionType(Overall)
                .build();

        final AggregateReportQuery stateQuery = toQueryBuilderWithCommonAttributes(query)
                .organizationType(OrganizationType.State)
                .organizationIds(of())
                .dimensionType(Overall)
                .build();

        final AggregateReportQuery schoolQuery = toQueryBuilderWithCommonAttributes(query)
                .organizationType(OrganizationType.School)
                .organizationIds(query.getSchoolIds())
                .dimensionType(Overall)
                .build();

        final AggregateReportQuery districtQuery = toQueryBuilderWithCommonAttributes(query)
                .organizationType(OrganizationType.District)
                .organizationIds(query.getDistrictIds())
                .dimensionType(Overall)
                .build();

        when(repository.findByOrganizationType(eq(user), eq(stateQuery), eq(OrganizationType.State))).thenReturn(stateReport);
        when(repository.findByOrganizationType(eq(user), eq(schoolQuery), eq(OrganizationType.School))).thenReturn(schoolReport);
        when(repository.findByOrganizationType(eq(user), eq(districtQuery), eq(OrganizationType.District))).thenReturn(districtReport);

        assertThat(service.findByQuery(user, query).getPayload()).usingRecursiveFieldByFieldElementComparator()
                .containsExactlyInAnyOrder(stateReport.getPayload().get(0), schoolReport.getPayload().get(0), districtReport.getPayload().get(0));

        verify(repository).findByOrganizationType(eq(user), eq(schoolQuery), eq(OrganizationType.School));
        verify(repository).findByOrganizationType(eq(user), eq(districtQuery), eq(OrganizationType.District));
        verify(repository).findByOrganizationType(eq(user), eq(stateQuery), eq(OrganizationType.State));
    }

    @Test
    public void itShouldConvertQueryIntoMultipleDimensionQueriesAndMergeResults() {

        final BasicAggregateReportResult overallReport = BasicAggregateReportResult.builder().row(reportRow(OrganizationType.State, -1L, Overall).build()).build();
        final BasicAggregateReportResult genderReport = BasicAggregateReportResult.builder().row(reportRow(OrganizationType.State, -1L, Gender).build()).build();
        final BasicAggregateReportResult ethnicityReport = BasicAggregateReportResult.builder().row(reportRow(OrganizationType.State, -1L, Ethnicity).build()).build();

        final BasicAggregateReportQuery query = reportQueryBuilder
                .assessmentTypeCode(SUMMATIVE.code())
                .includeState(true)
                .schoolIds(of())
                .dimensionTypes(of(Overall, Gender, Ethnicity))
                .build();

        final AggregateReportQuery overallQuery = toQueryBuilderWithCommonAttributes(query)
                .organizationType(OrganizationType.State)
                .organizationIds(of())
                .dimensionType(Overall)
                .build();

        final AggregateReportQuery genderQuery = toQueryBuilderWithCommonAttributes(query)
                .organizationType(OrganizationType.State)
                .organizationIds(of())
                .dimensionType(Gender)
                .build();

        final AggregateReportQuery ethnicityQuery = toQueryBuilderWithCommonAttributes(query)
                .organizationType(OrganizationType.State)
                .organizationIds(of())
                .dimensionType(Ethnicity)
                .build();

        when(repository.findByOrganizationType(eq(user), eq(overallQuery), eq(OrganizationType.State))).thenReturn(overallReport);
        when(repository.findByOrganizationType(eq(user), eq(genderQuery), eq(OrganizationType.State))).thenReturn(genderReport);
        when(repository.findByOrganizationType(eq(user), eq(ethnicityQuery), eq(OrganizationType.State))).thenReturn(ethnicityReport);

        assertThat(service.findByQuery(user, query).getPayload()).usingRecursiveFieldByFieldElementComparator()
                .containsExactlyInAnyOrder(overallReport.getPayload().get(0), genderReport.getPayload().get(0), ethnicityReport.getPayload().get(0));

        verify(repository).findByOrganizationType(eq(user), eq(overallQuery), eq(OrganizationType.State));
        verify(repository).findByOrganizationType(eq(user), eq(genderQuery), eq(OrganizationType.State));
        verify(repository).findByOrganizationType(eq(user), eq(ethnicityQuery), eq(OrganizationType.State));
    }

    @Test
    public void itShouldIncludeAllDistricts() {
        final BasicAggregateReportResult districtReport = BasicAggregateReportResult.builder().row(reportRow(OrganizationType.District, -3L, Overall).build()).build();

        final BasicAggregateReportQuery query = reportQueryBuilder
                .assessmentTypeCode(SUMMATIVE.code())
                .includeAllDistricts(true)
                .schoolIds(of())
                .districtIds(of(-19L))
                .dimensionType(Overall)
                .build();

        final AggregateReportQuery districtQuery = toQueryBuilderWithCommonAttributes(query)
                .organizationType(OrganizationType.State)
                .organizationIds(of())
                .dimensionType(Overall)
                .build();

        when(repository.findByOrganizationType(eq(user), eq(districtQuery), eq(OrganizationType.District))).thenReturn(districtReport);

        assertThat(service.findByQuery(user, query)).isEqualToComparingFieldByFieldRecursively(districtReport);

        verify(repository).findByOrganizationType(eq(user), eq(districtQuery), eq(OrganizationType.District));
    }

    @Test
    public void itShouldIncludeDistrictsAndDistrictsOfSchools() {
        final BasicAggregateReportResult districtReport = BasicAggregateReportResult.builder().row(reportRow(OrganizationType.District, -3L, Overall).build()).build();
        final BasicAggregateReportResult schoolReport = BasicAggregateReportResult.builder().row(reportRow(OrganizationType.School, -2L, Overall).build()).build();

        final BasicAggregateReportQuery query = reportQueryBuilder
                .assessmentTypeCode(SUMMATIVE.code())
                .includeAllDistricts(false)
                .schoolIds(of(-123L))
                .includeAllDistrictsOfSchools(true)
                .districtIds(of(-19L, -27L))
                .dimensionType(Overall)
                .build();

        when(repositoryHelper.findAllDistrictsOfSchools(query.getSchoolIds())).thenReturn(of(-19L, -77L));

        final AggregateReportQuery districtQuery = toQueryBuilderWithCommonAttributes(query)
                .organizationType(OrganizationType.District)
                .organizationIds(of(-19L, -27L, -77L))
                .dimensionType(Overall)
                .build();

        final AggregateReportQuery schoolQuery = toQueryBuilderWithCommonAttributes(query)
                .organizationType(OrganizationType.School)
                .organizationIds(of(-123L))
                .dimensionType(Overall)
                .build();

        when(repository.findByOrganizationType(eq(user), eq(districtQuery), eq(OrganizationType.District))).thenReturn(districtReport);
        when(repository.findByOrganizationType(eq(user), eq(schoolQuery), eq(OrganizationType.School))).thenReturn(schoolReport);

        assertThat(service.findByQuery(user, query).getPayload()).usingRecursiveFieldByFieldElementComparator()
                .containsExactlyInAnyOrder(schoolReport.getPayload().get(0), districtReport.getPayload().get(0));

        verify(repository).findByOrganizationType(eq(user), eq(schoolQuery), eq(OrganizationType.School));
        verify(repository).findByOrganizationType(eq(user), eq(districtQuery), eq(OrganizationType.District));
    }

    @Test
    public void itShouldIncludeAllSchoolsOfDistricts() {
        final BasicAggregateReportResult districtReport = BasicAggregateReportResult.builder().row(reportRow(OrganizationType.District, -19L, Overall).build()).build();
        final BasicAggregateReportResult schoolReport = BasicAggregateReportResult.builder().row(reportRow(OrganizationType.School, -2L, Overall).build()).build();

        final BasicAggregateReportQuery query = reportQueryBuilder
                .assessmentTypeCode(SUMMATIVE.code())
                .includeAllSchoolsOfDistricts(true)
                .districtIds(of(-19L))
                .schoolIds(of(-2L))
                .dimensionType(Overall)
                .build();

        final AggregateReportQuery districtQuery = toQueryBuilderWithCommonAttributes(query)
                .organizationType(OrganizationType.District)
                .organizationIds(of(-19L))
                .dimensionType(Overall)
                .build();

        when(repositoryHelper.findSchoolsIdsByDistrictIds(eq(of(-19L)))).thenReturn(of(-2L));
        when(repository.findByOrganizationType(eq(user), eq(districtQuery), eq(OrganizationType.District))).thenReturn(districtReport);
        when(repository.findByOrganizationType(eq(user), eq(districtQuery), eq(OrganizationType.School))).thenReturn(schoolReport);

        assertThat(service.findByQuery(user, query).getPayload()).usingRecursiveFieldByFieldElementComparator()
                .containsExactlyInAnyOrder(schoolReport.getPayload().get(0), districtReport.getPayload().get(0));

        verify(repository).findByOrganizationType(eq(user), eq(districtQuery), eq(OrganizationType.District));
        verify(repository).findByOrganizationType(eq(user), eq(districtQuery), eq(OrganizationType.School));
    }

    @Test
    public void itShouldIncludeAllSchoolsOfDistrictsForAllDistricts() {
        final BasicAggregateReportResult districtReport = BasicAggregateReportResult.builder().row(reportRow(OrganizationType.District, -19L, Overall).build()).build();
        final BasicAggregateReportResult schoolReport = BasicAggregateReportResult.builder().row(reportRow(OrganizationType.School, -2L, Overall).build()).build();

        final BasicAggregateReportQuery query = reportQueryBuilder
                .assessmentTypeCode(SUMMATIVE.code())
                .includeAllDistricts(true)
                .schoolIds(of())
                .districtIds(of())
                .includeAllSchoolsOfDistricts(true)
                .dimensionType(Overall)
                .build();

        final AggregateReportQuery stateQuery = toQueryBuilderWithCommonAttributes(query)
                .organizationType(OrganizationType.State)
                .organizationIds(of())
                .dimensionType(Overall)
                .build();

        final AggregateReportQuery districtQuery = toQueryBuilderWithCommonAttributes(query)
                .organizationType(OrganizationType.District)
                .organizationIds(of(-19L))
                .dimensionType(Overall)
                .build();

        when(repositoryHelper.findAllDistrictIds()).thenReturn(of(-19L));

        when(repository.findByOrganizationType(eq(user), eq(stateQuery), eq(OrganizationType.District))).thenReturn(districtReport);
        when(repository.findByOrganizationType(eq(user), eq(districtQuery), eq(OrganizationType.School))).thenReturn(schoolReport);

        assertThat(service.findByQuery(user, query).getPayload()).usingRecursiveFieldByFieldElementComparator()
                .containsExactlyInAnyOrder(schoolReport.getPayload().get(0), districtReport.getPayload().get(0));

        verify(repository).findByOrganizationType(eq(user), eq(stateQuery), eq(OrganizationType.District));
        verify(repository).findByOrganizationType(eq(user), eq(districtQuery), eq(OrganizationType.School));
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireConfiguredAssessmentWhenIncludeStateResults() {
        service.estimateReportRowCount(user, reportQueryBuilder.includeState(true).assessmentTypeCode(ICA.code()).build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireNotEmptyQuery() {
        service.findByQuery(user, BasicAggregateReportQuery.builder().build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireSubjectId() {
        service.estimateReportRowCount(user, reportQueryBuilder.subjectCodes(null).build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireAsmtGrades() {
        service.findByQuery(user, reportQueryBuilder.assessmentGradeCodes(null).build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireSchoolYears() {
        service.estimateReportRowCount(user, reportQueryBuilder.schoolYears(null).build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireOrganization() {
        service.estimateReportRowCount(user, reportQueryBuilder.includeState(false).schoolIds(ImmutableSet.of()).build());
    }

    private BasicAggregateRow.Builder reportRow(final OrganizationType type, final Long organizationId, final DimensionType dimensionType) {
        final ActiveAssessment assessment = ActiveAssessment.builder()
                .id(1)
                .subjectCode("Math")
                .gradeCode("3")
                .examSchoolYear(1999)
                .label("Assessment")
                .build();

        final Measures measures = Measures.builder()
                .avgScaleScore(2500)
                .avgStdErr(12)
                .level1Count(1)
                .level2Count(2)
                .level3Count(3)
                .level4Count(4)
                .build();

        final Organization organization = Organization.builder()
                .organizationType(type)
                .name("schoolName")
                .id(organizationId)
                .naturalId("schoolId")
                .build();

        return BasicAggregateRow.builder()
                .dimension(Dimension.builder().type(dimensionType).build())
                .assessment(assessment)
                .measures(measures)
                .organization(organization);
    }

    private AggregateReportQuery.Builder toQueryBuilderWithCommonAttributes(final BasicAggregateReportQuery reportQuery) {
        final StudentFilters filters = reportQuery.getStudentFilters();
        return AggregateReportQuery.builder()
                .assessmentTypeCode(reportQuery.getAssessmentTypeCode())
                .assessmentGradeCodes(reportQuery.getAssessmentGradeCodes())
                .subjectCodes(reportQuery.getSubjectCodes())
                .schoolYears(reportQuery.getSchoolYears())
                .completenessCodes(reportQuery.getCompletenessCodes())
                .administrativeConditionCodes(reportQuery.getAdministrativeConditionCodes())
                .genderCodes(filters.getGenderCodes())
                .ethnicityCodes(filters.getEthnicityCodes())
                .lepCodes(filters.getLepCodes())
                .elasCodes(filters.getElasCodes())
                .migrantStatusCodes(filters.getMigrantStatusCodes())
                .section504Codes(filters.getSection504Codes())
                .iepCodes(filters.getIepCodes())
                .economicDisadvantageCodes(filters.getEconomicDisadvantageCodes());
    }
}