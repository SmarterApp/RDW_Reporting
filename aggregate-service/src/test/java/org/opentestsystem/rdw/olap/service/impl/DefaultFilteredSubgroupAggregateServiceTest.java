package org.opentestsystem.rdw.olap.service.impl;

import com.google.common.collect.ImmutableSet;
import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.opentestsystem.rdw.olap.AggregateReportSettings;
import org.opentestsystem.rdw.olap.model.AggregateReportQuery;
import org.opentestsystem.rdw.olap.model.FilteredSubgroupReportResult;
import org.opentestsystem.rdw.olap.repository.CustomAggregateReportRepository;
import org.opentestsystem.rdw.olap.service.AuthorizationService;
import org.opentestsystem.rdw.olap.sqlbuilder.QueryProviderRepositoryHelper;
import org.opentestsystem.rdw.reporting.common.model.ActiveAssessment;
import org.opentestsystem.rdw.reporting.common.model.BasicAggregateReportQuery;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.FilteredSubgroupReportQuery;
import org.opentestsystem.rdw.reporting.common.model.FilteredSubgroupRow;
import org.opentestsystem.rdw.reporting.common.model.Measures;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.model.StudentFilters;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.springframework.core.task.TaskExecutor;

import static com.google.common.collect.ImmutableSet.of;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.common.model.AssessmentType.IAB;
import static org.opentestsystem.rdw.common.model.AssessmentType.ICA;
import static org.opentestsystem.rdw.common.model.AssessmentType.SUMMATIVE;
import static org.opentestsystem.rdw.common.model.Subject.MATH;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Overall;

public class DefaultFilteredSubgroupAggregateServiceTest {
    private CustomAggregateReportRepository<FilteredSubgroupRow, FilteredSubgroupReportResult> repository;
    private DefaultFilteredSubgroupAggregateService service;
    private AuthorizationService authorizationService;
    private FilteredSubgroupReportQuery.Builder reportQueryBuilder;
    private QueryPoolExecutor queryPoolExecutor;
    private QueryProviderRepositoryHelper repositoryHelper;
    private User user;

    @Before
    public void setUp() {
        final AggregateReportSettings aggregateReportSettings = mock(AggregateReportSettings.class);

        repositoryHelper = mock(QueryProviderRepositoryHelper.class);
        repository = mock(CustomAggregateReportRepository.class);
        authorizationService = mock(AuthorizationService.class);
        queryPoolExecutor = new QueryPoolExecutor();
        queryPoolExecutor.setPartitionSize(2);

        final TaskExecutor threadPoolTaskExecutor = queryPoolExecutor.threadPoolTaskExecutor();
        when(aggregateReportSettings.getStateAggregateAssessmentTypes()).thenReturn(ImmutableSet.of(SUMMATIVE.code()));

        service = new DefaultFilteredSubgroupAggregateService(repository, authorizationService, aggregateReportSettings, repositoryHelper, threadPoolTaskExecutor);

        reportQueryBuilder = FilteredSubgroupReportQuery.builder()
                .assessmentGradeCodes(of("-8"))
                .schoolIds(ImmutableSet.of(123L))
                .schoolYears(of(1999))
                .schoolIds(of(123L))
                .subjectCodes(of(MATH.code()))
                .assessmentTypeCode(IAB.code());

        user = User.builder()
                .id("id")
                .username("username")
                .password("password")
                .build();
    }

    @Test
    public void itShouldHandleFilteredSubgroupReportQuery() {
        assertThat(service.handles(FilteredSubgroupReportQuery.builder().build())).isTrue();
        assertThat(service.handles(BasicAggregateReportQuery.builder().build())).isFalse();
    }

    @Test(expected = NullPointerException.class)
    public void itShouldRequireNotNullQuery() {
        service.findByQuery(user, null);
    }

    @Test
    public void itShouldCallAuthorizationServiceToFindByQuery() {
        final FilteredSubgroupReportQuery query = reportQueryBuilder.build();
        final FilteredSubgroupReportResult report = FilteredSubgroupReportResult.builder()
                .row(reportRow(OrganizationType.School, -123L, Overall).build())
                .build();
        when(repository.findByOrganizationType(any(User.class), any(AggregateReportQuery.class), any(OrganizationType.class)))
                .thenAnswer(invocation -> {
                    return report;
                });

        assertThat(service.findByQuery(user, query)).isEqualToComparingFieldByFieldRecursively(report);
        verify(authorizationService).checkAuthorization(user, query);
    }

    @Test
    public void itShouldCallAuthorizationServiceToEstimateReportRowCount() {
        final FilteredSubgroupReportQuery query = reportQueryBuilder.build();
        when(repository.estimateReportRowCountByOrganizationType(any(AggregateReportQuery.class), any(OrganizationType.class))).thenReturn(10);

        assertThat(service.estimateReportRowCount(user, query)).isEqualTo(10);
        verify(authorizationService).checkAuthorization(user, query);
    }

    @Test
    public void itShouldAddOverallDimensionToRepositoryQuery() {
        final ArgumentCaptor<AggregateReportQuery> queryArgumentCaptor = ArgumentCaptor.forClass(AggregateReportQuery.class);

        final FilteredSubgroupReportResult emptyResult = FilteredSubgroupReportResult.builder().build();
        when(repository.findByOrganizationType(any(User.class), any(AggregateReportQuery.class), any(OrganizationType.class))).thenReturn(emptyResult);
        service.findByQuery(user, reportQueryBuilder.build());

        verify(repository).findByOrganizationType(eq(user), queryArgumentCaptor.capture(), eq(OrganizationType.School));
        assertThat(queryArgumentCaptor.getValue().getSubgroupKey()).isEqualTo(DimensionType.Overall.name());
    }

    @Test
    public void itShouldConvertQueryIntoMultipleOrganizationQueriesAndMergeResults() {
        final FilteredSubgroupReportResult stateReport = FilteredSubgroupReportResult.builder().row(reportRow(OrganizationType.State, -1L, Overall).build()).build();
        final FilteredSubgroupReportResult schoolReport = FilteredSubgroupReportResult.builder().row(reportRow(OrganizationType.School, -2L, Overall).build()).build();
        final FilteredSubgroupReportResult districtReport = FilteredSubgroupReportResult.builder().row(reportRow(OrganizationType.School, -3L, Overall).build()).build();
        final String subgroupName = Overall.name();

        final FilteredSubgroupReportQuery query = FilteredSubgroupReportQuery.builder()
                .assessmentGradeCodes(of("-8"))
                .subjectCodes(of(MATH.code()))
                .assessmentTypeCode(SUMMATIVE.code())
                .schoolYears(of(1999))
                .includeState(true)
                .districtIds(of(-19L, -29L))
                .schoolIds(of(123L))
                .subgroup(subgroupName, StudentFilters.builder().genderCodes(of("male")).build())
                .build();

        final AggregateReportQuery stateQuery = toQueryBuilderWithCommonAttributes(query, subgroupName)
                .organizationType(OrganizationType.State)
                .organizationIds(of())
                .genderCodes(query.getSubgroups().get(subgroupName).getGenderCodes())
                .dimensionType(Overall)
                .subgroupKey(subgroupName)
                .build();

        final AggregateReportQuery schoolQuery = toQueryBuilderWithCommonAttributes(query, subgroupName)
                .organizationType(OrganizationType.School)
                .organizationIds(query.getSchoolIds())
                .genderCodes(query.getSubgroups().get(subgroupName).getGenderCodes())
                .dimensionType(Overall)
                .subgroupKey(subgroupName)
                .build();

        final AggregateReportQuery districtQuery = toQueryBuilderWithCommonAttributes(query, subgroupName)
                .organizationType(OrganizationType.District)
                .organizationIds(query.getDistrictIds())
                .genderCodes(query.getSubgroups().get(subgroupName).getGenderCodes())
                .dimensionType(Overall)
                .subgroupKey(subgroupName)
                .build();

        when(repository.findByOrganizationType(eq(user), eq(stateQuery), eq(OrganizationType.State))).thenReturn(stateReport);
        when(repository.findByOrganizationType(eq(user), eq(schoolQuery), eq(OrganizationType.School))).thenReturn(schoolReport);
        when(repository.findByOrganizationType(eq(user), eq(districtQuery), eq(OrganizationType.District))).thenReturn(districtReport);

        assertThat(service.findByQuery(user, query).getPayload()).usingRecursiveFieldByFieldElementComparator()
                .containsExactlyInAnyOrder(stateReport.getPayload().get(0), schoolReport.getPayload().get(0), districtReport.getPayload().get(0));

        verify(repository).findByOrganizationType(eq(user), eq(schoolQuery), eq(OrganizationType.School));
        verify(repository).findByOrganizationType(eq(user), eq(districtQuery), eq(OrganizationType.District));
        verify(repository).findByOrganizationType(eq(user), eq(stateQuery), eq(OrganizationType.State));
    }


    @Test
    public void itShouldAddOverallSubgroupIfNoneIsGiven() {
        final FilteredSubgroupReportResult stateReport = FilteredSubgroupReportResult.builder().row(reportRow(OrganizationType.State, -1L, Overall).build()).build();
        final FilteredSubgroupReportResult stateOverallReport = FilteredSubgroupReportResult.builder().row(reportRow(OrganizationType.State, -1L, Overall).build()).build();
        final String testSubgroup = "testSubgroup";
        final FilteredSubgroupReportQuery query = reportQueryBuilder
                .assessmentGradeCodes(of("-8"))
                .subjectCodes(of(MATH.code()))
                .assessmentTypeCode(SUMMATIVE.code())
                .schoolYears(of(1999))
                .includeState(true)
                .subgroup(testSubgroup, StudentFilters.builder().genderCodes(of("male")).build())
                .schoolIds(of())
                .districtIds(of())
                .build();

        final AggregateReportQuery stateQuery = toQueryBuilderWithCommonAttributes(query, testSubgroup)
                .organizationType(OrganizationType.State)
                .organizationIds(of())
                .genderCodes(query.getSubgroups().get(testSubgroup).getGenderCodes())
                .dimensionType(Overall)
                .subgroupKey(testSubgroup)
                .build();

        final AggregateReportQuery stateOverallQuery = toQueryBuilderWithCommonAttributes(query, Overall.name())
                .organizationType(OrganizationType.State)
                .organizationIds(of())
                .dimensionType(Overall)
                .subgroupKey(Overall.name())
                .build();

        when(repository.findByOrganizationType(eq(user), eq(stateQuery), eq(OrganizationType.State))).thenReturn(stateReport);
        when(repository.findByOrganizationType(eq(user), eq(stateOverallQuery), eq(OrganizationType.State))).thenReturn(stateReport);

        assertThat(service.findByQuery(user, query).getPayload()).usingRecursiveFieldByFieldElementComparator()
                .containsExactlyInAnyOrder(stateReport.getPayload().get(0), stateOverallReport.getPayload().get(0));

        verify(repository).findByOrganizationType(eq(user), eq(stateQuery), eq(OrganizationType.State));
        verify(repository).findByOrganizationType(eq(user), eq(stateOverallQuery), eq(OrganizationType.State));
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireConfiguredAssessmentWhenIncludeStateResults() {
        service.estimateReportRowCount(user, reportQueryBuilder.includeState(true).assessmentTypeCode(ICA.code()).build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireNotEmptyQuery() {
        service.findByQuery(user, FilteredSubgroupReportQuery.builder().build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireSubjectId() {
        service.estimateReportRowCount(user, reportQueryBuilder.subjectCodes(null).build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireAsmtGrades() {
        service.findByQuery(user, reportQueryBuilder.assessmentGradeCodes(null).build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireSchoolYears() {
        service.estimateReportRowCount(user, reportQueryBuilder.schoolYears(null).build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireOrganization() {
        service.estimateReportRowCount(user, reportQueryBuilder.includeState(false).schoolIds(ImmutableSet.of()).build());
    }

    private FilteredSubgroupRow.Builder reportRow(final OrganizationType type, final Long organizationId, final DimensionType dimensionType) {
        final ActiveAssessment assessment = ActiveAssessment.builder()
                .id(1)
                .subjectCode("Math")
                .gradeCode("3")
                .examSchoolYear(1999)
                .label("Assessment")
                .build();

        final Measures measures = Measures.builder()
                .avgScaleScore(2500)
                .avgStdErr(12)
                .level1Count(1)
                .level2Count(2)
                .level3Count(3)
                .level4Count(4)
                .build();

        final Organization organization = Organization.builder()
                .organizationType(type)
                .name("schoolName")
                .id(organizationId)
                .naturalId("schoolId")
                .build();

        return FilteredSubgroupRow.builder()
                .subgroupKey("test")
                .assessment(assessment)
                .measures(measures)
                .organization(organization);
    }

    private AggregateReportQuery.Builder toQueryBuilderWithCommonAttributes(final FilteredSubgroupReportQuery reportQuery, final String subgroupKey) {

        final StudentFilters filters = reportQuery.getSubgroups().containsKey(subgroupKey) ? reportQuery.getSubgroups().get(subgroupKey) : StudentFilters.builder().build();
        return AggregateReportQuery.builder()
                .assessmentTypeCode(reportQuery.getAssessmentTypeCode())
                .assessmentGradeCodes(reportQuery.getAssessmentGradeCodes())
                .subjectCodes(reportQuery.getSubjectCodes())
                .schoolYears(reportQuery.getSchoolYears())
                .completenessCodes(reportQuery.getCompletenessCodes())
                .administrativeConditionCodes(reportQuery.getAdministrativeConditionCodes())
                .genderCodes(filters.getGenderCodes())
                .ethnicityCodes(filters.getEthnicityCodes())
                .lepCodes(filters.getLepCodes())
                .elasCodes(filters.getElasCodes())
                .migrantStatusCodes(filters.getMigrantStatusCodes())
                .section504Codes(filters.getSection504Codes())
                .iepCodes(filters.getIepCodes())
                .economicDisadvantageCodes(filters.getEconomicDisadvantageCodes());
    }
}