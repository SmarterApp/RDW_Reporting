package org.opentestsystem.rdw.olap.service.impl;


import com.google.common.collect.ImmutableSet;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.opentestsystem.rdw.olap.AggregateReportSettings;
import org.opentestsystem.rdw.olap.model.AggregateReportQueryDescription;
import org.opentestsystem.rdw.olap.model.TargetOrganizationQuery;
import org.opentestsystem.rdw.olap.model.TargetReportResult;
import org.opentestsystem.rdw.olap.repository.ReportRepository;
import org.opentestsystem.rdw.olap.repository.TargetReportRepository;
import org.opentestsystem.rdw.olap.service.AggregateQueryConverter;
import org.opentestsystem.rdw.olap.service.AggregateQueryHandler;
import org.opentestsystem.rdw.olap.service.AuthorizationService;
import org.opentestsystem.rdw.reporting.common.model.CustomAggregateReportQuery;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.Measures;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.model.StudentFilters;
import org.opentestsystem.rdw.reporting.common.model.TargetReportQuery;
import org.opentestsystem.rdw.reporting.common.model.TargetRow;
import org.springframework.core.task.TaskExecutor;

import static com.google.common.collect.ImmutableSet.of;
import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.common.model.AssessmentType.IAB;
import static org.opentestsystem.rdw.common.model.AssessmentType.ICA;
import static org.opentestsystem.rdw.common.model.AssessmentType.SUMMATIVE;
import static org.opentestsystem.rdw.common.model.Subject.MATH;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Overall;

@SuppressWarnings("unchecked")
public class TargetReportQueryHandlerTest extends AbstractAggregateQueryHandlerTest<TargetRow,
        TargetReportResult,
        TargetReportQuery,
        TargetOrganizationQuery> {

    private TargetReportRepository repository;
    private TargetQueryConverter queryConverter;
    private TargetReportQueryHandler serviceUnderTest;

    @Override
    protected AggregateQueryHandler createServiceUnderTest(final AuthorizationService authorizationService, final AggregateReportSettings aggregateReportSettings, final TaskExecutor threadPoolTaskExecutor) {
        queryConverter = mock(TargetQueryConverter.class);
        repository = mock(TargetReportRepository.class);
        serviceUnderTest = new TargetReportQueryHandler(repository, authorizationService, aggregateReportSettings, queryConverter, threadPoolTaskExecutor, 0);
        return serviceUnderTest;
    }

    @Override
    protected TargetReportQuery.Builder getAggregateQueryBuilderWithValidQuery() {
        return TargetReportQuery.builder()
                .dimensionType(DimensionType.Overall)
                .assessmentGradeCodes(of("-8"))
                .schoolIds(of(123L))
                .schoolYear(1999)
                .subjectCode(MATH.code())
                .assessmentTypeCode(SUMMATIVE.code());
    }

    @Override
    protected TargetReportQuery.Builder getEmtpyAggregateQueryBuilder() {
        return TargetReportQuery.builder();
    }

    @Override
    protected AggregateQueryConverter getQueryAdapter() {
        return queryConverter;
    }

    @Override
    protected ReportRepository getRepository() {
        return repository;
    }

    @Override
    protected TargetReportResult getRepositoryResults() {
        return TargetReportResult.builder()
                .row(AggregateTestUtils.targetRow(OrganizationType.School, -123L, Overall).build())
                .build();
    }

    @Override
    protected TargetOrganizationQuery getOrganizationTypeQuery() {
        return mock(TargetOrganizationQuery.class);
    }

    @Override
    public void itShouldHandleQuery() {
        assertThat(serviceUnderTest.handles(TargetReportQuery.builder().build())).isTrue();
        assertThat(serviceUnderTest.handles(CustomAggregateReportQuery.builder().build())).isFalse();
    }

    @Override
    public void itShouldReturnReportResultBuilder() {
        assertThat(serviceUnderTest.getReportResultBuilder()).isInstanceOf(TargetReportResult.Builder.class);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireSummativeAssessmentType() {
        serviceUnderTest.estimateReportRowCount(user, getAggregateQueryBuilderWithValidQuery().assessmentTypeCode(ICA.code()).build());
    }

    @Test
    public void itShouldAssumeSummativeForMissingAssessmentType() {
        final TargetReportQuery query = getAggregateQueryBuilderWithValidQuery().assessmentTypeCode(null).build();

        final ArgumentCaptor<TargetReportQuery> queryArgumentCaptor = ArgumentCaptor.forClass(TargetReportQuery.class);

        serviceUnderTest.estimateReportRowCount(user, query);
        verify(queryConverter).convert(queryArgumentCaptor.capture());
        assertThat(queryArgumentCaptor.getValue().getAssessmentTypeCode()).isEqualTo(SUMMATIVE.code());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireSubject() {
        serviceUnderTest.estimateReportRowCount(user, getAggregateQueryBuilderWithValidQuery().subjectCode(null).build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailWithMultipleAsmtGrades() {
        serviceUnderTest.estimateReportRowCount(user, getAggregateQueryBuilderWithValidQuery().assessmentGradeCodes(of("-4", "-3")).build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailWithICA() {
        serviceUnderTest.estimateReportRowCount(user, getAggregateQueryBuilderWithValidQuery().assessmentTypeCode(ICA.code()).build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailWithIAB() {
        serviceUnderTest.estimateReportRowCount(user, getAggregateQueryBuilderWithValidQuery().assessmentTypeCode(IAB.code()).build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailWithState() {
        serviceUnderTest.estimateReportRowCount(user, getAggregateQueryBuilderWithValidQuery().includeState(true).build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailWithMoreThanOneSchool() {
        serviceUnderTest.estimateReportRowCount(user, getAggregateQueryBuilderWithValidQuery().schoolIds(of(123L, 124L)).build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailWithMoreThanOneDistrict() {
        serviceUnderTest.estimateReportRowCount(user, getAggregateQueryBuilderWithValidQuery().schoolIds(of()).districtIds(of(123L, 124L)).build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailWithMoreThanOneOrganization() {
        serviceUnderTest.estimateReportRowCount(user, getAggregateQueryBuilderWithValidQuery().districtIds(of(123L)).build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailWithSchoolAndItsDistricts() {
        serviceUnderTest.estimateReportRowCount(user, getAggregateQueryBuilderWithValidQuery().includeAllSchoolsOfDistricts(true).build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailWithDistrictAndItsSchools() {
        serviceUnderTest.estimateReportRowCount(user, getAggregateQueryBuilderWithValidQuery().districtIds(of(124L)).schoolIds(of()).includeAllSchoolsOfDistricts(true).build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailWithAllDistricts() {
        serviceUnderTest.estimateReportRowCount(user, getAggregateQueryBuilderWithValidQuery().includeAllDistricts(true).build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailWithFilteredSubgroups() {
        serviceUnderTest.estimateReportRowCount(user, getAggregateQueryBuilderWithValidQuery().subgroup("test", StudentFilters.builder().build()).build());
    }

    @Test
    public void itShouldReturnEmptyReportWithInsufficientDataBasedOnMinNumberOfStudents() {
        final QueryPoolExecutor queryPoolExecutor = new QueryPoolExecutor();
        queryPoolExecutor.setPartitionSize(1);

        final AggregateReportSettings aggregateReportSettings = mock(AggregateReportSettings.class);
        when(aggregateReportSettings.getStateAggregateAssessmentTypes()).thenReturn(ImmutableSet.of(SUMMATIVE.code()));

        final TargetQueryConverter queryConverter = mock(TargetQueryConverter.class);
        final AggregateReportQueryDescription queryDescription = new AggregateReportQueryDescription(getOrganizationTypeQuery(), OrganizationType.State);
        when(queryConverter.convert(any())).thenReturn(newArrayList(queryDescription));

        final TargetReportRepository repository = mock(TargetReportRepository.class);

        int minNumberOfStudents = 3;
        serviceUnderTest = new TargetReportQueryHandler(repository,
                mock(AuthorizationService.class),
                mock(AggregateReportSettings.class),
                queryConverter,
                queryPoolExecutor.threadPoolTaskExecutor(),
                minNumberOfStudents);

        TargetReportResult reportResult = TargetReportResult.builder()
                .row(AggregateTestUtils.targetRow(OrganizationType.School, -123L, Overall)
                        .measures(Measures.builder().studentCount(minNumberOfStudents - 1).build())
                        .build())
                .notEnoughResults(false)
                .build();
        when(repository.findByOrganizationType(any(), any(), any())).thenReturn(reportResult);

        //verify that notEnoughResults is set to true since we have not enough students
        assertThat(serviceUnderTest.findByQuery(user, getAggregateQueryBuilderWithValidQuery().build()))
                .isEqualToComparingFieldByFieldRecursively(reportResult.copy().notEnoughResults(true).build());


        reportResult = TargetReportResult.builder()
                .row(AggregateTestUtils.targetRow(OrganizationType.School, -123L, Overall)
                        .measures(Measures.builder().studentCount(minNumberOfStudents).build())
                        .build())
                .build();

        when(repository.findByOrganizationType(any(), any(), any())).thenReturn(reportResult);

        //verify that notEnoughResults is set to false since we have not enough students
        assertThat(serviceUnderTest.findByQuery(user, getAggregateQueryBuilderWithValidQuery().build()))
                .isEqualToComparingFieldByFieldRecursively(reportResult);
    }
}
