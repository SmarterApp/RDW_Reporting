package org.opentestsystem.rdw.olap.repository.impl;


import com.google.common.collect.ImmutableList;
import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;
import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.olap.model.LongitudinalReportQuery;
import org.opentestsystem.rdw.olap.model.LongitudinalReportResult;
import org.opentestsystem.rdw.olap.model.YearGradePair;
import org.opentestsystem.rdw.olap.repository.LongitudinalReportRepository;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.LongitudinalRow;
import org.opentestsystem.rdw.reporting.common.model.Measures;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.opentestsystem.rdw.security.Permission;
import org.opentestsystem.rdw.security.PermissionScope;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.jdbc.Sql;

import java.util.List;
import java.util.UUID;

import static com.google.common.collect.ImmutableSet.of;
import static java.util.stream.Collectors.toList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.opentestsystem.rdw.common.model.AssessmentType.SUMMATIVE;
import static org.opentestsystem.rdw.common.model.Subject.MATH;
import static org.opentestsystem.rdw.olap.model.AggregateServicePermission.AggregateRead;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Overall;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.District;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.School;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.State;
import static org.opentestsystem.rdw.reporting.common.test.support.PermissionScopes.permissions;
import static org.springframework.test.jdbc.JdbcTestUtils.countRowsInTable;

@SuppressWarnings({"SqlNoDataSourceInspection", "SqlResolve"})
@Sql(scripts = {"classpath:LongitudinalEntitiesSetup.sql"})
@ActiveProfiles("redshift")
public class JdbcLongitudinalReportRepositoryRST extends RepositoryBackedIT {

    @Autowired
    private JdbcTemplate template;

    @Value("${reporting.state.name}")
    private String stateName;

    @Autowired
    private LongitudinalReportRepository repository;

    // this test is for a user without embargo permissions
    private static final User user = User.builder()
            .id(UUID.randomUUID().toString())
            .username("someone-10@somewhere.com")
            .password("redacted")
            //only invalid district and school ids; repository should ignore them
            .permissionsById(permissions(new Permission(AggregateRead, PermissionScope.builder()
                    .statewide(false)
                    .addDistrictIds(of(-100L))
                    .addSchoolIds(of(-100L))
                    .build())))
            .build();

    private int districtsCount;
    private LongitudinalReportQuery.Builder builder;

    @Before
    public void setUp() {
        districtsCount = countRowsInTable(template, "district");

        builder = LongitudinalReportQuery.builder()
                .assessmentTypeCode(AssessmentType.SUMMATIVE.code())
                .subjectCode(MATH.code())
                .dimensionType(Overall);
    }

    @Test
    public void itShouldBackFillMissingData() {
        final List<LongitudinalRow> reportRows = repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1998, "04"), new YearGradePair(1999, "05"), new YearGradePair(2000, "06")))
                .organizationType(State)
                .build(), OrganizationType.District).getPayload();

        assertThat(reportRows.size()).isEqualTo(districtsCount * 3);
        //check that we have a back filled row
        assertThat(reportRows.stream().filter(r -> r.getMeasures().getStudentCount() == 0).count()).isEqualTo(districtsCount * 3);
    }

    @Test
    public void itShouldCalculateMeasures() {
        builder.gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3"), new YearGradePair(1998, "-4"), new YearGradePair(1999, "-5")))
                .organizationIds(of(-19L))
                .organizationType(District);

        final LongitudinalRow grade3Row = repository.findByOrganizationType(user, builder
                        .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3"), new YearGradePair(1998, "-4"), new YearGradePair(1999, "-5")))
                        .organizationIds(of(-19L))
                        .organizationType(District).build(),
                OrganizationType.District)
                .getPayload()
                .stream()
                .filter(r -> (r.getAssessment().getExamSchoolYear() == 1997))
                .collect(toList())
                .get(0);

        final List<Double> cohortScores = template.queryForList("SELECT e.scale_score " +
                "FROM fact_student_exam_longitudinal e " +
                "JOIN school s ON s.id = e.school_id " +
                "WHERE e.student_id IN(-100, -102, -104, -105) AND e.asmt_grade_id = -3 AND s.district_id = -19", Double.class);

        final DescriptiveStatistics cohortStats = new DescriptiveStatistics();
        for (final Double scaleScore : cohortScores) {
            cohortStats.addValue(scaleScore);
        }

        assertThat(grade3Row.getCohortMeasures()).isEqualToComparingFieldByFieldRecursively(Measures.builder()
                .avgScaleScore((int) Math.round(cohortStats.getMean()))
                .avgStdErr((int) Math.round(cohortStats.getStandardDeviation() / Math.sqrt(cohortScores.size())))
                .level1Count(2)
                .level2Count(1)
                .level3Count(0)
                .level4Count(1)
                .build());

        final List<Double> scores = template.queryForList("SELECT e.scale_score " +
                "FROM fact_student_exam_longitudinal e " +
                "JOIN school s ON s.id = e.school_id " +
                "WHERE e.asmt_grade_id = -3 AND s.district_id = -19", Double.class);

        final DescriptiveStatistics stats = new DescriptiveStatistics();
        for (final Double scaleScore : scores) {
            stats.addValue(scaleScore);
        }
        assertThat(grade3Row.getMeasures()).isEqualToComparingFieldByFieldRecursively(Measures.builder()
                .avgScaleScore((int) Math.round(stats.getMean()))
                .avgStdErr((int) Math.round(stats.getStandardDeviation() / Math.sqrt(scores.size())))
                .level1Count(2)
                .level2Count(1)
                .level3Count(1)
                .level4Count(1)
                .build());
    }

    @Test
    public void itShouldReturnState() {
        final LongitudinalReportResult report = repository.findByOrganizationType(user, builder.
                        gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3"), new YearGradePair(1998, "-4"), new YearGradePair(1999, "-5")))
                        .organizationType(State)
                        .build()
                , OrganizationType.State);

        assertThat(report.isCreatedWhileDataEmbargoed()).isFalse();
        assertThat(report.getPayload().size()).isEqualTo(3);
        assertThat(report.getPayload().stream().filter(r -> r.getOrganization().getOrganizationType() == OrganizationType.State).count()).isEqualTo(3);
    }

    @Test
    public void itShouldReturnAllDistrictsInState() {
        final LongitudinalReportResult report = repository.findByOrganizationType(user, builder.
                        gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3"), new YearGradePair(1998, "-4"), new YearGradePair(1999, "-5")))
                        .organizationType(State)
                        .build()
                , OrganizationType.District);

        assertThat(report.isCreatedWhileDataEmbargoed()).isFalse();
        assertThat(report.getPayload().size()).isEqualTo(districtsCount * 3);
        assertThat(report.getPayload().stream().filter(r -> r.getOrganization().getOrganizationType() == OrganizationType.District).count()).isEqualTo(districtsCount * 3);
    }

    @Test
    public void itShouldReturnDistricts() {
        final LongitudinalReportResult report = repository.findByOrganizationType(user, builder.
                        gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3"), new YearGradePair(1998, "-4"), new YearGradePair(1999, "-5")))
                        .organizationType(District)
                        .organizationIds(of(-17L, -18L, -19L, -99L))
                        .build()
                , OrganizationType.District);

        assertThat(report.isCreatedWhileDataEmbargoed()).isFalse();
        assertThat(report.getPayload().size()).isEqualTo(districtsCount * 3);
        assertThat(report.getPayload().stream().filter(r -> r.getOrganization().getOrganizationType() == OrganizationType.District).count()).isEqualTo(districtsCount * 3);
    }

    @Test
    public void itShouldReturnAllSchoolsInDistrict() {
        final LongitudinalReportResult report = repository.findByOrganizationType(user, builder.
                        gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3"), new YearGradePair(1998, "-4"), new YearGradePair(1999, "-5")))
                        .organizationType(District)
                        .organizationIds(of(-19L, -99L))
                        .build()
                , OrganizationType.School);


        assertThat(report.isCreatedWhileDataEmbargoed()).isFalse();
        //there are two schools in district -19
        assertThat(report.getPayload().size()).isEqualTo(2 * 3);
        assertThat(report.getPayload().stream().filter(r -> r.getOrganization().getOrganizationType() == OrganizationType.School).count()).isEqualTo(2 * 3);
    }

    @Test
    public void itShouldReturnSchools() {
        final LongitudinalReportResult report = repository.findByOrganizationType(user, builder.
                        gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3"), new YearGradePair(1998, "-4"), new YearGradePair(1999, "-5")))
                        .organizationType(School)
                        .organizationIds(of(-8L, -9L, -99L))
                        .build()
                , OrganizationType.School);

        assertThat(report.isCreatedWhileDataEmbargoed()).isFalse();
        assertThat(report.getPayload().size()).isEqualTo(6);
        assertThat(report.getPayload().stream().filter(r -> r.getOrganization().getOrganizationType() == OrganizationType.School).count()).isEqualTo(6);
    }

    @Test
    public void itShouldReturnData() {
        final LongitudinalReportQuery.Builder builder = LongitudinalReportQuery.builder()
                .assessmentTypeCode(AssessmentType.SUMMATIVE.code())
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3"), new YearGradePair(1998, "-4"), new YearGradePair(1999, "-5")))
                .subjectCode(MATH.code())
                .dimensionType(Overall)
                .organizationType(State);

        final List<LongitudinalRow> reportRows = repository.findByOrganizationType(user, builder.build(), OrganizationType.State).getPayload();

        assertThat(reportRows.size()).isEqualTo(3);
        //check that we have a back filled row
        assertThat(reportRows.stream().filter(r -> r.getMeasures().getStudentCount() == 0).count()).isEqualTo(0);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireNotEmptyQuery() {
        repository.findByOrganizationType(user, LongitudinalReportQuery.builder().build(), OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireOrganizationIdsForSchoolOrganizationType() {
        repository.findByOrganizationType(user, LongitudinalReportQuery
                .builder()
                .assessmentTypeCode(SUMMATIVE.code())
                .dimensionType(DimensionType.Overall)
                .organizationType(School)
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1998, "04"), new YearGradePair(1999, "05"), new YearGradePair(2000, "06")))
                .subjectCode("test")
                .build(), OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireOrganizationIdsForDistrictOrganizationType() {
        repository.findByOrganizationType(user, LongitudinalReportQuery
                        .builder()
                        .assessmentTypeCode(SUMMATIVE.code())
                        .dimensionType(DimensionType.Overall)
                        .organizationType(District)
                        .gradeYearPairs(ImmutableList.of(new YearGradePair(1998, "04"), new YearGradePair(1999, "05"), new YearGradePair(2000, "06")))
                        .subjectCode("test")
                        .build()
                , OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireSubject() {
        repository.findByOrganizationType(user, LongitudinalReportQuery
                        .builder()
                        .assessmentTypeCode(SUMMATIVE.code())
                        .dimensionType(DimensionType.Overall)
                        .organizationType(State)
                        .gradeYearPairs(ImmutableList.of(new YearGradePair(1998, "04"), new YearGradePair(1999, "05"), new YearGradePair(2000, "06")))
                        .build()
                , OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireAssessmentType() {
        repository.findByOrganizationType(user, LongitudinalReportQuery
                        .builder()
                        .dimensionType(DimensionType.Overall)
                        .organizationType(State)
                        .gradeYearPairs(ImmutableList.of(new YearGradePair(1998, "04"), new YearGradePair(1999, "05"), new YearGradePair(2000, "06")))
                        .subjectCode("test")
                        .build()
                , OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireDimension() {
        repository.findByOrganizationType(user, LongitudinalReportQuery
                        .builder()
                        .assessmentTypeCode(SUMMATIVE.code())
                        .organizationType(State)
                        .gradeYearPairs(ImmutableList.of(new YearGradePair(1998, "04"), new YearGradePair(1999, "05"), new YearGradePair(2000, "06")))
                        .subjectCode("test")
                        .build()
                , OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireOrganization() {
        repository.findByOrganizationType(user, LongitudinalReportQuery
                        .builder()
                        .assessmentTypeCode(SUMMATIVE.code())
                        .dimensionType(DimensionType.Overall)
                        .gradeYearPairs(ImmutableList.of(new YearGradePair(1998, "04"), new YearGradePair(1999, "05"), new YearGradePair(2000, "06")))
                        .subjectCode("test")
                        .build()
                , OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireSchoolYearGrades() {
        repository.findByOrganizationType(user, LongitudinalReportQuery
                        .builder()
                        .assessmentTypeCode(SUMMATIVE.code())
                        .dimensionType(DimensionType.Overall)
                        .subjectCode("test")
                        .organizationType(State)
                        .build()
                , OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailForAllSchoolsInState() {
        final LongitudinalReportQuery query = LongitudinalReportQuery.builder()
                .assessmentTypeCode(SUMMATIVE.code())
                .dimensionType(Overall)
                .organizationType(State)
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1998, "04"), new YearGradePair(1999, "05"), new YearGradePair(2000, "06")))
                .subjectCode("test")
                .build();
        repository.findByOrganizationType(user, query, School);
    }
}