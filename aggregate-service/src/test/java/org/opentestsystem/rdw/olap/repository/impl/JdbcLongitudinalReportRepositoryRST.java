package org.opentestsystem.rdw.olap.repository.impl;


import com.google.common.collect.ImmutableList;
import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;
import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.olap.model.LongitudinalOrganizationQuery;
import org.opentestsystem.rdw.olap.model.LongitudinalReportResult;
import org.opentestsystem.rdw.olap.model.YearGradePair;
import org.opentestsystem.rdw.olap.repository.LongitudinalReportRepository;
import org.opentestsystem.rdw.reporting.common.model.ActiveAssessment;
import org.opentestsystem.rdw.reporting.common.model.AggregateRow;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.LongitudinalRow;
import org.opentestsystem.rdw.reporting.common.model.Measures;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.opentestsystem.rdw.security.Permission;
import org.opentestsystem.rdw.security.PermissionScope;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.jdbc.Sql;

import java.util.List;

import static com.google.common.collect.ImmutableSet.of;
import static java.util.stream.Collectors.toList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.opentestsystem.rdw.common.model.AssessmentType.SUMMATIVE;
import static org.opentestsystem.rdw.common.model.Subject.MATH;
import static org.opentestsystem.rdw.olap.TestUtils.verifyBooleanDimensionStudentountByYesNoUnknown;
import static org.opentestsystem.rdw.olap.TestUtils.verifyStateStudentCount;
import static org.opentestsystem.rdw.olap.model.AggregateServicePermission.AggregateRead;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.ELAS;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.EconomicDisadvantage;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Ethnicity;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Gender;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.IEP;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.LEP;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.MigrantStatus;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Overall;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Section504;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.StudentEnrolledGrade;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.District;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.School;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.State;
import static org.opentestsystem.rdw.reporting.common.test.support.PermissionScopes.permissions;
import static org.springframework.test.jdbc.JdbcTestUtils.countRowsInTable;

@SuppressWarnings({"SqlNoDataSourceInspection", "SqlResolve"})
@Sql(scripts = {"classpath:LongitudinalEntitiesSetup.sql"})
@ActiveProfiles("redshift")
public class JdbcLongitudinalReportRepositoryRST extends RepositoryBackedIT {

    @Autowired
    private JdbcTemplate template;

    @Value("${reporting.state.name}")
    private String stateName;

    @Autowired
    private LongitudinalReportRepository repository;

    // this test is for a user without embargo permissions
    private static final User user = User.builder()
            .id("userId")
            .username("someone-10@somewhere.com")
            .password("redacted")
            //only invalid district and school ids; repository should ignore them
            .permissionsById(permissions(new Permission(AggregateRead, PermissionScope.builder()
                    .statewide(false)
                    .addDistrictIds(of(-100L))
                    .addSchoolIds(of(-100L))
                    .build())))
            .build();

    private int districtsCount;
    private LongitudinalOrganizationQuery.Builder builder;

    @Before
    public void setUp() {
        districtsCount = countRowsInTable(template, "district");

        builder = LongitudinalOrganizationQuery.builder()
                .assessmentTypeCode(AssessmentType.SUMMATIVE.code())
                .subjectCode(MATH.code())
                .dimensionType(Overall);
    }

    @Test
    public void itShouldBackFillMissingData() {
        final List<LongitudinalRow> reportRows = repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(2000, "-6")))
                .organizationType(State)
                .build(), OrganizationType.District).getPayload();

        assertThat(reportRows.size()).isEqualTo(districtsCount);
        //check that we have a back filled row
        assertThat(reportRows.stream().filter(r -> r.getMeasures().getStudentCount() == 0).count()).isEqualTo(districtsCount);
    }

    @Test
    public void itShouldCalculateMeasures() {
        final LongitudinalRow grade3Row = repository.findByOrganizationType(user, builder.gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3"), new YearGradePair(1998, "-4"), new YearGradePair(1999, "-5")))
                        .organizationIds(of(-19L))
                        .organizationType(District).build(),
                OrganizationType.District)
                .getPayload()
                .stream()
                .filter(r -> (r.getAssessment().getExamSchoolYear() == 1997))
                .collect(toList())
                .get(0);

        final List<Double> cohortScores = template.queryForList("SELECT e.scale_score " +
                "FROM exam_longitudinal e " +
                "JOIN school s ON s.id = e.school_id " +
                "WHERE e.student_id IN(-100, -102, -104, -105) AND e.asmt_grade_id = -3 AND s.district_id = -19", Double.class);

        final DescriptiveStatistics cohortStats = new DescriptiveStatistics();
        for (final Double scaleScore : cohortScores) {
            cohortStats.addValue(scaleScore);
        }

        assertThat(grade3Row.getCohortMeasures()).isEqualToComparingFieldByFieldRecursively(Measures.builder()
                .avgScaleScore((int) Math.round(cohortStats.getMean()))
                .avgStdErr((int) Math.round(cohortStats.getStandardDeviation() / Math.sqrt(cohortScores.size())))
                .level1Count(2)
                .level2Count(1)
                .level3Count(0)
                .level4Count(1)
                .build());

        final List<Double> scores = template.queryForList("SELECT e.scale_score " +
                "FROM exam_longitudinal e " +
                "JOIN school s ON s.id = e.school_id " +
                "WHERE e.asmt_grade_id = -3 AND s.district_id = -19", Double.class);

        final DescriptiveStatistics stats = new DescriptiveStatistics();
        for (final Double scaleScore : scores) {
            stats.addValue(scaleScore);
        }
        assertThat(grade3Row.getMeasures()).isEqualToComparingFieldByFieldRecursively(Measures.builder()
                .avgScaleScore((int) Math.round(stats.getMean()))
                .avgStdErr((int) Math.round(stats.getStandardDeviation() / Math.sqrt(scores.size())))
                .level1Count(2)
                .level2Count(1)
                .level3Count(1)
                .level4Count(1)
                .build());
    }

    @Test
    public void itShouldDeriveAsmtAndSingleAsmtFlag() {
        final LongitudinalReportResult reportResult = repository.findByOrganizationType(user, builder
                        .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3"), new YearGradePair(1998, "-4"), new YearGradePair(1999, "-5")))
                        .organizationIds(of(-19L))
                        .organizationType(District).build(),
                OrganizationType.District);

        final LongitudinalRow grade3Row = reportResult
                .getPayload()
                .stream()
                .filter(r -> (r.getAssessment().getExamSchoolYear() == 1997))
                .collect(toList())
                .get(0);

        assertThat(grade3Row.isSingleAsmtInAggregate()).isFalse();
        assertThat(grade3Row.getAssessment()).isEqualToComparingFieldByFieldRecursively(ActiveAssessment.builder()
                .id(-3)
                .label("asmt-3")
                .examSchoolYear(1997)
                .gradeCode("-3")
                .subjectCode("Math")
                .build());

        assertThat(reportResult
                .getPayload()
                .stream()
                .filter(r -> (r.getAssessment().getExamSchoolYear() == 1998))
                .collect(toList())
                .get(0).isSingleAsmtInAggregate()).isTrue();
    }

    @Test
    public void itShouldReturnSubgroupKeyAsCustomDimensionForDataRows() {
        //data rows
        assertThat(repository.findByOrganizationType(user,
                builder.gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3"), new YearGradePair(1998, "-4"), new YearGradePair(1999, "-5")))
                        .organizationIds(of(-19L))
                        .organizationType(District)
                        .subgroupKey("testSubgroupKey").build(), OrganizationType.District)
                .getPayload()
                .stream()
                .filter(r -> (r.getDimension().getCode().equals("testSubgroupKey") && r.getDimension().getType() == DimensionType.Custom))
                .count()).isEqualTo(3);
    }

    @Test
    public void itShouldReturnSubgroupKeyAsCustomDimensionForBackFilledRows() {
        assertThat(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(2000, "-6")))
                .organizationType(State)
                .subgroupKey("testSubgroupKey").build(), OrganizationType.District).getPayload()
                .stream()
                .filter(r -> (r.getDimension().getCode().equals("testSubgroupKey") && r.getDimension().getType() == DimensionType.Custom))
                .count()).isEqualTo(districtsCount);
    }

    @Test
    public void itShouldReturnState() {
        final LongitudinalReportResult report = repository.findByOrganizationType(user, builder.
                        gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3"), new YearGradePair(1998, "-4"), new YearGradePair(1999, "-5")))
                        .organizationType(State)
                        .build()
                , OrganizationType.State);

        assertThat(report.isCreatedWhileDataEmbargoed()).isFalse();
        assertThat(report.getPayload().size()).isEqualTo(3);
        assertThat(report.getPayload().stream().filter(r -> r.getOrganization().getOrganizationType() == OrganizationType.State).count()).isEqualTo(3);
    }

    @Test
    public void itShouldReturnAllDistrictsInState() {
        final LongitudinalReportResult report = repository.findByOrganizationType(user, builder.
                        gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3"), new YearGradePair(1998, "-4"), new YearGradePair(1999, "-5")))
                        .organizationType(State)
                        .build()
                , OrganizationType.District);

        assertThat(report.isCreatedWhileDataEmbargoed()).isFalse();
        assertThat(report.getPayload().size()).isEqualTo(districtsCount * 3);
        assertThat(report.getPayload().stream().filter(r -> r.getOrganization().getOrganizationType() == OrganizationType.District).count()).isEqualTo(districtsCount * 3);
    }

    @Test
    public void itShouldReturnDistricts() {
        final LongitudinalReportResult report = repository.findByOrganizationType(user, builder.
                        gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3"), new YearGradePair(1998, "-4"), new YearGradePair(1999, "-5")))
                        .organizationType(District)
                        .organizationIds(of(-17L, -18L, -19L, -99L))
                        .build()
                , OrganizationType.District);

        assertThat(report.isCreatedWhileDataEmbargoed()).isFalse();
        assertThat(report.getPayload().size()).isEqualTo(districtsCount * 3);
        assertThat(report.getPayload().stream().filter(r -> r.getOrganization().getOrganizationType() == OrganizationType.District).count()).isEqualTo(districtsCount * 3);
    }

    @Test
    public void itShouldReturnAllSchoolsInDistrict() {
        final LongitudinalReportResult report = repository.findByOrganizationType(user, builder.
                        gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3"), new YearGradePair(1998, "-4"), new YearGradePair(1999, "-5")))
                        .organizationType(District)
                        .organizationIds(of(-19L, -99L))
                        .build()
                , OrganizationType.School);


        assertThat(report.isCreatedWhileDataEmbargoed()).isFalse();
        //there are two schools in district -19
        assertThat(report.getPayload().size()).isEqualTo(2 * 3);
        assertThat(report.getPayload().stream().filter(r -> r.getOrganization().getOrganizationType() == OrganizationType.School).count()).isEqualTo(2 * 3);
    }

    @Test
    public void itShouldReturnSchools() {
        final LongitudinalReportResult report = repository.findByOrganizationType(user, builder.
                        gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3"), new YearGradePair(1998, "-4"), new YearGradePair(1999, "-5")))
                        .organizationType(School)
                        .organizationIds(of(-8L, -9L, -99L))
                        .build()
                , OrganizationType.School);

        assertThat(report.isCreatedWhileDataEmbargoed()).isFalse();
        assertThat(report.getPayload().size()).isEqualTo(6);
        assertThat(report.getPayload().stream().filter(r -> r.getOrganization().getOrganizationType() == OrganizationType.School).count()).isEqualTo(6);
    }

    @Test
    public void itShouldFindByQueryWithIEPDimension() {
        //test with different organizations since they all are represented by different SQL parts that get assembled together
        final LongitudinalReportResult report = repository.findByOrganizationType(user, builder
                        .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                        .dimensionType(IEP)
                        .organizationType(School)
                        .organizationIds(of(-9L))
                        .build()
                , OrganizationType.School);

        assertThat(report.isCreatedWhileDataEmbargoed()).isFalse();
        List<LongitudinalRow> rows = report.getPayload();
        assertThat(rows.size()).isEqualTo(2);
        for (final AggregateRow row : rows) {
            if (row.getDimension().getCode().equalsIgnoreCase("no")) assertThat(row.getMeasures().getStudentCount()).isEqualTo(2);
            else assertThat(row.getMeasures().getStudentCount()).isEqualTo(3);
        }

        rows = repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(IEP)
                .organizationIds(null)
                .build(), District).getPayload();
        assertThat(rows.size()).isEqualTo((districtsCount) * 2);

        rows = repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(IEP)
                .build(), State).getPayload();
        assertThat(rows.size()).isEqualTo(2);
        verifyStateStudentCount(rows, 7);
    }

    @Test
    public void itShouldFindByQueryWithIEPDimensionAndGenderFilters() {
        final List<LongitudinalRow> rows = repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(IEP)
                .genderCodes(of("gender-18"))
                .build(), State).getPayload();

        assertThat(rows.size()).isEqualTo(2);
        verifyStateStudentCount(rows, 3);
    }

    @Test
    public void itShouldFindByQueryWithIEPDimensionAndFilter() {
        final List<LongitudinalRow> rows = repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(IEP)
                .iepCodes(of("yes"))
                .build(), State).getPayload();

        assertThat(rows.size()).isEqualTo(1);
        verifyStateStudentCount(rows, 5);
    }

    @Test
    public void itShouldFindByQueryWithLEPDimension() {
        List<LongitudinalRow> rows = repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(School)
                .organizationIds(of(-9L))
                .dimensionType(LEP)
                .build(), School).getPayload();

        assertThat(rows.size()).isEqualTo(2);
        for (final AggregateRow row : rows) {
            if (row.getDimension().getCode().equalsIgnoreCase("no")) assertThat(row.getMeasures().getStudentCount()).isEqualTo(1);
            else assertThat(row.getMeasures().getStudentCount()).isEqualTo(4);
        }

        rows = repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .organizationIds(null)
                .dimensionType(LEP)
                .build(), District).getPayload();
        assertThat(rows.size()).isEqualTo((districtsCount) * 2);
    }

    @Test
    public void itShouldFindByQueryWithLEPDimensionAndEthnicityFilter() {
        List<LongitudinalRow> rows = repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(LEP)
                .ethnicityCodes(of("ethnicity-28", "ethnicity-29"))
                .build(), State).getPayload();

        assertThat(rows.size()).isEqualTo(2);
        //there is one student but with two ethnicities, it is counted as two
        verifyStateStudentCount(rows, 2);

        rows = repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(LEP)
                .ethnicityCodes(of("ethnicity-28"))
                .build(), State).getPayload();
        assertThat(rows.size()).isEqualTo(2);
        verifyStateStudentCount(rows, 1);
    }

    @Test
    public void itShouldFindByQueryWithLEPDimensionAndFilter() {
        assertThat(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(LEP)
                .lepCodes(of("no"))
                .build(), District).getPayload().size()).isEqualTo(districtsCount);

        verifyStateStudentCount(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(LEP)
                .lepCodes(of("yes"))
                .build(), State).getPayload(), 6);

        verifyStateStudentCount(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(LEP)
                .lepCodes(of("no", "yes"))
                .build(), State).getPayload(), 7);
    }

    @Test
    public void itShouldFindByQueryWithELASDimensionAndFilter() {
        assertThat(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(ELAS)
                .build(), District).getPayload().size()).isEqualTo(districtsCount * 2);

        verifyStateStudentCount(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(ELAS)
                .elasCodes(of("RFEP"))
                .build(), State).getPayload(), 2);

        verifyStateStudentCount(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(ELAS)
                .elasCodes(of("RFEP"))
                .build(), State).getPayload(), 2);
    }

    @Test
    public void itShouldFindByQueryWithELASDAndGenderFilter() {
        assertThat(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(District)
                .organizationIds(of(-19L))
                .dimensionType(ELAS)
                .elasCodes(of("RFEP"))
                .genderCodes(of("gender-18"))
                .build(), District).getPayload().size()).isEqualTo((1));

    }

    @Test
    public void itShouldFindByQueryWithEconomicDisadvantageDimension() {
        assertThat(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(EconomicDisadvantage)
                .build(), District).getPayload().size()).isEqualTo((districtsCount) * 2);

        final List<LongitudinalRow> rows = repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(School)
                .organizationIds(of(-9L))
                .dimensionType(EconomicDisadvantage)
                .build(), School).getPayload();

        assertThat(rows.size()).isEqualTo(2);
        for (final AggregateRow row : rows) {
            if (row.getDimension().getCode().equalsIgnoreCase("no")) assertThat(row.getMeasures().getStudentCount()).isEqualTo(4);
            else assertThat(row.getMeasures().getStudentCount()).isEqualTo(1);
        }
    }

    @Test
    public void itShouldFindByQueryWithEconomicDisadvantageDimensionAndFilter() {
        assertThat(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(EconomicDisadvantage)
                .economicDisadvantageCodes(of("yes"))
                .build(), District).getPayload().size()).isEqualTo(districtsCount);
    }

    @Test
    public void itShouldFindByQueryWithEconomicDisadvantageDimensionAndGenderFilter() {
        final List<LongitudinalRow> rows = repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(EconomicDisadvantage)
                .economicDisadvantageCodes(of("yes"))
                .genderCodes(of("gender-18"))
                .build(), State).getPayload();

        verifyStateStudentCount(rows, 1);
    }

    @Test
    public void itShouldFindByQueryWithSection504Dimension() {
        assertThat(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(Section504)
                .build(), District).getPayload().size()).isEqualTo((districtsCount) * 3);

        final List<LongitudinalRow> rows = repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(School)
                .organizationIds(of(-9L))
                .dimensionType(Section504)
                .build(), School).getPayload();

        assertThat(rows.size()).isEqualTo(3);
        verifyBooleanDimensionStudentountByYesNoUnknown(rows, 1, 3, 1);
    }

    @Test
    public void itShouldFindByQueryWithSection504DimensionAndFilter() {
        assertThat(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(Section504)
                .section504Codes(of("undefined", "yes"))
                .build(), District).getPayload().size()).isEqualTo((districtsCount) * 2);
    }

    @Test
    public void itShouldFindByQueryWithSection504DimensionAndEconomicDisadvantageFilter() {
        assertThat(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(Section504)
                .economicDisadvantageCodes(of("no"))
                .build(), District).getPayload().size()).isEqualTo((districtsCount) * 3);

        final List<LongitudinalRow> rows = repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationIds(of(-9L))
                .organizationType(School)
                .economicDisadvantageCodes(of("no"))
                .dimensionType(Section504)
                .build(), School).getPayload();

        assertThat(rows.size()).isEqualTo(3);
        verifyBooleanDimensionStudentountByYesNoUnknown(rows, 1, 2, 1);
    }

    @Test
    public void itShouldFindByQueryWithMigrantStatusDimension() {
        assertThat(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(MigrantStatus)
                .build(), District).getPayload().size()).isEqualTo((districtsCount) * 3);

        List<LongitudinalRow> rows = repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(School)
                .dimensionType(MigrantStatus)
                .organizationIds(of(-9L))
                .administrativeConditionCodes(of("IN"))
                .completenessCodes(of("Complete"))
                .build(), School).getPayload();

        assertThat(rows.size()).isEqualTo(3);
        verifyBooleanDimensionStudentountByYesNoUnknown(rows, 1, 1, 1);

        rows = repository.findByOrganizationType(user, builder
                .administrativeConditionCodes(of())
                .completenessCodes(of())
                .genderCodes(of("gender-18"))
                .build(), School).getPayload();

        verifyBooleanDimensionStudentountByYesNoUnknown(rows, 1, 1, 0);
    }

    @Test
    public void itShouldFindByQueryWithMigrantStatusDimensionAndFilter() {
        assertThat(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(MigrantStatus)
                .migrantStatusCodes(of("yes"))
                .build(), District).getPayload().size()).isEqualTo(districtsCount);

        verifyStateStudentCount(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(MigrantStatus)
                .migrantStatusCodes(of("yes"))
                .build(), State).getPayload(), 4);
    }

    @Test
    public void itShouldFindByQueryWithMigrantStatusDimensionAndLEPFilter() {
        assertThat(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(MigrantStatus)
                .lepCodes(of("no"))
                .build(), District).getPayload().size()).isEqualTo(districtsCount * 3);

        verifyStateStudentCount(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(MigrantStatus)
                .lepCodes(of("no"))
                .build(), State).getPayload(), 1);
    }

    @Test
    public void itShouldFindByQueryWithMigrantStatusDimensionAnELASFilter() {
        assertThat(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(MigrantStatus)
                .elasCodes(of("EL"))
                .build(), District).getPayload().size()).isEqualTo(districtsCount * 3);
    }

    @Test
    public void itShouldFindByQueryWithGenderDimension() {
        assertThat(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(School)
                .organizationIds(of(-9L))
                .dimensionType(Gender)
                .build(), School).getPayload().size()).isEqualTo(countRowsInTable(template, "gender"));
    }

    @Test
    public void itShouldFindByQueryWithGenderDimensionAndFilter() {
        final List<LongitudinalRow> rows = repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(School)
                .organizationIds(of(-9L))
                .dimensionType(Gender)
                .genderCodes(of("gender-19"))
                .build(), School).getPayload();

        assertThat(rows.size()).isEqualTo(1);
        assertThat(rows.stream().filter(r -> (r.getDimension().getCode().equals("gender-19"))).mapToInt(r -> (r.getMeasures().getStudentCount())).sum()).isEqualTo(3);
    }

    @Test
    public void itShouldFindByQueryWithGenderDimensionAndMigrantStatusFilter() {
        assertThat(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(Gender)
                .migrantStatusCodes(of("no"))
                .build(), District).getPayload().size()).isEqualTo((districtsCount) * countRowsInTable(template, "gender"));

        List<LongitudinalRow> rows = repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(Gender)
                .migrantStatusCodes(of("no"))
                .build(), State).getPayload();

        assertThat(rows.stream().filter(r -> (r.getDimension().getCode().equals("gender-18"))).mapToInt(r -> (r.getMeasures().getStudentCount())).sum()).isEqualTo(1);
        assertThat(rows.stream().filter(r -> (r.getDimension().getCode().equals("gender-19"))).mapToInt(r -> (r.getMeasures().getStudentCount())).sum()).isEqualTo(1);

        rows = repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(Gender)
                .migrantStatusCodes(of("yes"))
                .build(), State).getPayload();

        assertThat(rows.stream().filter(r -> (r.getDimension().getCode().equals("gender-18"))).mapToInt(r -> (r.getMeasures().getStudentCount())).sum()).isEqualTo(2);
        assertThat(rows.stream().filter(r -> (r.getDimension().getCode().equals("gender-19"))).mapToInt(r -> (r.getMeasures().getStudentCount())).sum()).isEqualTo(2);
    }

    @Test
    public void itShouldFindByQueryWithEthnicityDimension() {
        final int ethnicityCount = countRowsInTable(template, "ethnicity");
        final List<LongitudinalRow> reportRows = repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(District)
                .organizationIds(of(-19L))
                .dimensionType(Ethnicity)
                .build(), District).getPayload();

        assertThat(reportRows.size()).isEqualTo(ethnicityCount);
        assertThat(reportRows.stream().filter(r -> (r.getMeasures().getAvgScaleScore() != null)).collect(toList()).size()).isEqualTo(2);

        assertThat(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .organizationIds(null)
                .dimensionType(Ethnicity)
                .build(), District).getPayload().size()).isEqualTo((districtsCount) * ethnicityCount);
    }

    @Test
    public void itShouldFindByQueryWithEthnicityDimensionAndFilter() {
        assertThat(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(District)
                .organizationIds(of(-19L))
                .dimensionType(Ethnicity)
                .ethnicityCodes(of("ethnicity-28"))
                .build(), District).getPayload().size()).isEqualTo(1);
    }

    @Test
    public void itShouldFindByQueryWithEthnicityDimensionAndIepFilter() {
        assertThat(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(Ethnicity)
                .iepCodes(of("no"))
                .build(), District).getPayload().size()).isEqualTo((districtsCount) * countRowsInTable(template, "ethnicity"));

        assertThat(repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(State)
                .dimensionType(Ethnicity)
                .iepCodes(of("yes"))
                .build(), District).getPayload().stream()
                .filter(r -> (r.getDimension().getCode().equals("ethnicity-29")))
                .mapToInt(r -> (r.getMeasures().getStudentCount()))
                .sum()).isEqualTo(2);
    }

    @Test
    public void itShouldFindByQueryWithEnrolledGradeDimension() {
        final List<LongitudinalRow> rows = repository.findByOrganizationType(user, builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3")))
                .organizationType(School)
                .organizationIds(of(-9L))
                .dimensionType(StudentEnrolledGrade)
                .build(), School).getPayload();

        assertThat(rows.size()).isEqualTo(1);
        assertThat(rows.stream().filter(r -> r.getDimension().getCode().equals("-3")).mapToInt(r -> r.getMeasures().getStudentCount()).sum()).isEqualTo(5);
    }

    @Test
    public void itShouldEstimateReportRowCount() {
        final Integer asmtCount = template.queryForObject("SELECT count(*) AS count FROM asmt_active_year ay LEFT JOIN asmt a ON a.id = ay.asmt_id" +
                "  WHERE a.grade_id IN (-3, -4, -5) AND a.subject_id IN (1) AND a.type_id = 3 AND ay.school_year IN (1997, 1998, 1999)", Integer.class);

        final int ethnicityCount = countRowsInTable(template, "ethnicity");
        final int genderCount = countRowsInTable(template, "gender");
        builder
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1997, "-3"), new YearGradePair(1998, "-4"), new YearGradePair(1999, "-5")))
                .organizationType(State)
                .subjectCode(MATH.code())
                // the below two filters do not change the counting rules
                .administrativeConditionCodes(of("IN"))
                .completenessCodes(of("Complete"));

        assertThat(repository.estimateReportRowCountByOrganizationType(builder.dimensionType(Overall).build(), District)).isEqualTo(asmtCount * districtsCount);
        //for the StudentEnrolledGrade we always assume that there is one entry found
        assertThat(repository.estimateReportRowCountByOrganizationType(builder.dimensionType(StudentEnrolledGrade).build(), District)).isEqualTo(asmtCount * districtsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(builder.dimensionType(Gender).build(), District)).isEqualTo(asmtCount * districtsCount * genderCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(builder.dimensionType(Ethnicity).build(), District)).isEqualTo(asmtCount * districtsCount * ethnicityCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(builder.dimensionType(MigrantStatus).build(), District)).isEqualTo(asmtCount * districtsCount * 3);
        assertThat(repository.estimateReportRowCountByOrganizationType(builder.dimensionType(Section504).build(), District)).isEqualTo(asmtCount * districtsCount * 3);
        assertThat(repository.estimateReportRowCountByOrganizationType(builder.dimensionType(LEP).build(), District)).isEqualTo(asmtCount * districtsCount * 2);
        assertThat(repository.estimateReportRowCountByOrganizationType(builder.dimensionType(IEP).build(), District)).isEqualTo(asmtCount * districtsCount * 2);
        assertThat(repository.estimateReportRowCountByOrganizationType(builder.dimensionType(EconomicDisadvantage).build(), District)).isEqualTo(asmtCount * districtsCount * 2);

        //test with filters
        assertThat(repository.estimateReportRowCountByOrganizationType(builder.dimensionType(Gender).genderCodes(of("gender-19")).build(), District)).isEqualTo(asmtCount * districtsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(builder.dimensionType(Ethnicity).genderCodes(of("gender-19")).ethnicityCodes(of("ethnicity-28")).build(), District)).isEqualTo(asmtCount * districtsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(builder.dimensionType(MigrantStatus).genderCodes(null).ethnicityCodes(null).migrantStatusCodes(of("yes")).build(), District)).isEqualTo(asmtCount * districtsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(builder.dimensionType(Section504).genderCodes(null).ethnicityCodes(null).section504Codes(of("undefined")).build(), District)).isEqualTo(asmtCount * districtsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(builder.dimensionType(LEP).section504Codes(null).lepCodes(of("yes")).build(), District)).isEqualTo(asmtCount * districtsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(builder.dimensionType(IEP).lepCodes(null).iepCodes(of("yes")).build(), District)).isEqualTo(asmtCount * districtsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(builder.dimensionType(EconomicDisadvantage).iepCodes(null).economicDisadvantageCodes(of("yes")).build(), District)).isEqualTo(asmtCount * districtsCount);

        assertThat(repository.estimateReportRowCountByOrganizationType(builder.dimensionType(Overall).organizationType(State).build(), State)).isEqualTo(asmtCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(builder.dimensionType(Overall).organizationType(District).organizationIds(of(-19L, -18L, -99L)).build(), District)).isEqualTo(asmtCount * 2);
        assertThat(repository.estimateReportRowCountByOrganizationType(builder.dimensionType(Overall).organizationType(School).organizationIds(of(-8L, -9L, -99L)).build(), School)).isEqualTo(asmtCount * 2);
        assertThat(repository.estimateReportRowCountByOrganizationType(builder.dimensionType(Overall).organizationType(State).organizationIds(null).build(), District)).isEqualTo(asmtCount * districtsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(builder.dimensionType(Overall).organizationType(District).organizationIds(of(-19L)).build(), School)).isEqualTo(asmtCount * 2);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireNotEmptyQuery() {
        repository.findByOrganizationType(user, LongitudinalOrganizationQuery.builder().build(), OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireOrganizationIdsForSchoolOrganizationType() {
        repository.findByOrganizationType(user, LongitudinalOrganizationQuery
                .builder()
                .assessmentTypeCode(SUMMATIVE.code())
                .dimensionType(DimensionType.Overall)
                .organizationType(School)
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1998, "04"), new YearGradePair(1999, "05"), new YearGradePair(2000, "06")))
                .subjectCode("test")
                .build(), OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireOrganizationIdsForDistrictOrganizationType() {
        repository.findByOrganizationType(user, LongitudinalOrganizationQuery
                        .builder()
                        .assessmentTypeCode(SUMMATIVE.code())
                        .dimensionType(DimensionType.Overall)
                        .organizationType(District)
                        .gradeYearPairs(ImmutableList.of(new YearGradePair(1998, "04"), new YearGradePair(1999, "05"), new YearGradePair(2000, "06")))
                        .subjectCode("test")
                        .build()
                , OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireSubject() {
        repository.findByOrganizationType(user, LongitudinalOrganizationQuery
                        .builder()
                        .assessmentTypeCode(SUMMATIVE.code())
                        .dimensionType(DimensionType.Overall)
                        .organizationType(State)
                        .gradeYearPairs(ImmutableList.of(new YearGradePair(1998, "04"), new YearGradePair(1999, "05"), new YearGradePair(2000, "06")))
                        .build()
                , OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireAssessmentType() {
        repository.findByOrganizationType(user, LongitudinalOrganizationQuery
                        .builder()
                        .dimensionType(DimensionType.Overall)
                        .organizationType(State)
                        .gradeYearPairs(ImmutableList.of(new YearGradePair(1998, "04"), new YearGradePair(1999, "05"), new YearGradePair(2000, "06")))
                        .subjectCode("test")
                        .build()
                , OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireDimension() {
        repository.findByOrganizationType(user, LongitudinalOrganizationQuery
                        .builder()
                        .assessmentTypeCode(SUMMATIVE.code())
                        .organizationType(State)
                        .gradeYearPairs(ImmutableList.of(new YearGradePair(1998, "04"), new YearGradePair(1999, "05"), new YearGradePair(2000, "06")))
                        .subjectCode("test")
                        .build()
                , OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireOrganization() {
        repository.findByOrganizationType(user, LongitudinalOrganizationQuery
                        .builder()
                        .assessmentTypeCode(SUMMATIVE.code())
                        .dimensionType(DimensionType.Overall)
                        .gradeYearPairs(ImmutableList.of(new YearGradePair(1998, "04"), new YearGradePair(1999, "05"), new YearGradePair(2000, "06")))
                        .subjectCode("test")
                        .build()
                , OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireSchoolYearGrades() {
        repository.findByOrganizationType(user, LongitudinalOrganizationQuery
                        .builder()
                        .assessmentTypeCode(SUMMATIVE.code())
                        .dimensionType(DimensionType.Overall)
                        .subjectCode("test")
                        .organizationType(State)
                        .build()
                , OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailForAllSchoolsInState() {
        final LongitudinalOrganizationQuery query = LongitudinalOrganizationQuery.builder()
                .assessmentTypeCode(SUMMATIVE.code())
                .dimensionType(Overall)
                .organizationType(State)
                .gradeYearPairs(ImmutableList.of(new YearGradePair(1998, "04"), new YearGradePair(1999, "05"), new YearGradePair(2000, "06")))
                .subjectCode("test")
                .build();
        repository.findByOrganizationType(user, query, School);
    }
}