package org.opentestsystem.rdw.olap.repository.impl;

import com.google.common.collect.ImmutableMap;
import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.olap.model.Assessment;
import org.opentestsystem.rdw.olap.model.Dimension;
import org.opentestsystem.rdw.olap.model.Measures;
import org.opentestsystem.rdw.olap.model.Organization;
import org.opentestsystem.rdw.olap.model.ReportQuery;
import org.opentestsystem.rdw.olap.model.ReportRow;
import org.opentestsystem.rdw.olap.repository.CustomAggregateReportRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Import;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.jdbc.Sql;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static com.google.common.collect.ImmutableSet.of;
import static java.util.stream.Collectors.toSet;
import static org.assertj.core.api.Assertions.assertThat;
import static org.opentestsystem.rdw.olap.model.DimensionType.Ethnicity;
import static org.opentestsystem.rdw.olap.model.DimensionType.Gender;
import static org.opentestsystem.rdw.olap.model.DimensionType.Overall;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.State;
import static org.springframework.test.jdbc.JdbcTestUtils.countRowsInTable;

@Import(JdbcCustomAggregateReportRowRepository.class)
@Sql(scripts = {"classpath:OlapEntitiesSetup.sql"})
public class JdbcCustomAggregateReportRowRepositoryRST extends RepositoryBackedIT {

    @Autowired
    private CustomAggregateReportRepository reportRepository;

    @Autowired
    JdbcTemplate template;

    @Value("${app.state.name}")
    private String stateName;
    private ReportRow stateOverall;
    private ReportQuery.Builder queryBuilder;

    @Before
    public void setUp() {
        queryBuilder = ReportQuery.builder()
                .asmtGrades(of(-8))
                .includeState(true)
                .schoolYears(of(1999))
                .subjectIds(of(1))
                .assessmentType(AssessmentType.ICA)
                .dimension(Overall);

        stateOverall = ReportRow.builder()
                .assessment(new Assessment(-8, -8, 1))
                .examSchoolYear(1999)
                .organization(new Organization(stateName, null, State))
                .dimension(new Dimension(null, Overall))
                .measures(Measures.builder()
                        .avgScaleScore((int) Math.round(of(2500, 2400, 2300, 2100, 2000).stream().mapToDouble(a -> a).average().getAsDouble()))
                        .avgStdErr((int) Math.round(Math.sqrt(((25 * 25) + (24 * 24) + (23 * 23) + (21 * 21) + (20 * 20)) / 5)))
                        .level1Count(2)
                        .level2Count(1)
                        .level3Count(1)
                        .level4Count(1)
                        .build())
                .build();
    }

    @Test
    public void itShouldFindByQuery() {
        assertThat(reportRepository.findByQuery(queryBuilder.build())).usingFieldByFieldElementComparator().containsExactly(stateOverall);
        assertThat(reportRepository.findByQuery(queryBuilder.subjectIds(of(2)).build())).isEmpty();

        assertThat(reportRepository.findByQuery(ReportQuery.builder()
                .asmtGrades(of(-9))
                .includeState(true)
                .schoolYears(of(1999))
                .subjectIds(of(2))
                .assessmentType(AssessmentType.SUMMATIVE)
                .dimension(Overall)
                .build()).size()).isEqualTo(1);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailForIAB() {
        reportRepository.findByQuery(queryBuilder.assessmentType(AssessmentType.IAB).build());
    }

    @Test
    public void itShouldChooseAllDistrictsFlagOverListOfDistrictIds() {
        assertThat(reportRepository.findByQuery(queryBuilder
                .includeState(false)
                .districts(ImmutableMap.of(-100, false))
                .includeAllDistricts(true)
                .build()).size()).isEqualTo(countRowsInTable(template, "district"));
    }

    @Test
    public void itShouldFindByQueryWithGender() {
        assertThat(reportRepository.findByQuery(queryBuilder
                .includeState(false)
                .schoolIds(of(-9))
                .dimensions(of(Gender))
                .build()).size()).isEqualTo(countRowsInTable(template, "gender"));
    }

    @Test
    public void itShouldFindByQueryWithAllSchoolsForDistricts() {
        final ReportQuery query = queryBuilder
                .includeState(false)
                .includeAllDistricts(false)
                .districts(ImmutableMap.of(-9, true))
                .build();

        final List<ReportRow> expectedRows = reportRepository.findByQuery(query
                .copy()
                .districts(ImmutableMap.of(-9, false))
                .schoolIds(of(-9, -10))
                .build());

        assertThat(reportRepository.findByQuery(query)).usingFieldByFieldElementComparator().containsOnlyElementsOf(expectedRows);

        // (1 state + 3 districts + 2 schools) = 6
        assertThat(reportRepository.findByQuery(query
                .copy()
                .includeState(true)
                .includeAllDistricts(true)
                .districts(ImmutableMap.of(-9, false, -8, false, -7, false))
                .schoolIds(of(-9, -8)).build()).size()).isEqualTo(6);

        // (1 state + 3 districts + 2 schools) X 5 dim = 30
        assertThat(reportRepository.findByQuery(query
                .copy()
                .includeState(true)
                .includeAllDistricts(true)
                .dimensions(of(Overall, Gender, Ethnicity))
                .districts(ImmutableMap.of(-9, false, -8, false, -7, false))
                .schoolIds(of(-9, -8)).build()).size()).isEqualTo(30);


        // (1 state + 3 districts + 2 schools(in district 9) + 2 schools) = 8
        //NOTE: in this case we get duplicate school -9, but this should not happen with the UI controlling the selection
        assertThat(reportRepository.findByQuery(query
                .copy()
                .includeState(true)
                .includeAllDistricts(true)
                .districts(ImmutableMap.of(-9, true, -8, false, -7, false))
                .schoolIds(of(-9, -8)).build()).size()).isEqualTo(8);
    }

    @Test
    public void itShouldFindByQueryWithEthnicity() {
        // district -99 does not exist
        assertThat(reportRepository.findByQuery(queryBuilder
                .includeState(false)
                .districts(ImmutableMap.of(-99, false))
                .dimensions(of(Ethnicity))
                .build()).size()).isZero();

        final List<ReportRow> reportRows = reportRepository.findByQuery(queryBuilder.
                includeState(false)
                .districts(ImmutableMap.of(-9, false))
                .dimensions(of(Ethnicity))
                .build());

        assertThat(reportRows.size()).isEqualTo(countRowsInTable(template, "ethnicity"));
        assertThat(reportRows.stream().filter(r -> (r.getMeasures().getAvgScaleScore() != null)).collect(Collectors.toList()).size()).isEqualTo(1);

        assertThat(reportRepository.findByQuery(queryBuilder.
                includeState(true)
                .includeAllDistricts(true)
                .dimensions(of(Ethnicity))
                .build()).size()).isEqualTo((countRowsInTable(template, "district") + 1) * countRowsInTable(template, "ethnicity"));
    }

    @Test
    public void itShouldFindByQueryWithMultipleValuesOfDiffParams() {

        final List<Map<String, Object>> asmtByDim = template.queryForList
                ("SELECT a.id, a.type_id, a.subject_id, a.grade_id, f.school_year" +
                        "  FROM asmt a LEFT JOIN fact_student_exam f ON a.id = f.asmt_id" +
                        "  WHERE a.grade_id IN (-8,-9) AND a.subject_id IN (1,2) AND a.type_id = 1 AND f.school_year IN (1999, 2000)" +
                        "  GROUP BY a.id, a.type_id, a.subject_id, a.grade_id, f.school_year");

        final int grade8AsmtSubject1Count = (int) asmtByDim.stream().filter(a -> (a.get("grade_id").equals(-8) && a.get("subject_id").equals(1))).map(a -> a.get("id")).distinct().count();
        final int grade8AsmtSubject2Count = (int) asmtByDim.stream().filter(a -> (a.get("grade_id").equals(-8) && a.get("subject_id").equals(2))).map(a -> a.get("id")).distinct().count();
        final int grade9AsmtSubject1Count = (int) asmtByDim.stream().filter(a -> (a.get("grade_id").equals(-9) && a.get("subject_id").equals(1))).map(a -> a.get("id")).distinct().count();
        final int grade9AsmtSubject2Count = (int) asmtByDim.stream().filter(a -> (a.get("grade_id").equals(-9) && a.get("subject_id").equals(2))).map(a -> a.get("id")).distinct().count();


        final List<ReportRow> reportRows = reportRepository.findByQuery(queryBuilder
                .asmtGrades(of(-8, -9))
                .subjectIds(of(1, 2))
                .schoolYears(of(1999, 2000))
                .dimensions(of(Ethnicity, Gender, Overall))
                .build());

        final int ethnicityCount = countRowsInTable(template, "ethnicity");
        final int genderCount = countRowsInTable(template, "gender");

        assertThat(reportRows.size()).isEqualTo(
                (grade8AsmtSubject1Count * ethnicityCount * genderCount * 2) +
                        (grade8AsmtSubject2Count * ethnicityCount * genderCount * 2) +
                        (grade9AsmtSubject1Count * ethnicityCount * genderCount * 2) +
                        (grade9AsmtSubject2Count * ethnicityCount * genderCount * 2) +
                        2 * (grade8AsmtSubject1Count + grade8AsmtSubject2Count + grade9AsmtSubject1Count + grade9AsmtSubject2Count)
        );

        final List<ReportRow> rowsWithNonZeroValues = reportRows.stream().filter(r -> (r.getMeasures().getAvgScaleScore() != null)).collect(Collectors.toList());
        assertThat(rowsWithNonZeroValues.size()).isEqualTo(11);
        assertThat(rowsWithNonZeroValues.stream().map(ReportRow::getOrganization).distinct().collect(toSet()))
                .usingFieldByFieldElementComparator()
                .containsOnly(new Organization(stateName, null, State));

        // This verifies that the data is grouped by asmt_id to support a use case when there are two assessments for
        // the same subject/grade/type and exam school year.
        assertThat(rowsWithNonZeroValues.stream().map(ReportRow::getAssessment).distinct().collect(toSet()))
                .usingFieldByFieldElementComparator().containsExactlyInAnyOrder(
                new Assessment(-8, -8, 1),
                new Assessment(-9, -9, 2));

        assertThat(rowsWithNonZeroValues.stream().map(ReportRow::getExamSchoolYear).filter(y -> (y == 1999)).count()).isEqualTo(8);
        assertThat(rowsWithNonZeroValues.stream().map(ReportRow::getExamSchoolYear).filter(y -> (y == 2000)).count()).isEqualTo(3);
        assertThat(rowsWithNonZeroValues.stream().map(ReportRow::getAssessment).filter(a -> (a.getSubjectId() == 1)).count()).isEqualTo(5);
        assertThat(rowsWithNonZeroValues.stream().map(ReportRow::getAssessment).filter(a -> (a.getSubjectId() == 2)).count()).isEqualTo(6);
    }


    @Test
    @Sql(scripts = {"classpath:OlapEntitiesSetup.sql"},
            statements = {"INSERT INTO  fact_student_exam (id, school_year, asmt_id, asmt_grade_id, completeness_id," +
                    "                                    administration_condition_id, performance_level," +
                    "                                    scale_score, scale_score_std_err, grade_id, student_id, school_id," +
                    "                                    iep, lep, section504, economic_disadvantage, migrant_status," +
                    "                                    claim1_scale_score, claim1_scale_score_std_err,claim1_category," +
                    "                                    claim2_scale_score, claim2_scale_score_std_err,claim2_category," +
                    "                                    claim3_scale_score, claim3_scale_score_std_err,claim3_category," +
                    "                                    claim4_scale_score, claim4_scale_score_std_err,claim4_category," +
                    "                                    completed_at, updated, update_import_id, migrate_id) VALUES " +
                    "(-34, 2000 , -10, -9, -9, -9, 1, 2500, 17, -8, -9, -9, true, true, false, false, true,  2000, 0.11, 1, 2100, 0.12, 2, 2500, 0.13, 3, 3500, .15, 4, '2016-08-14 19:05:33.000000', '2016-09-14 19:05:33.000000', -1, -1)",
            "INSERT INTO asmt_active_year (asmt_id, school_year) VALUES (-10, 2000)"})
    public void itShouldGroupByAssessmentId() {

        //if two different ICAs are administered at the same school year, we should group the data by the asmt id

        final List<ReportRow> reportRows = reportRepository.findByQuery(queryBuilder
                .asmtGrades(of(-9))
                .subjectIds(of(2))
                .schoolYears(of(2000))
                .dimensions(of(Overall))
                .build());
        assertThat(reportRows.stream().map(ReportRow::getAssessment).distinct().collect(toSet()))
                .usingFieldByFieldElementComparator().containsExactlyInAnyOrder(
                new Assessment(-10, -9, 2),
                new Assessment(-9, -9, 2));
    }
}