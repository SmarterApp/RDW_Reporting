package org.opentestsystem.rdw.olap.repository.impl;

import com.google.common.collect.ImmutableSet;
import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;
import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.rdw.olap.repository.CustomAggregateReportRepository;
import org.opentestsystem.rdw.olap.sqlbuilder.QueryWithReportTemplate;
import org.opentestsystem.rdw.reporting.common.model.ActiveAssessment;
import org.opentestsystem.rdw.reporting.common.model.Dimension;
import org.opentestsystem.rdw.reporting.common.model.Measures;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.model.ReportQuery;
import org.opentestsystem.rdw.reporting.common.model.ReportRow;
import org.opentestsystem.rdw.reporting.common.sqlbuilder.QueryProvider;
import org.opentestsystem.rdw.reporting.common.sqlbuilder.SqlBuilderConfig;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Import;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.jdbc.Sql;

import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

import static com.google.common.collect.ImmutableSet.of;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toSet;
import static org.assertj.core.api.Assertions.assertThat;
import static org.opentestsystem.rdw.common.model.AssessmentType.IAB;
import static org.opentestsystem.rdw.common.model.AssessmentType.ICA;
import static org.opentestsystem.rdw.common.model.AssessmentType.SUMMATIVE;
import static org.opentestsystem.rdw.common.model.Subject.ELA;
import static org.opentestsystem.rdw.common.model.Subject.MATH;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.EconomicDisadvantage;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Ethnicity;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Gender;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.IEP;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.LEP;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.MigrantStatus;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Overall;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Section504;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.StudentEnrolledGrade;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.State;
import static org.springframework.test.jdbc.JdbcTestUtils.countRowsInTable;

@SuppressWarnings({"SqlNoDataSourceInspection", "SqlResolve"})
@ComponentScan({"org.opentestsystem.rdw.olap.repository", "org.opentestsystem.rdw.olap.repository.impl", "org.opentestsystem.rdw.olap.sqlbuilder"})
@Import({SqlBuilderConfig.class,
        QueryProvider.class,
        QueryWithReportTemplate.class
})
@Sql(scripts = {"classpath:OlapEntitiesSetup.sql"})
public class JdbcCustomAggregateReportRowRepositoryRST extends RepositoryBackedIT {

    @Autowired
    private CustomAggregateReportRepository reportRepository;

    @Autowired
    JdbcTemplate template;

    @Value("${app.state.name}")
    private String stateName;

    private ReportRow stateOverall;
    private ReportQuery.Builder queryBuilder;
    private int ethnicityCount;
    private int genderCount;
    private int districtsCount;

    @Before
    public void setUp() {
        ethnicityCount = countRowsInTable(template, "ethnicity");
        genderCount = countRowsInTable(template, "gender");
        districtsCount = countRowsInTable(template, "district");

        queryBuilder = ReportQuery.builder()
                .assessmentGradeCodes(of("-4"))
                .includeState(true)
                .schoolYears(of(1999))
                .subjectCodes(of(MATH.code()))
                .assessmentTypeCode(ICA.code())
                .dimensionType(Overall);

        final ImmutableSet<Double> scaleScores = of(2500.0, 2400.0, 2300.0, 2100.0, 2000.0);
        final DescriptiveStatistics stats = new DescriptiveStatistics();
        for (final Double scaleScore : scaleScores) {
            stats.addValue(scaleScore);
        }
        stateOverall = ReportRow.builder()
                .assessment(ActiveAssessment.builder().id(-8).gradeCode("-4").subjectCode("Math").label("asmt-8").examSchoolYear(1999).build())
                .organization(Organization.builder().name(stateName).organizationType(State).build())
                .dimension(new Dimension(null, Overall))
                .measures(Measures.builder()
                        .avgScaleScore((int) Math.round(stats.getMean()))
                        .avgStdErr((int) Math.round(stats.getStandardDeviation() / Math.sqrt(scaleScores.size())))
                        .level1Count(2)
                        .level2Count(1)
                        .level3Count(1)
                        .level4Count(1)
                        .build())
                .build();
    }

    @Test
    public void itShouldFindByQuery() {
        assertThat(reportRepository.findByQuery(queryBuilder.build())).usingFieldByFieldElementComparator().containsExactly(stateOverall);
        assertThat(reportRepository.findByQuery(queryBuilder.subjectCodes(of(ELA.code())).build())).isEmpty();

        assertThat(reportRepository.findByQuery(ReportQuery.builder()
                .assessmentGradeCodes(of("-3"))
                .includeState(true)
                .schoolYears(of(1999))
                .subjectCodes(of(ELA.code()))
                .assessmentTypeCode(SUMMATIVE.code())
                .dimensionType(Overall)
                .build()).size()).isEqualTo(1);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailForIAB() {
        reportRepository.findByQuery(queryBuilder.assessmentTypeCode(IAB.code()).build());
    }

    @Test
    public void itShouldChooseAllDistrictsFlagOverListOfDistrictIds() {
        assertThat(reportRepository.findByQuery(queryBuilder
                .includeState(false)
                .districtIds(of(-100L))
                .includeAllSchoolsOfDistricts(false)
                .includeAllDistricts(true)
                .build()).size()).isEqualTo(districtsCount);
    }

    @Test
    public void itShouldFindByQueryWithIEP() {
        List<ReportRow> rows = reportRepository.findByQuery(queryBuilder
                .includeState(false)
                .includeAllDistricts(false)
                .schoolIds(of(-9L))
                .dimensionTypes(of(IEP))
                .build());

        assertThat(rows.size()).isEqualTo(2);
        for (final ReportRow row : rows) {
            if (row.getDimension().getCode().equalsIgnoreCase("no")) assertThat(countStudents(row.getMeasures())).isEqualTo(1);
            else assertThat(countStudents(row.getMeasures())).isEqualTo(0);
        }

        rows = reportRepository.findByQuery(queryBuilder
                .includeState(true)
                .includeAllDistricts(true)
                .schoolIds(null)
                .dimensionTypes(of(IEP))
                .build());

        assertThat(rows.size()).isEqualTo((districtsCount + 1) * 2);
        assertThat(rows.stream().filter(r -> (r.getOrganization().getOrganizationType() == State)).mapToInt(r -> countStudents(r.getMeasures())).sum()).isEqualTo(5);
    }

    @Test
    public void itShouldFindByQueryWithIEPAsDimensionAndFilters() {
        final List<ReportRow> rows = reportRepository.findByQuery(queryBuilder
                .includeState(true)
                .includeAllDistricts(true)
                .schoolIds(null)
                .dimensionTypes(of(IEP))
                .genderCodes(of("gender-18"))
                .build());

        assertThat(rows.size()).isEqualTo((districtsCount + 1) * 2);
        assertThat(rows.stream().filter(r -> (r.getOrganization().getOrganizationType() == State)).mapToInt(r -> countStudents(r.getMeasures())).sum()).isEqualTo(2);

    }

    @Test
    public void itShouldFindByQueryWithIEPAsDimensionAndFilter() {
        final List<ReportRow> rows = reportRepository.findByQuery(queryBuilder
                .includeState(true)
                .includeAllDistricts(true)
                .schoolIds(null)
                .dimensionTypes(of(IEP))
                .iepCodes(of("yes"))
                .build());

        assertThat(rows.size()).isEqualTo((districtsCount + 1));
        assertThat(rows.stream().filter(r -> (r.getOrganization().getOrganizationType() == State)).mapToInt(r -> countStudents(r.getMeasures())).sum()).isEqualTo(3);
    }

    @Test
    public void itShouldFindByQueryWithLEPAsDimension() {
        List<ReportRow> rows = reportRepository.findByQuery(queryBuilder
                .includeState(false)
                .includeAllDistricts(false)
                .schoolIds(of(-9L))
                .dimensionTypes(of(LEP))
                .build());

        assertThat(rows.size()).isEqualTo(2);
        for (final ReportRow row : rows) {
            if (row.getDimension().getCode().equalsIgnoreCase("no")) assertThat(countStudents(row.getMeasures())).isEqualTo(0);
            else assertThat(countStudents(row.getMeasures())).isEqualTo(1);
        }

        rows = reportRepository.findByQuery(queryBuilder
                .includeState(true)
                .includeAllDistricts(true)
                .schoolIds(null)
                .dimensionTypes(of(LEP))
                .build());
        assertThat(rows.size()).isEqualTo((districtsCount + 1) * 2);
    }

    @Test
    public void itShouldFindByQueryWithLEPAsDimensionAndEthnicityAndFilter() {
        final List<ReportRow> rows = reportRepository.findByQuery(queryBuilder
                .includeState(true)
                .includeAllDistricts(false)
                .dimensionTypes(of(LEP))
                .ethnicityCodes(of("ethnicity-28", "ethnicity-29"))
                .build());

        assertThat(rows.size()).isEqualTo(2);
        assertThat(rows.stream().filter(r -> (r.getOrganization().getOrganizationType() == State)).filter(r -> (r.getDimension().getCode().equals("yes"))).mapToInt(r -> countStudents(r.getMeasures())).sum()).isEqualTo(3);
    }

    @Test
    public void itShouldFindByQueryWithLEPAsDimensionAndFilter() {
        final List<ReportRow> rows = reportRepository.findByQuery(queryBuilder
                .includeState(true)
                .includeAllDistricts(true)
                .dimensionTypes(of(LEP))
                .lepCodes(of("no"))
                .build());

        assertThat(rows.size()).isEqualTo((districtsCount + 1));
        assertThat(rows.stream().filter(r -> (r.getOrganization().getOrganizationType() == State)).mapToInt(r -> countStudents(r.getMeasures())).sum()).isEqualTo(0);

        assertThat(reportRepository.findByQuery(queryBuilder
                .includeState(true)
                .includeAllDistricts(true)
                .dimensionTypes(of(LEP))
                .lepCodes(of("no", "yes"))
                .build()).stream().filter(r -> (r.getOrganization().getOrganizationType() == State)).mapToInt(r -> countStudents(r.getMeasures())).sum()).isEqualTo(5);
    }

    @Test
    public void itShouldFindByQueryWithEconomicDisadvantageAsDimension() {
        assertThat(reportRepository.findByQuery(queryBuilder
                .includeState(true)
                .includeAllDistricts(true)
                .dimensionTypes(of(EconomicDisadvantage))
                .build()).size()).isEqualTo((districtsCount + 1) * 2);

        final List<ReportRow> rows = reportRepository.findByQuery(queryBuilder
                .includeState(false)
                .includeAllDistricts(false)
                .schoolIds(of(-9L))
                .dimensionTypes(of(EconomicDisadvantage))
                .build());

        assertThat(rows.size()).isEqualTo(2);
        for (final ReportRow row : rows) {
            if (row.getDimension().getCode().equalsIgnoreCase("no")) assertThat(countStudents(row.getMeasures())).isEqualTo(1);
            else assertThat(countStudents(row.getMeasures())).isEqualTo(0);
        }
    }

    @Test
    public void itShouldFindByQueryWithEconomicDisadvantageAsDimensionAndFilter() {
        assertThat(reportRepository.findByQuery(queryBuilder
                .includeState(true)
                .includeAllDistricts(true)
                .dimensionTypes(of(EconomicDisadvantage))
                .economicDisadvantageCodes(of("yes"))
                .build()).size()).isEqualTo((districtsCount + 1));
    }

    @Test
    public void itShouldFindByQueryWithSection504AsDimension() {
        assertThat(reportRepository.findByQuery(queryBuilder
                .includeState(true)
                .includeAllDistricts(true)
                .schoolIds(of(1L))
                .dimensionTypes(of(Section504))
                .build()).size()).isEqualTo((districtsCount + 1) * 3);

        final List<ReportRow> rows = reportRepository.findByQuery(queryBuilder
                .includeState(false)
                .includeAllDistricts(false)
                .schoolIds(of(-9L))
                .dimensionTypes(of(Section504))
                .build());

        assertThat(rows.size()).isEqualTo(3);
        for (final ReportRow row : rows) {
            if (row.getDimension().getCode().equalsIgnoreCase("no")) assertThat(countStudents(row.getMeasures())).isEqualTo(0);
            else if (row.getDimension().getCode().equalsIgnoreCase("yes")) assertThat(countStudents(row.getMeasures())).isEqualTo(0);
            else assertThat(countStudents(row.getMeasures())).isEqualTo(1);
        }
    }

    @Test
    public void itShouldFindByQueryWithSection504AsDimensionAndFilter() {
        assertThat(reportRepository.findByQuery(queryBuilder
                .includeState(true)
                .includeAllDistricts(true)
                .dimensionTypes(of(Section504))
                .section504Codes(of("undefined", "yes"))
                .build()).size()).isEqualTo((districtsCount + 1) * 2);
    }

    @Test
    public void itShouldFindByQueryWithMigrantStatusAsDimension() {
        assertThat(reportRepository.findByQuery(queryBuilder
                .includeState(true)
                .includeAllDistricts(true)
                .dimensionTypes(of(MigrantStatus))
                .build()).size()).isEqualTo((districtsCount + 1) * 3);

        List<ReportRow> rows = reportRepository.findByQuery(queryBuilder
                .includeState(false)
                .includeAllDistricts(false)
                .schoolIds(of(-9L))
                .dimensionTypes(of(MigrantStatus))
                .administrativeConditionCodes(of("IN"))
                .completenessCodes(of("Complete"))
                .build());

        assertThat(rows.size()).isEqualTo(3);
        for (final ReportRow row : rows) {
            if (row.getDimension().getCode().equalsIgnoreCase("no")) assertThat(countStudents(row.getMeasures())).isEqualTo(0);
            else if (row.getDimension().getCode().equalsIgnoreCase("yes")) assertThat(countStudents(row.getMeasures())).isEqualTo(1);
            else assertThat(countStudents(row.getMeasures())).isEqualTo(0);
        }

        rows = reportRepository.findByQuery(queryBuilder.genderCodes(of("gender-18")).build());
        assertThat(rows.size()).isEqualTo(3);
        for (final ReportRow row : rows) {
            if (row.getDimension().getCode().equalsIgnoreCase("no")) assertThat(countStudents(row.getMeasures())).isEqualTo(0);
            else if (row.getDimension().getCode().equalsIgnoreCase("yes")) assertThat(countStudents(row.getMeasures())).isEqualTo(0);
            else assertThat(countStudents(row.getMeasures())).isEqualTo(0);
        }
    }

    @Test
    public void itShouldFindByQueryWithMigrantStatusAsDimensionAndFilter() {
        assertThat(reportRepository.findByQuery(queryBuilder
                .includeState(true)
                .includeAllDistricts(true)
                .dimensionTypes(of(MigrantStatus))
                .migrantStatusCodes(of("yes"))
                .build()).size()).isEqualTo((districtsCount + 1));
    }

    @Test
    public void itShouldFindByQueryWithGenderAsDimension() {
        assertThat(reportRepository.findByQuery(queryBuilder
                .includeState(false)
                .schoolIds(of(-9L))
                .dimensionTypes(of(Gender))
                .build()).size()).isEqualTo(countRowsInTable(template, "gender"));
    }

    @Test
    public void itShouldFindByQueryWithGenderAsDimensionAndFilter() {
        assertThat(reportRepository.findByQuery(queryBuilder
                .includeState(false)
                .schoolIds(of(-9L))
                .dimensionTypes(of(Gender))
                .genderCodes(of("gender-18"))
                .build()).size()).isEqualTo(1);
    }

    @Test
    public void itShouldFindByQueryWithEthnicityAsDimension() {
        // district -99 does not exist
        assertThat(reportRepository.findByQuery(queryBuilder
                .includeState(false)
                .districtIds(of(-99L))
                .includeAllSchoolsOfDistricts(false)
                .dimensionTypes(of(Ethnicity))
                .build()).size()).isZero();

        final List<ReportRow> reportRows = reportRepository.findByQuery(queryBuilder.
                includeState(false)
                .districtIds(of(-9L))
                .includeAllSchoolsOfDistricts(false)
                .dimensionTypes(of(Ethnicity))
                .build());

        assertThat(reportRows.size()).isEqualTo(countRowsInTable(template, "ethnicity"));
        assertThat(reportRows.stream().filter(r -> (r.getMeasures().getAvgScaleScore() != null)).collect(Collectors.toList()).size()).isEqualTo(1);

        assertThat(reportRepository.findByQuery(queryBuilder.
                includeState(true)
                .includeAllDistricts(true)
                .dimensionTypes(of(Ethnicity))
                .build()).size()).isEqualTo((districtsCount + 1) * countRowsInTable(template, "ethnicity"));
    }

    @Test
    public void itShouldFindByQueryWithEthnicityAsDimensionAndFilter() {
        assertThat(reportRepository.findByQuery(queryBuilder.
                includeState(false)
                .districtIds(of(-9L))
                .includeAllSchoolsOfDistricts(false)
                .dimensionTypes(of(Ethnicity))
                .ethnicityCodes(of("ethnicity-28"))
                .build()).size()).isEqualTo(1);
    }

    @Test
    public void itShouldFindByQueryWithEnrolledGradeAndGender() {
        List<ReportRow> rows = reportRepository.findByQuery(queryBuilder
                .includeState(false)
                .includeAllDistricts(false)
                .schoolIds(of(-8L))
                .dimensionTypes(of(StudentEnrolledGrade))
                .build());

        assertThat(rows.size()).isEqualTo(2);
        for (final ReportRow row : rows) {
            if (row.getDimension().getCode().equals("-5")) assertThat(countStudents(row.getMeasures())).isEqualTo(1);
            else assertThat(countStudents(row.getMeasures())).isEqualTo(2);
        }
    }

    @Test
    public void itShouldFindByQueryWithEnrolledGradeAndFilters() {
        List<ReportRow> rows = reportRepository.findByQuery(queryBuilder
                .includeState(false)
                .includeAllDistricts(false)
                .schoolIds(of(-8L))
                .dimensionTypes(of(StudentEnrolledGrade))
                .genderCodes(of("gender-18"))
                .build());

        assertThat(rows.size()).isEqualTo(1);
        assertThat(rows.get(0).getDimension().getCode()).isEqualTo("-4");
        assertThat(countStudents(rows.get(0).getMeasures())).isEqualTo(2);

        rows = reportRepository.findByQuery(queryBuilder.completenessCodes(of("Complete")).build());
        assertThat(rows.size()).isEqualTo(1);
        assertThat(rows.get(0).getDimension().getCode()).isEqualTo("-4");
        assertThat(countStudents(rows.get(0).getMeasures())).isEqualTo(1);

        rows = reportRepository.findByQuery(queryBuilder.administrativeConditionCodes(of("IN")).build());
        assertThat(rows.size()).isEqualTo(0);

        rows = reportRepository.findByQuery(queryBuilder.genderCodes(of("gender-19")).build());
        assertThat(rows.size()).isEqualTo(1);
        assertThat(rows.get(0).getDimension().getCode()).isEqualTo("-5");
        assertThat(countStudents(rows.get(0).getMeasures())).isEqualTo(1);

        rows = reportRepository.findByQuery(queryBuilder.administrativeConditionCodes(of("SD")).build());
        assertThat(rows.size()).isEqualTo(0);
    }

    @Test
    public void itShouldBackFillMissingDataForAllDimensionsButStudentEnrolledGrade() {
        final Integer asmtCount = template.queryForObject("SELECT count(*) AS count FROM asmt_active_year ay LEFT JOIN asmt a ON a.id = ay.asmt_id" +
                "  WHERE a.grade_id IN (-5) AND a.subject_id IN (2) AND a.type_id = 1 AND ay.school_year IN (1888)", Integer.class);

        assertThat(reportRepository.findByQuery(queryBuilder
                .assessmentTypeCode(ICA.code())
                .includeState(false)
                .includeAllDistricts(true)
                .schoolIds(null)
                .schoolYears(of(1888))
                .subjectCodes(of(ELA.code()))
                .assessmentGradeCodes(of("-5"))
                .dimensionTypes(of(Overall))
                // the below two filters do not change the back-filling rules
                .administrativeConditionCodes(of("IN"))
                .completenessCodes(of("Complete"))
                .build()).size()).isEqualTo(asmtCount * districtsCount);

        final List<ReportRow> reportRows = reportRepository.findByQuery(queryBuilder.dimensionTypes(of(Overall, StudentEnrolledGrade)).build());
        //we do not back-fill the data for the StudentEnrolledGrade
        assertThat(reportRows.size()).isEqualTo(asmtCount * districtsCount);

        assertThat(reportRows.stream().map(r -> r.getAssessment().getLabel()).filter(Objects::nonNull).collect(toList()).size()).isEqualTo(asmtCount * districtsCount);
        assertThat(reportRows.stream().map(r -> r.getAssessment().getSubjectCode()).filter(Objects::nonNull).collect(toList()).size()).isEqualTo(asmtCount * districtsCount);

        assertThat(reportRepository.findByQuery(queryBuilder.dimensionTypes(of(Overall, Gender)).genderCodes(of("gender-18")).build()).size())
                .isEqualTo(asmtCount * districtsCount * (1 + 1));

        assertThat(reportRepository.findByQuery(queryBuilder.dimensionTypes(of(Overall, Gender)).genderCodes(null).build()).size())
                .isEqualTo(asmtCount * districtsCount * (genderCount + 1));

        assertThat(reportRepository.findByQuery(queryBuilder.dimensionTypes(of(Overall, Gender, Ethnicity)).build()).size())
                .isEqualTo(asmtCount * districtsCount * (genderCount + ethnicityCount + 1));

        assertThat(reportRepository.findByQuery(queryBuilder.dimensionTypes(of(Overall, Gender, Ethnicity)).ethnicityCodes(of("ethnicity-28")).build()).size())
                .isEqualTo(asmtCount * districtsCount * (genderCount + 1 + 1));

        assertThat(reportRepository.findByQuery(queryBuilder.dimensionTypes(of(Overall, Gender, Ethnicity, MigrantStatus)).ethnicityCodes(null).build()).size())
                .isEqualTo(asmtCount * districtsCount * (genderCount + ethnicityCount + 3 + 1));

        assertThat(reportRepository.findByQuery(queryBuilder.dimensionTypes(of(Overall, Gender, Ethnicity, MigrantStatus, Section504)).build()).size())
                .isEqualTo(asmtCount * districtsCount * (genderCount + ethnicityCount + 3 + 3 + 1));

        assertThat(reportRepository.findByQuery(queryBuilder.dimensionTypes(of(Overall, Gender, Ethnicity, MigrantStatus, Section504, LEP)).build()).size())
                .isEqualTo(asmtCount * districtsCount * (genderCount + ethnicityCount + 3 + 3 + 2 + 1));

        assertThat(reportRepository.findByQuery(queryBuilder.dimensionTypes(of(Overall, Gender, Ethnicity, MigrantStatus, Section504, LEP, IEP)).build()).size())
                .isEqualTo(asmtCount * districtsCount * (genderCount + ethnicityCount + 3 + 3 + 2 + 2 + 1));

        assertThat(reportRepository.findByQuery(queryBuilder.dimensionTypes(of(Overall, Gender, Ethnicity, MigrantStatus, Section504, LEP, IEP, EconomicDisadvantage)).build()).size())
                .isEqualTo(asmtCount * districtsCount * (genderCount + ethnicityCount + 3 + 3 + 2 + 2 + 2 + 1));
    }

    @Test
    public void itShouldEstimateReportRowCount() {
        final Integer asmtCount = template.queryForObject("SELECT count(*) AS count FROM asmt_active_year ay JOIN asmt a ON a.id = ay.asmt_id" +
                "  WHERE a.grade_id IN (-5, -3) AND a.subject_id IN (1, 2) AND a.type_id = 1 AND ay.school_year IN (1888, 1999)", Integer.class);
        queryBuilder
                .assessmentTypeCode(ICA.code())
                .includeState(false)
                .includeAllDistricts(true)
                .schoolIds(null)
                .schoolYears(of(1888, 1999))
                .subjectCodes(of(MATH.code(), ELA.code()))
                .assessmentGradeCodes(of("-5", "-3"))
                // the below two filters do not change the counting rules
                .administrativeConditionCodes(of("IN"))
                .completenessCodes(of("Complete"));

        assertThat(reportRepository.estimateReportRowCount(queryBuilder.dimensionTypes(of(Overall)).build())).isEqualTo(asmtCount * districtsCount);
        //for the StudentEnrolledGrade we always assume that there is one entry found
        assertThat(reportRepository.estimateReportRowCount(queryBuilder.dimensionTypes(of(Overall, StudentEnrolledGrade)).build())).isEqualTo(asmtCount * districtsCount * 2);
        assertThat(reportRepository.estimateReportRowCount(queryBuilder.dimensionTypes(of(Overall, Gender)).build())).isEqualTo(asmtCount * districtsCount * (genderCount + 1));
        assertThat(reportRepository.estimateReportRowCount(queryBuilder.dimensionTypes(of(Overall, Gender, Ethnicity)).build())).isEqualTo(asmtCount * districtsCount * (genderCount + ethnicityCount + 1));
        assertThat(reportRepository.estimateReportRowCount(queryBuilder.dimensionTypes(of(Overall, Gender, Ethnicity, MigrantStatus)).build())).isEqualTo(asmtCount * districtsCount * (genderCount + ethnicityCount + 3 + 1));
        assertThat(reportRepository.estimateReportRowCount(queryBuilder.dimensionTypes(of(Overall, Gender, Ethnicity, MigrantStatus, Section504)).build())).isEqualTo(asmtCount * districtsCount * (genderCount + ethnicityCount + 3 + 3 + 1));
        assertThat(reportRepository.estimateReportRowCount(queryBuilder.dimensionTypes(of(Overall, Gender, Ethnicity, MigrantStatus, Section504, LEP)).build())).isEqualTo(asmtCount * districtsCount * (genderCount + ethnicityCount + 3 + 3 + 2 + 1));
        assertThat(reportRepository.estimateReportRowCount(queryBuilder.dimensionTypes(of(Overall, Gender, Ethnicity, MigrantStatus, Section504, LEP, IEP)).build())).isEqualTo(asmtCount * districtsCount * (genderCount + ethnicityCount + 3 + 3 + 2 + 2 + 1));
        assertThat(reportRepository.estimateReportRowCount(queryBuilder.dimensionTypes(of(Overall, Gender, Ethnicity, MigrantStatus, Section504, LEP, IEP, EconomicDisadvantage)).build())).isEqualTo(asmtCount * districtsCount * (genderCount + ethnicityCount + 3 + 3 + 2 + 2 + 2 + 1));

        //test with filters
        assertThat(reportRepository.estimateReportRowCount(queryBuilder.dimensionTypes(of(Overall, Gender, Ethnicity, MigrantStatus, Section504, LEP, IEP, EconomicDisadvantage)).genderCodes(of("gender-19")).build())).isEqualTo(asmtCount * districtsCount * (1 + ethnicityCount + 3 + 3 + 2 + 2 + 2 + 1));
        assertThat(reportRepository.estimateReportRowCount(queryBuilder.dimensionTypes(of(Overall, Gender, Ethnicity, MigrantStatus, Section504, LEP, IEP, EconomicDisadvantage)).genderCodes(of("gender-19")).ethnicityCodes(of("ethnicity-28")).build())).isEqualTo(asmtCount * districtsCount * (1 + 1 + 3 + 3 + 2 + 2 + 2 + 1));
        assertThat(reportRepository.estimateReportRowCount(queryBuilder.dimensionTypes(of(Overall, Gender, Ethnicity, MigrantStatus, Section504, LEP, IEP, EconomicDisadvantage)).genderCodes(null).ethnicityCodes(null).migrantStatusCodes(of("yes")).build())).isEqualTo(asmtCount * districtsCount * (genderCount + ethnicityCount + 1 + 3 + 2 + 2 + 2 + 1));
        assertThat(reportRepository.estimateReportRowCount(queryBuilder.dimensionTypes(of(Overall, Gender, Ethnicity, MigrantStatus, Section504, LEP, IEP, EconomicDisadvantage)).migrantStatusCodes(of("yes")).section504Codes(of("undefined")).build())).isEqualTo(asmtCount * districtsCount * (genderCount + ethnicityCount + 1 + 1 + 2 + 2 + 2 + 1));
        assertThat(reportRepository.estimateReportRowCount(queryBuilder.dimensionTypes(of(Overall, Gender, Ethnicity, MigrantStatus, Section504, LEP, IEP, EconomicDisadvantage)).migrantStatusCodes(null).section504Codes(null).lepCodes(of("yes")).build())).isEqualTo(asmtCount * districtsCount * (genderCount + ethnicityCount + 3 + 3 + 1 + 2 + 2 + 1));
        assertThat(reportRepository.estimateReportRowCount(queryBuilder.dimensionTypes(of(Overall, Gender, Ethnicity, MigrantStatus, Section504, LEP, IEP, EconomicDisadvantage)).lepCodes(of("yes")).iepCodes(of("yes")).build())).isEqualTo(asmtCount * districtsCount * (genderCount + ethnicityCount + 3 + 3 + 1 + 1 + 2 + 1));
        assertThat(reportRepository.estimateReportRowCount(queryBuilder.dimensionTypes(of(Overall, Gender, Ethnicity, MigrantStatus, Section504, LEP, IEP, EconomicDisadvantage)).lepCodes(of("yes")).iepCodes(of("yes")).economicDisadvantageCodes(of("yes")).build())).isEqualTo(asmtCount * districtsCount * (genderCount + ethnicityCount + 3 + 3 + 1 + 1 + 1 + 1));

        assertThat(reportRepository.estimateReportRowCount(queryBuilder.dimensionTypes(of(Overall)).includeState(true).includeAllDistricts(false).build())).isEqualTo(asmtCount);
        assertThat(reportRepository.estimateReportRowCount(queryBuilder.dimensionTypes(of(Overall)).includeState(false).includeAllDistricts(false).districtIds(of(-9L)).includeAllSchoolsOfDistricts(false).build())).isEqualTo(asmtCount);
        assertThat(reportRepository.estimateReportRowCount(queryBuilder.dimensionTypes(of(Overall)).includeState(false).includeAllDistricts(false).districtIds(of(-9L)).includeAllSchoolsOfDistricts(true).build())).isEqualTo(asmtCount * 3);
        assertThat(reportRepository.estimateReportRowCount(queryBuilder.dimensionTypes(of(Overall)).includeState(true).includeAllDistricts(false).districtIds(of(-9L)).includeAllSchoolsOfDistricts(true).build())).isEqualTo(asmtCount * 4);
        assertThat(reportRepository.estimateReportRowCount(queryBuilder.dimensionTypes(of(Overall)).includeState(false).includeAllDistricts(false).districtIds(null).schoolIds(of(-9L)).build())).isEqualTo(asmtCount);
    }

    @Test
    public void itShouldFindByQueryWithDiffSelectionsOfSchoolsAndDistricts() {
        final ReportQuery query = queryBuilder
                .includeState(false)
                .includeAllDistricts(false)
                .includeAllDistrictsOfSchools(false)
                .districtIds(of(-9L))
                .includeAllSchoolsOfDistricts(true).build();

        final List<ReportRow> expectedRows = reportRepository.findByQuery(query.copy()
                .includeAllSchoolsOfDistricts(false)
                .schoolIds(of(-9L, -10L)).build());

        assertThat(reportRepository.findByQuery(query)).usingFieldByFieldElementComparator().containsOnlyElementsOf(expectedRows);

        // (1 state + 3 districts + 2 schools) = 6
        assertThat(reportRepository.findByQuery(queryBuilder
                .includeState(true)
                .includeAllDistricts(true)
                .districtIds(of(-7L))
                .includeAllSchoolsOfDistricts(false)
                .schoolIds(of(-9L, -8L)).build()).size()).isEqualTo(6);

        // (1 state + [2 districts with 3 schools]=5 + 1 schools outside of the districts = 7
        assertThat(reportRepository.findByQuery(queryBuilder
                .includeState(true)
                .includeAllDistricts(false)
                .districtIds(of(-9L, -8L))
                .includeAllSchoolsOfDistricts(true)
                .schoolIds(of(-9L, -7L)).build()).size()).isEqualTo(7);

        // 3 districts + 4 schools = 7
        assertThat(reportRepository.findByQuery(queryBuilder
                .includeState(false)
                .includeAllDistricts(true)
                .includeAllSchoolsOfDistricts(true)
                .schoolIds(of(-9L, -7L)).build()).size()).isEqualTo(7);

        // 2 schools + 1 district + 1 school + 1 district = 5
        assertThat(reportRepository.findByQuery(queryBuilder
                .includeState(false)
                .includeAllDistricts(false)
                .includeAllSchoolsOfDistricts(true)
                .includeAllDistrictsOfSchools(true)
                .districtIds(of(-9L, -99L))
                .schoolIds(of(-7L, -77L)).build()).size()).isEqualTo(5);

        //check that includeAllSchoolsOfDistricts without given districts is ignored
        assertThat(reportRepository.findByQuery(queryBuilder
                .includeState(false)
                .includeAllDistricts(false)
                .includeAllSchoolsOfDistricts(true)
                .includeAllDistrictsOfSchools(true)
                .districtIds(of())
                .schoolIds(of(-7L)).build()).size()).isEqualTo(2);

        //check that includeAllDistrictsOfSchools without given schools is ignored
        assertThat(reportRepository.findByQuery(queryBuilder
                .includeState(true)
                .includeAllDistricts(false)
                .includeAllSchoolsOfDistricts(true)
                .includeAllDistrictsOfSchools(true)
                .districtIds(of())
                .schoolIds(of()).build()).size()).isEqualTo(1);

        //check that ids or non-existent school or district do not break the SQL
        assertThat(reportRepository.findByQuery(queryBuilder
                .includeState(true)
                .includeAllDistricts(false)
                .includeAllSchoolsOfDistricts(true)
                .includeAllDistrictsOfSchools(true)
                .districtIds(of(-77L))
                .schoolIds(of(-77L)).build()).size()).isEqualTo(1);
    }

    @Test
    public void itShouldFindByQueryWithMultipleValuesOfDiffParams() {
        final Integer asmtCount = template.queryForObject("SELECT count(*) AS count FROM asmt_active_year ay LEFT JOIN asmt a ON a.id = ay.asmt_id" +
                "  WHERE a.grade_id IN (-4,-3) AND a.subject_id IN (1,2) AND a.type_id = 1 AND ay.school_year IN (1999, 2000)", Integer.class);

        final List<ReportRow> reportRows = reportRepository.findByQuery(queryBuilder
                .assessmentTypeCode(ICA.code())
                .includeState(true)
                .assessmentGradeCodes(of("-4", "-3"))
                .subjectCodes(of(MATH.code(), ELA.code()))
                .schoolYears(of(1999, 2000))
                .dimensionTypes(of(Ethnicity, Gender, Overall))
                .build());

        assertThat(reportRows.size()).isEqualTo(asmtCount * (ethnicityCount + genderCount + 1));

        final List<ReportRow> rowsWithNonZeroValues = reportRows.stream().filter(r -> (r.getMeasures().getAvgScaleScore() != null)).collect(Collectors.toList());
        assertThat(rowsWithNonZeroValues.size()).isEqualTo(11);
        assertThat(rowsWithNonZeroValues.stream().map(ReportRow::getOrganization).distinct().collect(toSet()))
                .usingFieldByFieldElementComparator()
                .containsOnly(Organization.builder().name(stateName).organizationType(State).build());

        // This verifies that the data is grouped by asmt_id to support a use case when there are two assessments for
        // the same subject/grade/type and exam school year.
        assertThat(rowsWithNonZeroValues.stream().map(ReportRow::getAssessment).distinct().collect(toSet()))
                .usingFieldByFieldElementComparator().containsExactlyInAnyOrder(
                ActiveAssessment.builder().id(-8).gradeCode("-4").subjectCode("Math").label("asmt-8").examSchoolYear(1999).build(),
                ActiveAssessment.builder().id(-9).gradeCode("-3").subjectCode("ELA").examSchoolYear(2000).label("asmt-9").build(),
                ActiveAssessment.builder().id(-9).gradeCode("-3").subjectCode("ELA").examSchoolYear(1999).label("asmt-9").build());

        assertThat(rowsWithNonZeroValues.stream().map(ReportRow::getAssessment).filter(a -> (a.getExamSchoolYear() == 1999)).count()).isEqualTo(8);
        assertThat(rowsWithNonZeroValues.stream().map(ReportRow::getAssessment).filter(a -> (a.getExamSchoolYear() == 2000)).count()).isEqualTo(3);
        assertThat(rowsWithNonZeroValues.stream().map(ReportRow::getAssessment).filter(a -> (a.getSubjectCode().equals("Math"))).count()).isEqualTo(5);
        assertThat(rowsWithNonZeroValues.stream().map(ReportRow::getAssessment).filter(a -> (a.getSubjectCode().equals("ELA"))).count()).isEqualTo(6);
    }

    @Test
    @Sql(scripts = {"classpath:OlapEntitiesSetup.sql"},
            statements = {"INSERT INTO  fact_student_exam (id, school_year, asmt_id, completeness_id," +
                    "                                    administration_condition_id, performance_level," +
                    "                                    scale_score, scale_score_std_err, grade_id, student_id, school_id," +
                    "                                    iep, lep, section504, economic_disadvantage, migrant_status," +
                    "                                    claim1_scale_score, claim1_scale_score_std_err,claim1_category," +
                    "                                    claim2_scale_score, claim2_scale_score_std_err,claim2_category," +
                    "                                    claim3_scale_score, claim3_scale_score_std_err,claim3_category," +
                    "                                    claim4_scale_score, claim4_scale_score_std_err,claim4_category," +
                    "                                    completed_at, updated, update_import_id, migrate_id) VALUES " +
                    "(-34, 2000 , -10, -9, -99, 1, 2500, 17, -4, -9, -9, true, true, false, false, true,  2000, 0.11, 1, 2100, 0.12, 2, 2500, 0.13, 3, 3500, .15, 4, '2016-08-14 19:05:33.000000', '2016-09-14 19:05:33.000000', -1, -1)",
                    "INSERT INTO asmt_active_year (asmt_id, school_year) VALUES (-10, 2000)"})
    public void itShouldGroupByAssessmentId() {

        //if two different ICAs are administered at the same school year, we should group the data by the asmt id

        final List<ReportRow> reportRows = reportRepository.findByQuery(queryBuilder
                .assessmentGradeCodes(of("-3"))
                .subjectCodes(of(ELA.code()))
                .schoolYears(of(2000))
                .dimensionTypes(of(Overall))
                .build());
        assertThat(reportRows.stream().map(ReportRow::getAssessment).distinct().collect(toSet()))
                .usingFieldByFieldElementComparator().containsExactlyInAnyOrder(
                ActiveAssessment.builder().id(-10).gradeCode("-3").subjectCode("ELA").label("asmt-9-again").examSchoolYear(2000).build(),
                ActiveAssessment.builder().id(-9).gradeCode("-3").subjectCode("ELA").label("asmt-9").examSchoolYear(2000).build());
    }

    private int countStudents(final Measures measures) {
        return measures.getLevel1Count() + measures.getLevel2Count() + measures.getLevel3Count() + measures.getLevel4Count();
    }
}