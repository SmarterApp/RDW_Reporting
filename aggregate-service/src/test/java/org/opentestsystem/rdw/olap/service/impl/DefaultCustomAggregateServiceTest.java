package org.opentestsystem.rdw.olap.service.impl;

import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.opentestsystem.rdw.olap.repository.CustomAggregateReportRepository;
import org.opentestsystem.rdw.olap.service.AuthorizationService;
import org.opentestsystem.rdw.olap.service.CustomAggregateService;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.ReportQuery;
import org.opentestsystem.rdw.reporting.common.model.ReportRow;
import org.opentestsystem.rdw.reporting.common.web.security.User;

import java.util.List;

import static com.google.common.collect.ImmutableSet.of;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.common.model.Subject.MATH;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Ethnicity;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Overall;

public class DefaultCustomAggregateServiceTest {
    private CustomAggregateReportRepository repository;
    private CustomAggregateService service;
    private AuthorizationService authorizationService;
    private ReportQuery query;
    private User user;

    @Before
    public void setUp() {
        repository = mock(CustomAggregateReportRepository.class);
        authorizationService = mock(AuthorizationService.class);
        service = new DefaultCustomAggregateService(repository, authorizationService);

        query = ReportQuery.builder()
                .assessmentGradeCodes(of("-8"))
                .includeState(true)
                .schoolYears(of(1999))
                .subjectCodes(of(MATH.code()))
                .dimensionType(Overall)
                .build();

        user = User.builder()
                .id("id")
                .username("username")
                .password("password")
                .build();
    }

    @Test(expected = NullPointerException.class)
    public void itShouldRequireNotNullQuery() {
        service.findByQuery(user, null);
    }

    @Test
    public void findByQueryShouldCheckAuthorization() {
        service.findByQuery(user, query);
        verify(authorizationService, times(1))
                .checkAuthorization(user, query);
    }

    @Test
    public void estimateReportRowCountShouldCheckAuthorization() {
        service.estimateReportRowCount(user, query);
        verify(authorizationService, times(1))
                .checkAuthorization(user, query);
    }

    @Test
    public void itShouldUseRepositoryToFindByQuery() {
        final List<ReportRow> rows = mock(List.class);
        when(repository.findByQuery(user, query)).thenReturn(rows);

        assertThat(service.findByQuery(user, query)).isEqualTo(rows);
    }

    @Test
    public void itShouldAddOverallWhenQueryDoesNotHaveIt() {
        final ArgumentCaptor<ReportQuery> queryArgumentCaptor = ArgumentCaptor.forClass(ReportQuery.class);
        final ArgumentCaptor<User> userArgumentCaptor = ArgumentCaptor.forClass(User.class);
        service.findByQuery(user, ReportQuery.builder()
                .copy(query)
                .dimensionTypes(of(Ethnicity))
                .build());

        verify(repository).findByQuery(userArgumentCaptor.capture(), queryArgumentCaptor.capture());

        final ReportQuery query = queryArgumentCaptor.getValue();
        assertThat(query.getDimensionTypes()).contains(DimensionType.Overall);
        assertThat(userArgumentCaptor.getValue()).isEqualTo(user);
    }

    @Test(expected = NullPointerException.class)
    public void itShouldRequireNotNullQueryToEstimateRowCount() {
        service.estimateReportRowCount(user, null);
    }

    @Test
    public void itShouldUseRepositoryToEstimateRowCount() {
        when(repository.estimateReportRowCount(query)).thenReturn(99);
        assertThat(service.estimateReportRowCount(user, query)).isEqualTo(99);
    }

    @Test
    public void itShouldAddOverallWhenQueryDoesNotHaveItToEstimateRowCount() {
        final ArgumentCaptor<ReportQuery> argumentCaptor = ArgumentCaptor.forClass(ReportQuery.class);
        service.estimateReportRowCount(user, ReportQuery.builder()
                .copy(query)
                .dimensionTypes(of(Ethnicity))
                .build());

        verify(repository).estimateReportRowCount(argumentCaptor.capture());

        final ReportQuery query = argumentCaptor.getValue();
        assertThat(query.getDimensionTypes()).contains(DimensionType.Overall);
    }
}