package org.opentestsystem.rdw.olap.service.impl;

import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.opentestsystem.rdw.olap.model.ReportRow;
import org.opentestsystem.rdw.olap.repository.CustomAggregateReportRepository;
import org.opentestsystem.rdw.olap.service.CustomAggregateService;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.ReportQuery;

import java.util.List;

import static com.google.common.collect.ImmutableSet.of;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Ethnicity;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Overall;

public class DefaultCustomAggregateServiceTest {
    private CustomAggregateReportRepository repository;
    private CustomAggregateService service;
    private ReportQuery query;

    @Before
    public void setUp() {
        repository = mock(CustomAggregateReportRepository.class);
        service = new DefaultCustomAggregateService(repository);

        query = ReportQuery.builder()
                .asmtGrades(of(-8))
                .includeState(true)
                .schoolYears(of(1999))
                .subjectIds(of(1))
                .dimensionType(Overall)
                .build();
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireNotNullQuery() {
        service.findByQuery(null);
    }

    @Test
    public void itShouldUseRepositoryToFindByQuery() {
        final List<ReportRow> rows = mock(List.class);
        when(repository.findByQuery(query)).thenReturn(rows);

        assertThat(service.findByQuery(query)).isEqualTo(rows);
    }

    @Test
    public void itShouldAddOverallWhenQueryDoesNotHaveIt() {
        final ArgumentCaptor<ReportQuery> argumentCaptor = ArgumentCaptor.forClass(ReportQuery.class);
        service.findByQuery(ReportQuery.builder()
                .copy(query)
                .dimensionTypes(of(Ethnicity))
                .build());

        verify(repository).findByQuery(argumentCaptor.capture());

        final ReportQuery query = argumentCaptor.getValue();
        assertThat(query.getDimensionTypes()).contains(DimensionType.Overall);
    }


    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireNotNullQueryToEstimateRowCount() {
        service.estimateReportRowCount(null);
    }

    @Test
    public void itShouldUseRepositoryToEstimateRowCount() {
        when(repository.estimateReportRowCount(query)).thenReturn(99);
        assertThat(service.estimateReportRowCount(query)).isEqualTo(99);
    }

    @Test
    public void itShouldAddOverallWhenQueryDoesNotHaveItToEstimateRowCount() {
        final ArgumentCaptor<ReportQuery> argumentCaptor = ArgumentCaptor.forClass(ReportQuery.class);
        service.estimateReportRowCount(ReportQuery.builder()
                .copy(query)
                .dimensionTypes(of(Ethnicity))
                .build());

        verify(repository).estimateReportRowCount(argumentCaptor.capture());

        final ReportQuery query = argumentCaptor.getValue();
        assertThat(query.getDimensionTypes()).contains(DimensionType.Overall);
    }
}