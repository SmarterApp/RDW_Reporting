package org.opentestsystem.rdw.olap.service.impl;

import com.google.common.collect.ImmutableSet;
import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.opentestsystem.rdw.olap.AggregateReportSettings;
import org.opentestsystem.rdw.olap.model.OrganizationTypeQuery;
import org.opentestsystem.rdw.olap.repository.CustomAggregateReportRepository;
import org.opentestsystem.rdw.olap.service.AuthorizationService;
import org.opentestsystem.rdw.olap.service.CustomAggregateService;
import org.opentestsystem.rdw.olap.sqlbuilder.QueryProviderRepositoryHelper;
import org.opentestsystem.rdw.reporting.common.model.ActiveAssessment;
import org.opentestsystem.rdw.reporting.common.model.AggregateReport;
import org.opentestsystem.rdw.reporting.common.model.Dimension;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.Measures;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.model.ReportQuery;
import org.opentestsystem.rdw.reporting.common.model.ReportRow;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.springframework.core.task.TaskExecutor;

import static com.google.common.collect.ImmutableSet.of;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.common.model.AssessmentType.IAB;
import static org.opentestsystem.rdw.common.model.AssessmentType.ICA;
import static org.opentestsystem.rdw.common.model.AssessmentType.SUMMATIVE;
import static org.opentestsystem.rdw.common.model.Subject.MATH;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Overall;

public class DefaultCustomAggregateServiceTest {
    private CustomAggregateReportRepository repository;
    private CustomAggregateService service;
    private AuthorizationService authorizationService;
    private ReportQuery.Builder reportQueryBuilder;
    private QueryProviderRepositoryHelper repositoryHelper;
    private TaskExecutor threadPoolTaskExecutor;
    private QueryPoolExecutor queryPoolExecutor;
    private User user;

    @Before
    public void setUp() {

        repository = mock(CustomAggregateReportRepository.class);
        authorizationService = mock(AuthorizationService.class);
        final AggregateReportSettings aggregateReportSettings = mock(AggregateReportSettings.class);
        repositoryHelper = mock(QueryProviderRepositoryHelper.class);

        queryPoolExecutor = new QueryPoolExecutor();
        queryPoolExecutor.setPartitionSize(2);

        threadPoolTaskExecutor = queryPoolExecutor.threadPoolTaskExecutor();
        when(aggregateReportSettings.getStateAggregateAssessmentTypes()).thenReturn(ImmutableSet.of(SUMMATIVE.code()));

        service = new DefaultCustomAggregateService(repository, authorizationService, aggregateReportSettings, repositoryHelper, threadPoolTaskExecutor);

        reportQueryBuilder = ReportQuery.builder()
                .assessmentGradeCodes(of("-8"))
                .schoolIds(ImmutableSet.of(123L))
                .schoolYears(of(1999))
                .schoolIds(of(123L))
                .subjectCodes(of(MATH.code()))
                .assessmentTypeCode(IAB.code());

        user = User.builder()
                .id("id")
                .username("username")
                .password("password")
                .build();
    }

    @Test(expected = NullPointerException.class)
    public void itShouldRequireNotNullQuery() {
        service.findByQuery(user, null);
    }

    @Test
    public void itShouldCallAuthorizationServiceToFindByQuery() {
        final ReportQuery query = reportQueryBuilder.build();
        final AggregateReport report = AggregateReport.builder().row(reportRow().build()).build();
        when(repository.findByOrganizationType(any(User.class), any(OrganizationTypeQuery.class), any(OrganizationType.class))).thenReturn(report);

        assertThat(service.findByQuery(user, query)).isEqualToComparingFieldByFieldRecursively(report);
        verify(authorizationService).checkAuthorization(user, query);
    }

    @Test
    public void itShouldCallAuthorizationServiceToEstimateReportRowCount() {
        final ReportQuery query = reportQueryBuilder.build();
        when(repository.estimateReportRowCountByOrganizationType(any(OrganizationTypeQuery.class), any(OrganizationType.class))).thenReturn(10);

        assertThat(service.estimateReportRowCount(user, query)).isEqualTo(10);
        verify(authorizationService).checkAuthorization(user, query);
    }

    @Test
    public void itShouldAddOverallDimensionIfNoDimensionIsGiven() {
        final ArgumentCaptor<OrganizationTypeQuery> queryArgumentCaptor = ArgumentCaptor.forClass(OrganizationTypeQuery.class);

        when(repository.findByOrganizationType(any(User.class), any(OrganizationTypeQuery.class), any(OrganizationType.class))).thenReturn(mock(AggregateReport.class));
        service.findByQuery(user, reportQueryBuilder.build());

        verify(repository).findByOrganizationType(eq(user), queryArgumentCaptor.capture(), eq(OrganizationType.School));
        assertThat(queryArgumentCaptor.getValue().getDimensionType()).isEqualTo(DimensionType.Overall);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireConfiguredAssessmentWhenIncludeStateResults() {
        service.estimateReportRowCount(user, reportQueryBuilder.includeState(true).assessmentTypeCode(ICA.code()).build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireNotEmptyQuery() {
        service.findByQuery(user, ReportQuery.builder().build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireSubjectId() {
        service.estimateReportRowCount(user, reportQueryBuilder.subjectCodes(null).build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireAsmtGrades() {
        service.findByQuery(user, reportQueryBuilder.assessmentGradeCodes(null).build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireSchoolYears() {
        service.estimateReportRowCount(user, reportQueryBuilder.schoolYears(null).build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireOrganization() {
        service.estimateReportRowCount(user, reportQueryBuilder.includeState(false).schoolIds(ImmutableSet.of()).build());
    }


    private ReportRow.Builder reportRow() {
        final ActiveAssessment assessment = ActiveAssessment.builder()
                .id(1)
                .subjectCode("Math")
                .gradeCode("3")
                .examSchoolYear(1999)
                .label("Assessment")
                .build();

        final Measures measures = Measures.builder()
                .avgScaleScore(2500)
                .avgStdErr(12)
                .level1Count(1)
                .level2Count(2)
                .level3Count(3)
                .level4Count(4)
                .build();

        final Organization organization = Organization.builder()
                .organizationType(OrganizationType.School)
                .name("schoolName")
                .id(1L)
                .naturalId("schoolId")
                .build();

        return ReportRow.builder()
                .dimension(Dimension.builder().type(Overall).build())
                .assessment(assessment)
                .measures(measures)
                .organization(organization);
    }
}