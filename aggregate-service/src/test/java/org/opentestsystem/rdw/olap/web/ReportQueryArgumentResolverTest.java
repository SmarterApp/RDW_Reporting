package org.opentestsystem.rdw.olap.web;

import com.google.common.collect.ImmutableMap;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.ReportQuery;
import org.springframework.core.MethodParameter;
import org.springframework.web.bind.support.WebDataBinderFactory;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.method.support.ModelAndViewContainer;

import java.util.HashMap;
import java.util.Map;

import static com.google.common.collect.ImmutableSet.of;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class ReportQueryArgumentResolverTest {

    @Mock
    private MethodParameter methodParameter;

    @Mock
    private ModelAndViewContainer mavContainer;

    @Mock
    private NativeWebRequest webRequest;

    @Mock
    private WebDataBinderFactory binderFactory;

    private Map<String, String> parameters;
    private ReportQueryArgumentResolver resolver;

    @Before
    public void setup() {
        when(methodParameter.getParameterType())
                .thenAnswer(invocation -> ReportQuery.class);

        parameters = new HashMap<>();
        when(webRequest.getParameter(anyString()))
                .thenAnswer(invocation -> parameters
                        .get(invocation.getArgumentAt(0, String.class)));

        resolver = new ReportQueryArgumentResolver();
    }

    @Test
    public void itShouldResolveReportQueryParameters() {
        assertThat(resolver.supportsParameter(methodParameter)).isTrue();

        when(methodParameter.getParameterType())
                .thenAnswer(invocation -> Object.class);
        assertThat(resolver.supportsParameter(methodParameter)).isFalse();
    }

    @Test
    public void itShouldParseReportQueryResource() throws Exception {
        parameters.put("subjectIds", "1,2");
        parameters.put("schoolYears", "2017,2018");
        parameters.put("asmtGrades", "3,4");
        parameters.put("schoolIds", "7,8");
        parameters.put("districts", "5F,6T");
        parameters.put("dimensionTypes", "gender,ethnicity");
        parameters.put("state", "TT");
        parameters.put("assessmentType", "ICA");

        final ReportQuery resource = (ReportQuery) resolver.resolveArgument(methodParameter, mavContainer, webRequest, binderFactory);

        assertThat(resource).isEqualToComparingFieldByFieldRecursively(ReportQuery.builder()
                .subjectIds(of(1, 2))
                .schoolYears(of(2017, 2018))
                .asmtGrades(of(3, 4))
                .districts(ImmutableMap.of(5, false, 6, true))
                .schoolIds(of(7, 8))
                .dimensionTypes(of(DimensionType.Gender, DimensionType.Ethnicity))
                .includeAllDistricts(true)
                .includeState(true)
                .assessmentType(AssessmentType.ICA)
                .build());
    }

    @Test
    public void itShouldParseReportQueryResourceWithOptionalFields() throws Exception {
        parameters.put("subjectIds", "1");
        parameters.put("schoolYears", "2017");
        parameters.put("asmtGrades", "4");
        parameters.put("assessmentType", "SUMMATIVE");

        final ReportQuery resource = (ReportQuery) resolver.resolveArgument(methodParameter, mavContainer, webRequest, binderFactory);
        assertThat(resource).isEqualToComparingFieldByField(ReportQuery.builder()
                .subjectIds(of(1))
                .schoolYears(of(2017))
                .asmtGrades(of(4))
                .assessmentType(AssessmentType.SUMMATIVE)
                .build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireSubject() throws Exception {
        parameters.put("schoolYears", "2017");
        parameters.put("asmtGrades", "4");
        parameters.put("assessmentType", "ICA");
        resolver.resolveArgument(methodParameter, mavContainer, webRequest, binderFactory);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireSchoolYear() throws Exception {
        parameters.put("subjectIds", "1");
        parameters.put("asmtGrades", "4");
        parameters.put("assessmentType", "ICA");
        resolver.resolveArgument(methodParameter, mavContainer, webRequest, binderFactory);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireAsmtGrade() throws Exception {
        parameters.put("subjectIds", "1");
        parameters.put("schoolYears", "2017");
        parameters.put("assessmentType", "ICA");
        resolver.resolveArgument(methodParameter, mavContainer, webRequest, binderFactory);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireAssessmentType() throws Exception {
        parameters.put("subjectIds", "1");
        parameters.put("schoolYears", "2017");
        parameters.put("asmtGrades", "4");
        resolver.resolveArgument(methodParameter, mavContainer, webRequest, binderFactory);
    }

    @Test
    public void itShouldIgnoreUnsupportedDimension() throws Exception {
        parameters.put("subjectIds", "1");
        parameters.put("schoolYears", "2017");
        parameters.put("asmtGrades", "4");
        parameters.put("assessmentType", "ICA");
        parameters.put("dimensionTypes", "something");

        final ReportQuery resource = (ReportQuery) resolver.resolveArgument(methodParameter, mavContainer, webRequest, binderFactory);
        assertThat(resource.getDimensionTypes()).isEmpty();
    }
}