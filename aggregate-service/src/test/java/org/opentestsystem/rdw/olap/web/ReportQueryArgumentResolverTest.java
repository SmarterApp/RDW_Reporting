package org.opentestsystem.rdw.olap.web;

import com.google.common.collect.ImmutableMap;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.ReportQuery;
import org.springframework.core.MethodParameter;
import org.springframework.web.bind.support.WebDataBinderFactory;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.method.support.ModelAndViewContainer;

import java.util.HashMap;
import java.util.Map;

import static com.google.common.collect.ImmutableSet.of;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class ReportQueryArgumentResolverTest {

    @Mock
    private MethodParameter methodParameter;

    @Mock
    private ModelAndViewContainer mavContainer;

    @Mock
    private NativeWebRequest webRequest;

    @Mock
    private WebDataBinderFactory binderFactory;

    private Map<String, String> parameters;
    private ReportQueryArgumentResolver resolver;

    @Before
    public void setup() {
        when(methodParameter.getParameterType())
                .thenAnswer(invocation -> ReportQuery.class);

        parameters = new HashMap<>();
        when(webRequest.getParameter(anyString()))
                .thenAnswer(invocation -> parameters
                        .get(invocation.getArgumentAt(0, String.class)));

        resolver = new ReportQueryArgumentResolver();
    }

    @Test
    public void itShouldResolveReportQueryParameters() {
        assertThat(resolver.supportsParameter(methodParameter)).isTrue();

        when(methodParameter.getParameterType())
                .thenAnswer(invocation -> Object.class);
        assertThat(resolver.supportsParameter(methodParameter)).isFalse();
    }

    @Test
    public void itShouldParseReportQueryResource() throws Exception {
        parameters.put("subjectIds", "1,2");
        parameters.put("schoolYears", "2017,2018");
        parameters.put("asmtGradeIds", "3,4");
        parameters.put("schoolIds", "7,8");
        parameters.put("districts", "5F,6T");
        parameters.put("dimensionTypes", "gender,ethnicity");
        parameters.put("state", "TT");
        parameters.put("assessmentType", "ICA");

        final ReportQuery resource = (ReportQuery) resolver.resolveArgument(methodParameter, mavContainer, webRequest, binderFactory);

        assertThat(resource).isEqualToComparingFieldByFieldRecursively(ReportQuery.builder()
                .subjectIds(of(1, 2))
                .schoolYears(of(2017, 2018))
                .asmtGradeIds(of(3, 4))
                .districts(ImmutableMap.of(5L, false, 6L, true))
                .schoolIds(of(7L, 8L))
                .dimensionTypes(of(DimensionType.Gender, DimensionType.Ethnicity))
                .includeAllDistricts(true)
                .includeState(true)
                .assessmentType(AssessmentType.ICA)
                .build());
    }

    @Test
    public void itShouldParseReportQueryResourceWithOptionalFields() throws Exception {
        parameters.put("subjectIds", "1");
        parameters.put("schoolYears", "2017");
        parameters.put("asmtGradeIds", "4");
        parameters.put("assessmentType", "SUMMATIVE");
        parameters.put("genderIds", "-9,-8");
        parameters.put("completenessIds", "-19,-18");
        parameters.put("administrativeConditionIds", "-29,-28");
        parameters.put("lepIds", "-2,-3");
        parameters.put("ethnicityIds", "-39,-38");
        parameters.put("migrantStatusIds", "-49,-48");
        parameters.put("section504Ids", "-59,-58");
        parameters.put("iepIds", "-69,-68");
        parameters.put("economicDisadvantageIds", "-79,-78");

        final ReportQuery resource = (ReportQuery) resolver.resolveArgument(methodParameter, mavContainer, webRequest, binderFactory);
        assertThat(resource).isEqualToComparingFieldByField(ReportQuery.builder()
                .subjectIds(of(1))
                .schoolYears(of(2017))
                .asmtGradeIds(of(4))
                .assessmentType(AssessmentType.SUMMATIVE)
                .genderIds(of(-9, -8))
                .completenessIds(of(-19, -18))
                .administrativeConditionIds(of(-29, -28))
                .lepIds(of(-2, -3))
                .ethnicityIds(of(-39, -38))
                .migrantStatusIds(of(-49, -48))
                .section504Ids(of(-59, -58))
                .iepIds(of(-69, -68))
                .economicDisadvantageIds(of(-79, -78))
                .build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireSubject() throws Exception {
        parameters.put("schoolYears", "2017");
        parameters.put("asmtGradeIds", "4");
        parameters.put("assessmentType", "ICA");
        resolver.resolveArgument(methodParameter, mavContainer, webRequest, binderFactory);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireSchoolYear() throws Exception {
        parameters.put("subjectIds", "1");
        parameters.put("asmtGradeIds", "4");
        parameters.put("assessmentType", "ICA");
        resolver.resolveArgument(methodParameter, mavContainer, webRequest, binderFactory);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireAsmtGrade() throws Exception {
        parameters.put("subjectIds", "1");
        parameters.put("schoolYears", "2017");
        parameters.put("assessmentType", "ICA");
        resolver.resolveArgument(methodParameter, mavContainer, webRequest, binderFactory);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireAssessmentType() throws Exception {
        parameters.put("subjectIds", "1");
        parameters.put("schoolYears", "2017");
        parameters.put("asmtGradeIds", "4");
        resolver.resolveArgument(methodParameter, mavContainer, webRequest, binderFactory);
    }

    @Test
    public void itShouldIgnoreUnsupportedDimension() throws Exception {
        parameters.put("subjectIds", "1");
        parameters.put("schoolYears", "2017");
        parameters.put("asmtGradeIds", "4");
        parameters.put("assessmentType", "ICA");
        parameters.put("dimensionTypes", "something");

        final ReportQuery resource = (ReportQuery) resolver.resolveArgument(methodParameter, mavContainer, webRequest, binderFactory);
        assertThat(resource.getDimensionTypes()).isEmpty();
    }
}