package org.opentestsystem.rdw.olap.repository.impl;


import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.rdw.olap.model.ClaimOrganizationQuery;
import org.opentestsystem.rdw.olap.model.ClaimReportResult;
import org.opentestsystem.rdw.olap.repository.ClaimReportRepository;
import org.opentestsystem.rdw.reporting.common.model.ActiveAssessment;
import org.opentestsystem.rdw.reporting.common.model.AggregateRow;
import org.opentestsystem.rdw.reporting.common.model.ClaimRow;
import org.opentestsystem.rdw.reporting.common.model.Dimension;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.Measures;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.opentestsystem.rdw.security.Permission;
import org.opentestsystem.rdw.security.PermissionScope;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.jdbc.Sql;

import java.util.List;
import java.util.Objects;
import java.util.UUID;
import java.util.stream.Collectors;

import static com.google.common.collect.ImmutableSet.of;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toSet;
import static org.assertj.core.api.Assertions.assertThat;
import static org.opentestsystem.rdw.common.model.AssessmentType.ICA;
import static org.opentestsystem.rdw.common.model.AssessmentType.SUMMATIVE;
import static org.opentestsystem.rdw.common.model.Subject.ELA;
import static org.opentestsystem.rdw.common.model.Subject.MATH;
import static org.opentestsystem.rdw.olap.TestUtils.verifyBooleanDimensionStudentCodeCount;
import static org.opentestsystem.rdw.olap.TestUtils.verifyStateStudentCount;
import static org.opentestsystem.rdw.olap.model.AggregateServicePermission.AggregateRead;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.ELAS;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.EconomicDisadvantage;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Ethnicity;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Gender;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.IEP;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.LEP;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.MigrantStatus;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Overall;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Section504;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.StudentEnrolledGrade;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.District;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.School;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.State;
import static org.opentestsystem.rdw.reporting.common.test.support.PermissionScopes.permissions;
import static org.springframework.test.jdbc.JdbcTestUtils.countRowsInTable;

@SuppressWarnings({"SqlNoDataSourceInspection", "SqlResolve"})
@Sql(scripts = {"classpath:ClaimEntitiesSetup.sql"})
@ActiveProfiles("redshift")
public class JdbcClaimReportRepositoryRST extends RepositoryBackedIT {

    @Autowired
    private ClaimReportRepository repository;

    @Autowired
    private JdbcTemplate template;

    @Value("${reporting.state.name}")
    private String stateName;

    private static final int mathClaimsCount = 3;
    private static final int elaClaimsCount = 4;

    private ClaimOrganizationQuery.Builder queryBuilder;
    private int ethnicityCount;
    private int genderCount;
    private int districtsCount;

    // this test is for a user without embargo permissions
    private static final User user = User.builder()
            .id(UUID.randomUUID().toString())
            .username("someone-10@somewhere.com")
            .password("redacted")
            //only invalid district and school ids; repository should ignore them
            .permissionsById(permissions(new Permission(AggregateRead, PermissionScope.builder()
                    .statewide(false)
                    .addDistrictIds(of(-100L))
                    .addSchoolIds(of(-100L))
                    .build())))
            .build();

    @Before
    public void setUp() {
        ethnicityCount = countRowsInTable(template, "ethnicity");
        genderCount = countRowsInTable(template, "gender");
        districtsCount = countRowsInTable(template, "district");

        //note that no claims in the query means all claims for the given assessment type and subject to be returned
        queryBuilder = ClaimOrganizationQuery.builder()
                .assessmentGradeCodes(of("-4"))
                .organizationType(State)
                .schoolYears(of(1999))
                .claimCodesBySubject(ImmutableMap.of(MATH.code(), ImmutableSet.of("SOCK_2", "1", "3")))
                .assessmentTypeCode(ICA.code())
                .dimensionType(Overall);
    }

    @Test
    public void itShouldRunQueryAndBackFillData() {
        final ClaimReportResult reportResult = repository.findByOrganizationType(user, queryBuilder.claimCodesBySubject(ImmutableMap.of(MATH.code(), ImmutableSet.of("test", "test2"))).build(), State);
        assertThat(reportResult.isCreatedWhileDataEmbargoed()).isFalse();
        assertThat(reportResult.isHasResults()).isFalse();
        assertThat(reportResult.getResultCount()).isEqualTo(2);

        assertThat(reportResult.getPayload().size()).isEqualTo(2);
        assertThat(reportResult.getPayload().stream().map(ClaimRow::getClaimCode).collect(toList())).containsExactlyInAnyOrder("test", "test2");
    }

    @Test
    public void itShouldReturnSubgroupKeyAsCustomDimensionForBackFilledAndDataRows() {
        final List<ClaimRow> reportRows = repository.findByOrganizationType(user,
                queryBuilder
                        .subgroupKey("testSubgroupKey")
                        .dimensionType(Overall).build(), District).getPayload();

        assertThat(reportRows.size()).isEqualTo(districtsCount * mathClaimsCount);
        assertThat(reportRows.stream()
                .filter(r -> r.getDimension().getCode().equals("testSubgroupKey") && r.getDimension().getType() == DimensionType.Custom)
                .count()).isEqualTo(districtsCount * mathClaimsCount);
        //check that we have a back filled row
        assertThat(reportRows.stream().filter(r -> r.getMeasures().getStudentCount() == 0).count()).isEqualTo(mathClaimsCount);
    }

    @Test
    public void itShouldReturnStateData() {
        final ClaimReportResult reportResult = repository.findByOrganizationType(user, queryBuilder.build(), State);
        assertThat(reportResult.isCreatedWhileDataEmbargoed()).isFalse();
        assertThat(reportResult.isHasResults()).isTrue();
        assertThat(reportResult.getResultCount()).isEqualTo(3);

        final ClaimRow.Builder claimRowBuilder = ClaimRow.builder()
                .assessment(ActiveAssessment.builder().id(-8).gradeCode("-4").subjectCode("Math").label("asmt-8").examSchoolYear(1999).build())
                .organization(Organization.builder().name(stateName).organizationType(State).build())
                .dimension(Dimension.builder().type(Overall).build());

        assertThat(reportResult.getPayload())
                .usingRecursiveFieldByFieldElementComparator()
                .containsExactlyInAnyOrder(claimRowBuilder
                                .claimCode("SOCK_2")
                                .measures(Measures.builder().level1Count(2).level2Count(2).level3Count(1).build())
                                .build(),
                        claimRowBuilder
                                .claimCode("1")
                                .measures(Measures.builder().level1Count(3).level2Count(1).level3Count(1).build())
                                .build(),
                        claimRowBuilder
                                .claimCode("3")
                                .measures(Measures.builder().level1Count(2).level2Count(1).level3Count(2).build())
                                .build());
    }

    @Test
    public void itShouldReturnAllDistrictsInState() {
        final ClaimReportResult report = repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .build(), District);

        assertThat(report.isCreatedWhileDataEmbargoed()).isFalse();
        assertThat(report.getPayload().size()).isEqualTo(districtsCount * mathClaimsCount);
    }

    @Test
    public void itShouldReturnDistricts() {
        final ClaimReportResult report = repository.findByOrganizationType(user, queryBuilder
                .organizationType(District)
                .organizationIds(of(-17L, -18L, -19L, -99L))
                .build(), District);

        assertThat(report.isCreatedWhileDataEmbargoed()).isFalse();
        assertThat(report.getPayload().size()).isEqualTo(districtsCount * mathClaimsCount);
    }

    @Test
    public void itShouldReturnAllSchoolsInDistrict() {
        final ClaimReportResult report = repository.findByOrganizationType(user, queryBuilder
                .organizationType(District)
                .organizationIds(of(-19L, -99L))
                .build(), School);

        assertThat(report.isCreatedWhileDataEmbargoed()).isFalse();
        assertThat(report.getPayload().size()).isEqualTo(2 * mathClaimsCount);
    }

    @Test
    public void itShouldReturnSchools() {
        final ClaimReportResult report = repository.findByOrganizationType(user, queryBuilder
                .organizationType(School)
                .organizationIds(of(-9L, -10L, -99L))
                .build(), School);

        assertThat(report.isCreatedWhileDataEmbargoed()).isFalse();
        assertThat(report.getPayload().size()).isEqualTo(2 * mathClaimsCount);
    }

    @Test
    public void itShouldFindByQueryWithIEPDimension() {
        final ClaimReportResult report = repository.findByOrganizationType(user, queryBuilder
                .organizationType(School)
                .organizationIds(of(-9L))
                .dimensionType(IEP)
                .build(), School);

        assertThat(report.isCreatedWhileDataEmbargoed()).isFalse();
        List<ClaimRow> rows = report.getPayload();
        assertThat(rows.size()).isEqualTo(2 * mathClaimsCount);
        for (final ClaimRow row : rows) {
            if (row.getDimension().getCode().equalsIgnoreCase("no")) assertThat(row.getMeasures().getStudentCount()).isEqualTo(1);
            else assertThat(row.getMeasures().getStudentCount()).isEqualTo(0);
        }

        rows = repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(IEP)
                .organizationIds(null)
                .build(), District).getPayload();
        assertThat(rows.size()).isEqualTo((districtsCount) * 2 * mathClaimsCount);

        rows = repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(IEP)
                .build(), State).getPayload();
        verifyStateStudentCount(rows, 5 * mathClaimsCount);
    }

    @Test
    public void itShouldFindByQueryWithIEPDimensionAndGenderFilters() {
        final List<ClaimRow> rows = repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(IEP)
                .genderCodes(of("gender-18"))
                .build(), State).getPayload();

        verifyStateStudentCount(rows, 2 * mathClaimsCount);
    }

    @Test
    public void itShouldFindByQueryWithIEPDimensionAndFilter() {
        final List<ClaimRow> rows = repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(IEP)
                .iepCodes(of("yes"))
                .build(), State).getPayload();

        verifyStateStudentCount(rows, 3 * mathClaimsCount);
    }

    @Test
    public void itShouldFindByQueryWithLEPDimension() {
        List<ClaimRow> rows = repository.findByOrganizationType(user, queryBuilder
                .organizationType(School)
                .organizationIds(of(-9L))
                .dimensionType(LEP)
                .build(), School).getPayload();

        assertThat(rows.size()).isEqualTo(2 * mathClaimsCount);
        for (final ClaimRow row : rows) {
            if (row.getDimension().getCode().equalsIgnoreCase("no")) assertThat(row.getMeasures().getStudentCount()).isEqualTo(0);
            else assertThat(row.getMeasures().getStudentCount()).isEqualTo(1);
        }

        rows = repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .organizationIds(null)
                .dimensionType(LEP)
                .build(), District).getPayload();
        assertThat(rows.size()).isEqualTo((districtsCount) * 2 * mathClaimsCount);
    }

    @Test
    public void itShouldFindByQueryWithLEPDimensionAndEthnicityFilter() {
        final List<ClaimRow> rows = repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(LEP)
                .ethnicityCodes(of("ethnicity-28", "ethnicity-29"))
                .build(), State).getPayload();

        assertThat(rows.stream()
                .filter(r -> (r.getDimension().getCode().equals("yes")))
                .mapToInt(r -> (r.getMeasures().getStudentCount()))
                .sum()).isEqualTo(3 * mathClaimsCount);
    }

    @Test
    public void itShouldFindByQueryWithLEPDimensionAndFilter() {
        assertThat(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(LEP)
                .lepCodes(of("no"))
                .build(), District).getPayload().size()).isEqualTo((districtsCount * mathClaimsCount));

        verifyStateStudentCount(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(LEP)
                .lepCodes(of("no"))
                .build(), State).getPayload(), 0);

        verifyStateStudentCount(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(LEP)
                .lepCodes(of("no", "yes"))
                .build(), State).getPayload(), 5 * mathClaimsCount);
    }

    @Test
    public void itShouldFindByQueryWithELASDimensionAndFilter() {
        assertThat(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(ELAS)
                .elasCodes(of("EL"))
                .build(), District).getPayload().size()).isEqualTo(districtsCount * mathClaimsCount);

        verifyStateStudentCount(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(ELAS)
                .elasCodes(of("RFEP"))
                .build(), State).getPayload(), 0);

        verifyStateStudentCount(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(ELAS)
                .elasCodes(of("EL", "RFEP"))
                .build(), State).getPayload(), 5 * mathClaimsCount);
    }

    @Test
    public void itShouldFindByQueryWithEconomicDisadvantageDimension() {
        assertThat(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(EconomicDisadvantage)
                .build(), District).getPayload().size()).isEqualTo((districtsCount) * 2 * mathClaimsCount);

        final List<ClaimRow> rows = repository.findByOrganizationType(user, queryBuilder
                .organizationType(School)
                .organizationIds(of(-9L))
                .dimensionType(EconomicDisadvantage)
                .build(), School).getPayload();

        assertThat(rows.size()).isEqualTo(2 * mathClaimsCount);
        for (final ClaimRow row : rows) {
            if (row.getDimension().getCode().equalsIgnoreCase("no")) assertThat(row.getMeasures().getStudentCount()).isEqualTo(1);
            else assertThat(row.getMeasures().getStudentCount()).isEqualTo(0);
        }
    }

    @Test
    public void itShouldFindByQueryWithEconomicDisadvantageDimensionAndFilter() {
        assertThat(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(EconomicDisadvantage)
                .economicDisadvantageCodes(of("yes"))
                .build(), District).getPayload().size()).isEqualTo(districtsCount * mathClaimsCount);
    }

    @Test
    public void itShouldFindByQueryWithEconomicDisadvantageDimensionAndGenderFilter() {
        final List<ClaimRow> rows = repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(EconomicDisadvantage)
                .genderCodes(of("gender-18"))
                .build(), State).getPayload();

        verifyStateStudentCount(rows, 2 * mathClaimsCount);
    }

    @Test
    public void itShouldFindByQueryWithSection504Dimension() {
        assertThat(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(Section504)
                .build(), District).getPayload().size()).isEqualTo((districtsCount) * 3 * mathClaimsCount);

        final List<ClaimRow> rows = repository.findByOrganizationType(user, queryBuilder
                .organizationType(School)
                .organizationIds(of(-9L))
                .dimensionType(Section504)
                .build(), School).getPayload();

        assertThat(rows.size()).isEqualTo(3 * mathClaimsCount);
        verifyBooleanDimensionStudentCodeCount(rows, 0, 0, 1);
    }

    @Test
    public void itShouldFindByQueryWithSection504DimensionAndFilter() {
        assertThat(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(Section504)
                .section504Codes(of("undefined", "yes"))
                .build(), District).getPayload().size()).isEqualTo((districtsCount) * 2 * mathClaimsCount);
    }

    @Test
    public void itShouldFindByQueryWithSection504DimensionAndEconomicDisadvantageFilter() {
        assertThat(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(Section504)
                .economicDisadvantageCodes(of("no"))
                .build(), District).getPayload().size()).isEqualTo((districtsCount) * 3 * mathClaimsCount);

        final List<ClaimRow> rows = repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(Section504)
                .economicDisadvantageCodes(of("no"))
                .build(), State).getPayload();

        assertThat(rows.size()).isEqualTo(3 * mathClaimsCount);
        verifyBooleanDimensionStudentCodeCount(rows, 0, 4, 1);
    }

    @Test
    public void itShouldFindByQueryWithMigrantStatusDimension() {
        assertThat(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(MigrantStatus)
                .build(), District).getPayload().size()).isEqualTo((districtsCount) * 3 * mathClaimsCount);

        List<ClaimRow> rows = repository.findByOrganizationType(user, queryBuilder
                .organizationType(School)
                .dimensionType(MigrantStatus)
                .organizationIds(of(-9L))
                .administrativeConditionCodes(of("IN"))
                .completenessCodes(of("Complete"))
                .build(), School).getPayload();

        assertThat(rows.size()).isEqualTo(3 * mathClaimsCount);
        verifyBooleanDimensionStudentCodeCount(rows, 1, 0, 0);

        rows = repository.findByOrganizationType(user, queryBuilder.genderCodes(of("gender-18")).build(), School).getPayload();
        verifyBooleanDimensionStudentCodeCount(rows, 0, 0, 0);
    }

    @Test
    public void itShouldFindByQueryWithMigrantStatusDimensionAndFilter() {
        assertThat(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(MigrantStatus)
                .migrantStatusCodes(of("yes"))
                .build(), District).getPayload().size()).isEqualTo(districtsCount * mathClaimsCount);

        verifyStateStudentCount(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(MigrantStatus)
                .migrantStatusCodes(of("yes"))
                .build(), State).getPayload(), 5 * mathClaimsCount);
    }

    @Test
    public void itShouldFindByQueryWithMigrantStatusDimensionAndLEPFilter() {
        assertThat(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(MigrantStatus)
                .lepCodes(of("no"))
                .build(), District).getPayload().size()).isEqualTo(districtsCount * 3 * mathClaimsCount);

        verifyStateStudentCount(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(MigrantStatus)
                .lepCodes(of("no"))
                .build(), State).getPayload(), 0);
    }

    @Test
    public void itShouldFindByQueryWithMigrantStatusDimensionAnELASFilter() {
        assertThat(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(MigrantStatus)
                .elasCodes(of("EL"))
                .build(), District).getPayload().size()).isEqualTo(districtsCount * 3 * mathClaimsCount);
    }

    @Test
    public void itShouldFindByQueryWithGenderDimension() {
        assertThat(repository.findByOrganizationType(user, queryBuilder
                .organizationType(School)
                .organizationIds(of(-9L))
                .dimensionType(Gender)
                .build(), School).getPayload().size()).isEqualTo(countRowsInTable(template, "gender") * mathClaimsCount);
    }

    @Test
    public void itShouldFindByQueryWithGenderDimensionAndFilter() {
        final List<ClaimRow> rows = repository.findByOrganizationType(user, queryBuilder
                .organizationType(School)
                .organizationIds(of(-8L))
                .dimensionType(Gender)
                .genderCodes(of("gender-19"))
                .build(), School).getPayload();

        assertThat(rows.size()).isEqualTo(mathClaimsCount);
        assertThat(rows.stream().filter(r -> (r.getDimension().getCode().equals("gender-19"))).mapToInt(r -> (r.getMeasures().getStudentCount())).sum()).isEqualTo(mathClaimsCount);
    }

    @Test
    public void itShouldFindByQueryWithGenderDimensionAndMigrantStatusFilter() {
        assertThat(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(Gender)
                .migrantStatusCodes(of("no"))
                .build(), District).getPayload().size()).isEqualTo((districtsCount) * genderCount * mathClaimsCount);

        List<ClaimRow> rows = repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(Gender)
                .migrantStatusCodes(of("no"))
                .build(), State).getPayload();

        assertThat(rows.stream().filter(r -> (r.getDimension().getCode().equals("gender-18"))).mapToInt(r -> (r.getMeasures().getStudentCount())).sum()).isEqualTo(0);
        assertThat(rows.stream().filter(r -> (r.getDimension().getCode().equals("gender-19"))).mapToInt(r -> (r.getMeasures().getStudentCount())).sum()).isEqualTo(0);

        rows = repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(Gender)
                .migrantStatusCodes(of("yes"))
                .build(), State).getPayload();

        assertThat(rows.stream().filter(r -> (r.getDimension().getCode().equals("gender-18"))).mapToInt(r -> (r.getMeasures().getStudentCount())).sum()).isEqualTo(2 * mathClaimsCount);
        assertThat(rows.stream().filter(r -> (r.getDimension().getCode().equals("gender-19"))).mapToInt(r -> (r.getMeasures().getStudentCount())).sum()).isEqualTo(3 * mathClaimsCount);
    }

    @Test
    public void itShouldFindByQueryWithEthnicityDimension() {
        final List<ClaimRow> reportRows = repository.findByOrganizationType(user, queryBuilder
                .organizationType(District)
                .organizationIds(of(-19L))
                .dimensionType(Ethnicity)
                .build(), District).getPayload();

        assertThat(reportRows.size()).isEqualTo(ethnicityCount * mathClaimsCount);
        assertThat(reportRows.stream().filter(r -> (r.getMeasures().getStudentCount() > 0)).collect(toList()).size()).isEqualTo(mathClaimsCount);

        assertThat(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .organizationIds(null)
                .dimensionType(Ethnicity)
                .build(), District).getPayload().size()).isEqualTo((districtsCount) * ethnicityCount * mathClaimsCount);
    }

    @Test
    public void itShouldFindByQueryWithEthnicityDimensionAndFilter() {
        assertThat(repository.findByOrganizationType(user, queryBuilder
                .organizationType(District)
                .organizationIds(of(-19L))
                .dimensionType(Ethnicity)
                .ethnicityCodes(of("ethnicity-28"))
                .build(), District).getPayload().size()).isEqualTo(mathClaimsCount);
    }

    @Test
    public void itShouldFindByQueryWithEthnicityDimensionAndIepFilter() {
        assertThat(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(Ethnicity)
                .iepCodes(of("no"))
                .build(), District).getPayload().size()).isEqualTo((districtsCount) * ethnicityCount * mathClaimsCount);

        assertThat(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(Ethnicity)
                .iepCodes(of("no"))
                .build(), District).getPayload().stream()
                .filter(r -> (r.getDimension().getCode().equals("ethnicity-29")))
                .mapToInt(r -> (r.getMeasures().getStudentCount()))
                .sum()).isEqualTo(mathClaimsCount);

        assertThat(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(Ethnicity)
                .iepCodes(of("yes"))
                .build(), State).getPayload().stream()
                .filter(r -> (r.getDimension().getCode().equals("ethnicity-29")))
                .mapToInt(r -> (r.getMeasures().getStudentCount()))
                .sum()).isEqualTo(2 * mathClaimsCount);
    }

    @Test
    public void itShouldFindByQueryWithEthnicityDimensionAndSection504Filter() {
        assertThat(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(Ethnicity)
                .section504Codes(of("undefined"))
                .build(), District).getPayload().size()).isEqualTo((districtsCount) * ethnicityCount * mathClaimsCount);

        assertThat(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(Ethnicity)
                .claimCodesBySubject(ImmutableMap.of(MATH.code(), ImmutableSet.of("1")))
                .section504Codes(of("undefined"))
                .build(), State).getPayload().stream()
                .filter(r -> (r.getDimension().getCode().equals("ethnicity-29")))
                .mapToInt(r -> (r.getMeasures().getStudentCount()))
                .sum()).isEqualTo(1);

        assertThat(repository.findByOrganizationType(user, queryBuilder
                .organizationType(State)
                .dimensionType(Ethnicity)
                .section504Codes(of("no"))
                .claimCodesBySubject(ImmutableMap.of(MATH.code(), ImmutableSet.of("1")))
                .build(), State).getPayload().stream()
                .filter(r -> (r.getDimension().getCode().equals("ethnicity-29")))
                .mapToInt(r -> (r.getMeasures().getStudentCount()))
                .sum()).isEqualTo(2);
    }

    @Test
    public void itShouldFindByQueryWithEnrolledGradeDimension() {
        final List<ClaimRow> rows = repository.findByOrganizationType(user, queryBuilder
                .organizationType(School)
                .organizationIds(of(-8L))
                .dimensionType(StudentEnrolledGrade)
                .build(), School).getPayload();

        assertThat(rows.size()).isEqualTo(2 * mathClaimsCount);
        for (final ClaimRow row : rows) {
            if (row.getDimension().getCode().equals("-5")) assertThat(row.getMeasures().getStudentCount()).isEqualTo(1);
            else assertThat(row.getMeasures().getStudentCount()).isEqualTo(2);
        }
    }

    @Test
    public void itShouldFindByQueryWithEnrolledGradeDimensionAndDifferentFilters() {
        List<ClaimRow> rows = repository.findByOrganizationType(user, queryBuilder
                .organizationType(School)
                .organizationIds(of(-8L))
                .dimensionType(StudentEnrolledGrade)
                .genderCodes(of("gender-18"))
                .claimCodesBySubject(ImmutableMap.of(MATH.code(), ImmutableSet.of("1")))
                .build(), School).getPayload();

        assertThat(rows.size()).isEqualTo(1);
        assertThat(rows.get(0).getDimension().getCode()).isEqualTo("-4");
        assertThat(rows.get(0).getMeasures().getStudentCount()).isEqualTo(2);

        rows = repository.findByOrganizationType(user, queryBuilder.completenessCodes(of("Complete")).build(), School).getPayload();
        assertThat(rows.size()).isEqualTo(1);
        assertThat(rows.get(0).getDimension().getCode()).isEqualTo("-4");
        assertThat(rows.get(0).getMeasures().getStudentCount()).isEqualTo(1);

        rows = repository.findByOrganizationType(user, queryBuilder.administrativeConditionCodes(of("IN")).build(), School).getPayload();
        assertThat(rows.size()).isEqualTo(0);

        rows = repository.findByOrganizationType(user, queryBuilder.genderCodes(of("gender-19")).build(), School).getPayload();
        assertThat(rows.size()).isEqualTo(1);
        assertThat(rows.get(0).getDimension().getCode()).isEqualTo("-5");
        assertThat(rows.get(0).getMeasures().getStudentCount()).isEqualTo(1);

        rows = repository.findByOrganizationType(user, queryBuilder.administrativeConditionCodes(of("SD")).build(), School).getPayload();
        assertThat(rows.size()).isEqualTo(0);
    }

    @Test
    public void itShouldBackFillMissingDataForAllDimensionsButStudentEnrolledGrade() {
        final Integer asmtCount = template.queryForObject("SELECT count(*) AS count FROM asmt_active_year ay LEFT JOIN asmt a ON a.id = ay.asmt_id" +
                "  WHERE a.grade_id IN (-5) AND a.subject_id IN (2) AND a.type_id = 1 AND ay.school_year IN (1888)", Integer.class);
        queryBuilder
                .assessmentTypeCode(ICA.code())
                .organizationType(State)
                .schoolYears(of(1888))
                .claimCodesBySubject(ImmutableMap.of(ELA.code(), ImmutableSet.of("SOCK_R", "SOCK_LS", "2-W", "4-CR")))
                .assessmentGradeCodes(of("-5"))
                .dimensionType(Overall)
                // the below two filters do not change the back-filling rules
                .administrativeConditionCodes(of("IN"))
                .completenessCodes(of("Complete"));

        //we do not back-fill the data for the StudentEnrolledGrade
        assertThat(repository.findByOrganizationType(user, queryBuilder.dimensionType(StudentEnrolledGrade).build(), District).getPayload().size()).isEqualTo(0);

        final List<ClaimRow> reportRows = repository.findByOrganizationType(user, queryBuilder.dimensionType(Overall).build(), District).getPayload();
        assertThat(reportRows.size()).isEqualTo(asmtCount * districtsCount * elaClaimsCount);

        //make sure assessment label and subject codes are populated in back-filled data
        assertThat(reportRows.stream().map(r -> r.getAssessment().getLabel()).filter(Objects::nonNull).collect(toList()).size()).isEqualTo(asmtCount * districtsCount * elaClaimsCount);
        assertThat(reportRows.stream().map(r -> r.getAssessment().getSubjectCode()).filter(Objects::nonNull).collect(toList()).size()).isEqualTo(asmtCount * districtsCount * elaClaimsCount);

        assertThat(repository.findByOrganizationType(user, queryBuilder.dimensionType(Gender).genderCodes(of("gender-18")).build(), District).getPayload().size())
                .isEqualTo(asmtCount * districtsCount * elaClaimsCount);

        assertThat(repository.findByOrganizationType(user, queryBuilder.dimensionType(Gender).genderCodes(null).build(), District).getPayload().size())
                .isEqualTo(asmtCount * districtsCount * genderCount * elaClaimsCount);

        assertThat(repository.findByOrganizationType(user, queryBuilder.dimensionType(Ethnicity).build(), District).getPayload().size())
                .isEqualTo(asmtCount * districtsCount * ethnicityCount * elaClaimsCount);

        assertThat(repository.findByOrganizationType(user, queryBuilder.dimensionType(Ethnicity).ethnicityCodes(of("ethnicity-28")).build(), District).getPayload().size())
                .isEqualTo(asmtCount * districtsCount * elaClaimsCount);

        assertThat(repository.findByOrganizationType(user, queryBuilder.dimensionType(MigrantStatus).ethnicityCodes(null).build(), District).getPayload().size())
                .isEqualTo(asmtCount * districtsCount * 3 * elaClaimsCount);

        assertThat(repository.findByOrganizationType(user, queryBuilder.dimensionType(Section504).build(), District).getPayload().size())
                .isEqualTo(asmtCount * districtsCount * 3 * elaClaimsCount);

        assertThat(repository.findByOrganizationType(user, queryBuilder.dimensionType(LEP).build(), District).getPayload().size())
                .isEqualTo(asmtCount * districtsCount * 2 * elaClaimsCount);

        assertThat(repository.findByOrganizationType(user, queryBuilder.dimensionType(IEP).build(), District).getPayload().size())
                .isEqualTo(asmtCount * districtsCount * 2 * elaClaimsCount);

        assertThat(repository.findByOrganizationType(user, queryBuilder.dimensionType(EconomicDisadvantage).build(), District).getPayload().size())
                .isEqualTo(asmtCount * districtsCount * 2 * elaClaimsCount);
    }

    @Test
    public void itShouldEstimateReportRowCount() {
        final Integer asmtCount = template.queryForObject("SELECT count(*) AS count FROM asmt_active_year ay JOIN asmt a ON a.id = ay.asmt_id" +
                "  WHERE a.grade_id IN (-5, -3) AND a.subject_id IN (1) AND a.type_id = 1 AND ay.school_year IN (1888, 1999)", Integer.class);
        queryBuilder
                .assessmentTypeCode(ICA.code())
                .organizationType(State)
                .schoolYears(of(1888, 1999))
                .assessmentGradeCodes(of("-5", "-3"))
                // the below two filters do not change the counting rules
                .administrativeConditionCodes(of("IN"))
                .completenessCodes(of("Complete"));

        assertThat(repository.estimateReportRowCountByOrganizationType(queryBuilder.dimensionType(Overall).build(), District)).isEqualTo(asmtCount * districtsCount * mathClaimsCount);
        //for the StudentEnrolledGrade we always assume that there is one entry found
        assertThat(repository.estimateReportRowCountByOrganizationType(queryBuilder.dimensionType(StudentEnrolledGrade).build(), District)).isEqualTo(asmtCount * districtsCount * mathClaimsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(queryBuilder.dimensionType(Gender).build(), District)).isEqualTo(asmtCount * districtsCount * genderCount * mathClaimsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(queryBuilder.dimensionType(Ethnicity).build(), District)).isEqualTo(asmtCount * districtsCount * ethnicityCount * mathClaimsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(queryBuilder.dimensionType(MigrantStatus).build(), District)).isEqualTo(asmtCount * districtsCount * 3 * mathClaimsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(queryBuilder.dimensionType(Section504).build(), District)).isEqualTo(asmtCount * districtsCount * 3 * mathClaimsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(queryBuilder.dimensionType(LEP).build(), District)).isEqualTo(asmtCount * districtsCount * 2 * mathClaimsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(queryBuilder.dimensionType(IEP).build(), District)).isEqualTo(asmtCount * districtsCount * 2 * mathClaimsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(queryBuilder.dimensionType(EconomicDisadvantage).build(), District)).isEqualTo(asmtCount * districtsCount * 2 * mathClaimsCount);

        //test with filters
        assertThat(repository.estimateReportRowCountByOrganizationType(queryBuilder.dimensionType(Gender).genderCodes(of("gender-19")).build(), District)).isEqualTo(asmtCount * districtsCount * mathClaimsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(queryBuilder.dimensionType(Ethnicity).genderCodes(of("gender-19")).ethnicityCodes(of("ethnicity-28")).build(), District)).isEqualTo(asmtCount * districtsCount * mathClaimsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(queryBuilder.dimensionType(MigrantStatus).genderCodes(null).ethnicityCodes(null).migrantStatusCodes(of("yes")).build(), District)).isEqualTo(asmtCount * districtsCount * mathClaimsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(queryBuilder.dimensionType(Section504).genderCodes(null).ethnicityCodes(null).section504Codes(of("undefined")).build(), District)).isEqualTo(asmtCount * districtsCount * mathClaimsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(queryBuilder.dimensionType(LEP).section504Codes(null).lepCodes(of("yes")).build(), District)).isEqualTo(asmtCount * districtsCount * mathClaimsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(queryBuilder.dimensionType(IEP).lepCodes(null).iepCodes(of("yes")).build(), District)).isEqualTo(asmtCount * districtsCount * mathClaimsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(queryBuilder.dimensionType(EconomicDisadvantage).iepCodes(null).economicDisadvantageCodes(of("yes")).build(), District)).isEqualTo(asmtCount * districtsCount * mathClaimsCount);

        assertThat(repository.estimateReportRowCountByOrganizationType(queryBuilder.dimensionType(Overall).organizationType(State).build(), State)).isEqualTo(asmtCount * mathClaimsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(queryBuilder.dimensionType(Overall).organizationType(District).organizationIds(of(-19L, -17L, -99L)).build(), District)).isEqualTo(asmtCount * 2 * mathClaimsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(queryBuilder.dimensionType(Overall).organizationType(School).organizationIds(of(-9L, -10L, -99L)).build(), School)).isEqualTo(asmtCount * 2 * mathClaimsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(queryBuilder.dimensionType(Overall).organizationType(State).organizationIds(null).build(), District)).isEqualTo(asmtCount * districtsCount * mathClaimsCount);
        assertThat(repository.estimateReportRowCountByOrganizationType(queryBuilder.dimensionType(Overall).organizationType(District).organizationIds(of(-19L)).build(), School)).isEqualTo(asmtCount * 2 * mathClaimsCount);
    }

    @Test
    public void itShouldFindByQueryWithMultipleValuesOfDiffParams() {
        final Integer elaAsmtCount = template.queryForObject("SELECT count(*) AS count FROM asmt_active_year ay LEFT JOIN asmt a ON a.id = ay.asmt_id" +
                "  WHERE a.grade_id IN (-4,-3) AND a.subject_id = 2  AND a.type_id = 1 AND ay.school_year IN (1999, 2000)", Integer.class);

        final List<ClaimRow> reportRows = repository.findByOrganizationType(user, queryBuilder
                .assessmentTypeCode(ICA.code())
                .organizationType(State)
                .assessmentGradeCodes(of("-4", "-3"))
                .claimCodesBySubject(ImmutableMap.of(ELA.code(), ImmutableSet.of("SOCK_R", "SOCK_LS", "2-W", "4-CR")))
                .schoolYears(of(1999, 2000))
                .dimensionType(Overall)
                .build(), State).getPayload();

        assertThat(reportRows.size()).isEqualTo(elaAsmtCount * elaClaimsCount);

        final List<ClaimRow> rowsWithNonZeroValues = reportRows.stream().filter(r -> (r.getMeasures().getStudentCount() > 0)).collect(Collectors.toList());

        assertThat(rowsWithNonZeroValues.stream().map(AggregateRow::getOrganization).distinct().collect(toSet()))
                .usingFieldByFieldElementComparator()
                .containsOnly(Organization.builder().name(stateName).organizationType(State).build());

        // This verifies that the data is grouped by asmt_id to support a use case when there are two assessments for
        // the same subject/grade/type and exam school year.
        assertThat(rowsWithNonZeroValues.stream().map(AggregateRow::getAssessment).distinct().collect(toSet()))
                .usingFieldByFieldElementComparator().containsExactlyInAnyOrder(
                ActiveAssessment.builder().id(-9).gradeCode("-3").subjectCode("ELA").examSchoolYear(2000).label("asmt-9").build(),
                ActiveAssessment.builder().id(-9).gradeCode("-3").subjectCode("ELA").examSchoolYear(1999).label("asmt-9").build());

        assertThat(rowsWithNonZeroValues.stream().map(AggregateRow::getAssessment).filter(a -> (a.getExamSchoolYear() == 1999)).count()).isEqualTo(elaClaimsCount);
        assertThat(rowsWithNonZeroValues.stream().map(AggregateRow::getAssessment).filter(a -> (a.getExamSchoolYear() == 2000)).count()).isEqualTo(elaClaimsCount);
        assertThat(rowsWithNonZeroValues.stream().map(AggregateRow::getAssessment).filter(a -> (a.getSubjectCode().equals("ELA"))).count()).isEqualTo(2 * elaClaimsCount);
    }

    @Test
    @Sql(scripts = {"classpath:ClaimEntitiesSetup.sql"},
            statements = {"INSERT INTO  fact_exam_claim_score (id, subject_claim_score_id, exam_id, school_year, asmt_id, elas_id, completeness_id," +
                    "                                    administration_condition_id, category," +
                    "                                     grade_id, student_id, school_id," +
                    "                                    iep, lep, section504, economic_disadvantage, migrant_status," +
                    "                                    completed_at, updated, update_import_id, migrate_id) VALUES " +
                    "(-500, 4, -34, 2000 , -10, -11, -9, -99, 1, -4, -9, -9, true, true, false, false, true, '2016-08-14 19:05:33.000000', '2016-09-14 19:05:33.000000', -1, -1)",
                    "INSERT INTO asmt (id, grade_id, subject_id, type_id, school_year, name, label, cut_point_1, cut_point_2, cut_point_3, min_score, max_score, updated, update_import_id, migrate_id) VALUES" +
                            " (-1, -3, 2, 1, 2000, 'asmt-1','asmt-1',2300, 2500, 2700, 2000, 2800, '2016-08-14 19:05:33.000000', -1, -1)",
                    "INSERT INTO asmt_active_year (asmt_id, school_year) VALUES (-10, 2000), (-1,  2000)"})
    public void itShouldGroupByAssessmentId() {

        //if two different ICAs are administered at the same school year, we should group the data by the asmt id
        // note that we are not back-filling by asmt id since it is not an IAB
        final List<ClaimRow> reportRows = repository.findByOrganizationType(user, queryBuilder
                .assessmentGradeCodes(of("-3"))
                .claimCodesBySubject(ImmutableMap.of(ELA.code(), ImmutableSet.of("SOCK_R", "SOCK_LS", "2-W", "4-CR")))
                .schoolYears(of(2000))
                .dimensionType(Overall)
                .build(), State).getPayload();
        assertThat(reportRows.stream().map(AggregateRow::getAssessment).distinct().collect(toSet()))
                .usingFieldByFieldElementComparator().containsExactlyInAnyOrder(
                ActiveAssessment.builder().id(-10).gradeCode("-3").subjectCode("ELA").label("asmt-9-again").examSchoolYear(2000).build(),
                ActiveAssessment.builder().id(-9).gradeCode("-3").subjectCode("ELA").label("asmt-9").examSchoolYear(2000).build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireNotEmptyQuery() {
        repository.findByOrganizationType(user, ClaimOrganizationQuery.builder().build(), OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireOrganizationIdsForSchoolOrganizationType() {
        repository.findByOrganizationType(user, ClaimOrganizationQuery
                .builder()
                .assessmentTypeCode(SUMMATIVE.code())
                .dimensionType(DimensionType.Overall)
                .organizationType(School)
                .schoolYears(of(2000))
                .claimCodesBySubject(ImmutableMap.of(MATH.code(), ImmutableSet.of("SOCK_2")))
                .assessmentGradeCodes(of("grade"))
                .build(), OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireOrganizationIdsForDistrictOrganizationType() {
        repository.findByOrganizationType(user, ClaimOrganizationQuery
                        .builder()
                        .assessmentTypeCode(SUMMATIVE.code())
                        .dimensionType(DimensionType.Overall)
                        .organizationType(District)
                        .schoolYears(of(2000))
                        .claimCodesBySubject(ImmutableMap.of(MATH.code(), ImmutableSet.of("SOCK_2")))
                        .assessmentGradeCodes(of("grade"))
                        .build()
                , OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireSubject() {
        repository.findByOrganizationType(user, ClaimOrganizationQuery
                        .builder()
                        .assessmentTypeCode(SUMMATIVE.code())
                        .dimensionType(DimensionType.Overall)
                        .organizationType(State)
                        .schoolYears(of(2000))
                        .assessmentGradeCodes(of("grade"))
                        .build()
                , OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireAssessmentType() {
        repository.findByOrganizationType(user, ClaimOrganizationQuery
                        .builder()
                        .dimensionType(DimensionType.Overall)
                        .claimCodesBySubject(ImmutableMap.of(MATH.code(), ImmutableSet.of("SOCK_2")))
                        .organizationType(State)
                        .schoolYears(of(2000))
                        .assessmentGradeCodes(of("grade"))
                        .build()
                , OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireDimension() {
        repository.findByOrganizationType(user, ClaimOrganizationQuery
                        .builder()
                        .assessmentTypeCode(SUMMATIVE.code())
                        .claimCodesBySubject(ImmutableMap.of(MATH.code(), ImmutableSet.of("SOCK_2")))
                        .organizationType(State)
                        .schoolYears(of(2000))
                        .assessmentGradeCodes(of("grade"))
                        .build()
                , OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireOrganization() {
        repository.findByOrganizationType(user, ClaimOrganizationQuery
                        .builder()
                        .assessmentTypeCode(SUMMATIVE.code())
                        .dimensionType(DimensionType.Overall)
                        .claimCodesBySubject(ImmutableMap.of(MATH.code(), ImmutableSet.of("SOCK_2")))
                        .schoolYears(of(2000))
                        .assessmentGradeCodes(of("grade"))
                        .build()
                , OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireSchoolYear() {
        repository.findByOrganizationType(user, ClaimOrganizationQuery
                        .builder()
                        .assessmentTypeCode(SUMMATIVE.code())
                        .dimensionType(DimensionType.Overall)
                        .claimCodesBySubject(ImmutableMap.of(MATH.code(), ImmutableSet.of("SOCK_2")))
                        .assessmentGradeCodes(of("grade"))
                        .organizationType(State)
                        .build()
                , OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldRequireAsmtGrade() {
        repository.findByOrganizationType(user, ClaimOrganizationQuery
                        .builder()
                        .assessmentTypeCode(SUMMATIVE.code())
                        .dimensionType(DimensionType.Overall)
                        .claimCodesBySubject(ImmutableMap.of(MATH.code(), ImmutableSet.of("SOCK_2")))
                        .schoolYears(of(2000))
                        .organizationType(State)
                        .build()
                , OrganizationType.State);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailForAllSchoolsInState() {
        final ClaimOrganizationQuery query = ClaimOrganizationQuery.builder()
                .assessmentGradeCodes(of("-4"))
                .schoolYears(of(1999))
                .claimCodesBySubject(ImmutableMap.of(MATH.code(), ImmutableSet.of("SOCK_2")))
                .assessmentTypeCode(SUMMATIVE.code())
                .dimensionType(Overall)
                .organizationType(State)
                .build();
        repository.findByOrganizationType(user, query, School);
    }
}