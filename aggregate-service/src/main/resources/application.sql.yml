sql:
  administrationCondition:
    findAll: select id, code from administration_condition

  assessmentGrade:
    findAll: >-
      SELECT DISTINCT
        g.id,
        g.code
      FROM asmt a
        JOIN grade g ON g.id = a.grade_id

  assessmentType:
    findAll: select id, code from asmt_type

  completeness:
    findAll: select id, code from completeness

  gender:
    findAll: select id, code from gender

  schoolYear:
    findAll: select year from school_year

  studentEthnicity:
    findAll: select id, code from ethnicity

  subject:
    findAll: select id, code from subject


  # a tokenized version of the SQL query for the custom aggregate reports
  # the @{template.XXXX} tokens are replaced with the appropriate queries at run time
  customAggregate: >-
      CASE WHEN dim.organization_id = -1 THEN '${app.state.name}' else dim.organization_name END,
      CASE WHEN dim.organization_id = -1 THEN null else dim.organization_id END,
      dim.organization_type,
      dim.grade_id as asmt_grade_id,
      dim.school_year,
      dim.subject_id,
      dim.dimension_code,
      dim.dimension,
      dim.asmt_id,
      measure.score,
      measure.std_err,
      measure.level1,
      measure.level2,
      measure.level3,
      measure.level4
      FROM (@{template.customAggregateAllPermutations}) dim
        LEFT JOIN (@{template.customAggregate}) measure
      ON measure.asmt_grade_id = dim.grade_id
      AND measure.subject_id = dim.subject_id
      AND dim.school_year = measure.school_year
      AND dim.organization_id = measure.organization_id
      AND measure.dimension_id = dim.dimension_id
      AND measure.asmt_id = dim.asmt_id
      AND measure.dimension_id = dim.dimension_id

 # unlike all other dimensions we are not back-filling missing enrolled grades
  customAggregateByEnrolledGrade: >-
     CASE WHEN organization_id = -1 THEN '${app.state.name}' else organization_name END,
     CASE WHEN organization_id = -1 THEN null else organization_id END,
     organization_type,
     asmt_grade_id,
     school_year,
     subject_id,
     dimension_code,
     dimension,
     asmt_id,
     score,
     std_err,
     level1,
     level2,
     level3,
     level4
     FROM (@{template.customAggregate}) a

  # SQL does not support an Aggregate Product, but this seems to be a recommended way
  estimateReportRowCount: >-
   SELECT round(exp(sum(ln(count)))) as count from (
    SELECT sum(org_count)  AS count, 'organizations' AS type
      FROM
      (
        SELECT CASE WHEN :isIncludeState THEN 1 ELSE 0 END AS org_count
        UNION ALL
        SELECT CASE WHEN :isIncludeAllDistricts THEN (SELECT count(*) FROM district) ELSE 0 END AS org_count
        UNION ALL
        SELECT CASE WHEN :isIncludeDistricts THEN (SELECT count(*) FROM district WHERE id IN(:district_ids)) ELSE 0 END AS org_count
        UNION ALL
        SELECT CASE WHEN :isIncludeAllSchoolsInDistricts THEN (SELECT count(*) FROM school WHERE district_id IN (:school_district_ids)) ELSE 0 END AS org_count
        UNION ALL
        SELECT CASE WHEN :isIncludeSchools THEN (SELECT count(*) FROM school WHERE id IN (:school_ids)) ELSE 0 END AS org_count
      )
    
    UNION ALL
    
    SELECT count(*)  AS count, 'assessments' AS type
      FROM asmt_active_year ay LEFT JOIN asmt a ON a.id = ay.asmt_id
      WHERE a.grade_id IN (:asmt_grade_ids) AND a.subject_id IN (:subject_ids) AND a.type_id = :asmt_type_id AND ay.school_year IN (:school_years)
    
    UNION ALL
    
    SELECT sum(dim_count) AS count, 'dimensions' AS type
    FROM
      (
        SELECT CASE WHEN :gender THEN (select count(*) from gender) ELSE 0 END AS dim_count
        UNION ALL
        SELECT CASE WHEN :ethnicity THEN (select count(*) from ethnicity) ELSE 0 END AS dim_count
        UNION ALL
        SELECT CASE WHEN :iep THEN (select count(*) from strict_boolean) ELSE 0 END AS dim_count
        UNION ALL
        SELECT CASE WHEN :lep THEN (select count(*) from strict_boolean) ELSE 0 END AS dim_count
        UNION ALL
        SELECT CASE WHEN :section504 THEN (select count(*) from boolean) ELSE 0 END AS dim_count
        UNION ALL
        SELECT CASE WHEN :economic_disadvantage THEN (select count(*) from strict_boolean) ELSE 0 END AS dim_count
        UNION ALL
        SELECT CASE WHEN :migrant_status THEN (select count(*) from boolean) ELSE 0 END AS dim_count
        UNION ALL
        SELECT CASE WHEN :student_enrolled_grade THEN 1 ELSE 0 END AS dim_count
        UNION ALL
        SELECT CASE WHEN :overall THEN 1 ELSE 0 END AS dim_count
      )
    )