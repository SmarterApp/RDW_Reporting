package org.opentestsystem.rdw.olap.sqlbuilder;

import org.opentestsystem.rdw.olap.model.CustomAggregateOrganizationQuery;
import org.opentestsystem.rdw.olap.sqlbuilder.QueryReportTemplate.Builder;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.security.PermissionSource;
import org.opentestsystem.rdw.reporting.common.sqlbuilder.QueryProvider;

import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import static com.google.common.collect.Lists.newArrayList;
import static java.util.stream.Collectors.toList;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.padIntToSize;

/**
 * This implementation is responsible for converting {@link CustomAggregateOrganizationQuery} for claim report into a {@link QueryReportTemplate}
 */
public class ClaimQueryReportTemplateProvider extends BaseQueryReportTemplateProvider<CustomAggregateOrganizationQuery> {

    private static final String claimAggregateTemplateSql = "claimAggregate";
    //it is used to pad claims to the fixed sized in the SQL 'in' clause
    private final List<String> claimsSqlPadding;

    public ClaimQueryReportTemplateProvider(final Organization state,
                                            final int organizationPartitionSize,
                                            final QueryProvider queryProvider,
                                            final QueryProviderRepositoryHelper repositoryHelper,
                                            final PermissionSource permissionSource,
                                            final int maxSubjectClaims) {
        super(state, organizationPartitionSize, queryProvider, repositoryHelper, permissionSource);
        claimsSqlPadding = padIntToSize(newArrayList(), maxSubjectClaims * repositoryHelper.maxSubjects()).stream().map(Object::toString).collect(toList());

    }

    @Override
    protected String getTemplateSql() {
        return claimAggregateTemplateSql;
    }

    @Override
    public Builder createBuilderWithCommonAttributes(final CustomAggregateOrganizationQuery query) {
        return addFiltersAndDimension(super.createBuilderWithCommonAttributes(query), query)
                //add claims for to be available for estimated count and back-filling functionality
                .claimCodes(getRepositoryHelper().findAllClaimCodes(query.getAssessmentTypeCode(), query.getSubjectCodes()))
                .parameter("school_years", padIntToSize(query.getSchoolYears(), getRepositoryHelper().maxSchoolYears()))
                .parameter("asmt_grade_ids", padIntToSize(getRepositoryHelper().toGradeIds(query.getAssessmentGradeCodes()), getRepositoryHelper().maxAssessmentGrades()))
                .parameter("subject_ids", padIntToSize(getRepositoryHelper().toSubjectIds(query.getSubjectCodes()), getRepositoryHelper().maxSubjects()))
                .parameter("asmt_type_id", getRepositoryHelper().toAssessmentTypeId(query.getAssessmentTypeCode()))
                .parameter("subject_claim_score_codes", padClaims(query.getClaimCodes()))
                .parameter("all_claims", query.getClaimCodes().isEmpty());
    }

    private Collection<String> padClaims(final Collection<String> collection) {
        if (collection != null && collection.size() >= claimsSqlPadding.size()) return collection;

        if (collection == null) return claimsSqlPadding;
        final List<String> padded = newArrayList(claimsSqlPadding);

        final Iterator<String> iterator = collection.iterator();
        for (int i = 0; i < collection.size(); ++i) {
            claimsSqlPadding.set(i, iterator.next());
        }
        return padded;
    }
}