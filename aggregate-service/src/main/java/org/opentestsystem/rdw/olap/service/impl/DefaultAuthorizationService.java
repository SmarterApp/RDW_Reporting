package org.opentestsystem.rdw.olap.service.impl;

import org.opentestsystem.rdw.olap.service.AuthorizationService;
import org.opentestsystem.rdw.olap.service.OrganizationService;
import org.opentestsystem.rdw.olap.service.UserAssessmentTypeService;
import org.opentestsystem.rdw.olap.service.UserOrganizationService;
import org.opentestsystem.rdw.reporting.common.model.District;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.model.ReportQuery;
import org.opentestsystem.rdw.reporting.common.model.School;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.opentestsystem.rdw.security.PermissionScope;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Set;

import static com.google.common.collect.Sets.newLinkedHashSet;
import static org.opentestsystem.rdw.reporting.common.security.ReportingPermission.EmbargoRead;
import static org.opentestsystem.rdw.security.PermissionScope.EMPTY;
import static org.opentestsystem.rdw.security.PermissionScope.getScopeOrEmpty;

@Service
class DefaultAuthorizationService implements AuthorizationService {

    private final UserOrganizationService userOrganizationService;
    private final OrganizationService organizationService;
    private final UserAssessmentTypeService userAssessmentTypeService;

    @Autowired
    DefaultAuthorizationService(
            final UserOrganizationService userOrganizationService,
            final UserAssessmentTypeService userAssessmentTypeService,
            final OrganizationService organizationService) {
        this.userOrganizationService = userOrganizationService;
        this.userAssessmentTypeService = userAssessmentTypeService;
        this.organizationService = organizationService;
    }

    @Override
    public void checkAuthorization(final User user, final ReportQuery query) {
        checkOrganizationPermissions(user, query.getDistrictIds(), query.getSchoolIds());
        checkAssessmentTypePermission(user, query.getAssessmentTypeCode());
    }

    /**
     * Checks to make sure the given user has permission to run aggregate reports on the given districts and schools
     *
     * @param user        the {@link User} creating the report
     * @param districtIds the requested district IDs for the report
     * @param schoolIds   the requested school IDs for the report
     */
    private void checkOrganizationPermissions(final User user, final Set<Long> districtIds, final Set<Long> schoolIds) {

        // reduce user's entitled schools and districts to IDs for security check
        final Set<Long> userDistrictIds = newLinkedHashSet();
        final Set<Long> userSchoolIds = newLinkedHashSet();
        for (final Organization organization : userOrganizationService.getOrganizations(user)) {
            if (organization.getOrganizationType() == OrganizationType.School) {
                userSchoolIds.add(organization.getId());
            } else if (organization.getOrganizationType() == OrganizationType.District) {
                userDistrictIds.add(organization.getId());
            }
        }

        for (final Long districtId : districtIds) {
            if (!userDistrictIds.contains(districtId)) {
                throw new RuntimeException(String.format(
                        "user (%s) does not have access to district (ID: %s)", user.getUsername(), districtId));
            }
        }

        for (final Long schoolId : schoolIds) {
            if (!userSchoolIds.contains(schoolId)) {
                throw new RuntimeException(String.format(
                        "user (%s) does not have access to school (ID: %s)", user.getUsername(), schoolId));
            }
        }
    }

    @Override
    public boolean isMayContainEmbargoedResults(final User user, final ReportQuery query) {
        final PermissionScope embargoScope = getScopeOrEmpty(user.getPermissionsById(), EmbargoRead);
        if (embargoScope.equals(EMPTY)) return false;

        //state trumps all the districts embargo settings
        if (!organizationService.isStateEmbargoEnabled()) return false;

        if (organizationService.isStateEmbargoEnabled() && query.isIncludeState()) return true;

        if (embargoScope.isStatewide() && organizationService.isStateEmbargoEnabled()) return true;

        final Set<Long> querySchoolIds = query.getSchoolIds();
        final Set<Long> queryDistrictIds = query.getDistrictIds();

        for (final Organization organization : userOrganizationService.getOrganizations(user)) {
            if (organization.getOrganizationType() == OrganizationType.School && querySchoolIds.contains(organization.getId())) {
                if (((School) organization).isEmbargoEnabled()) return true;
            }
            if (organization.getOrganizationType() == OrganizationType.District && queryDistrictIds.contains(organization.getId())) {
                if (((District) organization).isEmbargoEnabled()) return true;
            }
        }
        return false;
    }

    /**
     * Checks to make sure that the given user has rights to create reports of the given assessment type id
     *
     * @param user           the {@link User} creating the report
     * @param assessmentType the requested assessment type of the report
     */
    private void checkAssessmentTypePermission(final User user, final String assessmentType) {
        if (userAssessmentTypeService.getAssessmentTypes(user).stream()
                .noneMatch(entity -> entity.getCode().equalsIgnoreCase(assessmentType))) {
            throw new RuntimeException(String.format(
                    "user (%s) is not allowed to create custom aggregate reports for assessment type (%s)",
                    user.getUsername(), assessmentType));
        }
    }

}
