
package org.opentestsystem.rdw.olap.repository.impl;

import org.opentestsystem.rdw.olap.model.AggregateReportQuery;
import org.opentestsystem.rdw.olap.model.AggregateRowReportResult;
import org.opentestsystem.rdw.olap.repository.ActiveAssessmentRepository;
import org.opentestsystem.rdw.olap.repository.CustomAggregateReportRepository;
import org.opentestsystem.rdw.olap.repository.EmbargoRepository;
import org.opentestsystem.rdw.olap.repository.OrganizationRepository;
import org.opentestsystem.rdw.olap.sqlbuilder.AggregateQueryReportTemplateProvider;
import org.opentestsystem.rdw.olap.sqlbuilder.QueryProviderRepositoryHelper;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemSettings;
import org.opentestsystem.rdw.reporting.common.model.ActiveAssessment;
import org.opentestsystem.rdw.reporting.common.model.AggregateRow;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.security.PermissionSource;
import org.opentestsystem.rdw.reporting.common.sqlbuilder.QueryProvider;
import org.springframework.jdbc.core.JdbcTemplate;

import static com.google.common.base.Preconditions.checkArgument;
import static org.springframework.util.CollectionUtils.isEmpty;

/**
 * This class represents common functionality for implementations of {@link CustomAggregateReportRepository}
 */
@SuppressWarnings("unchecked")
public abstract class AbstractCustomAggregateReportRepository<T extends AggregateRow<ActiveAssessment>,
        R extends AggregateRowReportResult<ActiveAssessment, T>,
        B extends AggregateRowReportResult.Builder<ActiveAssessment, T, B, R>>
        extends AbstractReportRepository<ActiveAssessment, T, R, AggregateReportQuery, B> implements CustomAggregateReportRepository<T, R> {

    private final ActiveAssessmentRepository activeAssessmentRepository;

    /**
     * Constructor
     */
    AbstractCustomAggregateReportRepository(final ReportingSystemSettings systemSettings,
                                            final JdbcTemplate jdbcTemplate,
                                            final QueryProviderRepositoryHelper reportQueryRepositoryHelper,
                                            final ActiveAssessmentRepository activeAssessmentRepository,
                                            final OrganizationRepository organizationRepository,
                                            final QueryProvider queryProvider,
                                            final EmbargoRepository embargoRepository,
                                            final int jdbcFetchSize,
                                            final int organizationPartitionSize) {
        super(systemSettings, jdbcTemplate, reportQueryRepositoryHelper, organizationRepository, queryProvider, embargoRepository, jdbcFetchSize, organizationPartitionSize);
        this.activeAssessmentRepository = activeAssessmentRepository;
    }

    @Override
    protected void validate(final AggregateReportQuery query) {
        super.validate(query);
        checkArgument(!isEmpty(query.getSubjectCodes()), "invalid query, missing a subject");
        checkArgument(!isEmpty(query.getAssessmentGradeCodes()), "invalid query, missing an assessment grade");
        checkArgument(!isEmpty(query.getSchoolYears()), "invalid query, missing a school year");
    }

    @Override
    protected AggregateQueryReportTemplateProvider getQueryReportTemplateProvider(
            final Organization state, final int organizationPartitionSize, final QueryProvider queryProvider, final QueryProviderRepositoryHelper reportQueryRepositoryHelper, final PermissionSource permissionSource) {
        return new AggregateQueryReportTemplateProvider(state, organizationPartitionSize, queryProvider, reportQueryRepositoryHelper, permissionSource);
    }

    /*
    /**
     * To simplify a report SQL, we are loading assessments and organizations separately.
     * This assumes/relies on the repositories results to be cached
     */
    protected ActiveAssessment findByIdAndSchoolYear(final String assessmentTypeCode, final int assessmentId, final int schoolYear) {
        for (final ActiveAssessment activeAssessment : activeAssessmentRepository.findAllByTypeCode(assessmentTypeCode)) {
            if (activeAssessment.getId() == assessmentId && activeAssessment.getExamSchoolYear() == schoolYear)
                return activeAssessment;
        }
        throw new IllegalArgumentException("unable to find an assessment by id " + assessmentId + " and school year " + schoolYear);
    }
}