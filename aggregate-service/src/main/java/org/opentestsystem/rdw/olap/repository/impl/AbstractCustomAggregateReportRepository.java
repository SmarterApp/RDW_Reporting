
package org.opentestsystem.rdw.olap.repository.impl;

import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.olap.model.AggregateReportQuery;
import org.opentestsystem.rdw.olap.model.CustomAggregateReportResult;
import org.opentestsystem.rdw.olap.repository.ActiveAssessmentRepository;
import org.opentestsystem.rdw.olap.repository.CustomAggregateReportRepository;
import org.opentestsystem.rdw.olap.repository.EmbargoRepository;
import org.opentestsystem.rdw.olap.repository.OrganizationRepository;
import org.opentestsystem.rdw.olap.sqlbuilder.CustomAggregateQueryWithReportTemplateProvider;
import org.opentestsystem.rdw.olap.sqlbuilder.OrganizationQueryReportTemplateProvider;
import org.opentestsystem.rdw.olap.sqlbuilder.QueryProviderRepositoryHelper;
import org.opentestsystem.rdw.olap.sqlbuilder.QueryWithReportTemplate;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemSettings;
import org.opentestsystem.rdw.reporting.common.model.ActiveAssessment;
import org.opentestsystem.rdw.reporting.common.model.AggregateRow;
import org.opentestsystem.rdw.reporting.common.model.Dimension;
import org.opentestsystem.rdw.reporting.common.model.Measures;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.model.School;
import org.opentestsystem.rdw.reporting.common.security.PermissionSource;
import org.opentestsystem.rdw.reporting.common.sqlbuilder.QueryProvider;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import javax.validation.constraints.NotNull;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Map;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.collect.Maps.newHashMap;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.getNullable;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.caseInsensitiveValue;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.District;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.State;
import static org.springframework.util.CollectionUtils.isEmpty;

/**
 * This class represents common functionality for implementations of {@link CustomAggregateReportRepository}
 */
@SuppressWarnings("unchecked")
abstract class AbstractCustomAggregateReportRepository<T extends AggregateRow, R extends CustomAggregateReportResult<T>, B extends CustomAggregateReportResult.Builder<T, B, R>>
        implements CustomAggregateReportRepository<R> {

    private static final Measures emptyMeasure = Measures.builder().build();

    private final ReportingSystemSettings systemSettings;
    private final NamedParameterJdbcTemplate jdbcTemplate;
    private final QueryProviderRepositoryHelper reportQueryRepositoryHelper;
    private final ActiveAssessmentRepository activeAssessmentRepository;
    private final OrganizationRepository organizationRepository;
    private final EmbargoRepository embargoRepository;
    private final QueryProvider queryProvider;
    private final Organization state;
    private final int organizationPartitionSize;

    /**
     * Constructor
     */
    AbstractCustomAggregateReportRepository(final ReportingSystemSettings systemSettings,
                                            final JdbcTemplate jdbcTemplate,
                                            final QueryProviderRepositoryHelper reportQueryRepositoryHelper,
                                            final ActiveAssessmentRepository activeAssessmentRepository,
                                            final OrganizationRepository organizationRepository,
                                            final QueryProvider queryProvider,
                                            final EmbargoRepository embargoRepository,
                                            final int jdbcFetchSize,
                                            final int organizationPartitionSize) {
        this.systemSettings = systemSettings;
        jdbcTemplate.setFetchSize(jdbcFetchSize);
        this.jdbcTemplate = new NamedParameterJdbcTemplate(jdbcTemplate);
        this.reportQueryRepositoryHelper = reportQueryRepositoryHelper;
        this.activeAssessmentRepository = activeAssessmentRepository;
        this.organizationRepository = organizationRepository;
        this.embargoRepository = embargoRepository;
        this.queryProvider = queryProvider;
        this.organizationPartitionSize = organizationPartitionSize;
        this.state = Organization.builder().name(systemSettings.getState().getName()).organizationType(OrganizationType.State).build();
    }

    /**
     * @return an instance of the {@link CustomAggregateReportResult.Builder} of the appropriate sub-type
     */
    protected abstract B getReportBuilder();

    /**
     * @return an instance of {@link ReportRowIdentity} for the given {@link AggregateRow}
     */
    protected abstract ReportRowIdentity getRowIdentity(T row);

    /**
     * @return an instance of an {@link AggregateRow} from the given data
     */
    protected abstract T buildReportRow(Organization organization, ActiveAssessment assessment, Dimension dimension, Measures measures, AggregateReportQuery query);

    @Override
    public R findByOrganizationType(@NotNull final PermissionSource permissionSource,
                                    @NotNull final AggregateReportQuery query,
                                    @NotNull final OrganizationType groupByOrganizationType) {
        validate(query);

        final QueryWithReportTemplate queryWithReportTemplate =
                new CustomAggregateQueryWithReportTemplateProvider(state, organizationPartitionSize, queryProvider, reportQueryRepositoryHelper, permissionSource)
                        .toQuery(query, groupByOrganizationType);

        final Map<ReportRowIdentity, T> templateRows = buildTemplateRowsByIdentity(queryWithReportTemplate, query);
        final String asmtTypeCode = query.getAssessmentTypeCode();
        final B reportBuilder = getReportBuilder();

        reportBuilder.rows(jdbcTemplate.query(
                queryWithReportTemplate.getSqlQuery(),
                queryWithReportTemplate.getParameterSource(),
                (row, index) -> {
                    final T r = buildReportRow(
                            findOneByIdAndType(row.getLong("organization_id"), OrganizationType.valueOf(row.getString("organization_type"))),
                            findByIdAndSchoolYear(asmtTypeCode, row.getInt("asmt_id"), row.getInt("school_year")),
                            Dimension.builder().code(getNullable(row, row.getString("dimension_code"))).type(caseInsensitiveValue(row.getString("dimension"))).build(),
                            measures(row, asmtTypeCode),
                            query);
                    if (!reportBuilder.isCreatedWhileDataEmbargoed()) {
                        reportBuilder.createdWhileDataEmbargoed(isCreatedWhileDataEmbargoed(r, asmtTypeCode));
                    }
                    reportBuilder.hasResults(true);
                    templateRows.remove(getRowIdentity(r));
                    return r;
                }));

        //back-fill with the left template rows
        if (!templateRows.isEmpty()) reportBuilder.rows(templateRows.values());
        return reportBuilder.build();
    }

    @Override
    public int estimateReportRowCountByOrganizationType(@NotNull final AggregateReportQuery query,
                                                        @NotNull final OrganizationType groupByOrganizationType) {
        validate(query);
        return new OrganizationQueryReportTemplateProvider<>(state, reportQueryRepositoryHelper)
                .toQuery(query, groupByOrganizationType)
                .getEstimatedRowCount();
    }

    private Measures measures(final ResultSet row, final String asmtTypeCode) throws SQLException {
        final Measures.Builder builder = Measures.builder()
                .avgScaleScore(row.getInt("score"))
                .avgStdErr(row.getInt("std_err"))
                .level1Count(row.getInt("level1"))
                .level2Count(row.getInt("level2"))
                .level3Count(row.getInt("level3"));

        if (!AssessmentType.IAB.code().equalsIgnoreCase(asmtTypeCode)) builder.level4Count(row.getInt("level4"));
        return builder.build();
    }

    private static void validate(final AggregateReportQuery query) {
        checkArgument(query.getAssessmentTypeCode() != null, "invalid query, missing an assessment type");
        checkArgument(query.getDimensionType() != null, "invalid query, missing a dimension type");
        checkArgument(query.getOrganizationType() != null && (query.getOrganizationType() == State || query.getOrganizationType() == District || query.getOrganizationType() == OrganizationType.School), "invalid query, unsupported organization type");
        checkArgument(!isEmpty(query.getSubjectCodes()), "invalid query, missing a subject");
        checkArgument(!isEmpty(query.getAssessmentGradeCodes()), "invalid query,, missing an assessment grade");
        checkArgument(!isEmpty(query.getSchoolYears()), "invalid query, missing a school year");
        // state shouldn't have org ids, district/school must have org ids
        checkArgument(query.getOrganizationType() != State ^ query.getOrganizationIds().isEmpty(), "invalid query, district/school requires organization ids and state does not");
    }

    /**
     * Process the row for a flag indicating that it has been generated while the data is embargo enabled.
     * This assumes that the SQL query filters out embargoed data for users that are not allowed to view it
     * and this method is only called when the data is allowed for the user.
     */
    private boolean isCreatedWhileDataEmbargoed(final AggregateRow rowToVerify, final String asmtTypeCode) {
        // embargo is only applicable to summative exams
        if (!asmtTypeCode.equalsIgnoreCase(AssessmentType.SUMMATIVE.code())) return false;

        //embargo is only applicable to the current year exams
        if (rowToVerify.getAssessment().getExamSchoolYear() != systemSettings.getSchoolYear()) return false;

        final Organization organization = rowToVerify.getOrganization();

        if (organization.getOrganizationType().equals(OrganizationType.State)) return embargoRepository.isStateEmbargoed();

        //schools inherit their district embargo flag
        final Long districtId = organization.getOrganizationType().equals(District) ? organization.getId() : ((School) organization).getDistrictId();
        return isDistrictEmbargoed(districtId);
    }

    private boolean isDistrictEmbargoed(final long districtId) {
        return embargoRepository.findAllEmbargoedDistrictIds().contains(districtId);
    }

    /**
     * To simplify a report SQL, we are loading assessments and organizations separately.
     * This assumes/relies on the repositories results to be cached
     */
    private ActiveAssessment findByIdAndSchoolYear(final String assessmentTypeCode, final int assessmentId, final int schoolYear) {
        for (final ActiveAssessment activeAssessment : activeAssessmentRepository.findAllByTypeCode(assessmentTypeCode)) {
            if (activeAssessment.getId() == assessmentId && activeAssessment.getExamSchoolYear() == schoolYear)
                return activeAssessment;
        }
        throw new IllegalArgumentException("unable to find an assessment by id " + assessmentId + " and school year " + schoolYear);
    }

    private Organization findOneByIdAndType(final long id, final OrganizationType type) {
        switch (type) {
            case School:
                return organizationRepository.findMapOfSchoolsById().get(id);
            case District:
                return organizationRepository.findMapOfDistrictsByIds().get(id);
            case State:
                return state;
            default:
                throw new IllegalStateException("Not supported organization type: " + type);
        }
    }

    private Map<ReportRowIdentity, T> buildTemplateRowsByIdentity(final QueryWithReportTemplate<ActiveAssessment> queryWithReportTemplate,
                                                                  final AggregateReportQuery query) {
        final Map<ReportRowIdentity, T> reportTemplate = newHashMap();
        // a template report consists of permutations of all the organizations and assessments
        for (final Organization organization : queryWithReportTemplate.getOrganizations()) {
            for (final ActiveAssessment assessment : queryWithReportTemplate.getAssessments()) {
                for (final Dimension dimension : queryWithReportTemplate.getDimensions()) {
                    final T row = buildReportRow(organization, assessment, dimension, emptyMeasure, query);
                    reportTemplate.put(getRowIdentity(row), row);
                }
            }
        }
        return reportTemplate;
    }

    /**
     * Represents an identity of a report row
     */
    static abstract class ReportRowIdentity<I extends AggregateRow> {
        final I reportRow;

        ReportRowIdentity(final I reportRow) {
            this.reportRow = reportRow;
        }
    }
}