
package org.opentestsystem.rdw.olap.repository.impl;

import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.olap.model.AggregateRowReportResult;
import org.opentestsystem.rdw.olap.model.OrganizationTypeQuery;
import org.opentestsystem.rdw.olap.repository.ActiveAssessmentRepository;
import org.opentestsystem.rdw.olap.repository.EmbargoRepository;
import org.opentestsystem.rdw.olap.repository.OrganizationRepository;
import org.opentestsystem.rdw.olap.repository.ReportRepository;
import org.opentestsystem.rdw.olap.sqlbuilder.BaseQueryReportTemplateProvider;
import org.opentestsystem.rdw.olap.sqlbuilder.QueryProviderRepositoryHelper;
import org.opentestsystem.rdw.olap.sqlbuilder.QueryReportTemplate;
import org.opentestsystem.rdw.olap.sqlbuilder.SimpleReportTemplateProvider;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemSettings;
import org.opentestsystem.rdw.reporting.common.model.ActiveAssessment;
import org.opentestsystem.rdw.reporting.common.model.AggregateRow;
import org.opentestsystem.rdw.reporting.common.model.Dimension;
import org.opentestsystem.rdw.reporting.common.model.Measures;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.model.School;
import org.opentestsystem.rdw.reporting.common.security.PermissionSource;
import org.opentestsystem.rdw.reporting.common.sqlbuilder.QueryProvider;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import javax.validation.constraints.NotNull;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Map;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.collect.Maps.newHashMap;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.District;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.State;

/**
 * This class represents common functionality for implementations of {@link ReportRepository}
 */
@SuppressWarnings("unchecked")
abstract class AbstractReportRepository<T extends AggregateRow,
        R extends AggregateRowReportResult<T>,
        Q extends OrganizationTypeQuery,
        B extends AggregateRowReportResult.Builder<T, B, R>>
        implements ReportRepository<T, R, Q> {

    private final ReportingSystemSettings systemSettings;
    private final NamedParameterJdbcTemplate jdbcTemplate;
    private final QueryProviderRepositoryHelper reportQueryRepositoryHelper;
    private final OrganizationRepository organizationRepository;
    private final EmbargoRepository embargoRepository;
    private final ActiveAssessmentRepository activeAssessmentRepository;


    private final QueryProvider queryProvider;
    private final Organization state;
    private final int organizationPartitionSize;

    /**
     * Constructor
     */
    AbstractReportRepository(final ReportingSystemSettings systemSettings,
                             final JdbcTemplate jdbcTemplate,
                             final QueryProviderRepositoryHelper reportQueryRepositoryHelper,
                             final OrganizationRepository organizationRepository,
                             final ActiveAssessmentRepository activeAssessmentRepository,
                             final QueryProvider queryProvider,
                             final EmbargoRepository embargoRepository,
                             final int jdbcFetchSize,
                             final int organizationPartitionSize) {
        this.systemSettings = systemSettings;
        jdbcTemplate.setFetchSize(jdbcFetchSize);
        this.jdbcTemplate = new NamedParameterJdbcTemplate(jdbcTemplate);
        this.reportQueryRepositoryHelper = reportQueryRepositoryHelper;
        this.activeAssessmentRepository = activeAssessmentRepository;
        this.organizationRepository = organizationRepository;
        this.embargoRepository = embargoRepository;
        this.queryProvider = queryProvider;
        this.organizationPartitionSize = organizationPartitionSize;
        this.state = Organization.builder().name(systemSettings.getState().getName()).organizationType(OrganizationType.State).build();
    }

    /**
     * @return an instance of the {@link AggregateRowReportResult.Builder} of the appropriate sub-type
     */
    protected abstract B getReportBuilder();

    /**
     * @return an instance of {@link ReportRowIdentity} for the given {@link AggregateRow}
     */
    protected abstract ReportRowIdentity getRowIdentity(T row);

    /**
     * @return an instance of an {@link AggregateRow} from the given data
     */
    protected abstract T buildEmptyReportRow(Organization organization, ActiveAssessment assessment, Dimension dimension, Q query);

    /**
     * Builds a report row from the given parameters
     */
    protected abstract T buildReportRow(ResultSet resultSet, Q query) throws SQLException;

    /**
     * Returns an instance of  {@link BaseQueryReportTemplateProvider}
     */
    protected abstract BaseQueryReportTemplateProvider<Q> getQueryReportTemplateProvider(Organization state, int organizationPartitionSize, QueryProvider queryProvider, QueryProviderRepositoryHelper reportQueryRepositoryHelper, PermissionSource permissionSource);

    @Override
    public R findByOrganizationType(@NotNull final PermissionSource permissionSource,
                                    @NotNull final Q query,
                                    @NotNull final OrganizationType groupByOrganizationType) {
        validate(query);

        final QueryReportTemplate queryWithReportTemplate =
                getQueryReportTemplateProvider(state, organizationPartitionSize, queryProvider, reportQueryRepositoryHelper, permissionSource)
                        .toQuery(query, groupByOrganizationType);

        final Map<ReportRowIdentity, T> templateRows = buildTemplateRowsByIdentity(queryWithReportTemplate, query);
        final B reportBuilder = getReportBuilder();

        reportBuilder.rows(jdbcTemplate.query(
                queryWithReportTemplate.getSqlQuery(),
                queryWithReportTemplate.getParameterSource(),
                (row, index) -> {
                    final T r = buildReportRow(row, query);
                    if (!reportBuilder.isCreatedWhileDataEmbargoed()) {
                        reportBuilder.createdWhileDataEmbargoed(isCreatedWhileDataEmbargoed(r, query.getAssessmentTypeCode()));
                    }
                    reportBuilder.hasResults(true);
                    templateRows.remove(getRowIdentity(r));
                    return r;
                }));

        //back-fill with the left template rows
        if (!templateRows.isEmpty()) reportBuilder.rows(templateRows.values());
        return reportBuilder.build();
    }

    @Override
    public int estimateReportRowCountByOrganizationType(@NotNull final Q query,
                                                        @NotNull final OrganizationType groupByOrganizationType) {
        validate(query);
        return new SimpleReportTemplateProvider<>(state, reportQueryRepositoryHelper)
                .toQuery(query, groupByOrganizationType)
                .getEstimatedRowCount();
    }

    protected void validate(final Q query) {
        checkArgument(query.getAssessmentTypeCode() != null, "invalid query, missing an assessment type");
        checkArgument(query.getDimensionType() != null, "invalid query, missing a dimension type");
        checkArgument(query.getOrganizationType() != null && (query.getOrganizationType() == State || query.getOrganizationType() == District || query.getOrganizationType() == OrganizationType.School), "invalid query, unsupported organization type");
        // state shouldn't have org ids, district/school must have org ids
        checkArgument(query.getOrganizationType() != State ^ query.getOrganizationIds().isEmpty(), "invalid query, district/school requires organization ids and state does not");
    }

    protected Measures measures(final ResultSet row, final String asmtTypeCode, final String prefix) throws SQLException {
        final Measures.Builder builder = Measures.builder()
                .avgScaleScore(row.getInt(prefix + "score"))
                .avgStdErr(row.getInt(prefix + "std_err"))
                .level1Count(row.getInt(prefix + "level1"))
                .level2Count(row.getInt(prefix + "level2"))
                .level3Count(row.getInt(prefix + "level3"));

        if (!AssessmentType.IAB.code().equalsIgnoreCase(asmtTypeCode)) builder.level4Count(row.getInt(prefix + "level4"));
        return builder.build();
    }


    /**
     * To simplify a report SQL, we are loading assessments and organizations separately.
     * This assumes/relies on the repositories results to be cached
     */
    protected ActiveAssessment findByIdAndSchoolYear(final String assessmentTypeCode, final int assessmentId, final int schoolYear) {
        for (final ActiveAssessment activeAssessment : activeAssessmentRepository.findAllByTypeCode(assessmentTypeCode)) {
            if (activeAssessment.getId() == assessmentId && activeAssessment.getExamSchoolYear() == schoolYear)
                return activeAssessment;
        }
        throw new IllegalArgumentException("unable to find an assessment by id " + assessmentId + " and school year " + schoolYear);
    }

    public QueryProviderRepositoryHelper getReportQueryRepositoryHelper() {
        return reportQueryRepositoryHelper;
    }

    /**
     * Process the row for a flag indicating that it has been generated while the data is embargo enabled.
     * This assumes that the SQL query filters out embargoed data for users that are not allowed to view it
     * and this method is only called when the data is allowed for the user.
     */
    private boolean isCreatedWhileDataEmbargoed(final AggregateRow rowToVerify, final String asmtTypeCode) {
        // embargo is only applicable to summative exams
        if (!asmtTypeCode.equalsIgnoreCase(AssessmentType.SUMMATIVE.code())) return false;

        //embargo is only applicable to the current year exams
        if (rowToVerify.getAssessment().getExamSchoolYear() != systemSettings.getSchoolYear()) return false;

        final Organization organization = rowToVerify.getOrganization();

        if (organization.getOrganizationType().equals(OrganizationType.State)) return embargoRepository.isStateEmbargoed();

        //schools inherit their district embargo flag
        final Long districtId = organization.getOrganizationType().equals(District) ? organization.getId() : ((School) organization).getDistrictId();
        return isDistrictEmbargoed(districtId);
    }

    private boolean isDistrictEmbargoed(final long districtId) {
        return embargoRepository.findAllEmbargoedDistrictIds().contains(districtId);
    }

    protected Organization findOneByIdAndType(final long id, final OrganizationType type) {
        switch (type) {
            case School:
                return organizationRepository.findMapOfSchoolsById().get(id);
            case District:
                return organizationRepository.findMapOfDistrictsByIds().get(id);
            case State:
                return state;
            default:
                throw new IllegalStateException("Not supported organization type: " + type);
        }
    }

    private Map<ReportRowIdentity, T> buildTemplateRowsByIdentity(final QueryReportTemplate queryWithReportTemplate, final Q query) {
        final Map<ReportRowIdentity, T> reportTemplate = newHashMap();
        // a template report consists of permutations of all the organizations and assessments
        for (final Organization organization : queryWithReportTemplate.getOrganizations()) {
            for (final ActiveAssessment assessment : queryWithReportTemplate.getAssessments()) {
                for (final Dimension dimension : queryWithReportTemplate.getDimensions()) {
                    final T row = buildEmptyReportRow(organization, assessment, dimension, query);
                    reportTemplate.put(getRowIdentity(row), row);
                }
            }
        }
        return reportTemplate;
    }

    /**
     * Represents an identity of a report row
     */
    static abstract class ReportRowIdentity<I extends AggregateRow> {
        final I reportRow;

        ReportRowIdentity(final I reportRow) {
            this.reportRow = reportRow;
        }
    }
}