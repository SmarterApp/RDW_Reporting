package org.opentestsystem.rdw.olap.sqlbuilder.impl;

import com.google.common.collect.ImmutableList;
import org.opentestsystem.rdw.olap.model.OrganizationTypeQuery;
import org.opentestsystem.rdw.olap.repository.LanguageRepository;
import org.opentestsystem.rdw.reporting.common.model.Target;
import org.opentestsystem.rdw.olap.repository.ActiveAssessmentRepository;
import org.opentestsystem.rdw.olap.repository.AdministrationConditionRepository;
import org.opentestsystem.rdw.olap.repository.AssessmentGradeRepository;
import org.opentestsystem.rdw.olap.repository.AssessmentTypeRepository;
import org.opentestsystem.rdw.olap.repository.BooleanRepository;
import org.opentestsystem.rdw.olap.repository.CodedEntityRepository;
import org.opentestsystem.rdw.olap.repository.CompletenessRepository;
import org.opentestsystem.rdw.olap.repository.ElasRepository;
import org.opentestsystem.rdw.olap.repository.EthnicityRepository;
import org.opentestsystem.rdw.olap.repository.GenderRepository;
import org.opentestsystem.rdw.olap.repository.OrganizationRepository;
import org.opentestsystem.rdw.olap.repository.SchoolYearRepository;
import org.opentestsystem.rdw.olap.repository.StrictBooleanRepository;
import org.opentestsystem.rdw.olap.repository.SubjectRepository;
import org.opentestsystem.rdw.olap.repository.TargetRepository;
import org.opentestsystem.rdw.olap.sqlbuilder.ReportTemplateProvider;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.stream.Collectors;

import static com.google.common.collect.Maps.newHashMap;
import static com.google.common.collect.Sets.newHashSet;
import static java.util.stream.Collectors.toSet;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Overall;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.StudentEnrolledGrade;

/**
 * Helper to manipulate the data from different repositories into format suitable for the {@link ReportTemplateProvider}s.
 * This helper uses multiple repositories that are expected to be `cacheable`.
 * It is only here to avoid multiple round-trips to Redshift.
 */
@Service
public class QueryProviderRepositoryHelper {

    private final OrganizationRepository organizationRepository;
    private final ActiveAssessmentRepository activeAssessmentRepository;
    private final GenderRepository genderRepository;
    private final ElasRepository elasRepository;
    private final LanguageRepository languageRepository;
    private final EthnicityRepository ethnicityRepository;
    private final BooleanRepository booleanRepository;
    private final StrictBooleanRepository strictBooleanRepository;
    private final SubjectRepository subjectRepository;
    private final AssessmentTypeRepository assessmentTypeRepository;
    private final AssessmentGradeRepository gradeRepository;
    private final CompletenessRepository completenessRepository;
    private final AdministrationConditionRepository administrativeConditionRepository;
    private final SchoolYearRepository schoolYearRepository;
    private final TargetRepository targetRepository;

    @Autowired
    QueryProviderRepositoryHelper(final OrganizationRepository organizationRepository,
                                  final ActiveAssessmentRepository activeAssessmentRepository,
                                  final GenderRepository genderRepository,
                                  final ElasRepository elasRepository,
                                  final LanguageRepository languageRepository,
                                  final EthnicityRepository ethnicityRepository,
                                  final BooleanRepository booleanRepository,
                                  final StrictBooleanRepository strictBooleanRepository,
                                  final SubjectRepository subjectRepository,
                                  final AssessmentTypeRepository assessmentTypeRepository,
                                  final AssessmentGradeRepository gradeRepository,
                                  final CompletenessRepository completenessRepository,
                                  final AdministrationConditionRepository administrativeConditionRepository,
                                  final SchoolYearRepository schoolYearRepository,
                                  final TargetRepository targetRepository) {
        this.organizationRepository = organizationRepository;
        this.activeAssessmentRepository = activeAssessmentRepository;
        this.genderRepository = genderRepository;
        this.elasRepository = elasRepository;
        this.languageRepository = languageRepository;
        this.ethnicityRepository = ethnicityRepository;
        this.booleanRepository = booleanRepository;
        this.strictBooleanRepository = strictBooleanRepository;
        this.subjectRepository = subjectRepository;
        this.assessmentTypeRepository = assessmentTypeRepository;
        this.gradeRepository = gradeRepository;
        this.completenessRepository = completenessRepository;
        this.administrativeConditionRepository = administrativeConditionRepository;
        this.schoolYearRepository = schoolYearRepository;
        this.targetRepository = targetRepository;
    }

    /**
     * Finds all {@link ActiveAssessment} represented by the given {@link OrganizationTypeQuery}.
     * It is used to fill in gap data in the custom aggregate report.
     *
     * @param organizationTypeQuery the {@link OrganizationTypeQuery}
     * @return a set of {@link ActiveAssessment}s
     */
    public Set<ActiveAssessment> findAssessmentsForQuery(final OrganizationTypeQuery organizationTypeQuery) {
        final Set<ActiveAssessment> assessments = newHashSet();
        for (final ActiveAssessment assessment : activeAssessmentRepository.findAllByTypeCode(organizationTypeQuery.getAssessmentTypeCode())) {
            if (organizationTypeQuery.contains(assessment.getSubjectCode(), assessment.getGradeCode(), assessment.getExamSchoolYear())) {
                assessments.add(assessment);
            }
        }
        return assessments;
    }

    /**
     * Return all possible values for the given {@link DimensionType} filtered based on the given {@link OrganizationTypeQuery}
     * This is used to fill in the gaps of the missing data in the custom aggregate report
     *
     * @param dimensionType the {@link DimensionType}
     * @param query         the {@link OrganizationTypeQuery}
     * @return all possible values for the given {@link DimensionType} filtered based on the given {@link OrganizationTypeQuery}
     */
    public List<Dimension> findDimensionsByTypeAndQueryFilters(final DimensionType dimensionType, final OrganizationTypeQuery query) {
        // no point looking up non-filtered dimensions that aren't backfilled
        // also, Overall is never a filter and doesn't have values associated with it
        if (dimensionType.equals(Overall) || (!dimensionType.isFilter() && !dimensionType.isBackfilled())) {
            return ImmutableList.of(Dimension.builder().type(dimensionType).build());
        }

        final Set<Integer> filters = newHashSet();
        final CodedEntityRepository repository = getRepositoryAndAddFilterByDimensionType(dimensionType, query, filters);

        if (dimensionType.isBackfilled()) {
            // For backfilled dimensions, get the specified values or all values if none specified
            return repository.findAll().stream()
                    .filter(e -> filters.isEmpty() || filters.contains(e.getId()))
                    .map(e -> Dimension.builder().code(e.getCode()).type(dimensionType).build())
                    .collect(Collectors.toList());
        } else {
            // For non-backfilled dimensions, get the specified values or no values if none specified
            if (filters.isEmpty()) {
                return ImmutableList.of(Dimension.builder().type(dimensionType).build());
            } else {
                return repository.findAll().stream()
                        .filter(e -> filters.contains(e.getId()))
                        .map(e -> Dimension.builder().code(e.getCode()).type(dimensionType).build())
                        .collect(Collectors.toList());
            }
        }
    }

    public Set<District> findDistrictsByIds(final Set<Long> districtIds) {
        final Set<District> districts = newHashSet();
        for (final Long districtId : districtIds) {
            if (organizationRepository.findMapOfDistrictsByIds().containsKey(districtId)) {
                districts.add(organizationRepository.findMapOfDistrictsByIds().get(districtId));
            }
        }
        return districts;
    }

    public Set<School> findSchoolsByDistrictIds(final Set<Long> districtIds) {
        final Set<School> schools = newHashSet();
        for (final Long districtId : districtIds) {
            if (organizationRepository.findAllSchoolsByDistrictId().containsKey(districtId)) {
                schools.addAll(organizationRepository.findAllSchoolsByDistrictId().get(districtId));
            }
        }
        return schools;
    }

    public Set<Long> findSchoolsIdsByDistrictIds(final Set<Long> districtIds) {
        return findSchoolsByDistrictIds(districtIds).stream().map(School::getId).collect(toSet());
    }

    public Set<School> findSchoolsByIds(final Set<Long> schoolIds) {
        final Set<School> schools = newHashSet();
        for (final Long schoolId : schoolIds) {
            if (organizationRepository.findMapOfSchoolsById().containsKey(schoolId)) {
                schools.add(organizationRepository.findMapOfSchoolsById().get(schoolId));
            }
        }
        return schools;
    }

    public Map<Integer, Set<Target>> findTargets(final OrganizationTypeQuery query) {
        final Map<Integer, Set<Target>> targetsByAsmtId = newHashMap();

        final Map<Integer, Set<Target>> targets = targetRepository.findAll();
        for (final ActiveAssessment assessment : findAssessmentsForQuery(query)) {
            if (!targets.containsKey(assessment.getId())) throw new IllegalStateException("missing targets for asmt id " + assessment.getId());
            targetsByAsmtId.put(assessment.getId(), targets.get(assessment.getId()));

        }
        return targetsByAsmtId;
    }

    public Target findTarget(final int assessmentId, final int targetId) {
        for (final Target target : targetRepository.findAll().get(assessmentId)) {
            if (target.getId() == targetId) return target;
        }
        throw new IllegalArgumentException("unable to find target by assessment id " + assessmentId + " and target id " + targetId);
    }

    public Collection<District> findAllDistricts() {
        return organizationRepository.findMapOfDistrictsByIds().values();
    }

    public Set<Long> findAllDistrictIds() {
        return organizationRepository.findMapOfDistrictsByIds().keySet();
    }

    public Set<Long> findAllDistrictsOfSchools(final Set<Long> schoolIds) {
        final Set<Long> districtIds = newHashSet();
        final Set<Long> schoolIdsLeftToProcess = newHashSet(schoolIds);
        final Map<Long, List<School>> schoolsByDistrictId = organizationRepository.findAllSchoolsByDistrictId();
        for (final Map.Entry<Long, List<School>> entry : schoolsByDistrictId.entrySet()) {
            final Long districtId = entry.getKey();
            for (final School school : entry.getValue()) {
                if (schoolIds.contains(school.getId())) {
                    schoolIdsLeftToProcess.remove(school.getId());
                    districtIds.add(districtId);
                }
                if (schoolIdsLeftToProcess.isEmpty()) return districtIds;
            }
        }
        return districtIds;
    }

    public int toAssessmentTypeId(final String assessmentType) {
        return toId(assessmentType, assessmentTypeRepository, "assessment type");
    }

    public Set<Integer> toSubjectIds(final Collection<String> subjectCodes) {
        final TreeMap<String, Integer> codeToId = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
        subjectRepository.findAll().forEach(entity -> codeToId.put(entity.getCode(), entity.getId()));
        return subjectCodes.stream()
                .map(codeToId::get)
                .collect(Collectors.toSet());
    }

    public Integer toSubjectId(final String subjectCode) {
        for (final SubjectAssessment e : subjectRepository.findAll()) {
            if (e.getCode().equals(subjectCode)) return e.getId();
        }
        throw new IllegalArgumentException("unable to find subject: " + subjectCode);
    }

    public Integer toGradeId(final String gradeCode) {
        for (final Grade grade : gradeRepository.findAll()) {
            if (grade.getCode().equals(gradeCode)) return grade.getId();
        }
        throw new IllegalArgumentException("unable to find grade by code " + gradeCode);
    }

    public Set<Integer> toGradeIds(final Collection<String> gradeCodes) {
        final TreeMap<String, Integer> codeToId = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
        gradeRepository.findAll().forEach(entity -> codeToId.put(entity.getCode(), entity.getId()));
        return gradeCodes.stream()
                .map(codeToId::get)
                .collect(Collectors.toSet());
    }

    public Set<Integer> toCompletenessIds(final Collection<String> completenessCodes) {
        return toIds(completenessCodes, completenessRepository);
    }

    public Set<Integer> toAdministrativeConditionIds(final Collection<String> administrativeConditionCodes) {
        return toIds(administrativeConditionCodes, administrativeConditionRepository);
    }

    public Set<Integer> toGenderIds(final Collection<String> genderCodes) {
        return toIds(genderCodes, genderRepository);
    }

    public Set<Integer> toElasIds(final Collection<String> elasCodes) {
        return toIds(elasCodes, elasRepository);
    }

    public Set<Integer> toLanguageIds(final Collection<String> languageCodes) {
        return toIds(languageCodes, languageRepository);
    }

    public Set<Integer> toEthnicityIds(final Collection<String> ethnicityCodes) {
        return toIds(ethnicityCodes, ethnicityRepository);
    }

    public Set<Integer> toStrictBooleanIds(final Collection<String> strictBooleanCodes) {
        return toIds(strictBooleanCodes, strictBooleanRepository);
    }

    public Set<Integer> toBooleanIds(final Collection<String> booleanCodes) {
        return toIds(booleanCodes, booleanRepository);
    }

    public int maxSize(final DimensionType dimensionType) {
        switch (dimensionType) {
            case Gender:
                return maxSize(genderRepository);
            case Ethnicity:
                return maxSize(ethnicityRepository);
            case LEP:
                return maxSize(strictBooleanRepository);
            case ELAS:
                return maxSize(elasRepository);
            case MigrantStatus:
                return maxSize(booleanRepository);
            case Section504:
                return maxSize(booleanRepository);
            case IEP:
                return maxSize(strictBooleanRepository);
            case EconomicDisadvantage:
                return maxSize(strictBooleanRepository);
            default:
                throw new IllegalArgumentException("unsupported request to findDimensions for dimensionType " + dimensionType);
        }
    }

    public int maxCompletenessCodes() {
        return maxSize(completenessRepository);
    }

    public int maxAdministrativeConditions() {
        return maxSize(administrativeConditionRepository);
    }

    public int maxSchoolYears() {
        return schoolYearRepository.findAll().size();
    }

    public int maxAssessmentGrades() {
        return gradeRepository.findAll().size();
    }

    public int maxSubjects() {
        return subjectRepository.findAll().size();
    }

    private int maxSize(final CodedEntityRepository repository) {
        return repository.findAll().size();
    }

    private CodedEntityRepository getRepositoryAndAddFilterByDimensionType(final DimensionType dimensionType,
                                                                           final OrganizationTypeQuery query,
                                                                           final Set<Integer> ids) {
        switch (dimensionType) {
            case Gender:
                ids.addAll(toGenderIds(query.getGenderCodes()));
                return genderRepository;
            case Ethnicity:
                ids.addAll(toEthnicityIds(query.getEthnicityCodes()));
                return ethnicityRepository;
            case LEP:
                ids.addAll(toStrictBooleanIds(query.getLepCodes()));
                return strictBooleanRepository;
            case ELAS:
                ids.addAll(toElasIds(query.getElasCodes()));
                return elasRepository;
            case Language:
                ids.addAll(toLanguageIds(query.getLanguageCodes()));
                return languageRepository;
            case MigrantStatus:
                ids.addAll(toBooleanIds(query.getMigrantStatusCodes()));
                return booleanRepository;
            case Section504:
                ids.addAll(toBooleanIds(query.getSection504Codes()));
                return booleanRepository;
            case IEP:
                ids.addAll(toStrictBooleanIds(query.getIepCodes()));
                return strictBooleanRepository;
            case EconomicDisadvantage:
                ids.addAll(toStrictBooleanIds(query.getEconomicDisadvantageCodes()));
                return strictBooleanRepository;
            default:
                throw new IllegalArgumentException("unsupported request to findDimensions for dimensionType " + dimensionType);
        }
    }

    private int toId(final String code, final CodedEntityRepository repository, final String codeType) {
        for (final CodedEntity e : repository.findAll()) {
            if (e.getCode().equals(code)) return e.getId();
        }
        throw new IllegalArgumentException("unable to find " + codeType + ": " + code);
    }

    private Set<Integer> toIds(final Collection<String> codes, final CodedEntityRepository repository) {
        final TreeMap<String, Integer> codeToId = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
        repository.findAll().forEach(entity -> codeToId.put(entity.getCode(), entity.getId()));
        return codes.stream()
                .map(codeToId::get)
                .collect(Collectors.toSet());
    }
}
