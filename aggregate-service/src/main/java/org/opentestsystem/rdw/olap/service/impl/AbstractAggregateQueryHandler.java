package org.opentestsystem.rdw.olap.service.impl;

import org.opentestsystem.rdw.olap.configuration.AggregateReportingProperties;
import org.opentestsystem.rdw.olap.model.AggregateReportQueryDescription;
import org.opentestsystem.rdw.olap.model.AggregateRowReportResult;
import org.opentestsystem.rdw.olap.model.OrganizationTypeQuery;
import org.opentestsystem.rdw.olap.repository.ReportRepository;
import org.opentestsystem.rdw.olap.service.AggregateQueryHandler;
import org.opentestsystem.rdw.olap.service.AuthorizationService;
import org.opentestsystem.rdw.reporting.common.model.AbstractAggregateReportQuery;
import org.opentestsystem.rdw.reporting.common.model.AggregateRow;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.StudentFilters;
import org.opentestsystem.rdw.reporting.common.security.User;
import org.springframework.core.task.TaskExecutor;

import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;

import static com.google.common.base.Preconditions.checkArgument;
import static java.util.stream.Collectors.toList;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Overall;

/**
 * Default functionality for implementations of a {@link AggregateQueryHandler} using "template method" pattern.
 */
@SuppressWarnings("unchecked")
abstract class AbstractAggregateQueryHandler<
        T extends AggregateRow,
        R extends AggregateRowReportResult<T>,
        Q extends AbstractAggregateReportQuery,
        B extends AggregateRowReportResult.Builder,
        O extends OrganizationTypeQuery,
        V extends OrganizationTypeQuery.Builder> implements AggregateQueryHandler<List<T>, R, Q> {
    private final ReportRepository<T, R, O> repository;
    private final AuthorizationService authorizationService;
    private final Set<String> stateAggregateAssessmentTypes;
    private final AbstractQueryConverter<Q, O, V> queryConverter;
    private final Executor threadPoolTaskExecutor;

    /**
     * Constructor
     */
    AbstractAggregateQueryHandler(
            final ReportRepository<T, R, O> repository,
            final AbstractQueryConverter<Q, O, V> queryConverter,
            final AuthorizationService authorizationService,
            final AggregateReportingProperties aggregateReportingProperties,
            final TaskExecutor threadPoolTaskExecutor) {
        this.repository = repository;
        this.authorizationService = authorizationService;
        this.queryConverter = queryConverter;
        this.threadPoolTaskExecutor = threadPoolTaskExecutor;
        stateAggregateAssessmentTypes = aggregateReportingProperties.getStateAggregateAssessmentTypes();
    }

    protected abstract B getReportResultBuilder();

    @Override
    public R findByQuery(final User user, final Q query) {
        authorizationService.checkAuthorization(user, query);

        final Q validQuery = preProcess(query);

        // repository is able to support a query for one level of organization and one dimension type
        // to improve the response time for the report we run these queries in parallel
        final Collection<R> reports = queryConverter.convert(validQuery)
                .stream()
                .map(q -> new RunQueryTask(q, repository, user))
                .map(t -> CompletableFuture.supplyAsync(t::run, threadPoolTaskExecutor))
                .map(CompletableFuture::join)
                .collect(toList());

        final B mergedReportBuilder = getReportResultBuilder();
        for (final R report : reports) {
            mergedReportBuilder.merge(report);
        }
        return (R) mergedReportBuilder.build();
    }

    @Override
    public int estimateReportRowCount(final User user, final Q query) {
        authorizationService.checkAuthorization(user, query);

        final Q validQuery = preProcess(query);

        return queryConverter.convert(validQuery)
                .stream()
                .mapToInt(q -> repository.estimateReportRowCountByOrganizationType(q.getQuery(), q.getGroupByOrganizationType()))
                .sum();
    }

    /**
     * Pre-process the query before handling it.
     * This includes validating it as well as adding any missing default values.
     *
     * @param queryIn the original query for processing
     * @return a valid query
     */
    protected Q preProcess(final Q queryIn) {
        Q query = queryIn.isFilteredSubgroupQuery()
                ? ensureOverallSubgroup(queryIn)
                : ensureDimension(queryIn, Overall);

        checkArgument(!query.getSubjectCodes().isEmpty(), "report query is missing subjects");
        checkArgument(!query.getAssessmentGradeCodes().isEmpty(), "report query is missing asmt grades");
        checkArgument(!query.getSchoolYears().isEmpty(), "report query is missing school years");
        checkArgument(!(!query.isIncludeState() && !query.isIncludeAllDistricts() && query.getDistrictIds().isEmpty() && query.getSchoolIds().isEmpty()), "report query is missing organization");
        if (query.isIncludeState()) {
            checkArgument(stateAggregateAssessmentTypes.contains(query.getAssessmentTypeCode()), "report query cannot include state results for " + query.getAssessmentTypeCode() + " assessment types");
        }
        return query;
    }

    private Q ensureDimension(final Q query, final DimensionType dimension) {
        return query.getDimensionTypes().contains(dimension)
                ? query
                : (Q) query.copy().dimensionType(Overall).build();
    }

    private Q ensureOverallSubgroup(final Q query) {
        return query.getSubgroups().keySet().contains(Overall.name())
                ? query
                : (Q) query.copy().subgroup(Overall.name(), StudentFilters.builder().build()).build();
    }

    private class RunQueryTask {
        private final AggregateReportQueryDescription<O> queryDescription;
        private final ReportRepository<T, R, O> reportRepository;
        private final User user;

        private RunQueryTask(final AggregateReportQueryDescription<O> queryDescription, final ReportRepository<T, R, O> reportRepository, final User user) {
            this.queryDescription = queryDescription;
            this.reportRepository = reportRepository;
            this.user = user;
        }

        private R run() {
            return reportRepository.findByOrganizationType(user, queryDescription.getQuery(), queryDescription.getGroupByOrganizationType());
        }
    }
}