package org.opentestsystem.rdw.olap.sqlbuilder;

import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.ReportQuery;

import java.util.List;
import java.util.Set;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.collect.Lists.newArrayList;
import static java.util.Collections.emptySet;
import static java.util.stream.Collectors.toList;
import static org.hibernate.validator.internal.util.CollectionHelper.newHashSet;
import static org.opentestsystem.rdw.common.model.AssessmentType.IAB;
import static org.opentestsystem.rdw.reporting.common.model.ReportQuery.checkIsValid;


/**
 * This class defines the steps for converting {@link ReportQuery} into a collection of SQL statements.
 */
@SuppressWarnings("unchecked")
abstract class CustomAggregateProviderTemplate<B extends ReportContext.Builder, T extends ReportContext> implements QueryProvider<T> {

    private final QueryProviderRepositoryHelper repositoryHelper;

    CustomAggregateProviderTemplate(final QueryProviderRepositoryHelper repositoryHelper) {
        this.repositoryHelper = repositoryHelper;
    }

    @Override
    public List<T> toQuery(final ReportQuery query) {
        return toQueryBuilders(query).stream().map(this::build).collect(toList());
    }

    /**
     * A final report is represented by one or more SQL statements: one per a pair of dimension and organization.
     * All SQLs are assembled by combining SQL snippets from custom-aggregate-report-template.sql.yml.
     * <p>
     * There is a common template with the parameters shared by all queries that gets decorated with
     * the organization level snippets, as well as dimensions and filters.
     * <p>
     * There are three different types of filters
     * <ls>
     * <li>common ones that are shared by all SQLs</li>
     * <li>the ones that are applicable for a dimension only</li>
     * <li>the ones that are specific to a particular organization level</li>
     * </ls>
     */
    private List<B> toQueryBuilders(final ReportQuery query) {

        checkIsValid(query);
        checkArgument(!IAB.code().equals(query.getAssessmentTypeCode()), "custom aggregate report for IAB is not supported yet");

        final List<B> builders = newArrayList();

        // some of the parameters are shared by all SQL statements; this creates a template to reuse with each query
        final B templateBuilder = createBuilderWithCommonAttributes(query);

        //each pair of organization/dimension is represented by a separate sql
        for (final DimensionType dimension : query.getDimensionTypes()) {

            // the dimension related parameters are the same for different types of organizations
            final B dimensionTemplateBuilder = (B) createBuilderWithFiltersAndDimensions(dimension, query).merge(templateBuilder);

            // for each level of organization add one or more builders to the result
            appendState(query, builders, dimensionTemplateBuilder);
            appendDistricts(query, builders, dimensionTemplateBuilder);
            appendSchools(query, builders, dimensionTemplateBuilder);
        }
        return builders;
    }

    private void appendState(final ReportQuery query, final List<B> queries, final B dimensionTemplateBuilder) {
        if (query.isIncludeState()) {
            queries.add((B) createBuilderWithState().merge(dimensionTemplateBuilder));
        }
    }

    private void appendDistricts(final ReportQuery query, final List<B> builders, final B dimensionTemplateBuilder) {
        if (query.isIncludeAllDistricts()) {
            builders.add((B) createBuilderWithAllDistricts().merge(dimensionTemplateBuilder));

        } else if (!query.getDistrictIds().isEmpty() || isIncludeAllDistrictsOfSchools(query)) {
            //individual districts could be included two ways: by ids or via 'isIncludeAllDistrictsOfSchools' flag
            final Set<Long> districtIds = newHashSet(query.getDistrictIds());
            if (isIncludeAllDistrictsOfSchools(query)) districtIds.addAll(repositoryHelper.findAllDistrictsOfSchools(query.getSchoolIds()));

            if (!districtIds.isEmpty()) builders.add((B) createBuilderWithDistrictIds(districtIds).merge(dimensionTemplateBuilder));
        }
    }

    private void appendSchools(final ReportQuery query, final List<B> builders, final B dimensionTemplateBuilder) {
        //schools could be selected individually or as part of a district selection
        final Set<Long> districtsWithAllSchools = newHashSet();
        if (isIncludeAllSchoolsOfDistricts(query)) {
            final Set<Long> districtIds = query.isIncludeAllDistricts() ? repositoryHelper.findAllDistrictIds() : query.getDistrictIds();
            districtsWithAllSchools.addAll(districtIds);

            if (!districtsWithAllSchools.isEmpty()) builders.add((B) createBuilderWithAllSchoolsOfDistricts(districtsWithAllSchools).merge(dimensionTemplateBuilder));
        }

        if (!query.getSchoolIds().isEmpty()) {
            //to avoid duplicate schools we need to filter those that are already included as part of districts selection
            final Set<Long> schoolIds = query.getSchoolIds();
            final Set<Long> schoolsIncludedAsAllOfDistricts = isIncludeAllSchoolsOfDistricts(query) ? repositoryHelper.findSchoolsIdsByDistrictIds(districtsWithAllSchools) : emptySet();
            schoolIds.removeAll(schoolsIncludedAsAllOfDistricts);

            if (!schoolIds.isEmpty()) builders.add((B) createBuilderWithSchoolIds(schoolIds).merge(dimensionTemplateBuilder));
        }
    }

    protected abstract B createBuilderInstance();

    protected abstract B createBuilderWithCommonAttributes(ReportQuery query);

    protected abstract B createBuilderWithFiltersAndDimensions(DimensionType dimensionType, ReportQuery query);

    // each method below maps to a SQL snippet in the custom-aggregate-report-template.sql.yml
    // they all provide a new instance of a builder initialized with the named level of organization related parameters
    protected abstract B createBuilderWithState();

    protected abstract B createBuilderWithAllDistricts();

    protected abstract B createBuilderWithDistrictIds(Set<Long> districtIds);

    protected abstract B createBuilderWithAllSchoolsOfDistricts(Set<Long> districtIds);

    protected abstract B createBuilderWithSchoolIds(Set<Long> schoolIds);

    protected abstract T build(final B builder);

    private boolean isIncludeAllSchoolsOfDistricts(final ReportQuery query) {
        return query.isIncludeAllSchoolsOfDistricts() && !query.getDistrictIds().isEmpty();
    }

    private boolean isIncludeAllDistrictsOfSchools(final ReportQuery query) {
        return query.isIncludeAllDistrictsOfSchools() && !query.getSchoolIds().isEmpty();
    }
}
