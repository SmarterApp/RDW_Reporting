package org.opentestsystem.rdw.olap.repository.impl;

import org.opentestsystem.rdw.olap.model.AltScoreOrganizationQuery;
import org.opentestsystem.rdw.olap.model.AltScoreReportResult;
import org.opentestsystem.rdw.olap.model.AltScoreRowIdentity;
import org.opentestsystem.rdw.olap.model.ReportRowIdentity;
import org.opentestsystem.rdw.olap.model.ReportTemplate;
import org.opentestsystem.rdw.olap.repository.ActiveAssessmentRepository;
import org.opentestsystem.rdw.olap.repository.AltScoreReportRepository;
import org.opentestsystem.rdw.olap.repository.EmbargoRepository;
import org.opentestsystem.rdw.olap.repository.OrganizationRepository;
import org.opentestsystem.rdw.olap.sqlbuilder.impl.QueryProviderRepositoryHelper;
import org.opentestsystem.rdw.olap.sqlbuilder.impl.query.AltScoreSqlQueryWithReportTemplateProvider;
import org.opentestsystem.rdw.olap.sqlbuilder.impl.template.AltScoreReportTemplateProvider;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemProperties;
import org.opentestsystem.rdw.reporting.common.model.ActiveAssessment;
import org.opentestsystem.rdw.reporting.common.model.AltScoreRow;
import org.opentestsystem.rdw.reporting.common.model.Dimension;
import org.opentestsystem.rdw.reporting.common.model.Measures;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.security.PermissionSource;
import org.opentestsystem.rdw.reporting.common.sqlbuilder.QueryProvider;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import javax.validation.constraints.NotNull;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Collection;
import java.util.Map;
import java.util.Set;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.collect.Maps.newHashMap;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.getNullable;
import static org.springframework.util.CollectionUtils.isEmpty;

/**
 * Implementation of {@link AltScoreReportRepository}
 */
@SuppressWarnings("unchecked")
@Repository
public class JdbcAltScoreReportRepository
        extends AbstractReportRepository<AltScoreRow, AltScoreReportResult, AltScoreOrganizationQuery, AltScoreReportResult.Builder>
        implements AltScoreReportRepository {
    /**
     * Constructor
     */
    @Autowired
    JdbcAltScoreReportRepository(@Qualifier("reportingSystemPropertiesResolver") final ReportingSystemProperties reportingSystemProperties,
                                 final JdbcTemplate jdbcTemplate,
                                 final QueryProviderRepositoryHelper reportQueryRepositoryHelper,
                                 final ActiveAssessmentRepository activeAssessmentRepository,
                                 final OrganizationRepository organizationRepository,
                                 final QueryProvider queryProvider,
                                 final EmbargoRepository embargoRepository,
                                 @Value("${app.aggregate-reports.custom-aggregate-report-repository.jdbc-fetch-size}") final int jdbcFetchSize,
                                 @Value("${app.aggregate-reports.custom-aggregate-report-repository.organization-partition-size}") final int organizationPartitionSize) {
        super(reportingSystemProperties, jdbcTemplate, reportQueryRepositoryHelper, organizationRepository, activeAssessmentRepository, queryProvider, embargoRepository, jdbcFetchSize, organizationPartitionSize);
    }

    @Override
    protected AltScoreReportResult.Builder getReportBuilder() {
        return AltScoreReportResult.builder();
    }

    @Override
    protected void validate(final AltScoreOrganizationQuery query) {
        super.validate(query);
        checkArgument(!isEmpty(query.getAltScoreCodesBySubject()), "invalid query, missing a subject");
        checkArgument(!isEmpty(query.getAssessmentGradeCodes()), "invalid query, missing an assessment grade");
        checkArgument(!isEmpty(query.getSchoolYears()), "invalid query, missing a school year");
    }

    @Override
    protected AltScoreSqlQueryWithReportTemplateProvider getQueryReportTemplateProvider(
            final Organization state,
            final int organizationPartitionSize,
            final QueryProvider queryProvider,
            final QueryProviderRepositoryHelper reportQueryRepositoryHelper,
            final PermissionSource permissionSource) {
        return new AltScoreSqlQueryWithReportTemplateProvider(state, organizationPartitionSize, queryProvider, reportQueryRepositoryHelper, permissionSource, reportingSystemProperties);
    }

    @Override
    protected AltScoreRow buildReportRow(final ResultSet row, final AltScoreOrganizationQuery query) throws SQLException {
        final String asmtTypeCode = query.getAssessmentTypeCode();
        return AltScoreRow.builder()
                .organization(findOneByIdAndType(row.getLong("organization_id"), OrganizationType.valueOf(row.getString("organization_type"))))
                .assessment(findByIdAndSchoolYear(asmtTypeCode, row.getInt("asmt_id"), row.getInt("school_year")))
                .dimension(buildDimension(row, query))
                .measures(Measures.builder()
                    .avgScaleScore(getNullable(row, row.getInt("score")))
                    .avgStdErr(getNullable(row, row.getInt("std_err")))
                    .level1Count(row.getInt("level1"))
                    .level2Count(row.getInt("level2"))
                    .level3Count(row.getInt("level3"))
                    .level4Count(row.getInt("level4"))
                    .level5Count(row.getInt("level5"))
                    .level6Count(row.getInt("level6"))
                    .build())
                .altScoreCode(row.getString("alt_score_code"))
                .build();
    }

    @Override
    protected ReportRowIdentity createReportRowIdentity(final AltScoreRow reportRow, final boolean considerAsmtIdAsPartOfIdentity) {
        return new AltScoreRowIdentity(reportRow, considerAsmtIdAsPartOfIdentity);
    }

    @Override
    protected Map<ReportRowIdentity, AltScoreRow> buildTemplateRowsByIdentity(final ReportTemplate queryWithReportTemplate,
                                                                           final AltScoreOrganizationQuery query,
                                                                           final boolean considerAsmtIdAsPartOfIdentity) {
        final Map<ActiveAssessment, Set<String>> altScoresByAssessment = getAltScoresByAssessment(queryWithReportTemplate);

        final Map<ReportRowIdentity, AltScoreRow> reportTemplate = newHashMap();
        // a template report consists of combinations of all the organizations and assessments
        queryWithReportTemplate.combinations((organization, assessment, dimension) -> {
            for (final String altScoreCode : altScoresByAssessment.get(assessment)) {
                final AltScoreRow row = buildEmptyReportRow(organization, assessment, dimension, query, altScoreCode);
                reportTemplate.put(createReportRowIdentity(row, considerAsmtIdAsPartOfIdentity), row);
            }
        });
        return reportTemplate;
    }


    private AltScoreRow buildEmptyReportRow(final Organization organization,
                                         final ActiveAssessment assessment,
                                         final Dimension dimension,
                                         final AltScoreOrganizationQuery query,
                                         final String altScoreCode) {
        return AltScoreRow.builder()
                .assessment(assessment)
                .organization(organization)
                .dimension(buildDimension(dimension, query))
                .measures(Measures.getEmptyMeasure())
                .altScoreCode(altScoreCode)
                .build();
    }

    @Override
    public int estimateReportRowCountByOrganizationType(@NotNull final AltScoreOrganizationQuery query,
                                                        @NotNull final OrganizationType groupByOrganizationType) {
        validate(query);
        final ReportTemplate reportTemplate = new AltScoreReportTemplateProvider(getState(), getReportQueryRepositoryHelper())
                .toQuery(query, groupByOrganizationType);

        final Map<ActiveAssessment, Set<String>> altScoresByAssessment = getAltScoresByAssessment(reportTemplate);

        return (reportTemplate.getOrganizations().size()
                * (int) altScoresByAssessment.values().stream().mapToLong(Collection::size).sum()
                * reportTemplate.getDimensions().size());
    }

    /**
     * @return collection of altScores from the given {@link ReportTemplate} mapped by {@link ActiveAssessment} (may not be empty).
     * A set of altScores for each assessment may not be null or empty;
     */
    private Map<ActiveAssessment, Set<String>> getAltScoresByAssessment(final ReportTemplate reportTemplate) {
        final Map<ActiveAssessment, Set<String>> altScoresByAssessment = newHashMap();
        final Map<String, Set<String>> altScoreCodesBySubject = reportTemplate.getAltScoreCodesBySubject();

        for (final ActiveAssessment activeAssessment : reportTemplate.getAssessments()) {
            if (!altScoreCodesBySubject.containsKey(activeAssessment.getSubjectCode()))
                throw new IllegalStateException("unable to find assessment for the altScore subject");
            altScoresByAssessment.put(activeAssessment, altScoreCodesBySubject.get(activeAssessment.getSubjectCode()));

        }
        return altScoresByAssessment;
    }
}
