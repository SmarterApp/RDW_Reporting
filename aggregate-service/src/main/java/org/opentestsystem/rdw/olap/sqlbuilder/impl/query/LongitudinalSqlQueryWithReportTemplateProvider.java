package org.opentestsystem.rdw.olap.sqlbuilder.impl.query;

import org.opentestsystem.rdw.olap.model.LongitudinalOrganizationQuery;
import org.opentestsystem.rdw.olap.model.LongitudinalReportResult;
import org.opentestsystem.rdw.olap.model.SqlQueryWithReportTemplate;
import org.opentestsystem.rdw.olap.model.SqlQueryWithReportTemplate.Builder;
import org.opentestsystem.rdw.olap.model.YearGradePair;
import org.opentestsystem.rdw.olap.sqlbuilder.impl.QueryProviderRepositoryHelper;
import org.opentestsystem.rdw.olap.sqlbuilder.impl.template.SimpleReportTemplateProvider;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemProperties;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.security.PermissionSource;
import org.opentestsystem.rdw.reporting.common.sqlbuilder.QueryProvider;
import org.springframework.beans.factory.annotation.Qualifier;

import javax.validation.constraints.NotNull;
import java.util.Iterator;
import java.util.List;

import static com.google.common.collect.Lists.newArrayList;
import static java.util.stream.Collectors.toList;
import static java.util.stream.IntStream.rangeClosed;


/**
 * This implementation is responsible for converting {@link LongitudinalOrganizationQuery} into a {@link SqlQueryWithReportTemplate}
 * that contains a SQL string, SQL parameters and an empty report template to produce {@link LongitudinalReportResult}
 */
@SuppressWarnings("unchecked")
public class LongitudinalSqlQueryWithReportTemplateProvider extends AbstractSqlQueryWithReportTemplateProvider<LongitudinalOrganizationQuery, SimpleReportTemplateProvider> {

    // Redshift is caching the query execution plan much better when SQL has the same number of parameters in the IN clause.
    // The best guess based on examining the execution plan is that the optimizer converts IN into ORs, and hence it sees it as
    // a different query. Optimizer also removes duplicate values from the IN, so to trick it we are padding each IN to a fixed size with
    // distinct invalid values. We need a bunch (20) invalid strings to pad the list of year-grade string values.
    private static final List<String> DISTINCT_STRINGS = rangeClosed(300, 320).boxed().map(r -> (Integer.toString(-1 * r))).collect(toList());

    private static final String longitudinalTemplateSql = "longitudinal";

    public LongitudinalSqlQueryWithReportTemplateProvider(
            final Organization state,
            final int organizationPartitionSize,
            final QueryProvider queryProvider,
            final QueryProviderRepositoryHelper repositoryHelper,
            final PermissionSource permissionSource,
            @Qualifier("reportingSystemPropertiesResolver") final ReportingSystemProperties reportingSystemProperties) {
        super(new SimpleReportTemplateProvider(state, repositoryHelper), organizationPartitionSize, queryProvider, repositoryHelper, permissionSource, reportingSystemProperties);
    }

    @Override
    public Builder createBuilderWithCommonAttributes(final LongitudinalOrganizationQuery query) {
        return addFiltersAndDimension(createBuilderInstance(), query)
                .reportTemplate(templateProvider.createBuilderWithCommonAttributes(query).build())
                .parameter("subject_id", getRepositoryHelper().toSubjectId(query.getSubjectCode()))
                .parameter("cohort_years", query.getYearGradePairs().size())
                .parameter("gradeYearPairsCount", query.getYearGradePairs().size())
                .parameter("yearGradePairs", toPaddedStrings(query.getYearGradePairs(), Math.max(query.getYearGradePairs().size(), getRepositoryHelper().maxAssessmentGrades())));
    }

    @Override
    protected String getTemplateSql() {
        return longitudinalTemplateSql;
    }

    private List<String> toPaddedStrings(@NotNull final List<YearGradePair> yearGradePairs, final int size) {
        if (yearGradePairs.size() > DISTINCT_STRINGS.size() || size > DISTINCT_STRINGS.size()) {
            throw new IllegalStateException("unsupported number of year/grade pairs");
        }

        final List<String> padded = newArrayList(DISTINCT_STRINGS.subList(0, size));

        final Iterator<YearGradePair> iterator = yearGradePairs.iterator();
        for (int i = 0; i < yearGradePairs.size(); ++i) {
            final YearGradePair yearGradePair = iterator.next();
            padded.set(i, yearGradePair.getSchoolYear() + "," + yearGradePair.getGradeCode());
        }
        return padded;
    }
}
