package org.opentestsystem.rdw.olap.sqlbuilder;

import com.google.common.collect.ImmutableList;
import org.opentestsystem.rdw.olap.sqlbuilder.QueryWithReportTemplate.Builder;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.model.ReportQuery;
import org.opentestsystem.rdw.reporting.common.sqlbuilder.QueryProvider;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Set;

import static com.google.common.collect.Lists.newArrayList;
import static java.util.Collections.emptySet;
import static org.hibernate.validator.internal.util.CollectionHelper.newHashSet;
import static org.opentestsystem.rdw.olap.sqlbuilder.QueryWithReportTemplate.builder;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.nullOrEmptyToDefault;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.EconomicDisadvantage;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Ethnicity;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Gender;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.IEP;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.LEP;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.MigrantStatus;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Section504;
import static org.opentestsystem.rdw.reporting.common.model.ReportQuery.checkIsValid;

/**
 * This implementation is responsible for constructing a custom aggregate query.
 */
@Component
public class CustomAggregateQueryProvider implements ReportQueryProvider {
    private static final List<Integer> UNMATCHABLE_INT_IDS = ImmutableList.of(-1);

    private static final String customAggregateTemplateSql = "customAggregate";
    private static final String stateAddOn = "state";
    private static final String districtsAddOn = "districts";
    private static final String allDistrictsAddOn = "allDistricts";
    private static final String schoolsAddOn = "schools";
    private static final String allSchoolsInDistrictsAddOn = "allSchoolsInDistricts";

    private final Organization state;
    private final QueryProvider queryProvider;
    private final ReportQueryRepositoryHelper repositoryHelper;

    @Autowired
    public CustomAggregateQueryProvider(@Value("${app.state.name}") final String stateName,
                                        final QueryProvider queryProvider,
                                        final ReportQueryRepositoryHelper repositoryHelper) {
        this.queryProvider = queryProvider;
        this.repositoryHelper = repositoryHelper;

        state = Organization.builder().name(stateName).organizationType(OrganizationType.State).build();
    }

    public Iterable<QueryWithReportTemplate> toQuery(final ReportQuery query) {
        checkIsValid(query);

        final Builder templateBuilder = toBuilderWithCommonAttributes(query);

        final List<QueryWithReportTemplate> queries = newArrayList();
        for (final DimensionType dimension : query.getDimensionTypes()) {
            final Builder dimensionTemplateBuilder = toBuilderWithFiltersAndDimensions(dimension, query).copy(templateBuilder);
            appendState(query, queries, dimensionTemplateBuilder);
            appendDistricts(query, queries, dimensionTemplateBuilder);
            appendSchools(query, queries, dimensionTemplateBuilder);
        }
        return queries;
    }

    private void appendState(final ReportQuery query, final List<QueryWithReportTemplate> queries, final Builder dimensionTemplateBuilder) {
        if (query.isIncludeState()) {
            queries.add(buildQuery(builder().addOn(stateAddOn).state(state).copy(dimensionTemplateBuilder)));
        }
    }

    private void appendDistricts(final ReportQuery query, final List<QueryWithReportTemplate> queries, final Builder dimensionTemplateBuilder) {
        if (query.isIncludeAllDistricts()) {
            queries.add(buildQuery(builder().addOn(allDistrictsAddOn).districts(repositoryHelper.findAllDistricts()).copy(dimensionTemplateBuilder)));

        } else if (!query.getDistrictIds().isEmpty() || isIncludeAllDistrictsOfSchools(query)) {
            //districts could be included two ways: by ids or via 'isIncludeAllDistrictsOfSchools' flag
            final Set<Long> districtIds = newHashSet(query.getDistrictIds());
            if (isIncludeAllDistrictsOfSchools(query)) districtIds.addAll(repositoryHelper.findAllDistrictsOfSchools(query.getSchoolIds()));

            if (!districtIds.isEmpty()) queries.add(buildQuery(toBuilderWithDistrictIds(districtIds).copy(dimensionTemplateBuilder)));
        }
    }

    private void appendSchools(final ReportQuery query, final List<QueryWithReportTemplate> queries, final Builder dimensionTemplateBuilder) {
        //schools could be selected individually or as part of a district selection
        final Set<Long> districtsWithAllSchools = newHashSet();
        if (isIncludeAllSchoolsOfDistricts(query)) {
            final Set<Long> districtIds = query.isIncludeAllDistricts() ? repositoryHelper.findAllDistrictIds() : query.getDistrictIds();
            districtsWithAllSchools.addAll(districtIds);

            if (!districtsWithAllSchools.isEmpty()) queries.add(buildQuery(toBuilderWithAllSchoolsOfDistricts(districtsWithAllSchools).copy(dimensionTemplateBuilder)));
        }

        if (!query.getSchoolIds().isEmpty()) {
            //to avoid duplicate schools we need to filter those that are already included as part of districts selection
            final Set<Long> schoolIds = query.getSchoolIds();
            final Set<Long> schoolsIncludedAsAllOfDistricts = isIncludeAllSchoolsOfDistricts(query) ? repositoryHelper.findSchoolsIdsByDistrictIds(districtsWithAllSchools) : emptySet();
            schoolIds.removeAll(schoolsIncludedAsAllOfDistricts);

            if (!schoolIds.isEmpty()) queries.add(buildQuery(toBuilderWithSchoolIds(schoolIds).copy(dimensionTemplateBuilder)));
        }
    }

    private boolean isIncludeAllSchoolsOfDistricts(final ReportQuery query) {
        return query.isIncludeAllSchoolsOfDistricts() && !query.getDistrictIds().isEmpty();
    }

    private boolean isIncludeAllDistrictsOfSchools(final ReportQuery query) {
        return query.isIncludeAllDistrictsOfSchools() && !query.getSchoolIds().isEmpty();
    }

    /**
     * A single {@link ReportQuery} is converted to one or more {@link QueryWithReportTemplate}s, but some of the parameters are common for all of them.
     * This method created a {@link ReportQuery#builder()} initialized with these type of parameters.
     *
     * @param query the {@link ReportQuery}
     * @return {@link ReportQuery.Builder} initialized with the common parameters
     */
    private Builder toBuilderWithCommonAttributes(final ReportQuery query) {
        return builder()
                .parameter("school_years", query.getSchoolYears())
                .parameter("asmt_grade_ids", repositoryHelper.toGradeIds(query.getAssessmentGradeCodes()))
                .parameter("subject_ids", repositoryHelper.toSubjectIds(query.getSubjectCodes()))
                .parameter("asmt_type_id", repositoryHelper.toAssessmentTypeId(query.getAssessmentTypeCode()))
                .assessments(repositoryHelper.findAssessmentsForQuery(query));
    }

    private Builder toBuilderWithDistrictIds(final Set<Long> districtIds) {
        return builder()
                .addOn(allDistrictsAddOn)
                .addOn(districtsAddOn)
                .parameter("district_ids", districtIds)
                .districts(repositoryHelper.findDistrictsByIds(districtIds));
    }

    private Builder toBuilderWithAllSchoolsOfDistricts(final Set<Long> districtIds) {
        return builder()
                .addOn(allSchoolsInDistrictsAddOn)
                .parameter("school_district_ids", districtIds)
                .schools(repositoryHelper.findSchoolsByDistrictIds(districtIds));
    }

    private Builder toBuilderWithSchoolIds(final Set<Long> schoolIds) {
        return builder()
                .addOn(schoolsAddOn)
                .parameter("school_ids", schoolIds)
                .schools(repositoryHelper.findSchoolsByIds(schoolIds));
    }

    private QueryWithReportTemplate buildQuery(final Builder builder) {
        return builder.build(queryProvider, customAggregateTemplateSql);
    }

    private Builder toBuilderWithFiltersAndDimensions(final DimensionType dimensionType, final ReportQuery query) {
        final Builder queryBuilder = builder().addOn(dimensionType.name());

        if (!query.getCompletenessCodes().isEmpty()) {
            queryBuilder
                    .addOn("completeness")
                    .parameter("completeness_ids", repositoryHelper.toCompletenessIds(query.getCompletenessCodes()));
        }

        if (!query.getAdministrativeConditionCodes().isEmpty()) {
            queryBuilder
                    .addOn("administration_condition")
                    .parameter("administration_condition_ids", repositoryHelper.toAdministrativeConditionIds(query.getAdministrativeConditionCodes()));
        }

        final Set<Integer> genderIds = repositoryHelper.toGenderIds(query.getGenderCodes());
        final Set<Integer> ethnicityIds = repositoryHelper.toEthnicityIds(query.getEthnicityCodes());
        final Set<Integer> lepIds = repositoryHelper.toStrictBooleanIds(query.getLepCodes());
        final Set<Integer> migrantStatusIds = repositoryHelper.toBooleanIds(query.getMigrantStatusCodes());
        final Set<Integer> section504Ids = repositoryHelper.toBooleanIds(query.getSection504Codes());
        final Set<Integer> iepIds = repositoryHelper.toStrictBooleanIds(query.getIepCodes());
        final Set<Integer> economicDisadvantageIds = repositoryHelper.toStrictBooleanIds(query.getEconomicDisadvantageCodes());

        addFilter(queryBuilder, Gender, genderIds, dimensionType == Gender);
        addFilter(queryBuilder, Ethnicity, ethnicityIds, dimensionType == Ethnicity);
        addFilter(queryBuilder, LEP, lepIds, dimensionType == LEP);
        addFilter(queryBuilder, MigrantStatus, migrantStatusIds, dimensionType == MigrantStatus);
        addFilter(queryBuilder, Section504, section504Ids, dimensionType == Section504);
        addFilter(queryBuilder, IEP, iepIds, dimensionType == IEP);
        addFilter(queryBuilder, EconomicDisadvantage, economicDisadvantageIds, dimensionType == EconomicDisadvantage);

        queryBuilder.dimensions(repositoryHelper.findDimensionsByTypeAndQueryFilters(dimensionType, query));

        switch (dimensionType) {
            case Gender:
                addFilterParams(queryBuilder, dimensionType, genderIds);
                break;
            case Ethnicity:
                addFilterParams(queryBuilder, dimensionType, ethnicityIds);
                break;
            case LEP:
                addFilterParams(queryBuilder, dimensionType, lepIds);
                break;
            case MigrantStatus:
                addFilterParams(queryBuilder, dimensionType, migrantStatusIds);
                break;
            case Section504:
                addFilterParams(queryBuilder, dimensionType, section504Ids);
                break;
            case IEP:
                addFilterParams(queryBuilder, dimensionType, iepIds);
                break;
            case EconomicDisadvantage:
                addFilterParams(queryBuilder, dimensionType, economicDisadvantageIds);
                break;
        }
        return queryBuilder;
    }

    private void addFilter(final Builder queryBuilder,
                           final DimensionType dimensionType,
                           final Set<Integer> dimensionFilters,
                           boolean isFilterSameAsDimension) {
        if (!isFilterSameAsDimension && !dimensionFilters.isEmpty()) {
            queryBuilder.addOn(dimensionType.name() + "_filter");
            addFilterParams(queryBuilder, dimensionType, dimensionFilters);
        }
    }

    private void addFilterParams(final Builder queryBuilder,
                                 final DimensionType dimensionType,
                                 final Set<Integer> dimensionFilters) {

        switch (dimensionType) {
            case Gender:
                queryBuilder.parameter("all_genders", dimensionFilters.isEmpty())
                        .parameter("gender_ids", nullOrEmptyToDefault(dimensionFilters, UNMATCHABLE_INT_IDS));
                break;
            case Ethnicity:
                queryBuilder.parameter("all_ethnicities", dimensionFilters.isEmpty())
                        .parameter("ethnicity_ids", nullOrEmptyToDefault(dimensionFilters, UNMATCHABLE_INT_IDS));
                break;

            case LEP:
                queryBuilder.parameter("all_leps", dimensionFilters.isEmpty())
                        .parameter("lep_ids", nullOrEmptyToDefault(dimensionFilters, UNMATCHABLE_INT_IDS));
                break;

            case MigrantStatus:
                queryBuilder.parameter("all_migrant_statuses", dimensionFilters.isEmpty())
                        .parameter("migrant_status_ids", nullOrEmptyToDefault(dimensionFilters, UNMATCHABLE_INT_IDS));
                break;
            case Section504:
                queryBuilder.parameter("all_section504s", dimensionFilters.isEmpty())
                        .parameter("section504_ids", nullOrEmptyToDefault(dimensionFilters, UNMATCHABLE_INT_IDS));
                break;

            case IEP:
                queryBuilder.parameter("all_ieps", dimensionFilters.isEmpty())
                        .parameter("iep_ids", nullOrEmptyToDefault(dimensionFilters, UNMATCHABLE_INT_IDS));
                break;

            case EconomicDisadvantage:
                queryBuilder.parameter("all_economic_disadvantages", dimensionFilters.isEmpty())
                        .parameter("economic_disadvantage_ids", nullOrEmptyToDefault(dimensionFilters, UNMATCHABLE_INT_IDS));
                break;
        }
    }
}
