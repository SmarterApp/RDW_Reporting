package org.opentestsystem.rdw.olap.sqlbuilder;

import com.google.common.collect.ImmutableList;
import org.opentestsystem.rdw.olap.model.Assessment;
import org.opentestsystem.rdw.olap.model.CodedEntity;
import org.opentestsystem.rdw.olap.model.Dimension;
import org.opentestsystem.rdw.olap.repository.ActiveAssessmentRepository;
import org.opentestsystem.rdw.olap.repository.BooleanRepository;
import org.opentestsystem.rdw.olap.repository.CodedEntityRepository;
import org.opentestsystem.rdw.olap.repository.EthnicityRepository;
import org.opentestsystem.rdw.olap.repository.GenderRepository;
import org.opentestsystem.rdw.olap.repository.OrganizationRepository;
import org.opentestsystem.rdw.olap.repository.StrictBooleanRepository;
import org.opentestsystem.rdw.olap.repository.SubjectRepository;
import org.opentestsystem.rdw.olap.sqlbuilder.QueryWithReportTemplate.Builder;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.model.ReportQuery;
import org.opentestsystem.rdw.reporting.common.sqlbuilder.QueryProvider;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;
import static org.opentestsystem.rdw.olap.sqlbuilder.QueryWithReportTemplate.builder;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.nullOrEmptyToDefault;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.EconomicDisadvantage;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Ethnicity;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Gender;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.IEP;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.LEP;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.MigrantStatus;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Overall;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Section504;

/**
 * This implementation is responsible for constructing a custom aggregate query.
 */
@Component
public class CustomAggregateQueryProvider implements ReportQueryProvider {
    private static final List<Integer> UNMATCHABLE_INT_IDS = ImmutableList.of(-1);

    private static final String customAggregateTemplateSql = "customAggregate";
    private static final String stateAddOn = "state";
    private static final String districtsAddOn = "districts";
    private static final String allDistrictsAddOn = "allDistricts";
    private static final String schoolsAddOn = "schools";
    private static final String allSchoolsInDistrictsAddOn = "allSchoolsInDistricts";

    private final Organization state;
    private final QueryProvider queryProvider;
    private final OrganizationRepository organizationRepository;
    private final ActiveAssessmentRepository activeAssessmentRepository;
    private final GenderRepository genderRepository;
    private final EthnicityRepository ethnicityRepository;
    private final BooleanRepository booleanRepository;
    private final StrictBooleanRepository strictBooleanRepository;
    private final SubjectRepository subjectRepository;

    @Autowired
    public CustomAggregateQueryProvider(@Value("${app.state.name}") final String stateName,
                                        final QueryProvider queryProvider,
                                        final OrganizationRepository organizationRepository,
                                        final ActiveAssessmentRepository activeAssessmentRepository,
                                        final GenderRepository genderRepository,
                                        final EthnicityRepository ethnicityRepository,
                                        final BooleanRepository booleanRepository,
                                        final StrictBooleanRepository strictBooleanRepository,
                                        final SubjectRepository subjectRepository) {
        this.queryProvider = queryProvider;
        this.organizationRepository = organizationRepository;
        this.activeAssessmentRepository = activeAssessmentRepository;
        this.genderRepository = genderRepository;
        this.ethnicityRepository = ethnicityRepository;
        this.booleanRepository = booleanRepository;
        this.strictBooleanRepository = strictBooleanRepository;
        this.subjectRepository = subjectRepository;

        state = Organization.builder().name(stateName).organizationType(OrganizationType.State).build();
    }

    public Iterable<QueryWithReportTemplate> toQuery(final ReportQuery query) {

        final List<QueryWithReportTemplate> queries = newArrayList();

        final Builder templateBuilder = toBuilderWithCommonAttributes(query);

        for (final DimensionType dimension : query.getDimensionTypes()) {

            final Builder dimensionTemplateBuilder = toBuilderWithFiltersAndDimensions(dimension, query).copy(templateBuilder);

            // build queries for each level of organization included into the query
            if (query.isIncludeState()) {
                queries.add(buildQuery(builder()
                        .addOn(stateAddOn)
                        .state(state)
                        .copy(dimensionTemplateBuilder)));
            }

            if (query.isIncludeAllDistricts()) {
                queries.add(buildQuery(builder()
                        .addOn(allDistrictsAddOn)
                        .districts(organizationRepository.findMapOfDistrictsByIds().values())
                        .copy(dimensionTemplateBuilder)));
            } else if (!query.getDistrictIds().isEmpty()) {
                queries.add(buildQuery(toBuilderWithDistrictIds(query.getDistrictIds()).
                        copy(dimensionTemplateBuilder)));
            }

            if (query.isIncludeAllSchoolsOfDistricts()) {
                queries.add(buildQuery(toBuilderWithAllSchoolsOfDistricts(query.getDistrictIds())
                        .copy(dimensionTemplateBuilder)));
            }

            if (query.isIncludeAllDistrictsOfSchools()) {
                //TODO:
            }


            if (!query.getSchoolIds().isEmpty()) {
                queries.add(buildQuery(toBuilderWithSchoolIds(query.getSchoolIds())
                        .copy(dimensionTemplateBuilder)));
            }

        }
        return queries;
    }

    /**
     * A single {@link ReportQuery} is converted to one or more {@link QueryWithReportTemplate}s, but some of the parameters are common for all of them.
     * This method created a {@link ReportQuery#builder()} initialized with these type of parameters.
     *
     * @param query the {@link ReportQuery}
     * @return {@link ReportQuery.Builder} initialized with the common parameters
     */
    private Builder toBuilderWithCommonAttributes(final ReportQuery query) {

        final Builder builder = builder()
                .parameter("school_years", query.getSchoolYears())
                .parameter("asmt_grade_ids", query.getAssessmentGradeIds())
                .parameter("subject_ids", query.getSubjectIds())
                .parameter("asmt_type_id", query.getAssessmentTypeId());


        for (final Assessment assessment : activeAssessmentRepository.findAllByTypeId(query.getAssessmentTypeId())) {
            if (query.getSchoolYears().contains(assessment.getExamSchoolYear())
                    && query.getSubjectIds().contains(toId(assessment.getSubjectCode(), subjectRepository))
                    && query.getAssessmentGradeIds().contains(assessment.getGradeId())) {
                builder.assessment(assessment);
            }
        }
        return builder;
    }

    private Builder toBuilderWithDistrictIds(final Set<Long> districtIds) {
        final Builder builder = builder()
                .addOn(allDistrictsAddOn)
                .addOn(districtsAddOn)
                .parameter("district_ids", districtIds);

        for (final Long districtId : districtIds) {
            if (organizationRepository.findMapOfDistrictsByIds().containsKey(districtId)) {
                builder.district(organizationRepository.findMapOfDistrictsByIds().get(districtId));
            }
        }
        return builder;
    }

    private Builder toBuilderWithAllSchoolsOfDistricts(final Set<Long> districtIds) {
        final Builder builder = builder()
                .addOn(allSchoolsInDistrictsAddOn)
                .parameter("school_district_ids", districtIds);

        for (final Long districtId : districtIds) {
            if (organizationRepository.findAllSchoolsByDistrictId().containsKey(districtId)) {
                builder.schools(organizationRepository.findAllSchoolsByDistrictId().get(districtId));
            }
        }
        return builder;
    }

    private Builder toBuilderWithSchoolIds(final Set<Long> schoolIds) {
        final Builder builder = builder()
                .addOn(schoolsAddOn)
                .parameter("school_ids", schoolIds);

        for (final Long schoolId : schoolIds) {
            if (organizationRepository.findMapOfSchoolsById().containsKey(schoolId)) {
                builder.school(organizationRepository.findMapOfSchoolsById().get(schoolId));
            }
        }
        return builder;
    }

    private QueryWithReportTemplate buildQuery(final Builder builder) {
        return builder.build(queryProvider, customAggregateTemplateSql);
    }

    private Builder toBuilderWithFiltersAndDimensions(final DimensionType dimensionType, final ReportQuery query) {
        final Builder queryBuilder = builder().addOn(dimensionType.name());

        if (!query.getCompletenessIds().isEmpty()) {
            queryBuilder
                    .addOn("completeness")
                    .parameter("completeness_ids", query.getCompletenessIds());
        }

        if (!query.getAdministrativeConditionIds().isEmpty()) {
            queryBuilder
                    .addOn("administration_condition")
                    .parameter("administration_condition_ids", query.getAdministrativeConditionIds());
        }

        addFilter(queryBuilder, Gender, query.getGenderIds(), dimensionType == Gender);
        addFilter(queryBuilder, Ethnicity, query.getEthnicityIds(), dimensionType == Ethnicity);
        addFilter(queryBuilder, LEP, query.getLepIds(), dimensionType == LEP);
        addFilter(queryBuilder, MigrantStatus, query.getMigrantStatusIds(), dimensionType == MigrantStatus);
        addFilter(queryBuilder, Section504, query.getSection504Ids(), dimensionType == Section504);
        addFilter(queryBuilder, IEP, query.getIepIds(), dimensionType == IEP);
        addFilter(queryBuilder, EconomicDisadvantage, query.getEconomicDisadvantageIds(), dimensionType == EconomicDisadvantage);

        switch (dimensionType) {
            case Overall:
                queryBuilder.dimension(new Dimension(null, Overall));
                break;
            case Gender:
                addDimension(queryBuilder, dimensionType, query.getGenderIds(), genderRepository);
                break;
            case Ethnicity:
                addDimension(queryBuilder, dimensionType, query.getEthnicityIds(), ethnicityRepository);
                break;
            case LEP:
                addDimension(queryBuilder, dimensionType, query.getLepIds(), strictBooleanRepository);
                break;
            case MigrantStatus:
                addDimension(queryBuilder, dimensionType, query.getMigrantStatusIds(), booleanRepository);
                break;
            case Section504:
                addDimension(queryBuilder, dimensionType, query.getSection504Ids(), booleanRepository);
                break;
            case IEP:
                addDimension(queryBuilder, dimensionType, query.getIepIds(), strictBooleanRepository);
                break;
            case EconomicDisadvantage:
                addDimension(queryBuilder, dimensionType, query.getEconomicDisadvantageIds(), strictBooleanRepository);
                break;
        }
        return queryBuilder;
    }

    private void addFilter(final Builder queryBuilder,
                           final DimensionType dimensionType,
                           final Set<Integer> dimensionFilters,
                           boolean isFilterSameAsDimension) {
        if (!isFilterSameAsDimension && !dimensionFilters.isEmpty()) {
            queryBuilder.addOn(dimensionType.name() + "_filter");
            addFilterParams(queryBuilder, dimensionType, dimensionFilters);
        }
    }

    private void addDimension(final Builder queryBuilder,
                              final DimensionType dimensionType,
                              final Set<Integer> dimensionFilters,
                              final CodedEntityRepository repository) {

        if (!dimensionFilters.isEmpty()) {
            queryBuilder.dimensions(repository.findAll().stream().filter(g -> dimensionFilters.contains(g.getId())).map(g -> new Dimension(g.getCode(), dimensionType)).collect(Collectors.toList()));
        } else {
            queryBuilder.dimensions(repository.findAll().stream().map(g -> new Dimension(g.getCode(), dimensionType)).collect(Collectors.toList()));
        }
        addFilterParams(queryBuilder, dimensionType, dimensionFilters);
    }

    private void addFilterParams(final Builder queryBuilder,
                                 final DimensionType dimensionType,
                                 final Set<Integer> dimensionFilters) {

        switch (dimensionType) {
            case Gender:
                queryBuilder.parameter("all_genders", dimensionFilters.isEmpty())
                        .parameter("gender_ids", nullOrEmptyToDefault(dimensionFilters, UNMATCHABLE_INT_IDS));
                break;
            case Ethnicity:
                queryBuilder.parameter("all_ethnicities", dimensionFilters.isEmpty())
                        .parameter("ethnicity_ids", nullOrEmptyToDefault(dimensionFilters, UNMATCHABLE_INT_IDS));
                break;

            case LEP:
                queryBuilder.parameter("all_leps", dimensionFilters.isEmpty())
                        .parameter("lep_ids", nullOrEmptyToDefault(dimensionFilters, UNMATCHABLE_INT_IDS));
                break;

            case MigrantStatus:
                queryBuilder.parameter("all_migrant_statuses", dimensionFilters.isEmpty())
                        .parameter("migrant_status_ids", nullOrEmptyToDefault(dimensionFilters, UNMATCHABLE_INT_IDS));
                break;
            case Section504:
                queryBuilder.parameter("all_section504s", dimensionFilters.isEmpty())
                        .parameter("section504_ids", nullOrEmptyToDefault(dimensionFilters, UNMATCHABLE_INT_IDS));
                break;

            case IEP:
                queryBuilder.parameter("all_ieps", dimensionFilters.isEmpty())
                        .parameter("iep_ids", nullOrEmptyToDefault(dimensionFilters, UNMATCHABLE_INT_IDS));
                break;

            case EconomicDisadvantage:
                queryBuilder.parameter("all_economic_disadvantages", dimensionFilters.isEmpty())
                        .parameter("economic_disadvantage_ids", nullOrEmptyToDefault(dimensionFilters, UNMATCHABLE_INT_IDS));
                break;
        }
    }

    private int toId(final String code, final CodedEntityRepository repository) {
        for (final CodedEntity e : repository.findAll()) {
            if (e.getCode().equals(code)) return e.getId();
        }
        throw new IllegalArgumentException("unable to find code " + code);
    }
}
