package org.opentestsystem.rdw.olap.sqlbuilder;

import com.google.common.collect.ImmutableList;
import org.opentestsystem.rdw.olap.sqlbuilder.QueryWithReportTemplate.Builder;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.model.ReportQuery;
import org.opentestsystem.rdw.reporting.common.sqlbuilder.QueryProvider;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Set;

import static com.google.common.collect.Lists.newArrayList;
import static java.util.stream.Collectors.toSet;
import static org.hibernate.validator.internal.util.CollectionHelper.newHashSet;
import static org.opentestsystem.rdw.olap.sqlbuilder.QueryWithReportTemplate.builder;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.nullOrEmptyToDefault;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.EconomicDisadvantage;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Ethnicity;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Gender;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.IEP;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.LEP;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.MigrantStatus;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Section504;
import static org.opentestsystem.rdw.reporting.common.model.ReportQuery.checkIsValid;

/**
 * This implementation is responsible for constructing a custom aggregate query.
 */
@Component
public class CustomAggregateQueryProvider implements ReportQueryProvider {
    private static final List<Integer> UNMATCHABLE_INT_IDS = ImmutableList.of(-1);

    private static final String customAggregateTemplateSql = "customAggregate";
    private static final String stateAddOn = "state";
    private static final String districtsAddOn = "districts";
    private static final String allDistrictsAddOn = "allDistricts";
    private static final String schoolsAddOn = "schools";
    private static final String allSchoolsInDistrictsAddOn = "allSchoolsInDistricts";

    private final Organization state;
    private final QueryProvider queryProvider;
    private final ReportQueryRepositoryHelper repositoryHelper;

    @Autowired
    public CustomAggregateQueryProvider(@Value("${app.state.name}") final String stateName,
                                        final QueryProvider queryProvider,
                                        final ReportQueryRepositoryHelper repositoryHelper) {
        this.queryProvider = queryProvider;
        this.repositoryHelper = repositoryHelper;

        state = Organization.builder().name(stateName).organizationType(OrganizationType.State).build();
    }

    public Iterable<QueryWithReportTemplate> toQuery(final ReportQuery query) {
        checkIsValid(query);

        final Builder templateBuilder = toBuilderWithCommonAttributes(query);

        final List<QueryWithReportTemplate> queries = newArrayList();
        for (final DimensionType dimension : query.getDimensionTypes()) {
            final Builder dimensionTemplateBuilder = toBuilderWithFiltersAndDimensions(dimension, query).copy(templateBuilder);
            appendState(query, queries, dimensionTemplateBuilder);
            appendDistricts(query, queries, dimensionTemplateBuilder);
            appendSchools(query, queries, dimensionTemplateBuilder);
        }
        return queries;
    }

    private void appendState(final ReportQuery query, final List<QueryWithReportTemplate> queries, final Builder dimensionTemplateBuilder) {
        if (query.isIncludeState()) {
            queries.add(buildQuery(builder().addOn(stateAddOn).state(state).copy(dimensionTemplateBuilder)));
        }
    }

    private void appendDistricts(final ReportQuery query, final List<QueryWithReportTemplate> queries, final Builder dimensionTemplateBuilder) {
        if (query.isIncludeAllDistricts()) {
            queries.add(buildQuery(builder().addOn(allDistrictsAddOn).districts(repositoryHelper.findAllDistricts()).copy(dimensionTemplateBuilder)));
        } else if (!query.getDistrictIds().isEmpty() || query.isIncludeAllDistrictsOfSchools()) {
            queries.add(buildQuery(toBuilderWithDistrictIds(query).copy(dimensionTemplateBuilder)));
        }
    }

    private void appendSchools(final ReportQuery query, final List<QueryWithReportTemplate> queries, final Builder dimensionTemplateBuilder) {
        //schools could be selected individually or as part of a district selection
        final Set<Long> districtsWithAllSchools = newHashSet();
        if (query.isIncludeAllSchoolsOfDistricts()) {
            districtsWithAllSchools.addAll(query.isIncludeAllDistricts() ? repositoryHelper.findAllDistrictIds() : query.getDistrictIds());
            queries.add(buildQuery(toBuilderWithAllSchoolsOfDistricts(districtsWithAllSchools).copy(dimensionTemplateBuilder)));
        }

        if (!query.getSchoolIds().isEmpty()) {
            //to avoid duplicate schools we need to filter those that are already included as part of districts selection
            Set<Long> schoolIds = query.getSchoolIds();
            if (query.isIncludeAllSchoolsOfDistricts()) {
                final Set<Long> schoolsIncludedAsAllOfDistricts = repositoryHelper.findSchoolsIdsByDistrictIds(districtsWithAllSchools);
                schoolIds = schoolIds.stream().filter(s -> !schoolsIncludedAsAllOfDistricts.contains(s)).collect(toSet());
            }
            if (!schoolIds.isEmpty()) queries.add(buildQuery(toBuilderWithSchoolIds(schoolIds).copy(dimensionTemplateBuilder)));
        }
    }

    /**
     * A single {@link ReportQuery} is converted to one or more {@link QueryWithReportTemplate}s, but some of the parameters are common for all of them.
     * This method created a {@link ReportQuery#builder()} initialized with these type of parameters.
     *
     * @param query the {@link ReportQuery}
     * @return {@link ReportQuery.Builder} initialized with the common parameters
     */
    private Builder toBuilderWithCommonAttributes(final ReportQuery query) {
        return builder()
                .parameter("school_years", query.getSchoolYears())
                .parameter("asmt_grade_ids", query.getAssessmentGradeIds())
                .parameter("subject_ids", query.getSubjectIds())
                .parameter("asmt_type_id", query.getAssessmentTypeId())
                .assessments(repositoryHelper.findAssessmentsForQuery(query));
    }

    private Builder toBuilderWithDistrictIds(final ReportQuery query) {
        final Set<Long> districtIds = newHashSet(query.getDistrictIds());
        if (query.isIncludeAllDistrictsOfSchools()) districtIds.addAll(repositoryHelper.findAllDistrictsOfSchools(query.getSchoolIds()));
        return builder()
                .addOn(allDistrictsAddOn)
                .addOn(districtsAddOn)
                .parameter("district_ids", districtIds)
                .districts(repositoryHelper.findDistrictsByIds(districtIds));
    }

    private Builder toBuilderWithAllSchoolsOfDistricts(final Set<Long> districtIds) {
        return builder()
                .addOn(allSchoolsInDistrictsAddOn)
                .parameter("school_district_ids", districtIds)
                .schools(repositoryHelper.findSchoolsByDistrictIds(districtIds));
    }

    private Builder toBuilderWithSchoolIds(final Set<Long> schoolIds) {
        return builder()
                .addOn(schoolsAddOn)
                .parameter("school_ids", schoolIds)
                .schools(repositoryHelper.findSchoolsByIds(schoolIds));
    }

    private QueryWithReportTemplate buildQuery(final Builder builder) {
        return builder.build(queryProvider, customAggregateTemplateSql);
    }

    private Builder toBuilderWithFiltersAndDimensions(final DimensionType dimensionType, final ReportQuery query) {
        final Builder queryBuilder = builder().addOn(dimensionType.name());

        if (!query.getCompletenessIds().isEmpty()) {
            queryBuilder
                    .addOn("completeness")
                    .parameter("completeness_ids", query.getCompletenessIds());
        }

        if (!query.getAdministrativeConditionIds().isEmpty()) {
            queryBuilder
                    .addOn("administration_condition")
                    .parameter("administration_condition_ids", query.getAdministrativeConditionIds());
        }

        addFilter(queryBuilder, Gender, query.getGenderIds(), dimensionType == Gender);
        addFilter(queryBuilder, Ethnicity, query.getEthnicityIds(), dimensionType == Ethnicity);
        addFilter(queryBuilder, LEP, query.getLepIds(), dimensionType == LEP);
        addFilter(queryBuilder, MigrantStatus, query.getMigrantStatusIds(), dimensionType == MigrantStatus);
        addFilter(queryBuilder, Section504, query.getSection504Ids(), dimensionType == Section504);
        addFilter(queryBuilder, IEP, query.getIepIds(), dimensionType == IEP);
        addFilter(queryBuilder, EconomicDisadvantage, query.getEconomicDisadvantageIds(), dimensionType == EconomicDisadvantage);

        queryBuilder.dimensions(repositoryHelper.findDimensionsByTypeAndQueryFilters(dimensionType, query));

        switch (dimensionType) {
            case Gender:
                addFilterParams(queryBuilder, dimensionType, query.getGenderIds());
                break;
            case Ethnicity:
                addFilterParams(queryBuilder, dimensionType, query.getEthnicityIds());
                break;
            case LEP:
                addFilterParams(queryBuilder, dimensionType, query.getLepIds());
                break;
            case MigrantStatus:
                addFilterParams(queryBuilder, dimensionType, query.getMigrantStatusIds());
                break;
            case Section504:
                addFilterParams(queryBuilder, dimensionType, query.getSection504Ids());
                break;
            case IEP:
                addFilterParams(queryBuilder, dimensionType, query.getIepIds());
                break;
            case EconomicDisadvantage:
                addFilterParams(queryBuilder, dimensionType, query.getEconomicDisadvantageIds());
                break;
        }
        return queryBuilder;
    }

    private void addFilter(final Builder queryBuilder,
                           final DimensionType dimensionType,
                           final Set<Integer> dimensionFilters,
                           boolean isFilterSameAsDimension) {
        if (!isFilterSameAsDimension && !dimensionFilters.isEmpty()) {
            queryBuilder.addOn(dimensionType.name() + "_filter");
            addFilterParams(queryBuilder, dimensionType, dimensionFilters);
        }
    }

    private void addFilterParams(final Builder queryBuilder,
                                 final DimensionType dimensionType,
                                 final Set<Integer> dimensionFilters) {

        switch (dimensionType) {
            case Gender:
                queryBuilder.parameter("all_genders", dimensionFilters.isEmpty())
                        .parameter("gender_ids", nullOrEmptyToDefault(dimensionFilters, UNMATCHABLE_INT_IDS));
                break;
            case Ethnicity:
                queryBuilder.parameter("all_ethnicities", dimensionFilters.isEmpty())
                        .parameter("ethnicity_ids", nullOrEmptyToDefault(dimensionFilters, UNMATCHABLE_INT_IDS));
                break;

            case LEP:
                queryBuilder.parameter("all_leps", dimensionFilters.isEmpty())
                        .parameter("lep_ids", nullOrEmptyToDefault(dimensionFilters, UNMATCHABLE_INT_IDS));
                break;

            case MigrantStatus:
                queryBuilder.parameter("all_migrant_statuses", dimensionFilters.isEmpty())
                        .parameter("migrant_status_ids", nullOrEmptyToDefault(dimensionFilters, UNMATCHABLE_INT_IDS));
                break;
            case Section504:
                queryBuilder.parameter("all_section504s", dimensionFilters.isEmpty())
                        .parameter("section504_ids", nullOrEmptyToDefault(dimensionFilters, UNMATCHABLE_INT_IDS));
                break;

            case IEP:
                queryBuilder.parameter("all_ieps", dimensionFilters.isEmpty())
                        .parameter("iep_ids", nullOrEmptyToDefault(dimensionFilters, UNMATCHABLE_INT_IDS));
                break;

            case EconomicDisadvantage:
                queryBuilder.parameter("all_economic_disadvantages", dimensionFilters.isEmpty())
                        .parameter("economic_disadvantage_ids", nullOrEmptyToDefault(dimensionFilters, UNMATCHABLE_INT_IDS));
                break;
        }
    }
}
