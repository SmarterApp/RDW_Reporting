package org.opentestsystem.rdw.olap.service.impl;

import org.opentestsystem.rdw.olap.model.AggregateReportQueryDescription;
import org.opentestsystem.rdw.olap.model.OrganizationTypeQuery;
import org.opentestsystem.rdw.olap.service.AggregateQueryConverter;
import org.opentestsystem.rdw.olap.sqlbuilder.impl.QueryProviderRepositoryHelper;
import org.opentestsystem.rdw.reporting.common.model.AbstractAggregateReportQuery;
import org.opentestsystem.rdw.reporting.common.model.AbstractSubgroupedAggregateReportQuery;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.model.StudentFilters;

import java.util.Collection;
import java.util.List;
import java.util.Set;

import static com.google.common.collect.Lists.newArrayList;
import static org.hibernate.validator.internal.util.CollectionHelper.newHashSet;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Overall;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.District;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.State;

/**
 * TODO does any of this really apply to a target report?
 * should we try to separate it out into a separate converter base?
 *
 * This class represents common methods shared by all implementations of {@link AggregateQueryConverter}
 */
@SuppressWarnings("unchecked")
abstract class AbstractQueryConverter<Q extends AbstractAggregateReportQuery, T extends OrganizationTypeQuery, B extends OrganizationTypeQuery.Builder>
        implements AggregateQueryConverter<Q, T> {

    private final QueryProviderRepositoryHelper repositoryHelper;

    /**
     * Constructor
     */
    AbstractQueryConverter(final QueryProviderRepositoryHelper repositoryHelper) {
        this.repositoryHelper = repositoryHelper;
    }

    @Override
    public Collection<AggregateReportQueryDescription<T>> convert(final Q query) {
        return query.isFilteredSubgroupQuery()
                ? convertFilteredSubgroupsQuery((AbstractSubgroupedAggregateReportQuery) query)
                : convertBasicQuery(query);

    }

    private Collection<AggregateReportQueryDescription<T>> convertBasicQuery(final Q reportQueryToCovert) {
        final List<AggregateReportQueryDescription<T>> queries = newArrayList();

        //convert queries to a single subject query if needed
        for (final Q reportQuery : unwrapToSupportedQueries(reportQueryToCovert)) {

            // some attributes are the same for all the queries
            final B commonQueryBuilder = toOrganizationQueryBuilderWithCommonAttributes(reportQuery, reportQuery.getStudentFilters());

            //each pair of organization/dimension is represented by a separate OrganizationTypeQuery
            for (final DimensionType dimension : reportQuery.getDimensionTypes()) {
                queries.addAll(buildOrganizationQueries(reportQuery, (T) commonQueryBuilder.dimensionType(dimension).build()));
            }
        }
        return queries;
    }

    private Collection<AggregateReportQueryDescription<T>> convertFilteredSubgroupsQuery(final AbstractSubgroupedAggregateReportQuery reportQueryToCovert) {
        final List<AggregateReportQueryDescription<T>> queries = newArrayList();

        //convert queries to a single subject query if needed
        for (final Q query : unwrapToSupportedQueries((Q) reportQueryToCovert)) {
            final AbstractSubgroupedAggregateReportQuery subgroupedQuery = (AbstractSubgroupedAggregateReportQuery) query;
            //each pair of organization/dimension is represented by a separate OrganizationTypeQuery
            for (final String subgroupsKey : subgroupedQuery.getSubgroups().keySet()) {
                queries.addAll(buildOrganizationQueries(query,
                        (T) toOrganizationQueryBuilderWithCommonAttributes(query, subgroupedQuery.getSubgroups().get(subgroupsKey))
                                .subgroupKey(subgroupsKey)
                                .dimensionType(Overall)
                                .build()));
            }
        }
        return queries;
    }

    private List<AggregateReportQueryDescription<T>> buildOrganizationQueries(final Q query, final T commonQuery) {
        final List<AggregateReportQueryDescription<T>> queries = newArrayList();
        // for each level of organization add one or more builders to the result
        if (query instanceof AbstractSubgroupedAggregateReportQuery) {
            appendState((AbstractSubgroupedAggregateReportQuery) query, queries, commonQuery);
        }
        appendDistricts(query, queries, commonQuery);
        appendSchools(query, queries, commonQuery);
        return queries;
    }

    /**
     * @return an instance of the {@link OrganizationTypeQuery.Builder} pre-loaded with the query specific attributes
     */
    protected abstract B getOrganizationTypeQueryBuilder(Q reportQuery, StudentFilters filters);

    /**
     * By default the query is returned as is, but it allows each implementation
     * to provide their customizations. For example, see {@link LongitudinalQueryConverter#unwrapToSupportedQueries(AbstractAggregateReportQuery)}
     */
    protected List<Q> unwrapToSupportedQueries(final Q reportQuery) {
        return newArrayList(reportQuery);
    }

    /**
     * A report query is converted into multiple instances of {@link OrganizationTypeQuery}: one per dimension or subgroup, and organization combination.
     * But some of the attributes are the same for all of the output {@link OrganizationTypeQuery}s. This method returns an {@link OrganizationTypeQuery.Builder}
     * pre-loaded with the common attributes.
     *
     * @param reportQuery the query to get the common attributes from
     * @param filters     the filters to add to the common attributes
     * @return {@link OrganizationTypeQuery.Builder} pre-loaded with the common attributes
     */
    private B toOrganizationQueryBuilderWithCommonAttributes(final Q reportQuery, final StudentFilters filters) {
        return (B) getOrganizationTypeQueryBuilder(reportQuery, filters)
                .assessmentTypeCode(reportQuery.getAssessmentTypeCode())
                .completenessCodes(reportQuery.getCompletenessCodes())
                .administrativeConditionCodes(reportQuery.getAdministrativeConditionCodes())
                .genderCodes(filters.getGenderCodes())
                .ethnicityCodes(filters.getEthnicityCodes())
                .lepCodes(filters.getLepCodes())
                .elasCodes(filters.getElasCodes())
                .languageCodes(filters.getLanguageCodes())
                .militaryConnectedCodes(filters.getMilitaryConnectedCodes())
                .migrantStatusCodes(filters.getMigrantStatusCodes())
                .section504Codes(filters.getSection504Codes())
                .iepCodes(filters.getIepCodes())
                .economicDisadvantageCodes(filters.getEconomicDisadvantageCodes());
    }

    /**
     * If the given instance of the reportQuery includes state, a new {@link AggregateReportQueryDescription} is appended to the given queries list
     *
     * @param query       the instance of {@link AbstractAggregateReportQuery}
     * @param queries     the list of {@link AggregateReportQueryDescription} to add a new description if needed
     * @param commonQuery the common attributes to be included into a newly built AggregateReportQueryDescription's query
     */
    private void appendState(final AbstractSubgroupedAggregateReportQuery query,
                             final List<AggregateReportQueryDescription<T>> queries,
                             final T commonQuery) {
        if (query.isIncludeState()) {
            queries.add(new AggregateReportQueryDescription(commonQuery.copy().organizationType(State).build(), State));
        }
    }

    /**
     * If the given instance of the reportQuery includes districts, a new {@link AggregateReportQueryDescription} is appended to the given queries list
     *
     * @param reportQuery the instance of {@link AbstractAggregateReportQuery}
     * @param queries     the list of {@link AggregateReportQueryDescription} to add a new description if needed
     * @param commonQuery the common attributes to be included into a newly built AggregateReportQueryDescription's query
     */
    private void appendDistricts(final Q reportQuery,
                                 final List<AggregateReportQueryDescription<T>> queries,
                                 final T commonQuery) {

        if (reportQuery instanceof AbstractSubgroupedAggregateReportQuery
                && ((AbstractSubgroupedAggregateReportQuery) reportQuery).isIncludeAllDistricts()) {
            final T query = (T) commonQuery.copy()
                    .organizationType(State)
                    .build();

            queries.add(new AggregateReportQueryDescription(query, District));

        } else if (!reportQuery.getDistrictIds().isEmpty() || isIncludeAllDistrictsOfSchools(reportQuery)) {
            //individual districts could be included two ways: by ids or via 'isIncludeAllDistrictsOfSchools' flag
            final Set<Long> districtIds = newHashSet(reportQuery.getDistrictIds());
            if (isIncludeAllDistrictsOfSchools(reportQuery)) {
                districtIds.addAll(repositoryHelper.findAllDistrictsOfSchools(reportQuery.getSchoolIds()));
            }

            if (!districtIds.isEmpty()) {
                final T query = (T) commonQuery
                        .copy()
                        .organizationType(District)
                        .organizationIds(districtIds)
                        .build();
                queries.add(new AggregateReportQueryDescription(query, District));
            }
        }
    }

    /**
     * If the given instance of the reportQuery includes schools, a new {@link AggregateReportQueryDescription} is appended to the given queries list
     *
     * @param reportQuery the instance of {@link AbstractAggregateReportQuery}
     * @param queries     the list of {@link AggregateReportQueryDescription} to add a new description if needed
     * @param commonQuery the common attributes to be included into a newly built AggregateReportQueryDescription's query
     */
    private void appendSchools(final Q reportQuery, final List<AggregateReportQueryDescription<T>> queries, final T commonQuery) {
        //schools could be selected individually or as part of a district selection
        final Set<Long> districtsWithAllSchools = newHashSet();
        if (isIncludeAllSchoolsOfDistricts(reportQuery)) {
            final Set<Long> districtIds = reportQuery instanceof AbstractSubgroupedAggregateReportQuery
                    && ((AbstractSubgroupedAggregateReportQuery) reportQuery).isIncludeAllDistricts()
                    ? repositoryHelper.findAllDistrictIds()
                    : reportQuery.getDistrictIds();
            districtsWithAllSchools.addAll(districtIds);

            if (!districtsWithAllSchools.isEmpty()) {
                final T query = (T) commonQuery
                        .copy()
                        .organizationType(District)
                        .organizationIds(districtsWithAllSchools)
                        .build();

                queries.add(new AggregateReportQueryDescription(query, OrganizationType.School));
            }
        }

        if (!reportQuery.getSchoolIds().isEmpty()) {
            final Set<Long> schoolIds = newHashSet(reportQuery.getSchoolIds());

            //to avoid duplicate schools we need to filter those that are already included as part of districts selection
            if (isIncludeAllSchoolsOfDistricts(reportQuery)) {
                schoolIds.removeAll(repositoryHelper.findSchoolsIdsByDistrictIds(districtsWithAllSchools));
            }

            if (!schoolIds.isEmpty()) {
                final T query = (T) commonQuery
                        .copy()
                        .organizationType(OrganizationType.School)
                        .organizationIds(schoolIds)
                        .build();

                queries.add(new AggregateReportQueryDescription(query, OrganizationType.School));
            }
        }
    }

    private boolean isIncludeAllSchoolsOfDistricts(final AbstractAggregateReportQuery query) {
        if (!(query instanceof AbstractSubgroupedAggregateReportQuery)) {
            return false;
        }
        final AbstractSubgroupedAggregateReportQuery subgroupedQuery = (AbstractSubgroupedAggregateReportQuery) query;
        return subgroupedQuery.isIncludeAllSchoolsOfDistricts()
                && (!query.getDistrictIds().isEmpty() || subgroupedQuery.isIncludeAllDistricts());
    }

    private boolean isIncludeAllDistrictsOfSchools(final AbstractAggregateReportQuery query) {
        if (!(query instanceof AbstractSubgroupedAggregateReportQuery)) {
            return false;
        }
        final AbstractSubgroupedAggregateReportQuery subgroupedQuery = (AbstractSubgroupedAggregateReportQuery) query;
        return subgroupedQuery.isIncludeAllDistrictsOfSchools() && !query.getSchoolIds().isEmpty();
    }
}
