package org.opentestsystem.rdw.olap.model;

import org.opentestsystem.rdw.reporting.common.model.TargetReportQuery;
import org.opentestsystem.rdw.reporting.common.model.TargetRow;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.Map;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;

/**
 * An instance of {@link AggregateRowReportResult} containing {@link TargetRow}s.
 * <p>
 * This report is produced in response to the {@link TargetReportQuery}.
 * <p>
 * As part of a target row we are returning the exams' average scale score and standard error.
 * To avoid an extra call to Redshift we are deriving this data for each target in the same SQL statement as
 * target report. If all targets have scores and therefore are present in the underlying table,
 * the exams's average scale score and standard error are the same for every row.
 * This is an expected behaviour. Since we have no way to enforce that all targets are scored,
 * we are comparing exam counts for each row. If the values are different, we replace them
 * with the one that has the highest student count.
 * <p>
 * Target report is for a Summative assessment, one organization, subject and grade. Based on the rules of
 * Summative assessments, it is expected to have only one assessment in the returned report.
 * However, once again, since we have no way to enforce it, we are capturing a row with max exam count per assessment.
 */
@SuppressWarnings("unchecked")
public class TargetReportResult extends AggregateRowReportResult<TargetRow> {
    private static final Logger logger = LoggerFactory.getLogger(TargetReportResult.class);

    public static Builder builder() {
        return new Builder();
    }

    @Override
    public Builder copy() {
        return builder().merge(this);
    }

    public static class Builder extends AggregateRowReportResult.Builder<TargetRow, TargetReportResult.Builder, TargetReportResult> {

        @Override
        protected TargetReportResult createInstance() {
            return new TargetReportResult();
        }

        @Override
        public TargetReportResult build() {

            final Map<Integer, TargetRow> rowsWithMaxStudentCountByAsmtId = newHashMap();
            if (!isInconsistentExamCount(rowsWithMaxStudentCountByAsmtId)) return super.build();

            logger.warn("detected inconsistent target scoring");

            final List<TargetRow> updatedRows = newArrayList();
            for (final TargetRow row : rows) {
                final TargetRow rowWithMaxStudentCount = rowsWithMaxStudentCountByAsmtId.get(row.getAssessment().getId());
                updatedRows.add(row.copy()
                        .measures(rowWithMaxStudentCount.getMeasures())
                        .build());
            }
            this.rows = updatedRows;
            return super.build();
        }

        private boolean isInconsistentExamCount(final Map<Integer, TargetRow> rowsWithMaxStudentCountByAsmtId) {

            boolean inconsistentExamCount = false;

            for (final TargetRow row : rows) {
                final int assessmentId = row.getAssessment().getId();
                if (rowsWithMaxStudentCountByAsmtId.containsKey(assessmentId)) {

                    final TargetRow rowWithMaxStudentCount = rowsWithMaxStudentCountByAsmtId.get(assessmentId);

                    inconsistentExamCount |= (row.getMeasures().getStudentCount() != rowWithMaxStudentCount.getMeasures().getStudentCount());
                    if (row.getMeasures().getStudentCount() > rowWithMaxStudentCount.getMeasures().getStudentCount()) {
                        rowsWithMaxStudentCountByAsmtId.put(assessmentId, row);
                    }

                } else {
                    rowsWithMaxStudentCountByAsmtId.put(assessmentId, row);
                }
            }
            return inconsistentExamCount;
        }
    }
}