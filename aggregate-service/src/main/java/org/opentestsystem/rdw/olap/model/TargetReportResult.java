package org.opentestsystem.rdw.olap.model;

import org.opentestsystem.rdw.reporting.common.model.TargetReportQuery;
import org.opentestsystem.rdw.reporting.common.model.TargetRow;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.Map;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;

/**
 * An instance of {@link AggregateRowReportResult} containing {@link TargetRow}s.
 * <p>
 * This report is produced in response to the {@link TargetReportQuery}.
 * <p>
 * As part of a target row we are returning the exams' average scale score and standard error.
 * To avoid an extra call to Redshift we are deriving this data for each target in the same SQL statement as
 * target report. If all targets have scores and therefore are present in the underlying table,
 * the exams's average scale score and standard error are the same for every row.
 * This is an expected behaviour. Since we have no way to enforce that all targets are scored,
 * we are comparing exam counts for each row. If the values are different, we replace them
 * with the one that has the highest exam count.
 * <p>
 * Target report is for a Summative assessment, one organization, subject and grade. Based on the rules of
 * Summative assessments, it is expected to have only one assessment in the returned report.
 * However, once again, since we have no way to enforce it, we are capturing a row with max exam count per assessment.
 */
@SuppressWarnings("unchecked")
public class TargetReportResult extends AggregateRowReportResult<TargetRow> {
    private static final Logger logger = LoggerFactory.getLogger(TargetReportResult.class);

    public static Builder builder() {
        return new Builder();
    }

    @Override
    public Builder copy() {
        return builder().merge(this);
    }

    public static class Builder extends AggregateRowReportResult.Builder<TargetRow, TargetReportResult.Builder, TargetReportResult> {

        private Map<Integer, TargetRow> rowsWithMaxExamCountByAsmtId = newHashMap();
        private boolean inconsistentExamCount = false;

        @Override
        protected TargetReportResult createInstance() {
            return new TargetReportResult();
        }

        public TargetReportResult build() {

            if (!inconsistentExamCount) return super.build();

            logger.warn("ADITS - Aggregate Detection of Inconsistent Target Scoring!");
            final List<TargetRow> updatedRows = newArrayList();
            for (final TargetRow row : rows) {
                final TargetRow rowWithMaxExamCount = rowsWithMaxExamCountByAsmtId.get(row.getAssessment().getId());
                updatedRows.add(row.copy()
                        .measures(rowWithMaxExamCount.getMeasures())
                        .examCount(rowWithMaxExamCount.getExamCount())
                        .build());
            }
            this.rows = updatedRows;
            return super.build();
        }

        @Override
        public Builder row(final TargetRow row) {
            super.row(row);

            final int assessmentId = row.getAssessment().getId();
            final TargetRow rowWithMaxExamCount = rowsWithMaxExamCountByAsmtId.putIfAbsent(assessmentId, row);

            if (rowWithMaxExamCount != null) {
                inconsistentExamCount = (inconsistentExamCount || row.getExamCount() == rowWithMaxExamCount.getExamCount());

                if (row.getExamCount() > rowWithMaxExamCount.getExamCount()) {
                    rowsWithMaxExamCountByAsmtId.replace(assessmentId, row);
                }
            }
            return this;
        }
    }
}