package org.opentestsystem.rdw.olap.model;

import org.opentestsystem.rdw.reporting.common.model.TargetReportQuery;
import org.opentestsystem.rdw.reporting.common.model.TargetRow;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.Map;
import java.util.Objects;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;

/**
 * An instance of {@link AggregateRowReportResult} containing {@link TargetRow}s.
 * <p>
 * This report is produced in response to the {@link TargetReportQuery}.
 * <p>
 * As part of a target row we are returning the students exams' average scale score and standard error.
 * To avoid an extra call to Redshift we are deriving this data for each target in the same SQL statement as
 * target report. If all targets have scores and therefore are present in the underlying table,
 * the exams's average scale score and standard error are the same for every row.
 * This is an expected behaviour. Since we have no way to enforce that all targets are scored,
 * we are comparing student/exams measures for each row. If the values are different, we replace them
 * with the one that has the highest student count.
 * <p>
 */
@SuppressWarnings("unchecked")
public class TargetReportResult extends AggregateRowReportResult<TargetRow> {
    private static final Logger logger = LoggerFactory.getLogger(TargetReportResult.class);

    public static Builder builder() {
        return new Builder();
    }

    @Override
    public Builder copy() {
        return builder().merge(this);
    }

    public static class Builder extends AggregateRowReportResult.Builder<TargetRow, TargetReportResult.Builder, TargetReportResult> {

        @Override
        protected TargetReportResult createInstance() {
            return new TargetReportResult();
        }

        @Override
        public TargetReportResult build() {

            final Map<ReportRowIdentity, TargetRow> rowsWithMaxStudentCount = newHashMap();
            if (!isInconsistentMeasures(rowsWithMaxStudentCount)) return super.build();

            logger.warn("detected inconsistent target scoring");

            final List<TargetRow> updatedRows = newArrayList();
            for (final TargetRow row : rows) {
                final TargetRow rowWithMaxStudentCount = rowsWithMaxStudentCount.get(new ReportRowIdentity(row, false));
                updatedRows.add(row.copy()
                        .measures(rowWithMaxStudentCount.getMeasures())
                        .build());
            }
            this.rows = updatedRows;
            return super.build();
        }

        /**
         * To find inconsistencies in the exam/student count we are using {@link ReportRowIdentity} and not {@link TargetRowIdentity}
         * since the exam count should be the same for all targets.
         */
        private boolean isInconsistentMeasures(final Map<ReportRowIdentity, TargetRow> rowsWithMaxStudentCount) {

            boolean isInconsistentMeasures = false;

            for (final TargetRow row : rows) {
                final ReportRowIdentity rowIdentity = new ReportRowIdentity(row, false);

                if (rowsWithMaxStudentCount.containsKey(rowIdentity)) {

                    final TargetRow rowWithMaxStudentCount = rowsWithMaxStudentCount.get(rowIdentity);

                    isInconsistentMeasures |= !Objects.equals(row.getMeasures(), rowWithMaxStudentCount.getMeasures());

                    if (row.getMeasures().getStudentCount() > rowWithMaxStudentCount.getMeasures().getStudentCount()) {
                        rowsWithMaxStudentCount.put(rowIdentity, row);
                    }

                } else {
                    rowsWithMaxStudentCount.put(rowIdentity, row);
                }
            }
            return isInconsistentMeasures;
        }
    }
}