package org.opentestsystem.rdw.olap.service.impl;

import org.opentestsystem.rdw.olap.AggregateReportSettings;
import org.opentestsystem.rdw.olap.model.BasicAggregateReportResult;
import org.opentestsystem.rdw.olap.model.OrganizationTypeQuery;
import org.opentestsystem.rdw.olap.repository.CustomAggregateReportRepository;
import org.opentestsystem.rdw.olap.service.AuthorizationService;
import org.opentestsystem.rdw.olap.service.BasicAggregateService;
import org.opentestsystem.rdw.olap.sqlbuilder.QueryProviderRepositoryHelper;
import org.opentestsystem.rdw.reporting.common.model.AbstractAggregateReportQuery;
import org.opentestsystem.rdw.reporting.common.model.AggregateQuery;
import org.opentestsystem.rdw.reporting.common.model.BasicAggregateReportQuery;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.model.StudentFilters;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.task.TaskExecutor;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.collect.Lists.newArrayList;
import static java.util.stream.Collectors.toList;
import static org.hibernate.validator.internal.util.CollectionHelper.newHashSet;
import static org.opentestsystem.rdw.reporting.common.model.AggregateQueryType.Basic;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Overall;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.District;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.State;

/**
 * Default implementation of an {@link BasicAggregateService} backed by a repository
 */
@Service
class DefaultBasicAggregateService implements BasicAggregateService {

    private final CustomAggregateReportRepository repository;
    private final AuthorizationService authorizationService;
    private final Set<String> stateAggregateAssessmentTypes;
    private final QueryProviderRepositoryHelper repositoryHelper;
    private final Executor threadPoolTaskExecutor;

    @Autowired
    DefaultBasicAggregateService(
            final CustomAggregateReportRepository repository,
            final AuthorizationService authorizationService,
            final AggregateReportSettings settings,
            final QueryProviderRepositoryHelper repositoryHelper,
            final TaskExecutor threadPoolTaskExecutor) {
        this.repository = repository;
        this.authorizationService = authorizationService;
        this.repositoryHelper = repositoryHelper;
        this.threadPoolTaskExecutor = threadPoolTaskExecutor;
        stateAggregateAssessmentTypes = settings.getStateAggregateAssessmentTypes();
    }

    @Override
    public boolean handles(final AggregateQuery query) {
        return Basic.equals(query.getQueryType());
    }

    @Override
    public BasicAggregateReportResult findByQuery(final User user, final BasicAggregateReportQuery query) {
        authorizationService.checkAuthorization(user, query);

        final BasicAggregateReportQuery validQuery = checkIsValid(ensureDimension(query, Overall));

        // repository is able to support a query for one level of organization and one dimension type
        // to improve the response time for the report we run these queries in parallel
        final List<BasicAggregateReportResult> reports = convertToOrganizationTypeQueries(validQuery)
                .stream()
                .map(q -> new RunQueryTask(q, repository, user))
                .map(t -> CompletableFuture.supplyAsync(t::run, threadPoolTaskExecutor))
                .map(CompletableFuture::join)
                .collect(toList());

        final BasicAggregateReportResult.Builder mergedReportBuilder = BasicAggregateReportResult.builder();
        for (final BasicAggregateReportResult report : reports) {
            mergedReportBuilder.merge(report);
        }
        return mergedReportBuilder.build();
    }

    @Override
    public int estimateReportRowCount(final User user, final BasicAggregateReportQuery query) {
        authorizationService.checkAuthorization(user, query);

        final BasicAggregateReportQuery validQuery = checkIsValid(ensureDimension(query, Overall));

        return convertToOrganizationTypeQueries(validQuery)
                .stream()
                .mapToInt(q -> repository.estimateReportRowCountByOrganizationType(q.getQuery(), q.getResultType()))
                .sum();
    }

    private List<OrganizationTypeQueryDescription> convertToOrganizationTypeQueries(final BasicAggregateReportQuery reportQuery) {
        final List<OrganizationTypeQueryDescription> queries = newArrayList();

        // some attributes are the same for all the queries
        final OrganizationTypeQuery.Builder commonQueryBuilder = toQueryBuilderWithCommonAttributes(reportQuery);

        //each pair of organization/dimension is represented by a separate OrganizationTypeQuery
        for (final DimensionType dimension : reportQuery.getDimensionTypes()) {
            final OrganizationTypeQuery commonQuery = commonQueryBuilder.dimensionType(dimension).build();

            // for each level of organization add one or more builders to the result
            appendState(reportQuery, queries, commonQuery);
            appendDistricts(reportQuery, queries, commonQuery);
            appendSchools(reportQuery, queries, commonQuery);
        }
        return queries;
    }

    private OrganizationTypeQuery.Builder toQueryBuilderWithCommonAttributes(final BasicAggregateReportQuery reportQuery) {
        final StudentFilters filters = reportQuery.getStudentFilters();
        return OrganizationTypeQuery.builder()
                .assessmentTypeCode(reportQuery.getAssessmentTypeCode())
                .assessmentGradeCodes(reportQuery.getAssessmentGradeCodes())
                .subjectCodes(reportQuery.getSubjectCodes())
                .schoolYears(reportQuery.getSchoolYears())
                .completenessCodes(reportQuery.getCompletenessCodes())
                .administrativeConditionCodes(reportQuery.getAdministrativeConditionCodes())
                .genderCodes(filters.getGenderCodes())
                .ethnicityCodes(filters.getEthnicityCodes())
                .lepCodes(filters.getLepCodes())
                .migrantStatusCodes(filters.getMigrantStatusCodes())
                .section504Codes(filters.getSection504Codes())
                .iepCodes(filters.getIepCodes())
                .economicDisadvantageCodes(filters.getEconomicDisadvantageCodes());
    }

    private void appendState(final AbstractAggregateReportQuery reportQuery,
                             final List<OrganizationTypeQueryDescription> queries,
                             final OrganizationTypeQuery commonQuery) {
        if (reportQuery.isIncludeState()) {
            queries.add(new OrganizationTypeQueryDescription(commonQuery.copy().organizationType(State).build(), State));
        }
    }

    private void appendDistricts(final AbstractAggregateReportQuery reportQuery,
                                 final List<OrganizationTypeQueryDescription> queries,
                                 final OrganizationTypeQuery commonQuery) {

        if (reportQuery.isIncludeAllDistricts()) {
            final OrganizationTypeQuery query = commonQuery.
                    copy()
                    .organizationType(State)
                    .build();

            queries.add(new OrganizationTypeQueryDescription(query, District));

        } else if (!reportQuery.getDistrictIds().isEmpty() || isIncludeAllDistrictsOfSchools(reportQuery)) {
            //individual districts could be included two ways: by ids or via 'isIncludeAllDistrictsOfSchools' flag
            final Set<Long> districtIds = newHashSet(reportQuery.getDistrictIds());
            if (isIncludeAllDistrictsOfSchools(reportQuery)) {
                districtIds.addAll(repositoryHelper.findAllDistrictsOfSchools(reportQuery.getSchoolIds()));
            }

            if (!districtIds.isEmpty()) {
                final OrganizationTypeQuery query = commonQuery
                        .copy()
                        .organizationType(District)
                        .organizationIds(districtIds)
                        .build();
                queries.add(new OrganizationTypeQueryDescription(query, District));
            }
        }
    }

    private void appendSchools(final AbstractAggregateReportQuery reportQuery, final List<OrganizationTypeQueryDescription> queries, final OrganizationTypeQuery commonQuery) {
        //schools could be selected individually or as part of a district selection
        final Set<Long> districtsWithAllSchools = newHashSet();
        if (isIncludeAllSchoolsOfDistricts(reportQuery)) {
            final Set<Long> districtIds = reportQuery.isIncludeAllDistricts() ? repositoryHelper.findAllDistrictIds() : reportQuery.getDistrictIds();
            districtsWithAllSchools.addAll(districtIds);

            if (!districtsWithAllSchools.isEmpty()) {
                final OrganizationTypeQuery query = commonQuery
                        .copy()
                        .organizationType(District)
                        .organizationIds(districtsWithAllSchools)
                        .build();

                queries.add(new OrganizationTypeQueryDescription(query, OrganizationType.School));
            }
        }

        if (!reportQuery.getSchoolIds().isEmpty()) {
            final Set<Long> schoolIds = reportQuery.getSchoolIds();

            //to avoid duplicate schools we need to filter those that are already included as part of districts selection
            if (isIncludeAllSchoolsOfDistricts(reportQuery)) {
                schoolIds.removeAll(repositoryHelper.findSchoolsIdsByDistrictIds(districtsWithAllSchools));
            }

            if (!schoolIds.isEmpty()) {
                final OrganizationTypeQuery query = commonQuery
                        .copy()
                        .organizationType(OrganizationType.School)
                        .organizationIds(schoolIds)
                        .build();

                queries.add(new OrganizationTypeQueryDescription(query, OrganizationType.School));
            }
        }
    }

    private boolean isIncludeAllSchoolsOfDistricts(final AbstractAggregateReportQuery query) {
        return query.isIncludeAllSchoolsOfDistricts() && !query.getDistrictIds().isEmpty();
    }

    private boolean isIncludeAllDistrictsOfSchools(final AbstractAggregateReportQuery query) {
        return query.isIncludeAllDistrictsOfSchools() && !query.getSchoolIds().isEmpty();
    }

    private static BasicAggregateReportQuery ensureDimension(final BasicAggregateReportQuery query, final DimensionType dimension) {
        return query.getDimensionTypes().contains(dimension) ? query : query.copy().dimensionType(Overall).build();
    }

    private BasicAggregateReportQuery checkIsValid(final BasicAggregateReportQuery query) {
        checkArgument(!query.getSubjectCodes().isEmpty(), "report query is missing subjects");
        checkArgument(!query.getAssessmentGradeCodes().isEmpty(), "report query is missing asmt grades");
        checkArgument(!query.getSchoolYears().isEmpty(), "report query is missing school years");
        checkArgument(!query.getDimensionTypes().isEmpty(), "report query is missing dimensionTypes");
        checkArgument(!(!query.isIncludeState() && !query.isIncludeAllDistricts() && query.getDistrictIds().isEmpty() && query.getSchoolIds().isEmpty()), "report query is missing organization");
        if (query.isIncludeState()) checkArgument(stateAggregateAssessmentTypes.contains(query.getAssessmentTypeCode()), "report query cannot include state results for " + query.getAssessmentTypeCode() + " assessment types");
        return query;
    }

    private static class RunQueryTask {
        private final OrganizationTypeQueryDescription queryDescription;
        private final CustomAggregateReportRepository reportRepository;
        private final User user;

        private RunQueryTask(final OrganizationTypeQueryDescription queryDescription, final CustomAggregateReportRepository reportRepository, final User user) {
            this.queryDescription = queryDescription;
            this.reportRepository = reportRepository;
            this.user = user;
        }

        private BasicAggregateReportResult run() {
            return reportRepository.findByOrganizationType(user, queryDescription.getQuery(), queryDescription.getResultType());
        }
    }

    private static class OrganizationTypeQueryDescription {
        private final OrganizationTypeQuery query;
        private final OrganizationType resultType;

        private OrganizationTypeQueryDescription(final OrganizationTypeQuery query, final OrganizationType resultType) {
            this.query = query;
            this.resultType = resultType;
        }

        private OrganizationTypeQuery getQuery() {
            return query;
        }

        private OrganizationType getResultType() {
            return resultType;
        }
    }
}