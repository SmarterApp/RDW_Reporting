package org.opentestsystem.rdw.olap.sqlbuilder;

import org.opentestsystem.rdw.olap.model.LongitudinalReportQuery;
import org.opentestsystem.rdw.olap.model.YearGradePair;
import org.opentestsystem.rdw.olap.sqlbuilder.QueryReportTemplate.Builder;
import org.opentestsystem.rdw.reporting.common.model.AssessmentDescription;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.security.PermissionSource;
import org.opentestsystem.rdw.reporting.common.sqlbuilder.QueryProvider;

import javax.validation.constraints.NotNull;
import java.util.Iterator;
import java.util.List;

import static com.google.common.collect.Lists.newArrayList;
import static java.util.stream.Collectors.toList;
import static java.util.stream.IntStream.rangeClosed;

/**
 * This implementation is responsible for converting {@link LongitudinalReportQuery} into a {@link QueryReportTemplate}
 */

public class LongitudinalQueryReportTemplateProvider extends BaseQueryReportTemplateProvider<LongitudinalReportQuery, AssessmentDescription> {

    // Redshift is caching the query execution plan much better when SQL has the same number of parameters in the IN clause.
    // The best guess based on examining the execution plan is that the optimizer converts IN into ORs, and hence it sees it as
    // a different query. Optimizer also removes duplicate values from the IN, so to trick it we are padding each IN to a fixed size with
    // distinct invalid values. We need a bunch (20) invalid strings to pad the list of year-grade string values.
    private static final List<String> DISTINCT_STRINGS = rangeClosed(300, 320).boxed().map(r -> (Integer.toString(-1 * r))).collect(toList());

    private static final String longitudinalTemplateSql = "longitudinal";

    public LongitudinalQueryReportTemplateProvider(final Organization state,
                                                   final int organizationPartitionSize,
                                                   final QueryProvider queryProvider,
                                                   final QueryProviderRepositoryHelper repositoryHelper,
                                                   final PermissionSource permissionSource) {
        super(state, organizationPartitionSize, queryProvider, repositoryHelper, permissionSource);
    }

    @Override
    public Builder createBuilderWithCommonAttributes(final LongitudinalReportQuery query) {
        return addFiltersAndDimension(super.createBuilderWithCommonAttributes(query), query)
                .parameter("subject_id", getRepositoryHelper().toSubjectId(query.getSubjectCode()))
                .parameter("cohort_years", query.getYearGradePairs().size())
                .parameter("gradeYearPairsCount", query.getYearGradePairs().size())
                .parameter("yearGradePairs", toPaddedStrings(query.getYearGradePairs(), Math.max(query.getYearGradePairs().size(), getRepositoryHelper().maxAssessmentGrades())));
    }

    @Override
    protected String getTemplateSql() {
        return longitudinalTemplateSql;
    }

    private List<String> toPaddedStrings(@NotNull final List<YearGradePair> yearGradePairs, final int size) {
        if (yearGradePairs.size() > DISTINCT_STRINGS.size() || size > DISTINCT_STRINGS.size()) {
            throw new IllegalStateException("unsupported number of year/grade pairs");
        }

        final List<String> padded = newArrayList(DISTINCT_STRINGS.subList(0, size));

        final Iterator<YearGradePair> iterator = yearGradePairs.iterator();
        for (int i = 0; i < yearGradePairs.size(); ++i) {
            final YearGradePair yearGradePair = iterator.next();
            padded.set(i, yearGradePair.getSchoolYear() + "," + yearGradePair.getGradeCode());
        }
        return padded;
    }
}