package org.opentestsystem.rdw.olap.service.impl;

import com.google.common.base.Charsets;
import com.google.common.base.Joiner;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.lang.mutable.MutableObject;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.olap.model.Dimension;
import org.opentestsystem.rdw.olap.model.Measures;
import org.opentestsystem.rdw.olap.model.ReportRow;
import org.opentestsystem.rdw.olap.service.AuthorizationService;
import org.opentestsystem.rdw.olap.service.CustomAggregateExportService;
import org.opentestsystem.rdw.olap.service.CustomAggregateService;
import org.opentestsystem.rdw.reporting.common.model.ReportQuery;
import org.opentestsystem.rdw.reporting.common.util.Headers;
import org.opentestsystem.rdw.reporting.common.util.MediaTypes;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.MessageSource;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.nio.charset.Charset;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import static java.util.stream.Collectors.toList;
import static org.apache.commons.lang.StringUtils.EMPTY;
import static org.apache.commons.lang.StringUtils.isBlank;
import static org.opentestsystem.rdw.common.model.AssessmentType.IAB;
import static org.opentestsystem.rdw.reporting.common.util.MediaTypes.getExtension;
import static org.springframework.http.HttpHeaders.CONTENT_DISPOSITION;
import static org.springframework.http.HttpHeaders.CONTENT_TYPE;

/**
 * Default implementation of a CustomAggregateExportService.
 * TODO: Once the ReportQuery contains filter criteria, we need to add the filters to the Attributes value(s).
 */
@Service
class DefaultCustomAggregateExportService implements CustomAggregateExportService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultCustomAggregateExportService.class);
    private static final Joiner AttributeJoiner = Joiner.on(" | ");

    private static final String NotApplicable = "";
    private static final Object[] EmptyObjectArray = new Object[]{};

    private final CustomAggregateService service;
    private final MessageSource messageSource;
    private final AuthorizationService authorizationService;
    private final Locale locale;

    @Autowired
    DefaultCustomAggregateExportService(final CustomAggregateService service,
                                        final MessageSource messageSource,
                                        final AuthorizationService authorizationService) {
        this.service = service;
        this.messageSource = messageSource;
        this.authorizationService = authorizationService;

        //Report CSV will always be in US English
        this.locale = Locale.US;
    }

    @Override
    public ResponseEntity<ByteArrayResource> exportReport(final User user, final ReportQuery query) {

        // Ensure user has authority to export report
        authorizationService.checkAuthorization(user, query);

        final List<ReportRow> results = service.findByQuery(user, query);

        final byte[] csvContent = printCsv(results, query);
        final ByteArrayResource resource = new ByteArrayResource(csvContent);
        final MediaType mediaType = MediaTypes.TEXT_CSV;
        final String filename = "custom_aggregate." + getExtension(mediaType);
        final String contentDisposition = Headers.formatContentDispositionAttachment(filename, Charset.forName("UTF-8"));

        final HttpHeaders responseHeaders = new HttpHeaders();
        responseHeaders.set(CONTENT_TYPE, mediaType.toString());
        responseHeaders.set(CONTENT_DISPOSITION, contentDisposition);

        return new ResponseEntity<>(resource, responseHeaders, HttpStatus.OK);
    }

    private byte[] printCsv(final List<ReportRow> results, final ReportQuery query) {
        final CSVFormat csvFormat = CSVFormat.DEFAULT
                .withHeader(getHeaders(query));

        try (final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
             final OutputStreamWriter writer = new OutputStreamWriter(outputStream, Charsets.UTF_8)) {
            final CSVPrinter printer = csvFormat.print(writer);
            final MutableObject printAttributes = new MutableObject(true);

            printer.printRecords(results.stream().map(result -> {
                final List<String> columnValues = new ArrayList<>();
                columnValues.add(result.getOrganization().getName());
                columnValues.add(result.getOrganization().getNaturalId());
                if (query.getAssessmentTypeId() == IAB.id()) {
                    columnValues.add(result.getAssessment().getLabel());
                }
                columnValues.add(AssessmentType.valueOf(query.getAssessmentTypeId()).name());
                columnValues.add(String.valueOf(result.getAssessment().getGradeId()));
                columnValues.add(getSchoolYearDisplay(result.getAssessment().getExamSchoolYear()));

                final Dimension dimension = result.getDimension();
                columnValues.add(dimension.getType().name() +
                        (isBlank(dimension.getCode()) ? EMPTY : ": " + dimension.getCode()));

                final Measures measures = result.getMeasures();
                final long studentCount = measures.getLevel1Count() +
                        measures.getLevel2Count() +
                        measures.getLevel3Count() +
                        measures.getLevel4Count();
                columnValues.add(String.valueOf(studentCount));

                columnValues.add(measures.getAvgScaleScore() == null ? NotApplicable : measures.getAvgScaleScore().toString());
                columnValues.add(measures.getAvgStdErr() == null ? NotApplicable : measures.getAvgStdErr().toString());
                columnValues.add(String.valueOf(measures.getLevel1Count()));
                columnValues.add(String.valueOf(measures.getLevel2Count()));
                columnValues.add(String.valueOf(measures.getLevel3Count()));
                if (query.getAssessmentTypeId() != IAB.id()) {
                    columnValues.add(String.valueOf(measures.getLevel4Count()));
                }

                if ((Boolean) printAttributes.getValue()) {
                    printAttributes.setValue(false);
                    columnValues.add(getAttributes(query));
                } else {
                    columnValues.add(EMPTY);
                }

                return columnValues;
            }).collect(toList()));

            printer.flush();
            writer.flush();
            return outputStream.toByteArray();
        } catch (final IOException e) {
            logger.warn("Problem exporting report CSV", e);
            throw new RuntimeException(e);
        }
    }

    private String[] getHeaders(final ReportQuery query) {
        final List<String> headers = new ArrayList<>();
        headers.add(getMessage("report.aggregate.export.header.organization"));
        headers.add(getMessage("report.aggregate.export.header.natural-id"));
        headers.add(getMessage("report.aggregate.export.header.assessment"));
        headers.add(getMessage("report.aggregate.export.header.assessment-type"));
        headers.add(getMessage("report.aggregate.export.header.grade"));
        headers.add(getMessage("report.aggregate.export.header.year"));
        headers.add(getMessage("report.aggregate.export.header.dimension"));
        headers.add(getMessage("report.aggregate.export.header.student-count"));
        headers.add(getMessage("report.aggregate.export.header.score"));
        headers.add(getMessage("report.aggregate.export.header.standard-deviation"));
        headers.addAll(getPerformanceLevelHeaders(query));
        headers.add(getMessage("report.aggregate.export.header.attributes"));
        return headers.toArray(new String[headers.size()]);
    }

    private List<String> getPerformanceLevelHeaders(final ReportQuery query) {
        final List<String> performanceLevelHeaders = new ArrayList<>();
        if (query.getAssessmentTypeId() == IAB.id()) {
            for (int i = 1; i <= 3; i++) {
                performanceLevelHeaders.add(getMessage("report.iab.level." + i + ".label"));
            }
        } else {
            for (int i = 1; i <= 4; i++) {
                performanceLevelHeaders.add(getMessage("report.ica.level." + i + ".description"));
            }
        }
        return performanceLevelHeaders;
    }

    private String getAttributes(final ReportQuery query) {
        final List<String> attributes = new ArrayList<>();

        final LocalDateTime localDate = LocalDateTime.now();
        attributes.add("Report Date: " + localDate.format(DateTimeFormatter.ISO_DATE_TIME));

        //TODO add filter criteria

        return AttributeJoiner.join(attributes);
    }

    private String getSchoolYearDisplay(final int schoolYear) {
        return (schoolYear - 1) + "-" + String.valueOf(schoolYear).substring(2);
    }

    private String getMessage(final String key) {
        return messageSource.getMessage(key, EmptyObjectArray, locale);
    }
}
