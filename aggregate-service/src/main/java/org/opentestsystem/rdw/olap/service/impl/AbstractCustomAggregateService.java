package org.opentestsystem.rdw.olap.service.impl;

import org.opentestsystem.rdw.olap.AggregateReportSettings;
import org.opentestsystem.rdw.olap.model.CustomAggregateReportResult;
import org.opentestsystem.rdw.olap.model.OrganizationTypeQuery;
import org.opentestsystem.rdw.olap.repository.CustomAggregateReportRepository;
import org.opentestsystem.rdw.olap.service.AggregateQueryHandler;
import org.opentestsystem.rdw.olap.service.AuthorizationService;
import org.opentestsystem.rdw.olap.sqlbuilder.QueryProviderRepositoryHelper;
import org.opentestsystem.rdw.reporting.common.model.AbstractAggregateReportQuery;
import org.opentestsystem.rdw.reporting.common.model.AggregateRow;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.model.StudentFilters;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.springframework.core.task.TaskExecutor;

import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;

import static com.google.common.base.Preconditions.checkArgument;
import static java.util.stream.Collectors.toList;
import static org.hibernate.validator.internal.util.CollectionHelper.newHashSet;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.District;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.State;

/**
 * Common functionality for implementations of a {@link AggregateQueryHandler}
 */
abstract class AbstractCustomAggregateService<Q extends AbstractAggregateReportQuery,
        T extends AggregateRow,
        R extends CustomAggregateReportResult<T>,
        B extends CustomAggregateReportResult.Builder<T, ?, R>> implements AggregateQueryHandler<List<T>, R, Q> {

    private final CustomAggregateReportRepository<R> repository;
    private final AuthorizationService authorizationService;
    private final Set<String> stateAggregateAssessmentTypes;
    private final QueryProviderRepositoryHelper repositoryHelper;
    private final Executor threadPoolTaskExecutor;

    /**
     * Constructor
     */
    AbstractCustomAggregateService(
            final CustomAggregateReportRepository<R> repository,
            final AuthorizationService authorizationService,
            final AggregateReportSettings settings,
            final QueryProviderRepositoryHelper repositoryHelper,
            final TaskExecutor threadPoolTaskExecutor) {
        this.repository = repository;
        this.authorizationService = authorizationService;
        this.repositoryHelper = repositoryHelper;
        this.threadPoolTaskExecutor = threadPoolTaskExecutor;
        stateAggregateAssessmentTypes = settings.getStateAggregateAssessmentTypes();
    }

    /**
     * @return provides an instance of the {@link CustomAggregateReportResult.Builder}
     */
    protected abstract B getReportBuilder();

    /**
     * Converts the given {@link AbstractAggregateReportQuery} into a collection of the corresponding {@link OrganizationTypeQueryDescription}s
     *
     * @param reportQuery the query to convert
     * @return the collection of {@link OrganizationTypeQueryDescription}s
     */
    protected abstract Collection<OrganizationTypeQueryDescription> toOrganizationTypeQueries(final Q reportQuery);

    @Override
    public R findByQuery(final User user, final Q query) {
        authorizationService.checkAuthorization(user, query);

        final Q validQuery = checkIsValid(query);

        // repository is able to support a query for one level of organization and one dimension type
        // to improve the response time for the report we run these queries in parallel
        final Collection<R> reports = toOrganizationTypeQueries(validQuery)
                .stream()
                .map(q -> new RunQueryTask<T, R>(q, repository, user))
                .map(t -> CompletableFuture.supplyAsync(t::run, threadPoolTaskExecutor))
                .map(CompletableFuture::join)
                .collect(toList());

        final B mergedReportBuilder = getReportBuilder();
        for (final R report : reports) {
            mergedReportBuilder.merge(report);
        }
        return mergedReportBuilder.build();
    }

    @Override
    public int estimateReportRowCount(final User user, final Q query) {
        authorizationService.checkAuthorization(user, query);

        final Q validQuery = checkIsValid(query);

        return toOrganizationTypeQueries(validQuery)
                .stream()
                .mapToInt(q -> repository.estimateReportRowCountByOrganizationType(q.getQuery(), q.getResultType()))
                .sum();
    }

    protected OrganizationTypeQuery.Builder toQueryBuilderWithCommonAttributes(final AbstractAggregateReportQuery reportQuery, final StudentFilters filters) {
        return OrganizationTypeQuery.builder()
                .assessmentTypeCode(reportQuery.getAssessmentTypeCode())
                .assessmentGradeCodes(reportQuery.getAssessmentGradeCodes())
                .subjectCodes(reportQuery.getSubjectCodes())
                .schoolYears(reportQuery.getSchoolYears())
                .completenessCodes(reportQuery.getCompletenessCodes())
                .administrativeConditionCodes(reportQuery.getAdministrativeConditionCodes())
                .genderCodes(filters.getGenderCodes())
                .ethnicityCodes(filters.getEthnicityCodes())
                .lepCodes(filters.getLepCodes())
                .elasCodes(filters.getElasCodes())
                .migrantStatusCodes(filters.getMigrantStatusCodes())
                .section504Codes(filters.getSection504Codes())
                .iepCodes(filters.getIepCodes())
                .economicDisadvantageCodes(filters.getEconomicDisadvantageCodes());
    }

    protected void appendState(final AbstractAggregateReportQuery reportQuery,
                               final List<OrganizationTypeQueryDescription> queries,
                               final OrganizationTypeQuery commonQuery) {
        if (reportQuery.isIncludeState()) {
            queries.add(new OrganizationTypeQueryDescription(commonQuery.copy().organizationType(State).build(), State));
        }
    }

    protected void appendDistricts(final AbstractAggregateReportQuery reportQuery,
                                   final List<OrganizationTypeQueryDescription> queries,
                                   final OrganizationTypeQuery commonQuery) {

        if (reportQuery.isIncludeAllDistricts()) {
            final OrganizationTypeQuery query = commonQuery.
                    copy()
                    .organizationType(State)
                    .build();

            queries.add(new OrganizationTypeQueryDescription(query, District));

        } else if (!reportQuery.getDistrictIds().isEmpty() || isIncludeAllDistrictsOfSchools(reportQuery)) {
            //individual districts could be included two ways: by ids or via 'isIncludeAllDistrictsOfSchools' flag
            final Set<Long> districtIds = newHashSet(reportQuery.getDistrictIds());
            if (isIncludeAllDistrictsOfSchools(reportQuery)) {
                districtIds.addAll(repositoryHelper.findAllDistrictsOfSchools(reportQuery.getSchoolIds()));
            }

            if (!districtIds.isEmpty()) {
                final OrganizationTypeQuery query = commonQuery
                        .copy()
                        .organizationType(District)
                        .organizationIds(districtIds)
                        .build();
                queries.add(new OrganizationTypeQueryDescription(query, District));
            }
        }
    }

    protected void appendSchools(final AbstractAggregateReportQuery reportQuery, final List<OrganizationTypeQueryDescription> queries, final OrganizationTypeQuery commonQuery) {
        //schools could be selected individually or as part of a district selection
        final Set<Long> districtsWithAllSchools = newHashSet();
        if (isIncludeAllSchoolsOfDistricts(reportQuery)) {
            final Set<Long> districtIds = reportQuery.isIncludeAllDistricts() ? repositoryHelper.findAllDistrictIds() : reportQuery.getDistrictIds();
            districtsWithAllSchools.addAll(districtIds);

            if (!districtsWithAllSchools.isEmpty()) {
                final OrganizationTypeQuery query = commonQuery
                        .copy()
                        .organizationType(District)
                        .organizationIds(districtsWithAllSchools)
                        .build();

                queries.add(new OrganizationTypeQueryDescription(query, OrganizationType.School));
            }
        }

        if (!reportQuery.getSchoolIds().isEmpty()) {
            final Set<Long> schoolIds = reportQuery.getSchoolIds();

            //to avoid duplicate schools we need to filter those that are already included as part of districts selection
            if (isIncludeAllSchoolsOfDistricts(reportQuery)) {
                schoolIds.removeAll(repositoryHelper.findSchoolsIdsByDistrictIds(districtsWithAllSchools));
            }

            if (!schoolIds.isEmpty()) {
                final OrganizationTypeQuery query = commonQuery
                        .copy()
                        .organizationType(OrganizationType.School)
                        .organizationIds(schoolIds)
                        .build();

                queries.add(new OrganizationTypeQueryDescription(query, OrganizationType.School));
            }
        }
    }

    protected boolean isIncludeAllSchoolsOfDistricts(final AbstractAggregateReportQuery query) {
        return query.isIncludeAllSchoolsOfDistricts() && !query.getDistrictIds().isEmpty();
    }

    protected boolean isIncludeAllDistrictsOfSchools(final AbstractAggregateReportQuery query) {
        return query.isIncludeAllDistrictsOfSchools() && !query.getSchoolIds().isEmpty();
    }

    protected Q checkIsValid(final Q query) {
        checkArgument(!query.getSubjectCodes().isEmpty(), "report query is missing subjects");
        checkArgument(!query.getAssessmentGradeCodes().isEmpty(), "report query is missing asmt grades");
        checkArgument(!query.getSchoolYears().isEmpty(), "report query is missing school years");
        checkArgument(!(!query.isIncludeState() && !query.isIncludeAllDistricts() && query.getDistrictIds().isEmpty() && query.getSchoolIds().isEmpty()), "report query is missing organization");
        if (query.isIncludeState()) checkArgument(stateAggregateAssessmentTypes.contains(query.getAssessmentTypeCode()), "report query cannot include state results for " + query.getAssessmentTypeCode() + " assessment types");
        return query;
    }

    private class RunQueryTask<T extends AggregateRow, R extends CustomAggregateReportResult<T>> {
        private final OrganizationTypeQueryDescription queryDescription;
        private final CustomAggregateReportRepository<R> reportRepository;
        private final User user;

        private RunQueryTask(final OrganizationTypeQueryDescription queryDescription, final CustomAggregateReportRepository<R> reportRepository, final User user) {
            this.queryDescription = queryDescription;
            this.reportRepository = reportRepository;
            this.user = user;
        }

        private R run() {
            return reportRepository.findByOrganizationType(user, queryDescription.getQuery(), queryDescription.getResultType());
        }
    }

    protected static class OrganizationTypeQueryDescription {
        private final OrganizationTypeQuery query;
        private final OrganizationType resultType;

        private OrganizationTypeQueryDescription(final OrganizationTypeQuery query, final OrganizationType resultType) {
            this.query = query;
            this.resultType = resultType;
        }

        private OrganizationTypeQuery getQuery() {
            return query;
        }

        private OrganizationType getResultType() {
            return resultType;
        }
    }
}