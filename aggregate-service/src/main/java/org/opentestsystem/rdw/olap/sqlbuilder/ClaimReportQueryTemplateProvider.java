package org.opentestsystem.rdw.olap.sqlbuilder;

import org.opentestsystem.rdw.olap.model.AggregateOrganizationQuery;
import org.opentestsystem.rdw.olap.model.ClaimReportResult;
import org.opentestsystem.rdw.olap.sqlbuilder.QueryReportTemplate.Builder;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.security.PermissionSource;
import org.opentestsystem.rdw.reporting.common.sqlbuilder.QueryProvider;

import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import static com.google.common.collect.Lists.newArrayList;
import static java.util.stream.Collectors.toList;
import static org.opentestsystem.rdw.common.model.AssessmentBoundaries.MaxScorableClaims;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.padIntToSize;

/**
 * This implementation is responsible for converting {@link AggregateOrganizationQuery} into a {@link QueryReportTemplate}
 * that contains a SQL string, SQL parameters and an empty report template to produce {@link ClaimReportResult}
 */
public class ClaimReportQueryTemplateProvider extends AbstractReportQueryTemplateProvider<AggregateOrganizationQuery> {

    private static final String claimAggregateTemplateSql = "claimAggregate";
    //it is used to pad claims to the fixed sized in the SQL 'in' clause
    private final List<String> claimsSqlPadding;

    public ClaimReportQueryTemplateProvider(final Organization state,
                                            final int organizationPartitionSize,
                                            final QueryProvider queryProvider,
                                            final QueryProviderRepositoryHelper repositoryHelper,
                                            final PermissionSource permissionSource) {
        super(state, organizationPartitionSize, queryProvider, repositoryHelper, permissionSource);
        claimsSqlPadding = padIntToSize(newArrayList(), MaxScorableClaims * repositoryHelper.maxSubjects()).stream().map(Object::toString).collect(toList());

    }

    @Override
    protected String getTemplateSql() {
        return claimAggregateTemplateSql;
    }

    @Override
    public Builder createBuilderWithCommonAttributes(final AggregateOrganizationQuery query) {
        return addFiltersAndDimension(super.createBuilderWithCommonAttributes(query), query)
                //add claims for to be available for estimated count and back-filling functionality
                .claimCodes(query.getClaimCodes())
                .parameter("school_years", padIntToSize(query.getSchoolYears(), getRepositoryHelper().maxSchoolYears()))
                .parameter("asmt_grade_ids", padIntToSize(getRepositoryHelper().toGradeIds(query.getAssessmentGradeCodes()), getRepositoryHelper().maxAssessmentGrades()))
                .parameter("subject_ids", padIntToSize(getRepositoryHelper().toSubjectIds(query.getSubjectCodes()), getRepositoryHelper().maxSubjects()))
                .parameter("asmt_type_id", getRepositoryHelper().toAssessmentTypeId(query.getAssessmentTypeCode()))
                .parameter("subject_claim_score_codes", padClaims(query.getClaimCodes()))
                .parameter("all_claims", query.getClaimCodes().isEmpty());
    }

    private Collection<String> padClaims(final Collection<String> collection) {
        if (collection != null && collection.size() >= claimsSqlPadding.size()) return collection;

        if (collection == null) return claimsSqlPadding;
        final List<String> padded = newArrayList(claimsSqlPadding);

        final Iterator<String> iterator = collection.iterator();
        for (int i = 0; i < collection.size(); ++i) {
            claimsSqlPadding.set(i, iterator.next());
        }
        return padded;
    }
}