
package org.opentestsystem.rdw.olap.repository.impl;

import org.opentestsystem.rdw.olap.model.ReportRowIdentity;
import org.opentestsystem.rdw.olap.model.ReportTemplate;
import org.opentestsystem.rdw.olap.model.TargetOrganizationQuery;
import org.opentestsystem.rdw.olap.model.TargetReportResult;
import org.opentestsystem.rdw.olap.model.TargetRowIdentity;
import org.opentestsystem.rdw.olap.repository.ActiveAssessmentRepository;
import org.opentestsystem.rdw.olap.repository.EmbargoRepository;
import org.opentestsystem.rdw.olap.repository.OrganizationRepository;
import org.opentestsystem.rdw.olap.repository.TargetReportRepository;
import org.opentestsystem.rdw.olap.sqlbuilder.impl.QueryProviderRepositoryHelper;
import org.opentestsystem.rdw.olap.sqlbuilder.impl.query.TargetSqlQueryWithReportTemplateProvider;
import org.opentestsystem.rdw.olap.sqlbuilder.impl.template.TargetReportTemplateProvider;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemProperties;
import org.opentestsystem.rdw.reporting.common.model.ActiveAssessment;
import org.opentestsystem.rdw.reporting.common.model.Dimension;
import org.opentestsystem.rdw.reporting.common.model.Measures;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.model.Target;
import org.opentestsystem.rdw.reporting.common.model.TargetReportingLevel;
import org.opentestsystem.rdw.reporting.common.model.TargetRow;
import org.opentestsystem.rdw.reporting.common.security.PermissionSource;
import org.opentestsystem.rdw.reporting.common.sqlbuilder.QueryProvider;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import javax.validation.constraints.NotNull;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Collection;
import java.util.Map;
import java.util.stream.Collectors;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.collect.Maps.newHashMap;
import static org.opentestsystem.rdw.reporting.common.model.TargetReportingLevel.Excluded;
import static org.opentestsystem.rdw.reporting.common.model.TargetReportingLevel.InsufficientData;

/**
 * Implementation of {@link TargetReportRepository}
 */
@SuppressWarnings("unchecked")
@Repository
public class JdbcTargetReportRepository
        extends AbstractReportRepository<TargetRow, TargetReportResult, TargetOrganizationQuery, TargetReportResult.Builder>
        implements TargetReportRepository {

    @Value("${reporting.target-report.insufficient-data-cutoff}")
    private Double insufficientDataCutoff;

    /**
     * Constructor
     */
    @Autowired
    JdbcTargetReportRepository(@Qualifier("reportingSystemPropertiesResolver") final ReportingSystemProperties reportingSystemProperties,
                               final JdbcTemplate jdbcTemplate,
                               final QueryProviderRepositoryHelper reportQueryRepositoryHelper,
                               final ActiveAssessmentRepository activeAssessmentRepository,
                               final OrganizationRepository organizationRepository,
                               final QueryProvider queryProvider,
                               final EmbargoRepository embargoRepository,
                               @Value("${app.aggregate-reports.custom-aggregate-report-repository.jdbc-fetch-size}") final int jdbcFetchSize,
                               @Value("${app.aggregate-reports.custom-aggregate-report-repository.organization-partition-size}") final int organizationPartitionSize) {
        super(reportingSystemProperties, jdbcTemplate, reportQueryRepositoryHelper, organizationRepository, activeAssessmentRepository, queryProvider, embargoRepository, jdbcFetchSize, organizationPartitionSize);
    }

    @Override
    protected TargetReportResult.Builder getReportBuilder() {
        return TargetReportResult.builder();
    }

    @Override
    protected void validate(final TargetOrganizationQuery query) {
        super.validate(query);
        checkArgument(query.getSubjectCode() != null, "invalid query, missing a subject");
        checkArgument(query.getAssessmentGradeCode() != null, "invalid query, missing an assessment grade");
        checkArgument(query.getOrganizationIds().size() == 1, "invalid query, requires one organization");
        checkArgument(query.getOrganizationType() == OrganizationType.District
                || query.getOrganizationType() == OrganizationType.School, "invalid query, unsupported organization type");
    }

    @Override
    protected TargetSqlQueryWithReportTemplateProvider getQueryReportTemplateProvider(
            final Organization state,
            final int organizationPartitionSize,
            final QueryProvider queryProvider,
            final QueryProviderRepositoryHelper reportQueryRepositoryHelper,
            final PermissionSource permissionSource) {
        return new TargetSqlQueryWithReportTemplateProvider(state, queryProvider, reportQueryRepositoryHelper, permissionSource, reportingSystemProperties);
    }

    @Override
    protected TargetRow buildReportRow(final ResultSet row, final TargetOrganizationQuery query) throws SQLException {
        final String asmtTypeCode = query.getAssessmentTypeCode();
        final int asmtId = row.getInt("asmt_id");
        final int targetId = row.getInt("target_id");
        final Target target = getReportQueryRepositoryHelper().findTarget(asmtId, targetId);
        return TargetRow.builder()
                .organization(findOneByIdAndType(row.getLong("organization_id"), OrganizationType.valueOf(row.getString("organization_type"))))
                .assessment(findByIdAndSchoolYear(asmtTypeCode, asmtId, row.getInt("school_year")))
                .dimension(buildDimension(row, query))
                .claimCode(row.getString("claim_code"))
                .targetNaturalId(row.getString("target_natural_id"))
                .measures(Measures.builder().avgScaleScore(row.getInt("score")).avgStdErr(row.getInt("std_err")).studentCount(row.getInt("exam_count")).build())
                .standardMetRelativeResidualLevel(asTargetReportingLevel(row.getDouble("standard_met_relative_residual_score"), row.getDouble("standard_met_relative_residual_score_std_err"), target))
                .studentRelativeResidualScoresLevel(asTargetReportingLevel(row.getDouble("student_relative_residual_score"), row.getDouble("student_relative_residual_score_std_err"), target))
                .build();
    }

    private TargetReportingLevel asTargetReportingLevel(final Double avgScore,
                                                        final Double stdErr,
                                                        final Target target) {

        if (!target.isIncludeInReport()) return Excluded;
        if (stdErr > insufficientDataCutoff) return InsufficientData;
        if (avgScore >= stdErr) return TargetReportingLevel.Above;
        if (avgScore <= (-1 * stdErr)) return TargetReportingLevel.Below;
        return TargetReportingLevel.Near;
    }

    @Override
    protected ReportRowIdentity createReportRowIdentity(final TargetRow reportRow, final boolean considerAsmtIdAsPartOfIdentity) {
        return new TargetRowIdentity(reportRow, considerAsmtIdAsPartOfIdentity);
    }

    @Override
    protected Map<ReportRowIdentity, TargetRow> buildTemplateRowsByIdentity(final ReportTemplate reportTemplateContext,
                                                                            final TargetOrganizationQuery query,
                                                                            final boolean considerAsmtIdAsPartOfIdentity) {
        final Map<ReportRowIdentity, TargetRow> reportTemplate = newHashMap();
        // a template report consists of combinations of all the organizations and assessments
        reportTemplateContext.combinations((organization, assessment, dimension) -> {
            for (final Target target : reportTemplateContext.getTargetsByAssessmentId().get(assessment.getId())) {
                final TargetRow row = buildEmptyReportRow(organization, assessment, dimension, query, target);
                reportTemplate.put(createReportRowIdentity(row, considerAsmtIdAsPartOfIdentity), row);
            }
        });
        return reportTemplate;
    }

    @Override
    public int estimateReportRowCountByOrganizationType(@NotNull final TargetOrganizationQuery query,
                                                        @NotNull final OrganizationType groupByOrganizationType) {
        validate(query);
        final ReportTemplate reportTemplate = new TargetReportTemplateProvider(getState(), getReportQueryRepositoryHelper())
                .toQuery(query, groupByOrganizationType);

        return (reportTemplate.getOrganizations().size()
                * reportTemplate.getTargetsByAssessmentId().values().stream().flatMap(Collection::stream).collect(Collectors.toList()).size()
                * reportTemplate.getDimensions().size());
    }

    private TargetRow buildEmptyReportRow(final Organization organization,
                                          final ActiveAssessment assessment,
                                          final Dimension dimension,
                                          final TargetOrganizationQuery query,
                                          final Target target) {
        return TargetRow.builder()
                .assessment(assessment)
                .organization(organization)
                .dimension(buildDimension(dimension, query))
                .measures(Measures.getEmptyMeasure())
                .claimCode(target.getClaimCode())
                .targetNaturalId(target.getNaturalId())
                .standardMetRelativeResidualLevel(target.isIncludeInReport() ? InsufficientData : Excluded)
                .studentRelativeResidualScoresLevel(target.isIncludeInReport() ? InsufficientData : Excluded)
                .build();
    }


}
