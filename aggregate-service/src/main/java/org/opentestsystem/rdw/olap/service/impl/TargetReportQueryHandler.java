package org.opentestsystem.rdw.olap.service.impl;

import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.olap.AggregateReportSettings;
import org.opentestsystem.rdw.olap.model.TargetOrganizationQuery;
import org.opentestsystem.rdw.olap.model.TargetReportResult;
import org.opentestsystem.rdw.olap.model.TargetReportResult.Builder;
import org.opentestsystem.rdw.olap.repository.TargetReportRepository;
import org.opentestsystem.rdw.olap.service.AuthorizationService;
import org.opentestsystem.rdw.olap.service.SubjectService;
import org.opentestsystem.rdw.reporting.common.model.AggregateQuery;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.ReportQueryType;
import org.opentestsystem.rdw.olap.model.SubjectAssessment;
import org.opentestsystem.rdw.reporting.common.model.TargetReportQuery;
import org.opentestsystem.rdw.reporting.common.model.TargetRow;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.task.TaskExecutor;
import org.springframework.stereotype.Service;

import static com.google.common.base.Preconditions.checkArgument;
import static org.opentestsystem.rdw.olap.model.TargetReportResult.builder;

/**
 * Responsible for handling {@link TargetReportQuery}
 */
@Service
class TargetReportQueryHandler extends AbstractAggregateQueryHandler<TargetRow,
        TargetReportResult,
        TargetReportQuery,
        Builder,
        TargetOrganizationQuery,
        TargetOrganizationQuery.Builder> {

    private final SubjectService subjectService;
    private final int minNumberOfStudents;

    @Autowired
    TargetReportQueryHandler(
            final TargetReportRepository repository,
            final AuthorizationService authorizationService,
            final AggregateReportSettings settings,
            final TargetQueryConverter queryConverter,
            final TaskExecutor threadPoolTaskExecutor,
            final SubjectService subjectService,
            @Value("${reporting.target-report.min-number-of-students}") final int minNumberOfStudents) {
        super(repository, queryConverter, authorizationService, settings, threadPoolTaskExecutor);
        this.subjectService = subjectService;
        this.minNumberOfStudents = minNumberOfStudents;
    }

    /**
     * Overrides the default implementation to handle a case when a report has less than the configured min number of students.
     * It is assumed that the Overall dimension must be present and it is enough to check one row's measures since they all
     * should be the same.
     * <p>
     * If the generated report has less rows than the min configured, it returns an empty report
     * with {@link TargetReportResult#isNotEnoughResults()} flag turned on.
     *
     * @see TargetReportResult
     */
    @Override
    public TargetReportResult findByQuery(final User user, final TargetReportQuery query) {

        final TargetReportResult reportResult = super.findByQuery(user, query);

        if (reportResult.getResultCount() == 0) return reportResult;

        for (final TargetRow row : reportResult.getPayload()) {
            if (row.getDimension().getType() == DimensionType.Overall) {
                return (row.getMeasures().getStudentCount() >= minNumberOfStudents) ? reportResult
                        : reportResult.copy().notEnoughResults(true).build();
            }
        }

        throw new IllegalStateException("missing row with Overall dimension");
    }

    @Override
    public boolean handles(final AggregateQuery query) {
        return query.getType() == ReportQueryType.Target;
    }

    @Override
    protected Builder getReportResultBuilder() {
        return builder();
    }

    @Override
    protected TargetReportQuery preProcess(final TargetReportQuery query) {
        checkArgument(!query.isFilteredSubgroupQuery(), "filtered subgroups are not supported");
        checkArgument(query.getSubjectCode() != null, "invalid query, missing a subject");
        checkArgument(query.getAssessmentGradeCodes().size() == 1, "invalid query, must have one assessment grade");
        checkArgument(query.getSchoolYears().size() == 1, "invalid query, must have exactly one school year");
        checkArgument(!query.isIncludeAllDistrictsOfSchools() && !query.isIncludeAllDistricts()
                && !query.isIncludeState() && !query.isIncludeAllSchoolsOfDistricts()
                && ((query.getSchoolIds().size() == 1 && query.getDistrictIds().isEmpty()) ||
                (query.getDistrictIds().size() == 1 && query.getSchoolIds().isEmpty())), "invalid query, supports one school or one district only");

        final String asmtTypeCode = query.getAssessmentTypeCode() != null ? query.getAssessmentTypeCode() : AssessmentType.SUMMATIVE.code();
        checkArgument(AssessmentType.SUMMATIVE.code().equals(asmtTypeCode), "supports summative assessments only");

        // although it may seem inefficient to get all the subject assessments, they are cached
        final SubjectAssessment subjectAssessment = subjectService.getSubjects().stream()
                .filter(sa -> query.getSubjectCode().equals(sa.getCode()) && asmtTypeCode.equals(sa.getAssessmentType()))
                .filter(SubjectAssessment::isTargetReport)
                .findFirst().orElse(null);
        checkArgument(subjectAssessment != null, "target report is not enabled for subject assessment");

        // query assessment type code may still be null so create patched copy if necessary
        return super.preProcess(query.getAssessmentTypeCode() != null ? query
                : query.copy().assessmentTypeCode(AssessmentType.SUMMATIVE.code()).build());
    }
}
