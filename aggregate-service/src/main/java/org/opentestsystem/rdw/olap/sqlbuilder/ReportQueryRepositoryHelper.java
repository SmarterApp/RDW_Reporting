package org.opentestsystem.rdw.olap.sqlbuilder;

import com.google.common.collect.ImmutableList;
import org.opentestsystem.rdw.olap.model.CodedEntity;
import org.opentestsystem.rdw.olap.repository.ActiveAssessmentRepository;
import org.opentestsystem.rdw.olap.repository.AdministrationConditionRepository;
import org.opentestsystem.rdw.olap.repository.AssessmentGradeRepository;
import org.opentestsystem.rdw.olap.repository.AssessmentTypeRepository;
import org.opentestsystem.rdw.olap.repository.BooleanRepository;
import org.opentestsystem.rdw.olap.repository.CodedEntityRepository;
import org.opentestsystem.rdw.olap.repository.CompletenessRepository;
import org.opentestsystem.rdw.olap.repository.EthnicityRepository;
import org.opentestsystem.rdw.olap.repository.GenderRepository;
import org.opentestsystem.rdw.olap.repository.OrganizationRepository;
import org.opentestsystem.rdw.olap.repository.StrictBooleanRepository;
import org.opentestsystem.rdw.olap.repository.SubjectRepository;
import org.opentestsystem.rdw.reporting.common.model.ActiveAssessment;
import org.opentestsystem.rdw.reporting.common.model.Dimension;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.District;
import org.opentestsystem.rdw.reporting.common.model.ReportQuery;
import org.opentestsystem.rdw.reporting.common.model.School;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.stream.Collectors;

import static com.google.common.collect.Sets.newHashSet;
import static java.util.stream.Collectors.toSet;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Overall;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.StudentEnrolledGrade;

/**
 * Helper to manipulate the data from different repositories into format suitable for the query builders.
 * This helpers uses multiple repositories that are expected to be `cacheable`.
 * It is only here to avoid multiple round-trips to Redshift.
 */
@Service
public class ReportQueryRepositoryHelper {

    private final OrganizationRepository organizationRepository;
    private final ActiveAssessmentRepository activeAssessmentRepository;
    private final GenderRepository genderRepository;
    private final EthnicityRepository ethnicityRepository;
    private final BooleanRepository booleanRepository;
    private final StrictBooleanRepository strictBooleanRepository;
    private final SubjectRepository subjectRepository;
    private final AssessmentTypeRepository assessmentTypeRepository;
    private final AssessmentGradeRepository gradeRepository;
    private final CompletenessRepository completenessRepository;
    private final AdministrationConditionRepository administrativeConditionRepository;

    @Autowired
    public ReportQueryRepositoryHelper(final OrganizationRepository organizationRepository,
                                       final ActiveAssessmentRepository activeAssessmentRepository,
                                       final GenderRepository genderRepository,
                                       final EthnicityRepository ethnicityRepository,
                                       final BooleanRepository booleanRepository,
                                       final StrictBooleanRepository strictBooleanRepository,
                                       final SubjectRepository subjectRepository,
                                       final AssessmentTypeRepository assessmentTypeRepository,
                                       final AssessmentGradeRepository gradeRepository,
                                       final CompletenessRepository completenessRepository,
                                       final AdministrationConditionRepository administrativeConditionRepository) {
        this.organizationRepository = organizationRepository;
        this.activeAssessmentRepository = activeAssessmentRepository;
        this.genderRepository = genderRepository;
        this.ethnicityRepository = ethnicityRepository;
        this.booleanRepository = booleanRepository;
        this.strictBooleanRepository = strictBooleanRepository;
        this.subjectRepository = subjectRepository;
        this.assessmentTypeRepository = assessmentTypeRepository;
        this.gradeRepository = gradeRepository;
        this.completenessRepository = completenessRepository;
        this.administrativeConditionRepository = administrativeConditionRepository;
    }

    /**
     * Finds all {@link ActiveAssessment} represented by the given {@link ReportQuery}.
     * It is used to fill in gap data in the custom aggregate report.
     *
     * @param query the {@link ReportQuery}
     * @return a set of {@link ActiveAssessment}s
     */
    public Set<ActiveAssessment> findAssessmentsForQuery(final ReportQuery query) {
        final Set<ActiveAssessment> assessments = newHashSet();
        for (final ActiveAssessment assessment : activeAssessmentRepository.findAllByTypeId(toAssessmentTypeId(query.getAssessmentTypeCode()))) {
            if (query.getSchoolYears().contains(assessment.getExamSchoolYear())
                    && query.getSubjectCodes().contains(assessment.getSubjectCode())
                    && toIds(query.getAssessmentGradeCodes(), gradeRepository).contains(assessment.getGradeId())) {
                assessments.add(assessment);
            }
        }
        return assessments;
    }

    /**
     * Return all possible values for the given {@link DimensionType} filtered based on the given {@link ReportQuery}
     * This is used to fill in the gaps of the missing data in the custom aggregate report
     *
     * @param dimensionType the {@link DimensionType}
     * @param query         the {@link ReportQuery}
     * @return all possible values for the given {@link DimensionType} filtered based on the given {@link ReportQuery}
     */
    public List<Dimension> findDimensionsByTypeAndQueryFilters(final DimensionType dimensionType, final ReportQuery query) {

        //we do not back-fill data for this dimension type
        if (dimensionType.equals(StudentEnrolledGrade)) return ImmutableList.of();

        if (dimensionType.equals(Overall)) return ImmutableList.of(new Dimension(null, Overall));

        final Set<Integer> filters = newHashSet();
        final CodedEntityRepository repository = getRepositoryAndAddFilterByDimensionType(dimensionType, query, filters);

        if (filters.isEmpty()) return repository.findAll().stream().map(g -> new Dimension(g.getCode(), dimensionType)).collect(Collectors.toList());

        return repository.findAll().stream().filter(g -> filters.contains(g.getId())).map(g -> new Dimension(g.getCode(), dimensionType)).collect(Collectors.toList());

    }

    public Set<District> findDistrictsByIds(final Set<Long> districtIds) {
        final Set<District> districts = newHashSet();
        for (final Long districtId : districtIds) {
            if (organizationRepository.findMapOfDistrictsByIds().containsKey(districtId)) {
                districts.add(organizationRepository.findMapOfDistrictsByIds().get(districtId));
            }
        }
        return districts;
    }

    public Set<School> findSchoolsByDistrictIds(final Set<Long> districtIds) {
        final Set<School> schools = newHashSet();
        for (final Long districtId : districtIds) {
            if (organizationRepository.findAllSchoolsByDistrictId().containsKey(districtId)) {
                schools.addAll(organizationRepository.findAllSchoolsByDistrictId().get(districtId));
            }
        }
        return schools;
    }

    public Set<Long> findSchoolsIdsByDistrictIds(final Set<Long> districtIds) {
        return findSchoolsByDistrictIds(districtIds).stream().map(School::getId).collect(toSet());
    }

    public Set<School> findSchoolsByIds(final Set<Long> schoolIds) {
        final Set<School> schools = newHashSet();
        for (final Long schoolId : schoolIds) {
            if (organizationRepository.findMapOfSchoolsById().containsKey(schoolId)) {
                schools.add(organizationRepository.findMapOfSchoolsById().get(schoolId));
            }
        }
        return schools;
    }

    public Collection<District> findAllDistricts() {
        return organizationRepository.findMapOfDistrictsByIds().values();
    }

    public Set<Long> findAllDistrictIds() {
        return organizationRepository.findMapOfDistrictsByIds().keySet();
    }

    public Set<Long> findAllDistrictsOfSchools(final Set<Long> schoolIds) {
        final Set<Long> districtIds = newHashSet();
        final Set<Long> schoolIdsLeftToProcess = newHashSet(schoolIds);
        final Map<Long, List<School>> schoolsByDistrictId = organizationRepository.findAllSchoolsByDistrictId();
        for (final Long districtId : schoolsByDistrictId.keySet()) {
            for (final School school : schoolsByDistrictId.get(districtId)) {
                if (schoolIds.contains(school.getId())) {
                    schoolIdsLeftToProcess.remove(school.getId());
                    districtIds.add(school.getId());
                }
                if (schoolIdsLeftToProcess.isEmpty()) return districtIds;
            }

        }
        return districtIds;
    }

    //Coded entity id lookup
    public int toAssessmentTypeId(final String assessmentType) {
        return toId(assessmentType, assessmentTypeRepository);
    }

    public Set<Integer> toSubjectIds(final Collection<String> subjectCodes) {
        return toIds(subjectCodes, subjectRepository);
    }

    public Set<Integer> toGradeIds(final Collection<String> gradeCodes) {
        return toIds(gradeCodes, gradeRepository);
    }

    public Set<Integer> toCompletenessIds(final Collection<String> completenessCodes) {
        return toIds(completenessCodes, completenessRepository);
    }

    public Set<Integer> toAdministrativeConditionIds(final Collection<String> administrativeConditionCodes) {
        return toIds(administrativeConditionCodes, administrativeConditionRepository);
    }

    public Set<Integer> toGenderIds(final Collection<String> genderCodes) {
        return toIds(genderCodes, genderRepository);
    }

    public Set<Integer> toEthnicityIds(final Collection<String> ethnicityCodes) {
        return toIds(ethnicityCodes, ethnicityRepository);
    }

    public Set<Integer> toStrictBooleanIds(final Collection<String> strictBooleanCodes) {
        return toIds(strictBooleanCodes, strictBooleanRepository);
    }

    public Set<Integer> toBooleanIds(final Collection<String> booleanCodes) {
        return toIds(booleanCodes, booleanRepository);
    }

    private CodedEntityRepository getRepositoryAndAddFilterByDimensionType(final DimensionType dimensionType,
                                                                           final ReportQuery query,
                                                                           final Set<Integer> ids) {
        switch (dimensionType) {
            case Gender:
                ids.addAll(toGenderIds(query.getGenderCodes()));
                return genderRepository;
            case Ethnicity:
                ids.addAll(toEthnicityIds(query.getEthnicityCodes()));
                return ethnicityRepository;
            case LEP:
                ids.addAll(toStrictBooleanIds(query.getLepCodes()));
                return strictBooleanRepository;
            case MigrantStatus:
                ids.addAll(toBooleanIds(query.getMigrantStatusCodes()));
                return booleanRepository;
            case Section504:
                ids.addAll(toBooleanIds(query.getSection504Codes()));
                return booleanRepository;
            case IEP:
                ids.addAll(toStrictBooleanIds(query.getIepCodes()));
                return strictBooleanRepository;
            case EconomicDisadvantage:
                ids.addAll(toStrictBooleanIds(query.getEconomicDisadvantageCodes()));
                return strictBooleanRepository;
            default:
                throw new IllegalArgumentException("unsupported request to findDimensions for dimensionType " + dimensionType);
        }
    }

    private int toId(final String code, final CodedEntityRepository repository) {
        for (final CodedEntity e : repository.findAll()) {
            if (e.getCode().equals(code)) return e.getId();
        }
        throw new IllegalArgumentException("unable to find code " + code);
    }

    private Set<Integer> toIds(final Collection<String> codes, final CodedEntityRepository repository) {
        final TreeMap<String, Integer> codeToId = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
        repository.findAll().forEach(entity -> codeToId.put(entity.getCode(), entity.getId()));
        return codes.stream()
                .map(codeToId::get)
                .collect(Collectors.toSet());
    }
}
