package org.opentestsystem.rdw.olap.repository.impl;

import com.google.common.collect.ImmutableSet;
import com.healthmarketscience.sqlbuilder.CustomSql;
import com.healthmarketscience.sqlbuilder.SelectQuery;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.olap.model.Assessment;
import org.opentestsystem.rdw.olap.model.Dimension;
import org.opentestsystem.rdw.olap.model.Measures;
import org.opentestsystem.rdw.olap.model.Organization;
import org.opentestsystem.rdw.olap.model.ReportRow;
import org.opentestsystem.rdw.olap.repository.CustomAggregateReportRepository;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.model.ReportQuery;
import org.opentestsystem.rdw.reporting.common.sqlbuilder.QueryProvider;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;
import org.springframework.util.PropertyPlaceholderHelper;

import javax.validation.constraints.NotNull;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Properties;
import java.util.Set;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.collect.ImmutableSet.copyOf;
import static com.google.common.collect.Lists.newArrayList;
import static com.healthmarketscience.sqlbuilder.SetOperationQuery.unionAll;
import static java.util.Arrays.copyOf;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.getNullable;
import static org.opentestsystem.rdw.reporting.common.model.ReportQuery.checkIsValid;

@SuppressWarnings("unchecked")
@Repository
class JdbcCustomAggregateReportRowRepository implements CustomAggregateReportRepository {

    private static final String customAggregateTemplateSql = "customAggregate";
    private static final String customAggregateAllPermutationsTemplateSql = "customAggregateAllPermutations";
    private static final String stateAddOn = "state";
    private static final String districtsAddOn = "districts";
    private static final String allDistrictsAddOn = "allDistricts";
    private static final String schoolsAddOn = "schools";
    private static final String allSchoolsInDistrictsAddOn = "allSchoolsInDistricts";

    private final NamedParameterJdbcTemplate jdbcTemplate;
    private final QueryProvider queryProvider;

    @Value("${sql.customAggregate}")
    private String customAggregateSql;

    @Value("${sql.customAggregateByEnrolledGrade}")
    private String customAggregateByEnrolledGradeSql;

    @Value("${sql.estimateReportRowCount}")
    private String estimateReportRowCountSql;

    @Autowired
    public JdbcCustomAggregateReportRowRepository(final NamedParameterJdbcTemplate jdbcTemplate,
                                                  final QueryProvider queryProvider) {
        this.jdbcTemplate = jdbcTemplate;
        this.queryProvider = queryProvider;
    }

    private static void validate(final ReportQuery query) {
        checkIsValid(query);
        checkArgument(!AssessmentType.IAB.equals(query.getAssessmentType()), "custom aggregate report for IAB is not supported yet");
    }

    @Override
    public List<ReportRow> findByQuery(@NotNull final ReportQuery query) {

        validate(query);

        final MapSqlParameterSource parameters = new MapSqlParameterSource()
                .addValue("school_years", query.getSchoolYears())
                .addValue("asmt_grade_ids", query.getAsmtGrades())
                .addValue("subject_ids", query.getSubjectIds())
                .addValue("asmt_type_id", query.getAssessmentType().id());

        if (!query.isIncludeAllDistricts() && !query.getDistrictIds().isEmpty()) parameters.addValue("district_ids", query.getDistrictIds());
        if (!query.getDistrictIdsWithAllSchools().isEmpty()) parameters.addValue("school_district_ids", query.getDistrictIdsWithAllSchools());
        if (!query.getSchoolIds().isEmpty()) parameters.addValue("school_ids", query.getSchoolIds());
        if (!query.getCompletenessCodes().isEmpty()) parameters.addValue("completeness_codes", query.getCompletenessCodes());
        if (!query.getAdministrativeConditionCodes().isEmpty()) parameters.addValue("administration_condition_codes", query.getAdministrativeConditionCodes());

        return jdbcTemplate.query(
                toQueryString(query),
                parameters,
                (row, index) -> ReportRow.builder()
                        .assessment(new Assessment(row.getInt("asmt_id"), row.getInt("asmt_grade_id"), row.getInt("subject_id")))
                        .examSchoolYear(row.getInt("school_year"))
                        .dimension(new Dimension(getNullable(row, row.getString("dimension_code")), DimensionType.caseInsensitiveValue(row.getString("dimension"))))
                        .organization(new Organization(row.getString("organization_name"), getNullable(row, row.getInt("organization_id")), OrganizationType.caseInsensitiveValue(row.getString("organization_type"))))
                        .measures(Measures.builder()
                                .avgScaleScore(row.getInt("score"))
                                .avgStdErr(row.getInt("std_err"))
                                .level1Count(row.getInt("level1"))
                                .level2Count(row.getInt("level2"))
                                .level3Count(row.getInt("level3"))
                                .level4Count(row.getInt("level4"))
                                .build())
                        .build());
    }

    @Override
    public int estimateReportRowCount(@NotNull final ReportQuery query) {

        validate(query);

        final Set<DimensionType> dimensionTypes = query.getDimensionTypes();
        final MapSqlParameterSource parameterSource = new MapSqlParameterSource()
                .addValue("school_years", query.getSchoolYears())
                .addValue("asmt_grade_ids", query.getAsmtGrades())
                .addValue("subject_ids", query.getSubjectIds())
                .addValue("asmt_type_id", query.getAssessmentType().id())
                .addValue("gender", dimensionTypes.contains(DimensionType.Gender))
                .addValue("ethnicity", dimensionTypes.contains(DimensionType.Ethnicity))
                .addValue("iep", dimensionTypes.contains(DimensionType.IEP))
                .addValue("lep", dimensionTypes.contains(DimensionType.LEP))
                .addValue("section504", dimensionTypes.contains(DimensionType.Section504))
                .addValue("economic_disadvantage", dimensionTypes.contains(DimensionType.EconomicDisadvantage))
                .addValue("migrant_status", dimensionTypes.contains(DimensionType.MigrantStatus))
                .addValue("student_enrolled_grade", dimensionTypes.contains(DimensionType.StudentEnrolledGrade))
                .addValue("overall", dimensionTypes.contains(DimensionType.Overall))
                .addValue("isIncludeState", query.isIncludeState())
                .addValue("isIncludeAllDistricts", query.isIncludeAllDistricts())
                .addValue("isIncludeDistricts", (!query.isIncludeAllDistricts() && !query.getDistrictIds().isEmpty()))
                .addValue("district_ids", (!query.isIncludeAllDistricts() && !query.getDistrictIds().isEmpty()) ? query.getDistrictIds() : -1)
                .addValue("isIncludeAllSchoolsInDistricts", !query.getDistrictIdsWithAllSchools().isEmpty())
                .addValue("school_district_ids", !query.getDistrictIdsWithAllSchools().isEmpty() ? query.getDistrictIdsWithAllSchools() : -1)
                .addValue("isIncludeSchools", !query.getSchoolIds().isEmpty())
                .addValue("school_ids", !query.getSchoolIds().isEmpty() ? query.getSchoolIds() : -1);

        return jdbcTemplate.queryForObject(estimateReportRowCountSql, parameterSource, Integer.class);
    }

    /**
     * A {@link ReportQuery} may include different types of organizations as well as different dimensions.
     * Each pair of organization/dimension is a separate SQL query. To avoid multiple round-trips to Redshift we want to build
     * them all and combine by 'UNION ALL' SQL clauses.
     */
    private String toQueryString(final ReportQuery query) {
        final List<SelectQuery> queries = newArrayList();

        for (final DimensionType dimension : query.getDimensionTypes()) {
            if (query.isIncludeState()) {
                queries.add(buildSql(newArrayList(stateAddOn), dimension, query));
            }

            if (query.isIncludeAllDistricts()) {
                queries.add(buildSql(newArrayList(allDistrictsAddOn), dimension, query));
            } else if (!query.getDistrictIds().isEmpty()) {
                queries.add(buildSql(newArrayList(allDistrictsAddOn, districtsAddOn), dimension, query));
            }

            if (!query.getDistrictIdsWithAllSchools().isEmpty()) {
                queries.add(buildSql(newArrayList(allSchoolsInDistrictsAddOn), dimension, query));
            }

            if (!query.getSchoolIds().isEmpty()) {
                queries.add(buildSql(newArrayList(schoolsAddOn), dimension, query));
            }
        }
        return queries.size() == 1 ? queries.get(0).toString() : unionAll(copyOf(queries.toArray(), queries.size(), SelectQuery[].class)).toString();
    }

    /**
     * Given `add-on`s that represent an `organization` part, build a SQL for the given dimension and query filters
     *
     * @param addOns        the collection of `add on`s that represent an `organization` part of SQL
     * @param dimensionType the {@link DimensionType} to add
     * @param query         the original {@link ReportQuery} with the filters
     * @return a built SQL string
     */
    private SelectQuery buildSql(final Collection<String> addOns, final DimensionType dimensionType, final ReportQuery query) {
        addOns.add(dimensionType.name());

        final Properties properties = new Properties();
        properties.put(customAggregateTemplateSql, buildCustomAggregateSqlString(query, copyOf(addOns)));

        if (dimensionType.equals(DimensionType.StudentEnrolledGrade)) {
            return new SelectQuery().addCustomColumns(new CustomSql(replacePlaceholders(customAggregateByEnrolledGradeSql, properties)));
        } else {
            properties.put(customAggregateAllPermutationsTemplateSql, queryProvider.newQuery(customAggregateAllPermutationsTemplateSql, addOns).toString());
            return new SelectQuery().addCustomColumns(new CustomSql(replacePlaceholders(customAggregateSql, properties)));
        }
    }

    private String buildCustomAggregateSqlString(final ReportQuery query, final ImmutableSet<String> addOns) {
        final Set<String> addOnsWithFilters = new HashSet(addOns);

        if (!query.getAdministrativeConditionCodes().isEmpty()) addOnsWithFilters.add("administration_condition");
        if (!query.getCompletenessCodes().isEmpty()) addOnsWithFilters.add("completeness");
        return queryProvider.newQuery(customAggregateTemplateSql, addOnsWithFilters).toString();
    }

    private String replacePlaceholders(final String val, final Properties properties) {
        final PropertyPlaceholderHelper propertyPlaceholderHelper = new PropertyPlaceholderHelper("@{template.", "}");
        return propertyPlaceholderHelper.replacePlaceholders(val, properties);
    }
}