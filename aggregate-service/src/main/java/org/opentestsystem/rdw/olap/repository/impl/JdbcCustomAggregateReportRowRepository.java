package org.opentestsystem.rdw.olap.repository.impl;

import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.olap.repository.ActiveAssessmentRepository;
import org.opentestsystem.rdw.olap.repository.CustomAggregateReportRepository;
import org.opentestsystem.rdw.olap.repository.EmbargoRepository;
import org.opentestsystem.rdw.olap.repository.OrganizationRepository;
import org.opentestsystem.rdw.olap.sqlbuilder.CustomAggregateQueryWithReportTemplateProvider;
import org.opentestsystem.rdw.olap.sqlbuilder.CustomAggregateReportContextProvider;
import org.opentestsystem.rdw.olap.sqlbuilder.QueryProviderRepositoryHelper;
import org.opentestsystem.rdw.olap.sqlbuilder.QueryWithReportTemplate;
import org.opentestsystem.rdw.olap.sqlbuilder.ReportContext;
import org.opentestsystem.rdw.reporting.common.model.ActiveAssessment;
import org.opentestsystem.rdw.reporting.common.model.AggregateReport;
import org.opentestsystem.rdw.reporting.common.model.Dimension;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.Measures;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.model.ReportQuery;
import org.opentestsystem.rdw.reporting.common.model.ReportRow;
import org.opentestsystem.rdw.reporting.common.model.School;
import org.opentestsystem.rdw.reporting.common.security.PermissionSource;
import org.opentestsystem.rdw.reporting.common.sqlbuilder.QueryProvider;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.task.TaskExecutor;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;

import javax.validation.constraints.NotNull;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;

import static java.util.stream.Collectors.toList;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.getNullable;
import static org.opentestsystem.rdw.reporting.common.model.AggregateReport.builder;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.District;

@Repository
class JdbcCustomAggregateReportRowRepository implements CustomAggregateReportRepository {

    private final NamedParameterJdbcTemplate jdbcTemplate;
    private final QueryProviderRepositoryHelper reportQueryRepositoryHelper;
    private final ActiveAssessmentRepository activeAssessmentRepository;
    private final OrganizationRepository organizationRepository;
    private final EmbargoRepository embargoRepository;
    private final QueryProvider queryProvider;
    private final Executor threadPoolTaskExecutor;
    private final Organization state;

    @Value("${app.aggregate-reports.custom-aggregate-report-repository.organization-partition-size}")
    private int organizationPartitionSize;

    @Value("${app.school-year}")
    private int currentSchoolYear;

    @Autowired
    public JdbcCustomAggregateReportRowRepository(@Value("${app.state.name}") final String stateName,
                                                  final NamedParameterJdbcTemplate jdbcTemplate,
                                                  final QueryProviderRepositoryHelper reportQueryRepositoryHelper,
                                                  final ActiveAssessmentRepository activeAssessmentRepository,
                                                  final OrganizationRepository organizationRepository,
                                                  final QueryProvider queryProvider,
                                                  final EmbargoRepository embargoRepository,
                                                  final TaskExecutor threadPoolTaskExecutor) {
        this.jdbcTemplate = jdbcTemplate;
        this.reportQueryRepositoryHelper = reportQueryRepositoryHelper;
        this.activeAssessmentRepository = activeAssessmentRepository;
        this.organizationRepository = organizationRepository;
        this.embargoRepository = embargoRepository;
        this.queryProvider = queryProvider;
        this.state = Organization.builder().name(stateName).organizationType(OrganizationType.State).build();
        this.threadPoolTaskExecutor = threadPoolTaskExecutor;
    }

    @Override
    public int estimateReportRowCount(@NotNull final ReportQuery query) {
        return new CustomAggregateReportContextProvider<>(state, reportQueryRepositoryHelper)
                .toQuery(query)
                .stream()
                .mapToInt(ReportContext::getEstimatedRowCount)
                .sum();
    }

    @Override
    public AggregateReport findByQuery(@NotNull final PermissionSource permissionSource, @NotNull final ReportQuery query) {
        final List<AggregateReport> reports = new CustomAggregateQueryWithReportTemplateProvider(state, organizationPartitionSize, queryProvider, reportQueryRepositoryHelper, permissionSource)
                .toQuery(query)
                .stream()
                .map(q -> new RunQueryTask(q, query.getAssessmentTypeCode()))
                .map(t -> CompletableFuture.supplyAsync(t::run, threadPoolTaskExecutor))
                .map(CompletableFuture::join)
                .collect(toList());

        final AggregateReport.Builder mergedReportBuilder = builder();
        for (final AggregateReport report : reports) {
            mergedReportBuilder.merge(report);
        }
        return mergedReportBuilder.build();
    }

    private class RunQueryTask {
        private final QueryWithReportTemplate queryWithReportTemplate;
        private final String asmtTypeCode;

        RunQueryTask(final QueryWithReportTemplate queryWithReportTemplate, final String asmtTypeCode) {
            this.queryWithReportTemplate = queryWithReportTemplate;
            this.asmtTypeCode = asmtTypeCode;
        }

        /**
         * Execute a SQL query and back-fill missing rows using {@link QueryWithReportTemplate#getReportTemplate()}
         */
        AggregateReport run() {
            final AggregateReport.Builder reportBuilder = builder();
            final Set<ReportRow> templateRows = queryWithReportTemplate.getReportTemplate();
            reportBuilder.rows(jdbcTemplate.query(
                    queryWithReportTemplate.getSqlQuery(),
                    queryWithReportTemplate.getParameterSource(),
                    (row, index) -> {
                        final ReportRow r = ReportRow.builder()
                                .assessment(findByIdAndSchoolYear(asmtTypeCode, row.getInt("asmt_id"), row.getInt("school_year")))
                                .dimension(Dimension.builder().code(getNullable(row, row.getString("dimension_code"))).type(DimensionType.caseInsensitiveValue(row.getString("dimension"))).build())
                                .organization(findOneByIdAndType(row.getLong("organization_id"), OrganizationType.valueOf(row.getString("organization_type"))))
                                .measures(Measures.builder()
                                        .avgScaleScore(row.getInt("score"))
                                        .avgStdErr(row.getInt("std_err"))
                                        .level1Count(row.getInt("level1"))
                                        .level2Count(row.getInt("level2"))
                                        .level3Count(row.getInt("level3"))
                                        .level4Count(row.getInt("level4"))
                                        .build())
                                .build();
                        if (!reportBuilder.isCreatedWhileDataEmbargoed()) reportBuilder.createdWhileDataEmbargoed(isCreatedWhileDataEmbargoed(r));
                        return removeFromTemplateIfExists(templateRows, r);
                    }));
            if (!templateRows.isEmpty()) reportBuilder.rows(templateRows);
            return reportBuilder.build();
        }

        private ReportRow removeFromTemplateIfExists(final Set<ReportRow> template, final ReportRow rowToVerify) {
            template.removeIf(row -> (row.getDimension().equals(rowToVerify.getDimension())
                    && row.getOrganization().equals(rowToVerify.getOrganization())
                    && row.getAssessment().equals(rowToVerify.getAssessment())));
            return rowToVerify;
        }

        /**
         * Process the row for a flag indicating that it has been generated while the data is embargo enabled.
         * This assumes that the SQL query filters out embargoed data for users that are not allowed to view it
         * and this method is only called when the data is allowed for the user.
         */
        private boolean isCreatedWhileDataEmbargoed(final ReportRow rowToVerify) {

            // embargo is only applicable to summative exams
            if (!asmtTypeCode.equalsIgnoreCase(AssessmentType.SUMMATIVE.code())) return false;

            //embargo is only applicable to the current year exams
            if (rowToVerify.getAssessment().getExamSchoolYear() != currentSchoolYear) return false;

            final Organization organization = rowToVerify.getOrganization();

            if (organization.getOrganizationType().equals(OrganizationType.State)) return embargoRepository.isStateEmbargoed();

            //schools inherit their district embargo flag
            final Long districtId = organization.getOrganizationType().equals(District) ? organization.getId() : ((School) organization).getDistrictId();
            return isDistrictEmbargoed(districtId);
        }

        private boolean isDistrictEmbargoed(final long districtId) {
            return embargoRepository.findAllEmbargoedDistrictIds().contains(districtId);
        }

        /**
         * To simplify a report SQL, we are loading assessments and organizations separately.
         * This assumes/relies on the repositories results to be cached
         */

        private ActiveAssessment findByIdAndSchoolYear(final String assessmentTypeCode, final int assessmentId, int schoolYear) {
            for (final ActiveAssessment activeAssessment : activeAssessmentRepository.findAllByTypeCode(assessmentTypeCode)) {
                if (activeAssessment.getId() == assessmentId && activeAssessment.getExamSchoolYear() == schoolYear)
                    return activeAssessment;
            }
            throw new IllegalArgumentException("unable to find an assessment by id " + assessmentId + " and school year " + schoolYear);
        }

        private Organization findOneByIdAndType(final long id, final OrganizationType type) {
            switch (type) {
                case School:
                    return organizationRepository.findMapOfSchoolsById().get(id);
                case District:
                    return organizationRepository.findMapOfDistrictsByIds().get(id);
                case State:
                    return state;
                default:
                    throw new IllegalStateException("Not supported organization type: " + type);
            }
        }
    }
}