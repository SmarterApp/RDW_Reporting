package org.opentestsystem.rdw.olap.sqlbuilder;

import com.google.common.collect.ImmutableList;
import org.opentestsystem.rdw.olap.model.CodedEntity;
import org.opentestsystem.rdw.olap.model.OrganizationTypeQuery;
import org.opentestsystem.rdw.olap.repository.ActiveAssessmentRepository;
import org.opentestsystem.rdw.olap.repository.AdministrationConditionRepository;
import org.opentestsystem.rdw.olap.repository.AssessmentGradeRepository;
import org.opentestsystem.rdw.olap.repository.AssessmentTypeRepository;
import org.opentestsystem.rdw.olap.repository.BooleanRepository;
import org.opentestsystem.rdw.olap.repository.CodedEntityRepository;
import org.opentestsystem.rdw.olap.repository.CompletenessRepository;
import org.opentestsystem.rdw.olap.repository.ElasRepository;
import org.opentestsystem.rdw.olap.repository.EthnicityRepository;
import org.opentestsystem.rdw.olap.repository.GenderRepository;
import org.opentestsystem.rdw.olap.repository.OrganizationRepository;
import org.opentestsystem.rdw.olap.repository.SchoolYearRepository;
import org.opentestsystem.rdw.olap.repository.StrictBooleanRepository;
import org.opentestsystem.rdw.olap.repository.SubjectRepository;
import org.opentestsystem.rdw.reporting.common.model.ActiveAssessment;
import org.opentestsystem.rdw.reporting.common.model.Dimension;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.District;
import org.opentestsystem.rdw.reporting.common.model.School;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Sets.newHashSet;
import static java.util.stream.Collectors.toSet;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.Overall;
import static org.opentestsystem.rdw.reporting.common.model.DimensionType.StudentEnrolledGrade;

/**
 * Helper to manipulate the data from different repositories into format suitable for the {@link QueryProvider}s.
 * This helper uses multiple repositories that are expected to be `cacheable`.
 * It is only here to avoid multiple round-trips to Redshift.
 */
@Service
public class QueryProviderRepositoryHelper {

    private final OrganizationRepository organizationRepository;
    private final ActiveAssessmentRepository activeAssessmentRepository;
    private final GenderRepository genderRepository;
    private final ElasRepository elasRepository;
    private final EthnicityRepository ethnicityRepository;
    private final BooleanRepository booleanRepository;
    private final StrictBooleanRepository strictBooleanRepository;
    private final SubjectRepository subjectRepository;
    private final AssessmentTypeRepository assessmentTypeRepository;
    private final AssessmentGradeRepository gradeRepository;
    private final CompletenessRepository completenessRepository;
    private final AdministrationConditionRepository administrativeConditionRepository;
    private final SchoolYearRepository schoolYearRepository;

    @Autowired
    public QueryProviderRepositoryHelper(final OrganizationRepository organizationRepository,
                                         final ActiveAssessmentRepository activeAssessmentRepository,
                                         final GenderRepository genderRepository,
                                         final ElasRepository elasRepository,
                                         final EthnicityRepository ethnicityRepository,
                                         final BooleanRepository booleanRepository,
                                         final StrictBooleanRepository strictBooleanRepository,
                                         final SubjectRepository subjectRepository,
                                         final AssessmentTypeRepository assessmentTypeRepository,
                                         final AssessmentGradeRepository gradeRepository,
                                         final CompletenessRepository completenessRepository,
                                         final AdministrationConditionRepository administrativeConditionRepository,
                                         final SchoolYearRepository schoolYearRepository) {
        this.organizationRepository = organizationRepository;
        this.activeAssessmentRepository = activeAssessmentRepository;
        this.genderRepository = genderRepository;
        this.elasRepository = elasRepository;
        this.ethnicityRepository = ethnicityRepository;
        this.booleanRepository = booleanRepository;
        this.strictBooleanRepository = strictBooleanRepository;
        this.subjectRepository = subjectRepository;
        this.assessmentTypeRepository = assessmentTypeRepository;
        this.gradeRepository = gradeRepository;
        this.completenessRepository = completenessRepository;
        this.administrativeConditionRepository = administrativeConditionRepository;
        this.schoolYearRepository = schoolYearRepository;
    }

    /**
     * Finds all {@link ActiveAssessment} represented by the given parameters.
     * It is used to fill in gap data in the custom aggregate report.
     *
     * @param assessmentTypeCode   assessment type code
     * @param schoolYears          school years
     * @param subjectCodes         subject codes
     * @param assessmentGradeCodes assessment grade codes
     * @return a set of {@link ActiveAssessment}s
     */
    public Set<ActiveAssessment> findAssessments(final String assessmentTypeCode,
                                                 final Set<Integer> schoolYears,
                                                 final Set<String> subjectCodes,
                                                 final Set<String> assessmentGradeCodes) {
        final Set<ActiveAssessment> assessments = newHashSet();
        for (final ActiveAssessment assessment : activeAssessmentRepository.findAllByTypeCode(assessmentTypeCode)) {
            if (schoolYears.contains(assessment.getExamSchoolYear())
                    && subjectCodes.contains(assessment.getSubjectCode())
                    && assessmentGradeCodes.contains(assessment.getGradeCode())) {
                assessments.add(assessment);
            }
        }
        return assessments;
    }

    /**
     * Return all possible values for the given {@link DimensionType} filtered based on the given {@link OrganizationTypeQuery}
     * This is used to fill in the gaps of the missing data in the custom aggregate report
     *
     * @param dimensionType the {@link DimensionType}
     * @param query         the {@link OrganizationTypeQuery}
     * @return all possible values for the given {@link DimensionType} filtered based on the given {@link OrganizationTypeQuery}
     */
    public List<Dimension> findDimensionsByTypeAndQueryFilters(final DimensionType dimensionType, final OrganizationTypeQuery query) {

        //we do not back-fill data for this dimension type
        if (dimensionType.equals(StudentEnrolledGrade)) return ImmutableList.of();

        if (dimensionType.equals(Overall)) return ImmutableList.of(Dimension.builder().type(Overall).build());

        final Set<Integer> filters = newHashSet();
        final CodedEntityRepository repository = getRepositoryAndAddFilterByDimensionType(dimensionType, query, filters);

        final Predicate<CodedEntity> predicate = filters.isEmpty()
                ? entity -> true
                : entity -> filters.contains(entity.getId());

        return repository.findAll().stream()
                .filter(predicate)
                .map(g -> Dimension.builder().code(g.getCode()).type(dimensionType).build())
                .collect(Collectors.toList());

    }

    public Set<District> findDistrictsByIds(final Set<Long> districtIds) {
        final Set<District> districts = newHashSet();
        for (final Long districtId : districtIds) {
            if (organizationRepository.findMapOfDistrictsByIds().containsKey(districtId)) {
                districts.add(organizationRepository.findMapOfDistrictsByIds().get(districtId));
            }
        }
        return districts;
    }

    public Set<School> findSchoolsByDistrictIds(final Set<Long> districtIds) {
        final Set<School> schools = newHashSet();
        for (final Long districtId : districtIds) {
            if (organizationRepository.findAllSchoolsByDistrictId().containsKey(districtId)) {
                schools.addAll(organizationRepository.findAllSchoolsByDistrictId().get(districtId));
            }
        }
        return schools;
    }

    public Set<Long> findSchoolsIdsByDistrictIds(final Set<Long> districtIds) {
        return findSchoolsByDistrictIds(districtIds).stream().map(School::getId).collect(toSet());
    }

    public Set<School> findSchoolsByIds(final Set<Long> schoolIds) {
        final Set<School> schools = newHashSet();
        for (final Long schoolId : schoolIds) {
            if (organizationRepository.findMapOfSchoolsById().containsKey(schoolId)) {
                schools.add(organizationRepository.findMapOfSchoolsById().get(schoolId));
            }
        }
        return schools;
    }

    public Collection<District> findAllDistricts() {
        return organizationRepository.findMapOfDistrictsByIds().values();
    }

    public Set<Long> findAllDistrictIds() {
        return organizationRepository.findMapOfDistrictsByIds().keySet();
    }

    public Set<Long> findAllDistrictsOfSchools(final Set<Long> schoolIds) {
        final Set<Long> districtIds = newHashSet();
        final Set<Long> schoolIdsLeftToProcess = newHashSet(schoolIds);
        final Map<Long, List<School>> schoolsByDistrictId = organizationRepository.findAllSchoolsByDistrictId();
        for (final Map.Entry<Long, List<School>> entry : schoolsByDistrictId.entrySet()) {
            final Long districtId = entry.getKey();
            for (final School school : entry.getValue()) {
                if (schoolIds.contains(school.getId())) {
                    schoolIdsLeftToProcess.remove(school.getId());
                    districtIds.add(districtId);
                }
                if (schoolIdsLeftToProcess.isEmpty()) return districtIds;
            }
        }
        return districtIds;
    }

    //Coded entity id lookup
    public int toAssessmentTypeId(final String assessmentType) {
        return toId(assessmentType, assessmentTypeRepository);
    }

    public Set<Integer> toSubjectIds(final Collection<String> subjectCodes) {
        return toIds(subjectCodes, subjectRepository);
    }

    public Set<Integer> toGradeIds(final Collection<String> gradeCodes) {
        return toIds(gradeCodes, gradeRepository);
    }

    public Set<Integer> toCompletenessIds(final Collection<String> completenessCodes) {
        return toIds(completenessCodes, completenessRepository);
    }

    public Set<Integer> toAdministrativeConditionIds(final Collection<String> administrativeConditionCodes) {
        return toIds(administrativeConditionCodes, administrativeConditionRepository);
    }

    public Set<Integer> toGenderIds(final Collection<String> genderCodes) {
        return toIds(genderCodes, genderRepository);
    }

    public Set<Integer> toElasIds(final Collection<String> elasCodes) {
        return toIds(elasCodes, elasRepository);
    }

    public Set<Integer> toEthnicityIds(final Collection<String> ethnicityCodes) {
        return toIds(ethnicityCodes, ethnicityRepository);
    }

    public Set<Integer> toStrictBooleanIds(final Collection<String> strictBooleanCodes) {
        return toIds(strictBooleanCodes, strictBooleanRepository);
    }

    public Set<Integer> toBooleanIds(final Collection<String> booleanCodes) {
        return toIds(booleanCodes, booleanRepository);
    }

    public int maxSize(final DimensionType dimensionType) {
        switch (dimensionType) {
            case Gender:
                return maxSize(genderRepository);
            case Ethnicity:
                return maxSize(ethnicityRepository);
            case LEP:
                return maxSize(strictBooleanRepository);
            case ELAS:
                return maxSize(elasRepository);
            case MigrantStatus:
                return maxSize(booleanRepository);
            case Section504:
                return maxSize(booleanRepository);
            case IEP:
                return maxSize(strictBooleanRepository);
            case EconomicDisadvantage:
                return maxSize(strictBooleanRepository);
            default:
                throw new IllegalArgumentException("unsupported request to findDimensions for dimensionType " + dimensionType);
        }
    }

    public int maxCompletenessCodes() {
        return maxSize(completenessRepository);
    }

    public int maxAdministrativeConditions() {
        return maxSize(administrativeConditionRepository);
    }

    public int maxSchoolYears() {
        return schoolYearRepository.findAll().size();
    }

    public int maxAssessmentGrades() {
        return gradeRepository.findAll().size();
    }

    public int maxSubjects() {
        return subjectRepository.findAll().size();
    }


    private int maxSize(final CodedEntityRepository repository) {
        return repository.findAll().size();
    }

    private CodedEntityRepository getRepositoryAndAddFilterByDimensionType(final DimensionType dimensionType,
                                                                           final OrganizationTypeQuery query,
                                                                           final Set<Integer> ids) {
        switch (dimensionType) {
            case Gender:
                ids.addAll(toGenderIds(query.getGenderCodes()));
                return genderRepository;
            case Ethnicity:
                ids.addAll(toEthnicityIds(query.getEthnicityCodes()));
                return ethnicityRepository;
            case LEP:
                ids.addAll(toStrictBooleanIds(query.getLepCodes()));
                return strictBooleanRepository;
            case ELAS:
                ids.addAll(toElasIds(newArrayList()));
                return elasRepository;
            case MigrantStatus:
                ids.addAll(toBooleanIds(query.getMigrantStatusCodes()));
                return booleanRepository;
            case Section504:
                ids.addAll(toBooleanIds(query.getSection504Codes()));
                return booleanRepository;
            case IEP:
                ids.addAll(toStrictBooleanIds(query.getIepCodes()));
                return strictBooleanRepository;
            case EconomicDisadvantage:
                ids.addAll(toStrictBooleanIds(query.getEconomicDisadvantageCodes()));
                return strictBooleanRepository;
            default:
                throw new IllegalArgumentException("unsupported request to findDimensions for dimensionType " + dimensionType);
        }
    }

    private int toId(final String code, final CodedEntityRepository repository) {
        for (final CodedEntity e : repository.findAll()) {
            if (e.getCode().equals(code)) return e.getId();
        }
        throw new IllegalArgumentException("unable to find code " + code);
    }

    private Set<Integer> toIds(final Collection<String> codes, final CodedEntityRepository repository) {
        final TreeMap<String, Integer> codeToId = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
        repository.findAll().forEach(entity -> codeToId.put(entity.getCode(), entity.getId()));
        return codes.stream()
                .map(codeToId::get)
                .collect(Collectors.toSet());
    }
}
