package org.opentestsystem.rdw.olap.stream;

import com.amazonaws.services.s3.Headers;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.opentestsystem.rdw.olap.model.AggregateReport;
import org.opentestsystem.rdw.olap.service.CustomAggregateService;
import org.opentestsystem.rdw.reporting.common.model.AggregateRequestMessage;
import org.opentestsystem.rdw.reporting.common.model.AggregateResponseMessage;
import org.opentestsystem.rdw.reporting.common.stream.MessageSecurityService;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.net.URI;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Properties;

import static org.opentestsystem.rdw.olap.stream.AggregateRequestProcessor.AggregateRequest;
import static org.opentestsystem.rdw.reporting.common.model.ReportStatus.COMPLETED;
import static org.opentestsystem.rdw.reporting.common.model.ReportStatus.FAILED;
import static org.opentestsystem.rdw.reporting.common.model.ReportStatus.NO_RESULTS;
import static org.springframework.http.MediaType.APPLICATION_JSON;

/**
 * This component is responsible for processing aggregate report requests arriving
 * via a message.  A report is generated, persisted to the archive service, and
 * a response message is published to the response message channel.
 */
@Component
public class AggregateReports {
    private static final Logger logger = LoggerFactory.getLogger(AggregateReports.class);

    private final AggregateRequestProcessor processor;
    private final MessageSecurityService messageSecurityService;
    private final CustomAggregateService service;
    private final ObjectMapper objectMapper;
    private final ArchiveService archiveService;

    @Autowired
    public AggregateReports(final AggregateRequestProcessor processor,
                            final MessageSecurityService messageSecurityService,
                            final CustomAggregateService service,
                            final ObjectMapper objectMapper,
                            final ArchiveService archiveService) {
        this.processor = processor;
        this.messageSecurityService = messageSecurityService;
        this.service = service;
        this.objectMapper = objectMapper;
        this.archiveService = archiveService;
    }

    @StreamListener(AggregateRequest)
    public void handleAggregateRequest(final Message<AggregateRequestMessage> message) {
        final AggregateRequestMessage payload = message.getPayload();
        logger.debug("Received aggregate report request: {}", payload.getId());

        Path jsonFile = null;
        try {
            final User user = messageSecurityService.getUser(message);
            final AggregateReport report = service.findByQuery(user, payload.getQuery());

            final boolean hasResults = report.getRows().stream()
                    .anyMatch(reportRow -> reportRow.getMeasures().getAvgScaleScore() != null);
            if (!hasResults) {
                sendNoResults(payload.getId());
                return;
            }

            jsonFile = Files.createTempFile(String.valueOf(payload.getId()), "json");

            objectMapper.writeValue(jsonFile.toFile(), report.getRows());
            archiveJson(jsonFile.toFile(), payload.getResponseLocation());
            sendSuccess(payload.getId(), report.getRows().size(), report.isCreatedWhileDataEmbargoed());

        } catch (final Exception e) {
            logger.warn("Unable to generate aggregate report", e);
            sendFailure(payload.getId(), e.getMessage());

        } finally {
            if (jsonFile != null) {
                try {
                    Files.deleteIfExists(jsonFile);
                } catch (final IOException e) {
                    logger.warn("Unable to delete temporary aggregate report json file", e);
                }
            }
        }

    }

    private void archiveJson(final File jsonfile, final URI targetLocation) throws IOException {
        final Properties properties = new Properties();
        properties.put(Headers.CONTENT_LENGTH, jsonfile.length());
        properties.put(Headers.CONTENT_TYPE, APPLICATION_JSON.toString());

        try (final FileInputStream input = new FileInputStream(jsonfile)) {
            archiveService.writeResource(targetLocation.toASCIIString(), input, properties);
        }
    }

    private void sendFailure(final long requestId, final String infoMessage) {
        final AggregateResponseMessage responsePayload = AggregateResponseMessage.builder()
                .id(requestId)
                .status(FAILED)
                .message(infoMessage)
                .build();
        final Message<AggregateResponseMessage> responseMessage = MessageBuilder.createMessage(responsePayload, new MessageHeaders(new HashMap<>()));
        processor.aggregateResponse().send(responseMessage);
    }

    private void sendSuccess(final long requestId, final long resultCount, final boolean createdWhileDataEmbargoed) {
        final AggregateResponseMessage responsePayload = AggregateResponseMessage.builder()
                .id(requestId)
                .status(COMPLETED)
                .resultCount(resultCount)
                .createdWhileDataEmbargoed(createdWhileDataEmbargoed)
                .build();
        final Message<AggregateResponseMessage> responseMessage = MessageBuilder.createMessage(responsePayload, new MessageHeaders(new HashMap<>()));
        processor.aggregateResponse().send(responseMessage);
        logger.debug("Sent aggregate report success response: {}", requestId);
    }

    private void sendNoResults(final long requestId) {
        final AggregateResponseMessage responsePayload = AggregateResponseMessage.builder()
                .id(requestId)
                .status(NO_RESULTS)
                .build();
        final Message<AggregateResponseMessage> responseMessage = MessageBuilder.createMessage(responsePayload, new MessageHeaders(new HashMap<>()));
        processor.aggregateResponse().send(responseMessage);
        logger.debug("Sent aggregate report no results response: {}", requestId);
    }
}
