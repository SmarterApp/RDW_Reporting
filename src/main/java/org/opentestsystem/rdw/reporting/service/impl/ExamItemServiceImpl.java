package org.opentestsystem.rdw.reporting.service.impl;

import com.google.common.io.ByteStreams;
import org.opentestsystem.rdw.reporting.model.AnswerKey;
import org.opentestsystem.rdw.reporting.model.ExamItemSolution;
import org.opentestsystem.rdw.reporting.model.ScoringCriteria;
import org.opentestsystem.rdw.reporting.repository.ArtifactRepository;
import org.opentestsystem.rdw.reporting.service.ExamItemService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import java.io.IOException;
import java.io.InputStream;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

// TODO: Implement authorization
@Service
public class ExamItemServiceImpl implements ExamItemService {
    private static final Logger logger = LoggerFactory.getLogger(ExamItemServiceImpl.class);
    private ArtifactRepository artifactRepository;

    @Autowired
    public ExamItemServiceImpl(ArtifactRepository artifactRepository)
    {
        this.artifactRepository = artifactRepository;
    }

    @Override
    public ExamItemSolution getByItemNumber(String number) {
        try {
            Document xmlDoc = getXmlDocument(number);

            XPath xPath = XPathFactory
                .newInstance()
                .newXPath();

            return getExamItemSolution(xPath, xmlDoc, number);
        } catch (IOException e) {
            String message = "Error reading the item xml for item number: " + number;

            logger.warn(message, e);
            throw new RuntimeException(message, e);
        } catch (SAXException | ParserConfigurationException e) {
            String message = "Error parsing the item xml for item number: " + number;

            logger.warn(message, e);
            throw new RuntimeException(message, e);
        }
    }

    private Document getXmlDocument(String id) throws IOException, SAXException, ParserConfigurationException {
        DocumentBuilderFactory builder = DocumentBuilderFactory.newInstance();

        builder.setValidating(false);
        builder.setIgnoringComments(false);
        builder.setIgnoringElementContentWhitespace(true);
        builder.setNamespaceAware(true);

        InputStream fileStream = artifactRepository.getItemXml(id);
        return builder
            .newDocumentBuilder()
            .parse(fileStream);
    }

    private ExamItemSolution getExamItemSolution(XPath xPath, Document xmlDoc, String id){
        try {
            Node rubriclistNode = (Node) xPath
                .compile("/itemrelease/item/content/rubriclist")
                .evaluate(xmlDoc, XPathConstants.NODE);

            return new ExamItemSolution()
                .builder()
                .answerKey(getAnswerKey(xPath, xmlDoc))
                .rubrics(getRubrics(xPath, id, rubriclistNode))
                .exemplars(getExemplars(xPath, id, rubriclistNode))
                .build();

        } catch (XPathExpressionException e) {
            logger.warn("Error while parsing item xml.", e);
            throw new RuntimeException("Error parsing xml for id: " + id, e);
        }
    }

    private AnswerKey getAnswerKey(XPath xPath, Document xmlDoc) {

        try{
            if(!itemFormatIsValidToHaveAnswerKey(xPath, xmlDoc))
                return null;

            Node answerKeyNode = (Node) xPath
                .compile("/itemrelease/item/attriblist/attrib[@attid=\"itm_att_Answer Key\"]")
                .evaluate(xmlDoc, XPathConstants.NODE);

            if(answerKeyNode == null){
                return null;
            }

            return new AnswerKey()
                .builder()
                .name(getXmlValue(xPath, "./name", answerKeyNode))
                .value(getXmlValue(xPath, "./val", answerKeyNode))
                .description(getXmlValue(xPath, "./desc", answerKeyNode))
                .build();
        }
        catch (XPathExpressionException e){
            // No answer key attribute found.
            return null;
        }
    }

    private boolean itemFormatIsValidToHaveAnswerKey(XPath xPath, Document xmlDoc) {
        try {
            String format = getXmlValue(xPath, "/itemrelease/item/@format", xmlDoc).toUpperCase();
            return format.equals("EBSR") || format.equals("MS") || format.equals("MC");
        } catch (XPathExpressionException e) {
            return false;
        }
    }

    private List<ScoringCriteria> getRubrics(XPath xPath, String id, Node rubriclistNode) {
        if(rubriclistNode == null)
            return new ArrayList<>();

        try{
            NodeList rubricNodes = (NodeList) xPath
                .compile("./rubric")
                .evaluate(rubriclistNode, XPathConstants.NODESET);

            return IntStream
                .range(0, rubricNodes.getLength())
                .mapToObj(rubricNodes::item)
                .map(node -> getRubric(xPath, node, id))
                .collect(Collectors.toList());

        } catch (XPathExpressionException e) {
            logger.warn("Item xml contained a rubriclist element but no rubrics for id: " + id, e);
            return new ArrayList<>();
        }
    }

    private List<ScoringCriteria> getExemplars(XPath xPath, String id, Node rubriclistNode) {
        if(rubriclistNode == null)
            return new ArrayList<>();

        NodeList sampleList = null;
        try {
            sampleList = (NodeList) xPath
                .compile("./samplelist")
                .evaluate(rubriclistNode, XPathConstants.NODESET);

            if(sampleList == null || sampleList.getLength() == 0)
                return new ArrayList<>();

            NodeList sampleNodes = (NodeList) xPath
                .compile("./samplelist/sample")
                .evaluate(rubriclistNode, XPathConstants.NODESET);

            return IntStream
                .range(0, sampleNodes.getLength())
                .mapToObj(sampleNodes::item)
                .map(node -> getExemplar(xPath, node, id))
                .collect(Collectors.toList());
        } catch (XPathExpressionException e) {
            logger.warn("Item xml contained a samplelist element but no samples for id: " + id, e);
            return new ArrayList<>();
        }
    }

    private ScoringCriteria getRubric(XPath xPath, Node node, String id){
        try {
            return new ScoringCriteria()
                .builder()
                .name(getXmlValue(xPath, "./name", node))
                .scorepoint(getXmlValue(xPath, "./@scorepoint", node))
                .template(encodeImages(getXmlValue(xPath, "./val", node), id))
                .build();
        } catch (XPathExpressionException | IOException e) {
            logger.warn("Error while parsing rubric xml.", e);
            throw new RuntimeException("Error parsing rubric xml for id: " + id, e);
        }
    }

    private ScoringCriteria getExemplar(XPath xPath, Node node, String id){
        try {
            return new ScoringCriteria()
                .builder()
                .name(getXmlValue(xPath, "./name", node))
                .scorepoint(getXmlValue(xPath, "./@scorepoint", node))
                .template(encodeImages(getXmlValue(xPath, "./samplecontent", node), id))
                .build();
        } catch (XPathExpressionException | IOException e) {
            logger.warn("Error while parsing sample xml.", e);
            throw new RuntimeException("Error parsing sample xml for id: " + id, e);
        }
    }

    private String getXmlValue(XPath xPath, String expression, Node node) throws XPathExpressionException {
        Node valueNode = (Node)  xPath
            .compile(expression)
            .evaluate(node, XPathConstants.NODE);

        if(valueNode == null)
            return "";

        return valueNode.getNodeType() == Node.ATTRIBUTE_NODE
            ? valueNode.getNodeValue()
            : valueNode.getTextContent();
    }

    private String encodeImages(String html, String id) throws IOException {
        String imgRegex = "<img[^>]+src\\s*=\\s*['\"]([^'\"]+)['\"][^>]*>";
        String result = html;

        Matcher matcher = Pattern.compile(imgRegex).matcher(html);

        while (matcher.find()) {
            String imageFileName = matcher.group(1);
            InputStream imageStream = artifactRepository.getArtifactFromItemDirectory(id, imageFileName);
            String encoding = Base64
                .getEncoder()
                .encodeToString(ByteStreams.toByteArray(imageStream));

            String mimeType = URLConnection.guessContentTypeFromName(imageFileName);
            result = result.replace(imageFileName, "data:" + mimeType + ";base64," + encoding);
            matcher.end();
        }

        return result;
    }
}
