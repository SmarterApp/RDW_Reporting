package org.opentestsystem.rdw.reporting.service.impl;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Multimap;
import com.google.common.collect.Multimaps;
import org.opentestsystem.rdw.reporting.model.DistrictAndInstitutionIdentities;
import org.opentestsystem.rdw.reporting.model.Permission;
import org.opentestsystem.rdw.reporting.model.PermissionScope;
import org.opentestsystem.rdw.reporting.repository.EntityRepository;
import org.opentestsystem.rdw.reporting.security.support.Authorities;
import org.opentestsystem.rdw.reporting.service.AuthorizationService;
import org.opentestsystem.rdw.reporting.service.AuthorizationServiceException;
import org.opentestsystem.rdw.security.Grant;
import org.opentestsystem.rdw.security.service.PermissionService;
import org.opentestsystem.rdw.security.service.PermissionServiceException;
import org.opentestsystem.rdw.security.support.Grants;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.stereotype.Service;

import javax.validation.constraints.NotNull;
import java.util.Collection;
import java.util.Map;
import java.util.Set;

import static com.google.common.collect.Sets.newLinkedHashSet;

@Service
public class AuthorizationServiceImpl implements AuthorizationService {

	private PermissionService permissionService;
	private EntityRepository entityRepository;
	private String stateId;

	@Autowired
	public AuthorizationServiceImpl(
		@NotNull PermissionService permissionService,
		@NotNull EntityRepository entityRepository,
		@NotNull @Value("${application.state}") String stateId) {
		this.permissionService = permissionService;
		this.entityRepository = entityRepository;
		this.stateId = stateId;
	}

	public Set<Grant> getGrants(String[] encodedGrants) throws AuthorizationServiceException {
		final Set<Grant> grants = newLinkedHashSet();
		for (String encodedGrant : encodedGrants) {
			final Grant grant = Grants.from(encodedGrant);

			/*
				Do not add redundant grants or grants that
				do not belong to the application instance's state
			 */
			if (stateId.equals(grant.getStateId()) && !Grants.contains(grants, grant)) {
				grants.add(grant);
			}
		}

		/*
			Secures the application by throwing exception if the user
			has no authority to access data for this state
		 */
		if (grants.isEmpty()) {
			throw new AuthorizationServiceException(String.format(
				"Grants do not permit access to state \"%s\"", stateId));
		}

		return ImmutableSet.copyOf(grants);
	}

	public Set<Permission> getPermissions(Collection<Grant> grants) throws AuthorizationServiceException {

		/*
			Groups grants by role to later combine their districts and institutions into a single scope
			This is to cover the case of multiple non-intersecting grants being given
			(e.g. roleA,stateA,districtA and roleA,stateA,districtB)
		 */
		final Multimap<String, Grant> grantsByRole = Multimaps.index(grants, Grant::getRole);
		final Map<String, Collection<String>> permissionsByRole = getPermissionsByRole();
		final DistrictAndInstitutionIdentities identities = getIdentities(grants);
		final Set<Permission> permissions = newLinkedHashSet();

		/*
			Identify and store the permissions associated with the role
		 */
		for (String role : grantsByRole.keySet()) {

			final Collection<String> permissionIds = permissionsByRole.get(role);

			/*
				User may have roles not registered to this application in the permission service.
			 */
			if (permissionIds != null) {
				for (String permissionId : permissionIds) {
					permissions.add(
						Permission.builder()
							.id(permissionId)
							.scope(createScope(grantsByRole.get(role), identities))
							.build()
					);
				}
			}


		}
		return ImmutableSet.copyOf(permissions);
	}

	/**
	 * Gets all of the natural ID to local entity ID mappings for districts and institutions
	 * @param grants the grants holding the districts and institutions
	 * @return collection of district and institution natural ID to entity ID mappings
	 */
	private DistrictAndInstitutionIdentities getIdentities(Collection<Grant> grants) {
		final Set<String> districtNaturalIds = newLinkedHashSet();
		final Set<String> institutionNaturalIds = newLinkedHashSet();
		for (Grant grant : grants) {
			if (grant.getEntityLevel() == Grant.EntityLevel.DISTRICT) {
				districtNaturalIds.add(grant.getEntityId());
			} else {
				institutionNaturalIds.add(grant.getEntityId());
			}
		}
		return entityRepository.findAll(districtNaturalIds, institutionNaturalIds);
	}

	public Set<GrantedAuthority> getAuthorities(Collection<Grant> grants) throws AuthorizationServiceException {
		final Map<String, Collection<String>> permissionsByRole = getPermissionsByRole();
		final ImmutableSet.Builder<GrantedAuthority> authorities = ImmutableSet.builder();
		for (Grant grant : grants) {
			if (grant.getEntityLevel() == Grant.EntityLevel.STATE) {
				authorities.add(Authorities.createRole(grant.getRole()));
				final Collection<String> permissionIds = permissionsByRole.get(grant.getRole());
				if (permissionIds != null) {
					for (String permission : permissionIds) {
						authorities.add(Authorities.createPermission(permission));
					}
				}
			}
		}
		return authorities.build();
	}

	private Map<String, Collection<String>> getPermissionsByRole() throws AuthorizationServiceException {
		try {
			return permissionService.getPermissionsByRole();
		} catch (PermissionServiceException exception) {
			throw new AuthorizationServiceException("Failed to get permissions", exception);
		}
	}

	private PermissionScope createScope(Collection<Grant> grantsWithSameRole, DistrictAndInstitutionIdentities identities) {

		if (grantsWithSameRole.size() == 1) {
			return createScope(grantsWithSameRole.iterator().next(), identities);
		}

		/*
			Below implementation assumes if there was a state-level role,
			all other scopes for the same role are contained in that role and therefore already filtered out
			and there should only be one scope left for this role
		 */
		final ImmutableSet.Builder<Long> districtIds = ImmutableSet.builder();
		final ImmutableSet.Builder<Long> institutionIds = ImmutableSet.builder();

		for (Grant grant : grantsWithSameRole) {
			if (grant.getEntityLevel() == Grant.EntityLevel.DISTRICT) {
				districtIds.add(identities.getDistrictIdsByNaturalId().get(grant.getEntityId()));
			} else {
				institutionIds.add(identities.getInstitutionIdsByNaturalId().get(grant.getEntityId()));
			}
		}

		return PermissionScope.builder()
			.districtIds(districtIds.build())
			.institutionIds(institutionIds.build())
			.build();
	}

	private PermissionScope createScope(Grant grant, DistrictAndInstitutionIdentities identities) {
		if (grant.getEntityLevel() == Grant.EntityLevel.STATE) {
			return PermissionScope.STATEWIDE;
		}
		if (grant.getEntityLevel() == Grant.EntityLevel.DISTRICT) {
			return PermissionScope.builder()
				.districtIds(ImmutableSet.of(identities.getDistrictIdsByNaturalId().get(grant.getEntityId())))
				.build();
		}
		return PermissionScope.builder()
			.institutionIds(ImmutableSet.of(identities.getInstitutionIdsByNaturalId().get(grant.getEntityId())))
			.build();

	}
}
