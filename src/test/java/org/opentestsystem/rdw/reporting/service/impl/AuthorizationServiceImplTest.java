package org.opentestsystem.rdw.reporting.service.impl;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import org.junit.Before;
import org.junit.Test;
import org.mockito.internal.matchers.apachecommons.ReflectionEquals;
import org.opentestsystem.rdw.reporting.model.GroupMembership;
import org.opentestsystem.rdw.reporting.model.Permission;
import org.opentestsystem.rdw.reporting.model.PermissionScope;
import org.opentestsystem.rdw.reporting.repository.DistrictRepository;
import org.opentestsystem.rdw.reporting.repository.GroupMembershipRepository;
import org.opentestsystem.rdw.reporting.repository.InstitutionRepository;
import org.opentestsystem.rdw.security.Grant;
import org.opentestsystem.rdw.security.service.PermissionService;
import org.springframework.security.core.authority.SimpleGrantedAuthority;

import java.util.List;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

public class AuthorizationServiceImplTest {

    private final String stateA = "stateA";
    private final String stateB = "stateB";
    private PermissionService permissionService;
    private DistrictRepository districtRepository;
    private InstitutionRepository institutionRepository;
    private GroupMembershipRepository groupMembershipRepository;
    private AuthorizationServiceImpl authorizationService;

    @Before
    public void before() throws Exception {
        permissionService = mock(PermissionService.class);
        districtRepository = mock(DistrictRepository.class);
        institutionRepository = mock(InstitutionRepository.class);
        groupMembershipRepository = mock(GroupMembershipRepository.class);
        authorizationService = new AuthorizationServiceImpl(stateA, permissionService, districtRepository, institutionRepository, groupMembershipRepository);

        when(permissionService.getPermissionsByRole()).thenReturn(ImmutableMap.of(
                "a", ImmutableSet.of("a"),
                "b", ImmutableSet.of("b"),
                "c", ImmutableSet.of("c"),
                "d", ImmutableSet.of("d", "f"),
                "e", ImmutableSet.of()
        ));
        when(districtRepository.findAllIds(ImmutableSet.of("a"))).thenReturn(ImmutableMap.of("a", 1L));
        when(institutionRepository.findAllIds(ImmutableSet.of("a"))).thenReturn(ImmutableMap.of("a", 1L));
        when(groupMembershipRepository.findAllForUsername("a")).thenReturn(ImmutableList.of(new GroupMembership(1L, 1L)));
    }

    @Test
    public void getGrantsShouldOnlyIncludeGrantsForTheSpecifiedState() throws Exception {
        final String[] encodedGrants = {"|stateA|roleA|STATE|||||stateA||||||||||", "|stateB|roleA|STATE|||||stateB||||||||||"};
        assertThat("getGrants should only include grants for the state ID set in the authorization service",
                authorizationService.getGrants(encodedGrants), is(ImmutableSet.of(
                        Grant.builder().entityId(stateA).role("roleA").entityLevel(Grant.EntityLevel.STATE).stateId(stateA).build()
                )));
    }

    @Test
    public void getPermissionsShouldCorrectlyDerivePermissionsFromGrants() throws Exception {
        final List<Grant> grants = ImmutableList.of(
                Grant.builder().entityId("a").role("a").entityLevel(Grant.EntityLevel.STATE).stateId("a").build(),
                Grant.builder().entityId("a").role("b").entityLevel(Grant.EntityLevel.DISTRICT).stateId("a").districtId("a").build(),
                Grant.builder().entityId("a").role("c").entityLevel(Grant.EntityLevel.INSTITUTION).stateId("a").districtId("a").institutionId("a").build(),
                Grant.builder().entityId("a").role("d").entityLevel(Grant.EntityLevel.DISTRICT).stateId("a").districtId("a").build(),
                Grant.builder().entityId("a").role("d").entityLevel(Grant.EntityLevel.INSTITUTION).stateId("a").districtId("a").institutionId("a").build()
        );

        assertThat("the permissions should reflect the given grants and group the districts and institutions into the same scope when the role is the same",
                authorizationService.getPermissions(grants), new ReflectionEquals(ImmutableSet.of(
                        new Permission("a", new PermissionScope(null, null)),
                        new Permission("b", new PermissionScope(ImmutableSet.of(1L), null)),
                        new Permission("c", new PermissionScope(null, ImmutableSet.of(1L))),
                        new Permission("d", new PermissionScope(ImmutableSet.of(1L), ImmutableSet.of(1L))),
                        new Permission("f", new PermissionScope(ImmutableSet.of(1L), ImmutableSet.of(1L)))
                )));
    }

    @Test
    public void getAuthoritiesShouldOnlyReturnStateLevelRolesAndPermissions() throws Exception {
        assertThat("getAuthorities should return only state level roles and permissions",
                authorizationService.getAuthorities(ImmutableList.of(
                        Grant.builder().entityId("a").role("a").entityLevel(Grant.EntityLevel.STATE).stateId("a").build(),
                        Grant.builder().entityId("a").role("b").entityLevel(Grant.EntityLevel.DISTRICT).stateId("a").districtId("a").build(),
                        Grant.builder().entityId("a").role("c").entityLevel(Grant.EntityLevel.INSTITUTION).stateId("a").districtId("a").institutionId("a").build()
                )),
                is(ImmutableSet.of(
                        new SimpleGrantedAuthority("ROLE_A"),
                        new SimpleGrantedAuthority("PERM_A")
                )));
    }

    @Test
    public void getAuthoritiesShouldIgnoreRolesNotProvidedByThePermissionService() throws Exception {
        assertThat("getAuthorities should ignore roles not provided by the permission service",
                authorizationService.getAuthorities(ImmutableList.of(
                        Grant.builder().entityId("a").role("z").entityLevel(Grant.EntityLevel.STATE).stateId("a").build()
                )),
                is(ImmutableSet.of()));
    }

    @Test
    public void getAuthoritiesShouldNotFailIfThereAreNoPermissionsForAGivenRole() throws Exception {
        assertThat("getAuthorities should not fail when there is a role with no permissions",
                authorizationService.getAuthorities(ImmutableList.of(
                        Grant.builder().entityId("a").role("e").entityLevel(Grant.EntityLevel.STATE).stateId("a").build()
                )),
                is(ImmutableSet.of(
                        new SimpleGrantedAuthority("ROLE_E")
                )));
    }

    @Test
    public void getAuthoritiesShouldReturnAllStateLevelRolesAndPermissions() throws Exception {
        assertThat("getAuthorities should return all state level roles and permissions",
                authorizationService.getAuthorities(ImmutableList.of(
                        Grant.builder().entityId("a").role("a").entityLevel(Grant.EntityLevel.STATE).stateId("a").build(),
                        Grant.builder().entityId("a").role("b").entityLevel(Grant.EntityLevel.STATE).stateId("a").build(),
                        Grant.builder().entityId("a").role("c").entityLevel(Grant.EntityLevel.STATE).stateId("a").build(),
                        Grant.builder().entityId("a").role("d").entityLevel(Grant.EntityLevel.STATE).stateId("a").build()
                )),
                is(ImmutableSet.of(
                        new SimpleGrantedAuthority("ROLE_A"),
                        new SimpleGrantedAuthority("PERM_A"),
                        new SimpleGrantedAuthority("ROLE_B"),
                        new SimpleGrantedAuthority("PERM_B"),
                        new SimpleGrantedAuthority("ROLE_C"),
                        new SimpleGrantedAuthority("PERM_C"),
                        new SimpleGrantedAuthority("ROLE_D"),
                        new SimpleGrantedAuthority("PERM_D"),
                        new SimpleGrantedAuthority("PERM_F")
                )));
    }

    @Test
    public void getGroupsByIdShouldReturnEmptyIfTheUserDoesNotHaveGroupPII() throws Exception {
        assertThat("getGroupsById should not return groups for users without group PII",
                authorizationService.getGroupsById(ImmutableSet.of(), "a"), is(ImmutableMap.of()));
    }

    @Test
    public void getGroupsByIdShouldReturnAllOfTheGroupsAssociatedWithTheUsernameForUsersWithGroupPII() throws Exception {
        assertThat("getGroupsById should return all groups associated with the username",
                authorizationService.getGroupsById(ImmutableSet.of(new Permission("GROUP_PII_READ", PermissionScope.STATEWIDE)), "a"),
                is(ImmutableMap.of(1L, new GroupMembership(1L, 1L))));
    }

}