package org.opentestsystem.rdw.reporting.exam.schoolgrade;

import org.junit.Ignore;
import org.junit.Test;
import org.opentestsystem.rdw.reporting.JdbcRepositoryWithPermissionIT;
import org.opentestsystem.rdw.reporting.TestData;
import org.opentestsystem.rdw.reporting.common.model.Assessment;
import org.opentestsystem.rdw.reporting.common.security.User;
import org.opentestsystem.rdw.security.Permission;
import org.opentestsystem.rdw.security.PermissionScope;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Import;
import org.springframework.test.context.jdbc.Sql;

import java.util.Map;

import static com.google.common.collect.Maps.newHashMap;
import static org.assertj.core.api.Assertions.assertThat;
import static org.opentestsystem.rdw.reporting.common.security.ReportingPermission.TestDataLoadingRead;
import static org.opentestsystem.rdw.reporting.common.test.support.PermissionScopes.individualOf;
import static org.opentestsystem.rdw.reporting.common.test.support.PermissionScopes.permissions;
import static org.opentestsystem.rdw.reporting.common.test.support.PermissionScopes.schools;

@Import(JdbcSchoolGradeAssessmentRepository.class)
@Sql(scripts = {"classpath:integration-test-data.sql"})
public class JdbcSchoolGradeAssessmentRepositoryIT extends JdbcRepositoryWithPermissionIT {

    @Autowired
    private SchoolGradeAssessmentRepository repository;

    private SchoolGradeAssessmentSearch.Builder search() {
        return SchoolGradeAssessmentSearch.builder()
                .schoolId(-30)
                .gradeId(-1)
                .schoolYear(1997);
    }

    @Override
    protected User.Builder userBuilder() {
        // every test wants statewide individual permissions
        // also, to avoid multiple district embargo entries, grant state permissions for embargo
        // (previous to phase 6, the school_year being before current negated embargo settings)
        final Map<String, Permission> permissionMap = newHashMap();
        permissionMap.putAll(individualStatewide);
        permissionMap.put(TestDataLoadingRead, new Permission(TestDataLoadingRead, PermissionScope.STATEWIDE));

        return super.userBuilder()
            .permissionsById(permissionMap);
    }

    @Test
    public void findLatestShouldFindTheLatestExam() {
        final Assessment actual = repository.findLatest(userBuilder().build(), search().build());
        assertThat(actual).isEqualToComparingFieldByField(TestData.ALL_ASSESSMENTS_BY_ID.get(-3));
    }

    @Test
    public void findLatestOfBadPermissionsShouldFindNothing() {
        assertThat(repository.findLatest(userBuilder().permissionsById(permissions(individualOf(schools(-100L)))).build(), search().build())).isNull();
    }

    @Test
    public void findLatestOfBadSchoolShouldFindNothing() {
        assertThat(repository.findLatest(userBuilder().build(), search().schoolId(-40).build())).isNull();
    }

    @Test
    public void findLatestOfBadSchoolGradeShouldFindNothing() {
        assertThat(repository.findLatest(userBuilder().build(), search().gradeId(-2).build())).isNull();
    }

    @Test
    public void findLatestOfAbsentYearShouldFindNothing() {
        assertThat(repository.findLatest(userBuilder().build(),
                search().schoolYear(2016).build())).isNull();
    }

    @Ignore("Failing after phase 6 embargo changes; need to investigate")
    @Test
    public void itShouldFindAllAssessmentsRespectingTransferAccess() {
        final SchoolGradeAssessmentSearch query = search()
                .schoolId(-40)
                .schoolYear(1998)
                .build();

        //a teacher has access to more than one school, but the search limits it to one only
        final User user = userBuilder().build();
        assertThat(repository.findAll(user, query).stream())
                .usingRecursiveFieldByFieldElementComparator()
                .containsOnly(TestData.ALL_ASSESSMENTS_BY_ID.get(-2));

        getReportingSystemProperties().setTransferAccessEnabled(true);
        assertThat(repository.findAll(user, query).stream())
                .usingRecursiveFieldByFieldElementComparator()
                .containsOnly(TestData.ALL_ASSESSMENTS_BY_ID.get(-1), TestData.ALL_ASSESSMENTS_BY_ID.get(-2));
    }
}
