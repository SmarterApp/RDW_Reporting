package org.opentestsystem.rdw.reporting.group;

import org.opentestsystem.rdw.reporting.common.model.School;
import org.opentestsystem.rdw.reporting.common.security.PermissionSource;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.retry.annotation.Backoff;
import org.springframework.retry.annotation.Retryable;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collection;
import java.util.List;
import java.util.Set;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Sets.newHashSet;
import static java.util.stream.Collectors.toSet;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.safeSplit;


@Repository
class JdbcUserGroupRepository implements UserGroupRepository {

    private final NamedParameterJdbcTemplate template;

    @Value("${sql.teacherGroup.findAllByUsername}")
    private String findAllQuery;

    @Value("${sql.teacherGroup.findOneByUsernameAndId}")
    private String findOneQuery;

    @Value("${sql.teacherGroup.create}")
    private String createQuery;

    @Value("${sql.teacherGroup.update}")
    private String updateQuery;

    @Value("${sql.teacherGroup.delete}")
    private String deleteQuery;

    @Value("${sql.teacherGroupMembership.findAllStudentIdsByGroupId}")
    private String findAllMembershipStudentIdsByGroupIdQuery;

    @Value("${sql.teacherGroupMembership.create}")
    private String createMembershipQuery;

    @Value("${sql.teacherGroupMembership.delete}")
    private String deleteMembershipQuery;

    @Value("${sql.teacherGroupMembership.deleteAllByGroupId}")
    private String deleteMembershipByGroupIdQuery;


    JdbcUserGroupRepository(final NamedParameterJdbcTemplate template) {
        this.template = template;
    }

    @Override
    public List<Group> findAll(final PermissionSource permissionSource) {
        return template.query(
                findAllQuery,
                new MapSqlParameterSource()
                        .addValue("user_login", permissionSource.getUsername()),
                (row, index) -> {

                    final List<String> studentIdStrings = safeSplit(row.getString("student_ids"), "|");
                    final int studentCount = studentIdStrings != null
                            ? studentIdStrings.size()
                            : 0;

                    return Group.builder()
                            .id(row.getLong("id"))
                            .name(row.getString("name"))
                            // support for groups table
                            .schoolId(row.getInt("school_id"))
                            .schoolName(row.getString("school_name"))
                            .subjectCode(row.getString("subject_code"))
                            .subjectCodes(decodeSubjects(row.getString("subject_code")))
                            .school(School.builder()
                                    .id(row.getLong("school_id"))
                                    .name(row.getString("school_name"))
                                    .build()
                            )
                            .studentCount(studentCount)
                            .userCreated(true)
                            .build();
                }
        );
    }

    @Override
    public Group findOne(final PermissionSource permissionSource, final long groupId) {
        try {
            return template.queryForObject(
                    findOneQuery,
                    new MapSqlParameterSource()
                            .addValue("user_login", permissionSource.getUsername())
                            .addValue("id", groupId),
                    (row, index) -> {
                        final List<String> studentIdStrings = safeSplit(row.getString("student_ids"), "|");
                        final Set<Long> studentIds = studentIdStrings != null
                                ? studentIdStrings.stream().map(Long::valueOf).collect(toSet())
                                : newHashSet();

                        return Group.builder()
                                .id(row.getLong("id"))
                                .name(row.getString("name"))
                                .school(School.builder()
                                        .id(row.getLong("school_id"))
                                        .name(row.getString("school_name"))
                                        .build()
                                )
                                .studentIds(studentIds)
                                .subjectCodes(decodeSubjects(row.getString("subject_code")))
                                .build();
                    }
            );
        } catch (final Exception exception) {
            return null;
        }
    }

    @Override
    @Transactional
    @Retryable(
            maxAttemptsExpression = "${jdbc.retry.default.max-attempts}",
            backoff = @Backoff(
                    delayExpression = "${jdbc.retry.default.delay}",
                    multiplierExpression = "${jdbc.retry.default.multiplier}",
                    random = true
            )
    )
    public Group create(final String username, final Group group) {
        final KeyHolder keyHolder = new GeneratedKeyHolder();
        template.update(
                createQuery,
                new MapSqlParameterSource()
                        .addValue("user_login", username)
                        .addValue("name", group.getName())
                        .addValue("school_id", group.getSchoolId())
                        .addValue("subject_code", encodeSubjects(group.getSubjectCodes())),
                keyHolder
        );

        final long groupId = keyHolder.getKey().longValue();

        template.batchUpdate(
                createMembershipQuery,
                group.getStudentIds().stream()
                        .map(studentId -> new MapSqlParameterSource()
                                .addValue("group_id", groupId)
                                .addValue("student_id", studentId)
                        )
                        .toArray(MapSqlParameterSource[]::new)
        );

        return group.copy()
                .id(groupId)
                .build();
    }

    @Override
    @Transactional
    @Retryable(
            maxAttemptsExpression = "${jdbc.retry.default.max-attempts}",
            backoff = @Backoff(
                    delayExpression = "${jdbc.retry.default.delay}",
                    multiplierExpression = "${jdbc.retry.default.multiplier}",
                    random = true
            )
    )
    public void update(final Group group) {

        final Collection<Long> previousIds = template.queryForList(
                findAllMembershipStudentIdsByGroupIdQuery,
                new MapSqlParameterSource("group_id", group.getId()),
                Long.class
        );

        final Collection<Long> currentIds = group.getStudentIds();
        final Collection<Long> createIds = newArrayList();
        final Collection<Long> deleteIds = newArrayList();

        for (final long id : currentIds) {
            if (!previousIds.contains(id)) {
                createIds.add(id);
            }
        }

        for (final long id : previousIds) {
            if (!currentIds.contains(id)) {
                deleteIds.add(id);
            }
        }

        if (!deleteIds.isEmpty()) {
            template.batchUpdate(
                    deleteQuery,
                    toSqlParameterSources(deleteIds, group.getId())
            );
        }

        if (!createIds.isEmpty()) {
            template.batchUpdate(
                    createMembershipQuery,
                    toSqlParameterSources(createIds, group.getId())
            );
        }

        template.update(
                updateQuery,
                new MapSqlParameterSource()
                        .addValue("id", group.getId())
                        .addValue("name", group.getName())
                        .addValue("subject_code", encodeSubjects(group.getSubjectCodes()))
        );

    }

    @Override
    @Transactional
    @Retryable(
            maxAttemptsExpression = "${jdbc.retry.default.max-attempts}",
            backoff = @Backoff(
                    delayExpression = "${jdbc.retry.default.delay}",
                    multiplierExpression = "${jdbc.retry.default.multiplier}",
                    random = true
            )
    )
    public void delete(final long groupId) {
        template.update(
                deleteMembershipByGroupIdQuery,
                new MapSqlParameterSource("group_id", groupId)
        );
        template.update(
                deleteQuery,
                new MapSqlParameterSource("id", groupId)
        );
    }

    private SqlParameterSource[] toSqlParameterSources(final Collection<Long> studentIds, final long groupId) {
        return studentIds.stream()
                .map(studentId -> new MapSqlParameterSource()
                        .addValue("group_id", groupId)
                        .addValue("student_id", studentId)
                )
                .toArray(MapSqlParameterSource[]::new);
    }

    /**
     * Transforms subject codes into single subject code for storage
     * Currently multiple subjects aren't supported.
     *
     * @param subjectCodes the subject codes to transform
     * @return null if subjectCodes is null, empty or contains multiple elements. The single subject code element if present
     */
    private String encodeSubjects(final Set<String> subjectCodes) {
        if (subjectCodes == null
                || subjectCodes.isEmpty()
                || subjectCodes.size() > 1) {
            return null;
        }
        return subjectCodes.iterator().next();
    }

    /**
     * Transforms single subject code into a collection of one subject code or null if the subject code is null
     *
     * @param subjectCode the subject code to transform
     * @return null if the subject code is null or a set of the single subject code if present
     */
    private Set<String> decodeSubjects(final String subjectCode) {
        if (subjectCode == null) {
            return null;
        }
        return newHashSet(subjectCode);
    }

}
