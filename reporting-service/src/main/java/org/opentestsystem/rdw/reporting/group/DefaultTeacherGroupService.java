package org.opentestsystem.rdw.reporting.group;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.opentestsystem.rdw.reporting.student.Student;
import org.opentestsystem.rdw.reporting.student.StudentRepository;
import org.opentestsystem.rdw.reporting.student.StudentSearch;
import org.springframework.retry.annotation.Backoff;
import org.springframework.retry.annotation.Retryable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collection;
import java.util.List;
import java.util.Optional;
import java.util.Set;

import static com.google.common.collect.Lists.newArrayList;


@Service
class DefaultTeacherGroupService implements TeacherGroupService {

    private final TeacherGroupRepository groupRepository;
    private final TeacherGroupMembershipRepository groupMembershipRepository;
    private final StudentRepository studentRepository;

    DefaultTeacherGroupService(final TeacherGroupRepository groupRepository,
                               final TeacherGroupMembershipRepository groupMembershipRepository,
                               final StudentRepository studentRepository) {
        this.groupRepository = groupRepository;
        this.groupMembershipRepository = groupMembershipRepository;
        this.studentRepository = studentRepository;
    }

    @Override
    public List<Group> getGroups(final User user) {
        return ImmutableList.copyOf(groupRepository.findAll(user));
    }

    @Override
    public Optional<TeacherGroup> getGroup(final User user, final long groupId) {
        final TeacherGroup group = groupRepository.findOne(user, groupId);
        if (group == null) {
            return Optional.empty();
        }

        // Add students, omitting those the user no longer has access to
        final Set<Student> students = ImmutableSet.copyOf(
                studentRepository.findAll(user, StudentSearch.builder()
                        .studentIds(group.getStudentIds())
                        .build()
                )
        );

        return Optional.of(group.copy().students(students).build());
    }

    @Override
    @Transactional
    @Retryable(
            maxAttemptsExpression = "${jdbc.retry.default.max-attempts}",
            backoff = @Backoff(delayExpression = "${jdbc.retry.default.delay}", multiplierExpression = "${jdbc.retry.default.multiplier}", random = true)
    )
    public TeacherGroup saveGroup(final User user, final TeacherGroup group) {
        if (group.getId() == null) {
            return createGroup(user, group);
        }
        return updateGroup(user, group);
    }

    @Override
    @Transactional
    @Retryable(
            maxAttemptsExpression = "${jdbc.retry.default.max-attempts}",
            backoff = @Backoff(delayExpression = "${jdbc.retry.default.delay}", multiplierExpression = "${jdbc.retry.default.multiplier}", random = true)
    )
    public void deleteGroup(final User user, final long groupId) {
        checkUpdateAuthority(user, groupId);
        groupRepository.delete(groupId);
        groupMembershipRepository.deleteAllByGroupId(groupId);
    }

    private TeacherGroup createGroup(final User user, final TeacherGroup group) {
        checkCreateAuthority(user, group);

        final TeacherGroup created = groupRepository.create(user.getUsername(), group);
        groupMembershipRepository.createAll(created.getId(), group.getStudentIds());

        return created;
    }

    private TeacherGroup updateGroup(final User user, final TeacherGroup group) {
        checkUpdateAuthority(user, group.getId());

        final Collection<Long> currentIds = group.getStudentIds();
        final Collection<Long> previousIds = groupMembershipRepository.findAllStudentIdsByGroupId(group.getId());
        final Collection<Long> createIds = newArrayList();
        final Collection<Long> deleteIds = newArrayList();

        for (final long id : currentIds) {
            if (!previousIds.contains(id)) {
                createIds.add(id);
            }
        }

        for (final long id : previousIds) {
            if (!currentIds.contains(id)) {
                deleteIds.add(id);
            }
        }

        groupRepository.update(group);
        groupMembershipRepository.createAll(group.getId(), createIds);
        groupMembershipRepository.deleteAll(group.getId(), deleteIds);

        return group;
    }

    private void checkCreateAuthority(final User user, final TeacherGroup group) {
        final Set<Long> entitledStudentIds = ImmutableSet.copyOf(studentRepository.findAllIdsByUsername(user));
        if (!entitledStudentIds.containsAll(group.getStudentIds())) {
            // log and exit transaction without exception?
            throw new RuntimeException(String.format(
                    "Error creating teacher group: User \"%s\" does not have access to one or more of the provided student IDs",
                    user.getUsername()
            ));
        }
    }

    private void checkUpdateAuthority(final User user, final long groupId) {
        final TeacherGroup existing = groupRepository.findOne(user, groupId);
        if (existing == null) {
            throw new RuntimeException(String.format(
                    "Error updating teacher group: User \"%s\" does not have access group with ID: %s",
                    user.getUsername(), groupId
            ));
        }
    }

}
