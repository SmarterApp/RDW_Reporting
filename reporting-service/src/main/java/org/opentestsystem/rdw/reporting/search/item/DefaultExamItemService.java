package org.opentestsystem.rdw.reporting.search.item;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.io.ByteStreams;
import org.opentestsystem.rdw.reporting.search.artifact.ArtifactRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import java.io.IOException;
import java.net.URLConnection;
import java.util.Base64;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.IntStream;

import static com.google.common.collect.ImmutableList.toImmutableList;

@Service
class DefaultExamItemService implements ExamItemService {

    private static final Logger logger = LoggerFactory.getLogger(DefaultExamItemService.class);
    private static final ImmutableSet ANSWER_KEY_FORMATS = ImmutableSet.of("EBSR", "MS", "MC");
    private static final Pattern IMAGE_PATTERN = Pattern.compile("<img[^>]+src\\s*=\\s*['\"]([^'\"]+)['\"][^>]*>");
    private final ArtifactRepository artifactRepository;
    private DocumentBuilder documentBuilder;
    private XPathExpression rubricListPath;
    private XPathExpression answerKeyPath;
    private XPathExpression rubricPath;
    private XPathExpression samplePath;
    private XPathExpression namePath;
    private XPathExpression valuePath;
    private XPathExpression descriptionPath;
    private XPathExpression scorePointPath;
    private XPathExpression sampleContentPath;
    private XPathExpression formatPath;

    @Autowired
    DefaultExamItemService(final ArtifactRepository artifactRepository) {
        this.artifactRepository = artifactRepository;

        try {
            final DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
            documentBuilderFactory.setValidating(false);
            documentBuilderFactory.setIgnoringComments(false);
            documentBuilderFactory.setIgnoringElementContentWhitespace(true);
            documentBuilderFactory.setNamespaceAware(true);
            this.documentBuilder = documentBuilderFactory.newDocumentBuilder();

            final XPath xPath = XPathFactory.newInstance().newXPath();
            this.rubricListPath = xPath.compile("/itemrelease/item/content/rubriclist");
            this.answerKeyPath = xPath.compile("/itemrelease/item/attriblist/attrib[@attid=\"itm_att_Answer Key\"]");
            this.rubricPath = xPath.compile("./rubric");
            this.samplePath = xPath.compile("./samplelist/sample");
            this.namePath = xPath.compile("./name");
            this.valuePath = xPath.compile("./val");
            this.descriptionPath = xPath.compile("./desc");
            this.scorePointPath = xPath.compile("./@scorepoint");
            this.sampleContentPath = xPath.compile("./samplecontent");
            this.formatPath = xPath.compile("/itemrelease/item/@format");
        } catch (final Exception exception) {
            logger.error("Error initializing {}", getClass().getName(), exception);
        }
    }

    @Override
    public ExamItemScoringGuide getScoringGuide(final String id) {
        try {
            return getExamItemSolution(getXmlDocument(id), id);
        }
        catch(SAXException exception) {
            logger.error(String.format("SAXException while trying to read the item xml: %s", id), exception);
            throw new RuntimeException(String.format("Error reading the xml for item: %s", id), exception);
        }
        catch (final IOException | XPathExpressionException exception) {
            throw new NoSuchElementException(String.format("Rubric/Exemplar data is not available for item: %s", id));
        }
    }

    // DocumentBuilder.parse is not thread-safe: https://stackoverflow.com/questions/12455602/is-documentbuilder-thread-safe
    private synchronized Document getXmlDocument(final String id) throws IOException, SAXException {
        return documentBuilder.parse(artifactRepository.getItemXml(id));
    }

    private ExamItemScoringGuide getExamItemSolution(final Node root, final String id) throws XPathExpressionException {

        final Node node = (Node) rubricListPath.evaluate(root, XPathConstants.NODE);

        // TODO remove once we have this information available
        final AnswerKey answerKey = itemFormatIsValidToHaveAnswerKey(root)
                ? safeValue(root, answerKeyPath, this::createAnswerKey, null) : null;

        final List<ScoringCriterion> rubrics = safeList(node, rubricPath, n -> createRubric(n, id), ImmutableList.of());

        final List<ScoringCriterion> exemplars = safeList(node, samplePath, n -> createExemplar(n, id), ImmutableList.of());

        return ExamItemScoringGuide.builder()
                .answerKey(answerKey)
                .rubrics(rubrics)
                .exemplars(exemplars)
                .build();
    }

    private boolean itemFormatIsValidToHaveAnswerKey(final Node node) throws XPathExpressionException {
        return ANSWER_KEY_FORMATS.contains(safeValue(node, formatPath, "").toUpperCase());
    }

    private AnswerKey createAnswerKey(final Node node) {
        return AnswerKey.builder()
                .name(safeValue(node, namePath, ""))
                .value(safeValue(node, valuePath, ""))
                .description(safeValue(node, descriptionPath, ""))
                .build();
    }

    private ScoringCriterion createRubric(final Node node, final String id) {
        return ScoringCriterion.builder()
                .scorepoint(safeValue(node, scorePointPath, ""))
                .template(encodeImages(safeValue(node, valuePath, ""), id))
                .build();
    }

    private ScoringCriterion createExemplar(final Node node, final String id) {
        return ScoringCriterion.builder()
                .scorepoint(safeValue(node, scorePointPath, ""))
                .template(encodeImages(safeValue(node, sampleContentPath, ""), id))
                .build();
    }

    private String encodeImages(final String html, final String id) {
        String result = html;
        final Matcher matcher = IMAGE_PATTERN.matcher(html);
        while (matcher.find()) {
            final String imagePath = matcher.group(1);
            try {
                final String base64Image = Base64.getEncoder()
                        .encodeToString(ByteStreams.toByteArray(
                                artifactRepository.getArtifactFromItemDirectory(id, imagePath)
                        ));

                final String mimeType = URLConnection.guessContentTypeFromName(imagePath);
                result = result.replace(imagePath, "data:" + mimeType + ";base64," + base64Image);
            } catch (final IOException exception) {
                logger.warn("Unable to find image \"{}\" for item: {}", imagePath, id, exception);
            }
            matcher.end();
        }
        return result;
    }

    private <T> T safeValue(final Node start, final XPathExpression expression, final Function<Node, T> mapper, final T defaultValue) {
        if (start == null) {
            return defaultValue;
        }
        final Node node;
        try {
            node = (Node) expression.evaluate(start, XPathConstants.NODE);
        } catch (final XPathExpressionException exception) {
            return defaultValue;
        }
        if (node == null) {
            return defaultValue;
        }
        return mapper.apply(node);
    }

    private <T> List<T> safeList(final Node start, final XPathExpression expression, final Function<Node, T> mapper, final List<T> defaultValue) {
        if (start == null) {
            return defaultValue;
        }
        final NodeList nodes;
        try {
            nodes = (NodeList) expression.evaluate(start, XPathConstants.NODESET);
        } catch (final XPathExpressionException exception) {
            return defaultValue;
        }
        if (nodes == null) {
            return defaultValue;
        }
        return IntStream
                .range(0, nodes.getLength())
                .mapToObj(nodes::item)
                .map(mapper)
                .collect(toImmutableList());
    }

    private String safeValue(final Node node, final XPathExpression expression, final String defaultValue) {
        if (node == null) {
            return defaultValue;
        }
        final Node valueNode;
        try {
            valueNode = (Node) expression.evaluate(node, XPathConstants.NODE);
        } catch (final XPathExpressionException exception) {
            return defaultValue;
        }
        if (valueNode == null) {
            return defaultValue;
        }
        return valueNode.getNodeType() == Node.ATTRIBUTE_NODE
                ? valueNode.getNodeValue()
                : valueNode.getTextContent();
    }

}
