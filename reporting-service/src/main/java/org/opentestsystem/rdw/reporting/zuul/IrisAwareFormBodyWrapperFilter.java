package org.opentestsystem.rdw.reporting.zuul;

import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.http.HttpServletRequestWrapper;
import com.netflix.zuul.http.ServletInputStreamWrapper;
import org.springframework.cloud.netflix.zuul.filters.pre.FormBodyWrapperFilter;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpOutputMessage;
import org.springframework.http.MediaType;
import org.springframework.http.converter.StringHttpMessageConverter;
import org.springframework.util.AntPathMatcher;
import org.springframework.util.Assert;
import org.springframework.util.ReflectionUtils;
import org.springframework.util.StringUtils;

import javax.servlet.ServletInputStream;
import javax.servlet.ServletRequest;
import javax.servlet.ServletRequestWrapper;
import javax.servlet.http.HttpServletRequest;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Field;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import static com.google.common.base.Charsets.UTF_8;
import static org.apache.commons.lang3.StringUtils.EMPTY;

/**
 * This class is mostly taken from {@link FormBodyWrapperFilter} which is responsible for
 * converting a client request with content-type MediaType.APPLICATION_FORM_URLENCODED or
 * MediaType.MULTIPART_FORM_DATA into a forwarded request to the proxied service.
 *
 * This class is responsible for being aware that IRIS requests are malformed and although
 * they advertise a content-type of MediaType.APPLICATION_FORM_URLENCODED, the content actually
 * consists of JSON.  This class re-interprets the form key of:
 * {"items":[{"id":"I-xxx-xxxxx"}]}
 * with an empty-string value as a JSON payload and wraps the client request in a suitable
 * RequestWrapper.
 */
public class IrisAwareFormBodyWrapperFilter extends FormBodyWrapperFilter {

    private static final StringHttpMessageConverter converter = new StringHttpMessageConverter(UTF_8);
    private static final AntPathMatcher PathMatcher = new AntPathMatcher();
    private static final String IrisPathPattern = "/iris/**";

    private final Field requestField;
    private final Field servletRequestField;

    public IrisAwareFormBodyWrapperFilter() {
        this.requestField = ReflectionUtils.findField(HttpServletRequestWrapper.class,
                "req", HttpServletRequest.class);
        this.servletRequestField = ReflectionUtils.findField(ServletRequestWrapper.class,
                "request", ServletRequest.class);
        Assert.notNull(this.requestField,
                "HttpServletRequestWrapper.req field not found");
        Assert.notNull(this.servletRequestField,
                "ServletRequestWrapper.request field not found");
        this.requestField.setAccessible(true);
        this.servletRequestField.setAccessible(true);
    }

    @Override
    public Object run() {
        final RequestContext ctx = RequestContext.getCurrentContext();
        final HttpServletRequest request = ctx.getRequest();
        if (!PathMatcher.match(IrisPathPattern, request.getRequestURI())) {
            return super.run();
        }

        final FormBodyRequestWrapper wrapper;
        if (request instanceof HttpServletRequestWrapper) {
            final HttpServletRequest wrapped = (HttpServletRequest) ReflectionUtils
                    .getField(this.requestField, request);
            wrapper = new FormBodyRequestWrapper(wrapped);
            ReflectionUtils.setField(this.requestField, request, wrapper);
            ReflectionUtils.setField(this.servletRequestField, request, wrapper);
        }
        else {
            wrapper = new FormBodyRequestWrapper(request);
            ctx.setRequest(wrapper);
        }
        ctx.getZuulRequestHeaders().put("content-type", wrapper.getContentType());
        return null;
    }

    class FormBodyRequestWrapper extends Servlet30RequestWrapper {

        private final HttpServletRequest request;

        private byte[] contentData;

        private MediaType contentType;

        private int contentLength;

        FormBodyRequestWrapper(final HttpServletRequest request) {
            super(request);
            this.request = request;
        }

        @Override
        public String getContentType() {
            if (this.contentData == null) {
                buildContentData();
            }
            return this.contentType.toString();
        }

        @Override
        public int getContentLength() {
            if (super.getContentLength() <= 0) {
                return super.getContentLength();
            }
            if (this.contentData == null) {
                buildContentData();
            }
            return this.contentLength;
        }

        public long getContentLengthLong() {
            return getContentLength();
        }

        @Override
        public ServletInputStream getInputStream() throws IOException {
            if (this.contentData == null) {
                buildContentData();
            }
            return new ServletInputStreamWrapper(this.contentData);
        }

        private synchronized void buildContentData() {
            try {
                String payload = EMPTY;
                final Set<String> queryParams = findQueryParams();
                for (final Map.Entry<String, String[]> entry : this.request.getParameterMap().entrySet()) {
                    if (queryParams.contains(entry.getKey())) continue;

                    payload = entry.getKey();
                    break;
                }

                final FormHttpOutputMessage data = new FormHttpOutputMessage();
                this.contentType = MediaType.valueOf(this.request.getContentType());
                data.getHeaders().setContentType(this.contentType);
                converter.write(payload, this.contentType, data);
                // copy new content type including multipart boundary
                this.contentType = data.getHeaders().getContentType();
                this.contentData = data.getInput();
                this.contentLength = this.contentData.length;
            }
            catch (final Exception e) {
                throw new IllegalStateException("Cannot convert json-as-form data", e);
            }
        }

        private Set<String> findQueryParams() {
            final Set<String> result = new HashSet<>();
            final String query = this.request.getQueryString();
            if (query != null) {
                for (String value : StringUtils.tokenizeToStringArray(query, "&")) {
                    if (value.contains("=")) {
                        value = value.substring(0, value.indexOf("="));
                    }
                    result.add(value);
                }
            }
            return result;
        }

        private class FormHttpOutputMessage implements HttpOutputMessage {

            private final HttpHeaders headers = new HttpHeaders();
            private final ByteArrayOutputStream output = new ByteArrayOutputStream();

            @Override
            public HttpHeaders getHeaders() {
                return this.headers;
            }

            @Override
            public OutputStream getBody() throws IOException {
                return this.output;
            }

            public byte[] getInput() throws IOException {
                this.output.flush();
                return this.output.toByteArray();
            }

        }

    }
}
