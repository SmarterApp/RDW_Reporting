package org.opentestsystem.rdw.reporting.student;

import com.google.common.collect.ImmutableMap;
import org.opentestsystem.rdw.reporting.common.jdbc.SecurityParameterProvider;
import org.opentestsystem.rdw.reporting.common.security.PermissionSource;
import org.opentestsystem.rdw.reporting.exam.AbstractExamRepository;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;

import javax.validation.constraints.NotNull;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static com.google.common.collect.Sets.newHashSet;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.getNullable;

@Repository
class JdbcStudentRepository implements StudentRepository {

    private final NamedParameterJdbcTemplate template;
    private final SecurityParameterProvider securityParameterProvider;

    @Value("${sql.student.findAll}")
    private String findAllQuery;

    @Value("${sql.ethnicity.findEthnicityCodesByStudentIds}")
    private String findEthnicityCodesByStudentIdsQuery;

    JdbcStudentRepository(final NamedParameterJdbcTemplate template,
                          final SecurityParameterProvider securityParameterProvider) {
        this.template = template;
        this.securityParameterProvider = securityParameterProvider;
    }

    @Override
    public List<Student> findAll(@NotNull final PermissionSource permissionSource,
                                 @NotNull final StudentSearch search) {
        return template.query(
                findAllQuery,
                new MapSqlParameterSource()
                        .addValues(securityParameterProvider.getSecurityParameters(permissionSource))
                        .addValue("group_id", search.getGroupId())
                        .addValue("school_id", search.getSchoolId()),
                this::buildStudents
        );
    }

    private List<Student> buildStudents(final ResultSet row) throws SQLException {

        final List<Student> students = newArrayList();
        final List<Student.Builder> studentBuilders = newArrayList();
        final Set<Long> studentIds = newHashSet();

        while (row.next()) {
            final long studentId = row.getLong("id");
            final Student.Builder studentBuilder = Student.builder()
                    .id(studentId)
                    .ssid(row.getString("ssid"))
                    .firstName(row.getString("first_name"))
                    .lastName(row.getString("last_or_surname"))
                    .genderCode(row.getString("gender_code"))
                    .englishLanguageAcquisitionStatusCode(row.getString("elas_code"))
                    .individualEducationPlan(row.getBoolean("iep"))
                    .limitedEnglishProficiency(getNullable(row, row.getBoolean("lep")))
                    .section504(getNullable(row, row.getBoolean("section504")))
                    .migrantStatus(getNullable(row, row.getBoolean("migrant_status")));

            studentBuilders.add(studentBuilder);
            studentIds.add(studentId);
        }

        final Map<Long, Set<String>> ethnicityCodesByStudentId = findEthnicityCodesForStudentIds(studentIds);

        row.beforeFirst();
        for (int i = 0; row.next(); i++) {
            final Student.Builder studentBuilder = studentBuilders.get(i);
            final long studentId = row.getLong("id");
            studentBuilder.ethnicityCodes(ethnicityCodesByStudentId.get(studentId));
            students.add(studentBuilder.build());
        }

        return students;
    }

    /**
     * Duplicative with {@link AbstractExamRepository}
     */
    private Map<Long, Set<String>> findEthnicityCodesForStudentIds(final Collection<Long> studentIds) {
        if (studentIds == null || studentIds.isEmpty()) {
            return ImmutableMap.of();
        }
        final Map<Long, Set<String>> ethnicityCodesByStudentId = newHashMap();
        template.query(
                findEthnicityCodesByStudentIdsQuery,
                new MapSqlParameterSource("student_ids", studentIds),
                row -> {
                    final long studentId = row.getLong("student_id");
                    final String ethnicityCode = row.getString("ethnicity_code");

                    final Set<String> studentEthnicityCodes = ethnicityCodesByStudentId.get(studentId);
                    if (studentEthnicityCodes == null) {
                        ethnicityCodesByStudentId.put(studentId, newHashSet(ethnicityCode));
                    } else {
                        studentEthnicityCodes.add(ethnicityCode);
                    }
                });
        return ethnicityCodesByStudentId;
    }

}
