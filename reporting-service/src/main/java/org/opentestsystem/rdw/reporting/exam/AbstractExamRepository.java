package org.opentestsystem.rdw.reporting.exam;

import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.reporting.common.jdbc.Exams;
import org.opentestsystem.rdw.reporting.common.jdbc.ScaleScores;
import org.opentestsystem.rdw.reporting.common.jdbc.SecurityParameterProvider;
import org.opentestsystem.rdw.reporting.common.jdbc.StudentContexts;
import org.opentestsystem.rdw.reporting.common.jdbc.TraitScores;
import org.opentestsystem.rdw.reporting.common.model.Exam;
import org.opentestsystem.rdw.reporting.common.model.Student;
import org.opentestsystem.rdw.reporting.common.model.StudentContext;
import org.opentestsystem.rdw.reporting.common.security.PermissionSource;
import org.opentestsystem.rdw.reporting.student.StudentEthnicityRepository;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import javax.validation.constraints.NotNull;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Sets.newHashSet;

public abstract class AbstractExamRepository<T extends AbstractExamSearch> implements ExamRepository<T> {

    private final NamedParameterJdbcTemplate template;
    private final SecurityParameterProvider securityParameterProvider;
    private final String findAllForAssessmentQuery;
    private final StudentEthnicityRepository ethnicityRepository;

    @Value("${sql.exam.findExamLevelTraitScoresByExamIds}")
    private String findExamLevelTraitScoresByExamIds;

    protected AbstractExamRepository(
            @NotNull final NamedParameterJdbcTemplate template,
            @NotNull final SecurityParameterProvider securityParameterProvider,
            @NotNull final String findAllForAssessmentQuery,
            @NotNull final StudentEthnicityRepository ethnicityRepository) {
        this.template = template;
        this.securityParameterProvider = securityParameterProvider;
        this.findAllForAssessmentQuery = findAllForAssessmentQuery;
        this.ethnicityRepository = ethnicityRepository;
    }

    abstract protected Map<String, Object> getParameters(final T search);

    /**
     * Allows for overriding the query string if it changes based on the search
     */
    protected String getFindAllForAssessmentQuery(@NotNull final T search) {
        return findAllForAssessmentQuery;
    }

    public List<Exam> findAllForAssessment(@NotNull final PermissionSource permissionSource, @NotNull final T search) {
        return template.query(
                getFindAllForAssessmentQuery(search),
                new MapSqlParameterSource()
                        .addValues(securityParameterProvider.getSecurityParameters(permissionSource))
                        .addValue("school_year", search.getSchoolYear())
                        .addValue("assessment_id", search.getAssessmentId())
                        .addValues(getParameters(search)),
                (resultSet) -> {
                    return buildExams(resultSet, permissionSource);
                }
        );
    }

    private List<Exam> buildExams(final ResultSet resultSet, final PermissionSource permissionSource) throws SQLException {
        final List<Exam.Builder> examBuilders = newArrayList();
        final Set<Long> studentIds = newHashSet();
        int asmtTypeId = 0;

        while (resultSet.next()) {
            final Exam.Builder examBuilder = Exam.builder()
                    .studentContext(StudentContexts.map(resultSet, StudentContext.builder()).build());

            examBuilders.add(Exams.map(resultSet, examBuilder, permissionSource.getPermissionsById())
                    .claimScaleScores(ScaleScores.mapClaimScores(resultSet))
                    .altScaleScores(ScaleScores.mapAltScores(resultSet)));
            studentIds.add(resultSet.getLong("student_id"));

            asmtTypeId = resultSet.getInt("asmt_type_id");
        }

        // for summative assessments, fetch the exam level trait scores
        if (AssessmentType.SUMMATIVE.id() == asmtTypeId) {
            final Map<Long, Exam.Builder> map =
                examBuilders.stream().collect(Collectors.toMap(Exam.Builder::getId, Function.identity()));
            template.query(findExamLevelTraitScoresByExamIds,
                new MapSqlParameterSource("exam_ids", map.keySet()),
                (row) -> {
                    map.get(row.getLong("exam_id")).traitScore(TraitScores.map(row));
                });
        }

        final Map<Long, Set<String>> ethnicityCodesByStudentId = ethnicityRepository.findEthnicityCodesByStudentIds(studentIds);

        final List<Exam> exams = newArrayList();
        resultSet.beforeFirst();
        for (int i = 0; resultSet.next(); i++) {
            final Exam.Builder examBuilder = examBuilders.get(i);
            final long studentId = resultSet.getLong("student_id");
            final Set<String> ethnicityCodes = ethnicityCodesByStudentId.get(studentId);
            examBuilder.student(Student.builder()
                    .id(studentId)
                    .ssid(resultSet.getString("student_ssid"))
                    .firstName(resultSet.getString("student_first_name"))
                    .lastName(resultSet.getString("student_last_name"))
                    .genderCode(resultSet.getString("student_gender_code"))
                    .ethnicityCodes(ethnicityCodes)
                    .build()
            );
            exams.add(examBuilder.build());
        }

        return exams;
    }


}
