package org.opentestsystem.rdw.admin.security.session;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import org.junit.Before;
import org.junit.Test;
import org.opensaml.saml2.core.Assertion;
import org.opensaml.saml2.core.Attribute;
import org.opensaml.saml2.core.NameID;
import org.opensaml.saml2.core.Response;
import org.opentestsystem.rdw.admin.security.User;
import org.opentestsystem.rdw.security.Permission;
import org.opentestsystem.rdw.security.PermissionScope;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.providers.ExpiringUsernameAuthenticationToken;
import org.springframework.security.saml.SAMLCredential;

import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

import static org.assertj.core.api.Assertions.assertThat;


public class ExpiringUsernameAuthenticationTokenSerializationTest extends SessionObjectMapperBase {

    private ExpiringUsernameAuthenticationToken token;

    @Before
    public void setup() throws Exception {
        final Permission groupWrite = new Permission("GROUP_WRITE", PermissionScope.STATEWIDE);
        final User user = User.builder()
                .id("testUser")
                .username("username")
                .password("password")
                .firstName("firstName")
                .permissionsById(ImmutableMap.of("GROUP_WRITE", groupWrite))
                .authorities(ImmutableSet.of(new SimpleGrantedAuthority("ROLE_USER")))
                .build();

        final Date date = new Date();

        final Response response = readResponseFromResource("/samlResponse.large.xml");
        final Assertion assertion = response.getAssertions().get(0);
        final NameID nameID = assertion.getSubject().getNameID();
        final List<Attribute> attributes = assertion.getAttributeStatements().stream()
                .flatMap(statement -> statement.getAttributes().stream())
                .collect(Collectors.toList());

        final SAMLCredential credential = new SAMLCredential(nameID, assertion, "https://some.sso.provider.org/", attributes,"https://somewhere.org/");

        token = new ExpiringUsernameAuthenticationToken(date, user, credential, user.getAuthorities());
    }

    @Test
    public void itShouldRoundTripAToken() throws Exception {
        final String serializedToken = getObjectMapper().writeValueAsString(token);
        final ExpiringUsernameAuthenticationToken deserializedToken = getObjectMapper().readValue(serializedToken, ExpiringUsernameAuthenticationToken.class);
        assertThat(deserializedToken.getTokenExpiration()).isEqualTo(token.getTokenExpiration());
        assertThat(deserializedToken.getPrincipal()).isEqualTo(token.getPrincipal());

        final SAMLCredential deserializedCredentials = (SAMLCredential) deserializedToken.getCredentials();
        final SAMLCredential credential = (SAMLCredential) token.getCredentials();
        assertThat(deserializedCredentials.getNameID().getValue())
                .isNotBlank()
                .isEqualTo(credential.getNameID().getValue());

        assertThat(deserializedToken.getAuthorities())
                .usingRecursiveFieldByFieldElementComparator()
                .containsExactlyElementsOf(token.getAuthorities());
    }

    @Test
    public void itShouldHandleANullExpirationDate() throws Exception {
        token = new ExpiringUsernameAuthenticationToken(null, token.getPrincipal(), token.getCredentials(), token.getAuthorities());
        final String serializedToken = getObjectMapper().writeValueAsString(token);
        final ExpiringUsernameAuthenticationToken deserializedToken = getObjectMapper().readValue(serializedToken, ExpiringUsernameAuthenticationToken.class);

        assertThat(deserializedToken.getTokenExpiration()).isNull();
    }

}