package org.opentestsystem.rdw.admin.service.impl;

import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import org.apache.commons.codec.binary.Hex;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.csv.CSVRecord;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.rdw.admin.model.CsvValidationResult;
import org.opentestsystem.rdw.admin.model.ImportStatus;
import org.opentestsystem.rdw.admin.model.StudentGroupBatch;
import org.opentestsystem.rdw.admin.repository.StudentGroupBatchRepository;
import org.opentestsystem.rdw.admin.security.User;
import org.opentestsystem.rdw.admin.service.CsvValidationService;
import org.opentestsystem.rdw.admin.service.GroupsSource;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.opentestsystem.rdw.security.Permission;
import org.opentestsystem.rdw.security.PermissionScope;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.web.multipart.MultipartFile;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;
import static java.util.Collections.emptyList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyListOf;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class DefaultStudentGroupBatchServiceTest {
    private static final Joiner CommaJoiner = Joiner.on(",");
    private static final Joiner LineJoiner = Joiner.on("\n");

    private static final List<String> ValidHeaders = ImmutableList.of("header_a", "header_b");

    private static final List<String> ValidValues = ImmutableList.copyOf(ValidHeaders.stream()
            .map(header -> header + "_val_汉字")
            .collect(Collectors.toList()));

    @Mock
    private StudentGroupBatchRepository repository;

    @Mock
    private ArchiveService archiveService;

    @Mock
    private GroupsSource source;

    @Mock
    private CsvValidationService validationService;

    @Captor
    private ArgumentCaptor<List<String>> headerCaptor;

    private DefaultStudentGroupBatchService service;
    private MultipartFile file;
    private List<List<String>> values;

    private final Permission groupWrite = new Permission("GROUP_WRITE", PermissionScope.STATEWIDE);
    private final User user = User.builder()
            .id("user")
            .username("test")
            .password("password")
            .authorities(ImmutableSet.of(new SimpleGrantedAuthority("ROLE_USER")))
            .permissionsById(ImmutableMap.of("GROUP_WRITE", groupWrite))
            .build();

    @Before
    public void before() {
        when(validationService.toFailureMessage(anyListOf(CsvValidationResult.class))).thenReturn("message");
        when(validationService.validateHeaders(anyListOf(String.class))).thenReturn(emptyList());

        values = newArrayList();
        when(validationService.validateRecords(any(Iterator.class), any(PermissionScope.class)))
                .thenAnswer(invocation -> {
                    final Iterator<CSVRecord> recordIterator = (Iterator<CSVRecord>) invocation.getArgumentAt(0, Iterator.class);
                    while (recordIterator.hasNext()) {
                        final CSVRecord record = recordIterator.next();
                        values.add(newArrayList(record.iterator()));
                    }
                    return Collections.emptyList();
                });

        service = new DefaultStudentGroupBatchService(repository, archiveService, validationService, source);

        file = mock(MultipartFile.class);
        when(file.getOriginalFilename()).thenReturn("file name");
        when(file.getSize()).thenReturn(150L);
        when(file.getContentType()).thenReturn("csv");
        when(repository.create(any(StudentGroupBatch.class))).thenAnswer(invocation -> invocation.getArguments()[0]);
    }

    @Test
    public void itShouldUseRepositoryToFindAllStudentGroupBatches() throws IOException {
        final Iterable studentGroupBatches = mock(Iterable.class);
        when(repository.findByCreator("test")).thenReturn(studentGroupBatches);

        assertThat(service.findAllStudentGroupBatches(user)).isEqualTo(studentGroupBatches);
    }

    @Test
    public void itShouldUploadAndValidate() throws IOException {
        final String payload = payload(ValidHeaders, ValidValues);
        when(file.getInputStream()).thenReturn(new ByteArrayInputStream(payload.getBytes()));

        final StudentGroupBatch batch = StudentGroupBatch.builder()
                .creator(user.getUsername())
                .status(ImportStatus.ACCEPTED)
                .digest(DigestUtils.md5Hex(payload.getBytes()).toUpperCase())
                .build();
        assertThat(service.upload(user, file)).isEqualTo(batch);
        assertThat(values).hasSize(1);
        assertThat(values.get(0)).containsExactlyElementsOf(ValidValues);
    }

    @Test
    public void itShouldNotUploadIfColumnHeadersAreMissing() throws IOException {
        final String payload = payload(ValidHeaders, ValidValues);
        when(file.getInputStream()).thenReturn(new ByteArrayInputStream(payload.getBytes()));
        when(validationService.validateHeaders(anyListOf(String.class)))
                .thenReturn(Collections.singletonList(CsvValidationResult.builder()
                        .row(0)
                        .message("Bad stuffs")
                        .build()));

        final StudentGroupBatch batch = StudentGroupBatch.builder()
                .creator(user.getUsername())
                .status(ImportStatus.BAD_DATA)
                .digest(Hex.encodeHexString(DigestUtils.md5(payload)).toUpperCase())
                .message("message")
                .build();
        assertThat(service.upload(user, file)).isEqualTo(batch);
    }

    @Test
    public void itShouldNotUploadEmptyFile() throws IOException {
        when(file.getInputStream()).thenReturn(new ByteArrayInputStream("".getBytes()));
        final StudentGroupBatch batch = StudentGroupBatch.builder()
                .creator(user.getUsername())
                .status(ImportStatus.BAD_DATA)
                .digest(Hex.encodeHexString(DigestUtils.md5("")).toUpperCase())
                .message("message")
                .build();
        assertThat(service.upload(user, file)).isEqualTo(batch);
    }

    @Test
    public void itShouldNotUploadIfFailedToReadTheFile() throws IOException {
        when(file.getInputStream()).thenThrow(new RuntimeException("failed"));

        final StudentGroupBatch batch = StudentGroupBatch.builder()
                .creator(user.getUsername())
                .status(ImportStatus.BAD_DATA)
                .digest(Hex.encodeHexString(DigestUtils.md5("")).toUpperCase())
                .message("Exception processing upload: failed")
                .build();
        assertThat(service.upload(user, file)).isEqualTo(batch);
    }

    @Test
    public void itShouldHandleBOMBytes() throws Exception {
        final String payloadWithBOM = '\uFEFF' + payload(ValidHeaders, ValidValues);
        when(file.getInputStream()).thenReturn(new ByteArrayInputStream(payloadWithBOM.getBytes()));

        service.upload(user, file);

        verify(validationService).validateHeaders(headerCaptor.capture());
        final List<String> headers = headerCaptor.getValue();
        assertThat(headers).containsExactlyElementsOf(ValidHeaders);
    }

    private String payload(final List<String> headers, final List<String> values) {
        return LineJoiner.join(CommaJoiner.join(headers), CommaJoiner.join(values));
    }
}