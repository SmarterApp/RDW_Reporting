package org.opentestsystem.rdw.admin.model;

/*

USE warehouse;

CREATE TABLE IF NOT EXISTS embargo_scope (
  id int NOT NULL PRIMARY KEY,
  code varchar(50) -- individual or aggregate
)

CREATE TABLE IF NOT EXISTS tenant_aggregate_embargo (
  id int NOT NULL PRIMARY KEY,
  enabled tinyint NOT NULL,
  school_year smallint NOT NULL
);

CREATE TABLE IF NOT EXISTS district_embargo (
  id int NOT NULL PRIMARY KEY,
  scope_id int NOT NULL,
  enabled tinyint NOT NULL,
  school_year smallint NOT NULL,
  district_id int NOT NULL,
  INDEX idx__district_embargo__scope (scope_id),
  INDEX idx__district_embargo__district (district_id),
  CONSTRAINT fk__district_embargo__scope FOREIGN KEY (scope_id) REFERENCES embargo_scope(id)
  CONSTRAINT fk__district_embargo__district FOREIGN KEY (district_id) REFERENCES district(id)
);

CREATE TABLE IF NOT EXISTS embargo (
  id int NOT NULL PRIMARY KEY,
  scope_id int, -- null for state/tenant
  district_id int, -- null for state/tenant
  school_year smallint NOT NULL,
  enabled tinyint NOT NULL,
  INDEX idx__district_embargo__scope (scope_id),
  CONSTRAINT fk__district_embargo__scope FOREIGN KEY (scope_id) REFERENCES embargo_scope(id)
);

-- audit columns? created_on, updated_on?



/embargoes
// do i group on ui or backend? backend would yield smaller payload...
// OR if we present them in different tabs we should have different parent collections: aggregateEmbargoes... etc
{
    tenantAggregateEmbargoEnabled: boolean,
    districtEmbargoes: [
        {
            aggregateEnabled: boolean,
            individualEnabled: boolean,
            schoolYear: number, // if showing multiple years on UI
            district: {
                id: number,
                name: string
            }
    ]
}

 */
public class Embargo {

    private Organization district;
    private int schoolYear;
    private boolean enabled;

}
