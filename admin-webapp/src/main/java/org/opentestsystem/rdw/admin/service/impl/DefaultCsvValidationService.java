package org.opentestsystem.rdw.admin.service.impl;

import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableList;
import org.apache.commons.csv.CSVRecord;
import org.opentestsystem.rdw.admin.model.CsvSubject;
import org.opentestsystem.rdw.admin.model.CsvValidationResult;
import org.opentestsystem.rdw.admin.repository.SchoolRepository;
import org.opentestsystem.rdw.admin.repository.SchoolYearRepository;
import org.opentestsystem.rdw.admin.service.CsvValidationService;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.security.PermissionScope;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.StringJoiner;

import static com.google.common.collect.Lists.newArrayList;
import static org.apache.commons.lang.StringUtils.isBlank;
import static org.apache.commons.lang.StringUtils.isNotBlank;
import static org.opentestsystem.rdw.admin.model.CsvValidationResult.failure;

/**
 * Default implementation of a CsvValidationService
 */
@Service
public class DefaultCsvValidationService implements CsvValidationService {

    public final static String HeaderGroup = "group_name";
    public final static String HeaderSchool = "school_natural_id";
    public final static String HeaderYear = "school_year";
    public final static String HeaderSubject = "subject_code";
    public final static String HeaderSSID = "student_ssid";
    public final static String HeaderUser = "group_user_login";

    public final static List<String> RequiredHeaders = ImmutableList.of(
            HeaderGroup,
            HeaderSchool,
            HeaderYear,
            HeaderSubject,
            HeaderSSID,
            HeaderUser
    );
    static final int MaxStudentsPerGroup = 200;
    private static final String ValidationFailureFormat = "Row: %1$d Failure: %2$s";
    private static final String ValidationSuccessFormat = "%1$d group%2$s accepted for %3$s (%4$s).";
    private static final String MoreFailuresFormat = "With %1$d additional validation failures";
    private static final String MoreSuccessesFormat = "With %1$d additional schools";
    private static final int MaxMessages = 100;
    private final SchoolRepository schoolRepository;
    private final SchoolYearRepository schoolYearRepository;

    @Autowired
    public DefaultCsvValidationService(final SchoolRepository schoolRepository,
                                       final SchoolYearRepository schoolYearRepository) {
        this.schoolRepository = schoolRepository;
        this.schoolYearRepository = schoolYearRepository;
    }

    @Override
    public List<CsvValidationResult> validateHeaders(final List<String> csvHeaders) {
        for (int i = 0; i < RequiredHeaders.size(); i++) {
            if (!RequiredHeaders.get(i).equalsIgnoreCase(csvHeaders.get(i))) {
                return newArrayList(failure(0,
                        "Invalid headers. Headers must be in order: [" + Joiner.on(",").join(RequiredHeaders) + "]"));
            }
        }
        return newArrayList();
    }

    @Override
    public List<CsvValidationResult> validateRecords(final Iterator<CSVRecord> recordIterator,
                                                     final PermissionScope permissionScope) {

        final List<CsvValidationResult> failures = new ArrayList<>();
        final List<CsvValidationResult> successes = new ArrayList<>();

        final List<Organization> availableSchools = schoolRepository.findAll(permissionScope);
        final List<Integer> schoolYears = schoolYearRepository.findAll();

        final Set<String> completedSchools = new HashSet<>();
        final Set<String> completedSchoolGroupYears = new HashSet<>();

        String currentSchool = null;
        String currentGroup = null;
        String currentSchoolGroupYear = null;
        CsvSubject currentSchoolGroupYearSubject = null;
        int studentCountPerGroup = 0;
        int groupCountPerSchool = 0;
        long recordNumber = 0;

        while (recordIterator.hasNext()) {
            final CSVRecord record = recordIterator.next();
            final String school = record.get(HeaderSchool);
            final String group = record.get(HeaderGroup);
            final Integer schoolYear = getAsInt(record, HeaderYear);
            final CsvSubject subject = CsvSubject.valueOfCaseInsensitive(record.get(HeaderSubject));
            recordNumber = record.getRecordNumber();

            //Require all key fields to be set
            if (!validateKeyValues(failures, school, group, schoolYear, recordNumber)) {
                continue;
            }

            //Validate the School Year
            if (!schoolYears.contains(schoolYear)) {
                addUniqueFailure(failures, recordNumber, "Invalid school year: " + schoolYear);
            }

            //Validate the School
            if (currentSchool == null || !currentSchool.equals(school)) {
                if (currentSchool != null) {
                    completedSchools.add(currentSchool);
                    successes.add(success(recordNumber, groupCountPerSchool, getSchool(availableSchools, currentSchool)));
                }
                completedSchoolGroupYears.clear();
                currentSchoolGroupYear = null;
                currentSchool = null;
                groupCountPerSchool = 0;

                if (validateSchool(failures, availableSchools, completedSchools, school, recordNumber)) {
                    currentSchool = school;
                } else {
                    // no point in continuing processing since we don't have a current school
                    continue;
                }
            }

            //Validate the School, Group, and Year
            final String schoolGroupYear = school + group + String.valueOf(schoolYear);
            if (currentSchoolGroupYear == null || !currentSchoolGroupYear.equalsIgnoreCase(schoolGroupYear)) {
                if (currentSchoolGroupYear != null) {
                    completedSchoolGroupYears.add(currentSchoolGroupYear);
                }
                currentSchoolGroupYearSubject = null;
                currentSchoolGroupYear = schoolGroupYear;

                validateStudentCount(failures, currentSchool, currentGroup, studentCountPerGroup, recordNumber - 1);
                studentCountPerGroup = 0;
                currentGroup = group;
                groupCountPerSchool++;

                validateSchoolGroupYear(failures, completedSchoolGroupYears, schoolGroupYear, recordNumber);
            }

            //Validate the Subject
            if (currentSchoolGroupYearSubject == null) {
                currentSchoolGroupYearSubject = subject;
            } else if (subject != null && !subject.equals(currentSchoolGroupYearSubject)) {
                addUniqueFailure(failures, recordNumber,
                        "Record is attempting to re-define group subject from ["
                                + currentSchoolGroupYearSubject.name() + "] to [" + subject.name() + "]");

                currentSchoolGroupYearSubject = subject;
            }

            //Count students
            if (isNotBlank(record.get(HeaderSSID))) {
                studentCountPerGroup++;
            }
        }

        validateStudentCount(failures, currentSchool, currentGroup, studentCountPerGroup, recordNumber);

        if (failures.isEmpty()) {
            successes.add(success(recordNumber, groupCountPerSchool, getSchool(availableSchools, currentSchool)));
            return ImmutableList.copyOf(successes);
        }

        return ImmutableList.copyOf(failures);
    }

    @Override
    public String toFailureMessage(final List<CsvValidationResult> failures) {
        final StringJoiner joiner = new StringJoiner("\n");
        final List<CsvValidationResult> subList = failures.size() < MaxMessages ? failures : failures.subList(0, MaxMessages);
        for (final CsvValidationResult validationResult : subList) {
            joiner.add(String.format(ValidationFailureFormat, validationResult.getRow(), validationResult.getMessage()));
        }
        if (failures.size() > MaxMessages) {
            joiner.add(String.format(MoreFailuresFormat, failures.size() - MaxMessages));
        }
        return joiner.toString();
    }

    @Override
    public String toSuccessMessage(final List<CsvValidationResult> successes) {
        final StringJoiner joiner = new StringJoiner("\n");
        final List<CsvValidationResult> subList = successes.size() < MaxMessages ? successes : successes.subList(0, MaxMessages);
        for (final CsvValidationResult validationResult : subList) {
            joiner.add(validationResult.getMessage());
        }
        if (successes.size() > MaxMessages) {
            joiner.add(String.format(MoreSuccessesFormat, successes.size() - MaxMessages));
        }
        return joiner.toString();
    }

    private Integer getAsInt(final CSVRecord row, final String header) {
        try {
            return Integer.valueOf(row.get(header));
        } catch (final NumberFormatException e) {
            return null;
        }
    }

    private static boolean validateKeyValues(final List<CsvValidationResult> failures,
                                             final String school,
                                             final String group,
                                             final Integer schoolYear,
                                             final long recordNumber) {
        boolean failure = false;

        if (isBlank(school)) {
            failures.add(failure(recordNumber, "Record does not contain a school"));
            failure = true;
        }
        if (isBlank(group)) {
            failures.add(failure(recordNumber, "Record does not contain a group name"));
            failure = true;
        }
        if (schoolYear == null) {
            failures.add(failure(recordNumber, "Record does not contain a school year"));
            failure = true;
        }

        return !failure;
    }

    private static boolean validateSchool(final List<CsvValidationResult> failures,
                                          final List<Organization> availableSchools,
                                          final Set<String> completedSchools,
                                          final String school,
                                          final long recordNumber) {
        boolean failure = false;

        if (availableSchools.stream().noneMatch(x -> Objects.equals(x.getNaturalId(), school))) {
            addUniqueFailure(failures, recordNumber, "School [" + school + "] can not be found");
            failure = true;
        }
        if (completedSchools.contains(school)) {
            addUniqueFailure(failures, recordNumber, "School [" + school + "] is out-of-order: sort CSV by school, group, year");
            failure = true;
        }

        return !failure;
    }

    private static void validateStudentCount(final List<CsvValidationResult> failures,
                                             final String school,
                                             final String group,
                                             final int studentCount,
                                             final long recordNumber) {
        if (studentCount > MaxStudentsPerGroup) {
            addUniqueFailure(failures, recordNumber,
                    "School [" + school + "] Group [" + group + "] contains "
                            + studentCount + " students.  Maximum students allowed per group is " + MaxStudentsPerGroup);
        }
    }

    private static void validateSchoolGroupYear(final List<CsvValidationResult> failures,
                                                final Set<String> completedSchoolGroupYears,
                                                final String schoolGroupYear,
                                                final long recordNumber) {
        if (completedSchoolGroupYears.contains(schoolGroupYear)) {
            addUniqueFailure(failures, recordNumber, "Record is out-of-order: sort CSV by school, group, year");
        }
    }

    private static void addUniqueFailure(final List<CsvValidationResult> failures, final long recordNumber, final String message) {
        for (final CsvValidationResult failure : failures) {
            if (failure.getMessage().equals(message)) return;
        }
        failures.add(failure(recordNumber, message));
    }

    private static CsvValidationResult success(final long recordNumber, final int groupCount, final Organization school) {
        return CsvValidationResult.success(recordNumber, String.format(ValidationSuccessFormat,
                groupCount, groupCount == 1 ? "" : "s", school.getName(), school.getNaturalId()));
    }

    private static Organization getSchool(final List<Organization> availableSchools, final String naturalId) {
        return availableSchools.stream().filter(x -> Objects.equals(x.getNaturalId(), naturalId)).findFirst().get();
    }

}
