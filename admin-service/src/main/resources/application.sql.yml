sql:
  admin:
    findWarehouseImports: >-
      SELECT i.id, i.digest FROM import i LIMIT 10;

  assessment:
    reporting:
      findAll: >-
        SELECT
          a.id,
          a.label,
          a.name,
          a.grade_code,
          a.type_id,
          a.school_year,
          ${sql.snippet.asmtScoreCodeColumns},
          a.min_score,
          a.max_score,
          a.cut_point_1,
          a.cut_point_2,
          a.cut_point_3,
          a.cut_point_4,
          a.cut_point_5,
          su.code as subject_code
        FROM asmt a
        JOIN subject su on a.subject_id = su.id
        WHERE (:label_query IS NULL OR a.label LIKE concat('%', :label_query, '%'))
          AND (:name_query IS NULL OR a.name LIKE concat('%', :name_query, '%'))
        ORDER BY a.school_year DESC
        LIMIT :limit

  embargo:
    # query to find all embargo records given a school year and a list of (user's) districts
    # this includes counts of summative exams grouped by each org so it has performance implications
    findAllBySchoolYear: >-
      SELECT
        st.*,
        coalesce(se.individual, 0) as individual,
        coalesce(se.aggregate, 1) as aggregate,
        su.code AS subject_code,
        coalesce(cnt.count, 0) as count
      FROM (SELECT 'State' AS org_type, NULL AS org_id, NULL AS org_name, :school_year AS school_year) st
        JOIN subject su ON 1=1
        LEFT JOIN (SELECT a.subject_id, COUNT(e.id) AS count
                    FROM asmt a JOIN exam e on a.id = e.asmt_id
                    WHERE a.type_id = 3 AND e.deleted = 0 AND e.school_year = :school_year
                    GROUP BY a.subject_id) cnt ON su.id = cnt.subject_id
        LEFT JOIN state_embargo se ON se.school_year = :school_year
      UNION ALL
      SELECT
        'District' AS org_type,
        d.id AS org_id,
        d.name AS org_name,
        :school_year AS school_year,
        IF(se.individual = 0 OR de.individual = 0 OR (se.individual IS NULL and de.individual IS NULL), 0, 1) as individual,
        IF(se.aggregate = 0 OR de.aggregate = 0, 0, 1) as aggregate,
        su.code AS subject_code,
        COALESCE(cnt.count, 0) AS count
      FROM district d JOIN subject su ON 1=1
        LEFT JOIN (SELECT s.district_id, a.subject_id, COUNT(e.id) AS count
                    FROM asmt a JOIN exam e on a.id = e.asmt_id JOIN school s ON e.school_id = s.id
                    WHERE s.district_id IN (:district_ids) AND a.type_id = 3 AND e.deleted = 0 AND e.school_year = :school_year
                    GROUP BY s.district_id, a.subject_id) cnt ON d.id = cnt.district_id AND su.id = cnt.subject_id
        LEFT JOIN state_embargo se ON se.school_year = :school_year
        LEFT JOIN district_embargo de ON d.id = de.district_id and de.school_year = :school_year
      WHERE d.id IN (:district_ids)

    findOneBySchoolYearAndState: >-
      SELECT 'State' AS org_type, NULL AS org_id, NULL AS org_name, :school_year AS school_year, se.individual, se.aggregate
      FROM state_embargo se
      WHERE se.school_year = :school_year

    findOneBySchoolYearAndDistrict: >-
      SELECT 'District' AS org_type, d.id AS org_id, d.name AS org_name, :school_year AS school_year, de.individual, de.aggregate
      FROM district d
        JOIN district_embargo de ON d.id = de.district_id
      WHERE de.school_year = :school_year AND d.id = :district_id

    findTestResultsAvailability: >-
      SELECT
        dist.id AS district_id,
        dist.name AS district_name,
        exam.school_year,
        sub.id AS subject_id,
        sub.code AS subject_code,
        ert.name AS report_type,
        IF(ert.name = 'Aggregate', coalesce(de.aggregate, 0), coalesce(de.individual, 0)) AS status,
        coalesce(count(exam.id),0) AS count
      FROM exam
        JOIN school sch ON exam.school_id = sch.id
        JOIN district dist ON sch.district_id = dist.id
        JOIN asmt ON exam.asmt_id = asmt.id
        JOIN subject sub ON asmt.subject_id = sub.id
        JOIN embargo_report_type ert on 1=1
        LEFT JOIN district_embargo de ON
          asmt.school_year = de.school_year AND
          sch.district_id = de.district_id AND
          sub.id = de.subject_id
        WHERE asmt.type_id = 3 AND exam.deleted = 0
          AND IF(ert.name = 'Aggregate', coalesce(de.aggregate,0), coalesce(de.individual,0)) IN (:included_statuses)
          AND (
            IF(ert.name = 'Aggregate', coalesce(de.aggregate,0), coalesce(de.individual,0)) NOT IN (:filtered_statuses)
              OR dist.id IN (:district_ids)
           )
      GROUP BY exam.school_year, dist.id, sub.id, ert.name

    findEmbargoAuditRecords: >-
      SELECT
        ade.school_year AS school_year,
        d.name AS district,
        s.code AS subject,
        individual,
        previous_individual,
        aggregate,
        previous_aggregate,
        updated_by AS user,
        ade.updated AS updated
      FROM audit_district_embargo ade
      LEFT JOIN district d ON ade.district_id = d.id
      LEFT JOIN subject s ON ade.subject_id = s.id
      WHERE ade.updated > :start_date
      ORDER BY ade.updated DESC;

    createState: >-
      INSERT INTO state_embargo (school_year, individual, aggregate, updated_by)
      VALUES (:school_year, :individual, :aggregate, :updated_by)

    createDistrict: >-
      INSERT INTO district_embargo (district_id, school_year, individual, aggregate, updated_by)
      VALUES (:district_id, :school_year, :individual, :aggregate, :updated_by)

    updateState: >-
      UPDATE state_embargo
      SET individual = :individual, aggregate = :aggregate, updated_by = :updated_by
      WHERE school_year = :school_year

    updateDistrict: >-
      UPDATE district_embargo
      SET individual = :individual, aggregate = :aggregate, updated_by = :updated_by
      WHERE district_id = :district_id AND school_year = :school_year

  group:
    findAllDistinctSchoolYears: >-
      SELECT distinct sg.school_year
      FROM student_group sg
        JOIN school sc ON sc.id = sg.school_id
      WHERE sg.deleted = 0
        and ${sql.snippet.basicPermission}

    findAllByQuery: >-
      SELECT sg.id,
        sg.name AS group_name,
        sc.name AS school_name,
        sc.id AS school_id,
        sg.school_year,
        (SELECT count(*) FROM student_group_membership sgm WHERE sgm.student_group_id = sg.id) AS student_count,
        s.code AS subject_code
      FROM student_group sg
        JOIN school sc ON sc.id = sg.school_id
        LEFT JOIN subject s ON s.id = sg.subject_id
      WHERE sg.school_id = :school_id
        and sg.deleted = 0
        and (sg.subject_id is null or s.code in (:subject_codes))
        and sg.school_year = :school_year
        and ${sql.snippet.basicPermission}

    delete: >-
      update student_group sg
        JOIN school sc ON sg.school_id = sc.id
      set sg.deleted = 1,
        sg.update_import_id = :import_id
      WHERE sg.id = :id
        and ${sql.snippet.basicPermission}

  school:
    findAll: >-
      SELECT name, id, natural_id
      FROM school sc
      WHERE ${sql.snippet.basicPermission}

  schoolYear:
    findAll: >-
      SELECT year FROM school_year ORDER BY year

  status:
    readTest: >-
      SELECT ist.name FROM import_status ist

  import:
    createQuery: >-
      INSERT INTO import (status, content, contentType, digest, batch) VALUES
        (0, :content, :contentType, :digest, :batch)

    triggerQuery: >-
      UPDATE import SET status = 1 WHERE id = :id

    statusQuery: >-
      UPDATE import SET status = :status, message = :message WHERE id = :id

    createGroup: >-
      INSERT INTO import (status, content, contentType, digest, batch, creator) VALUES
        (0, 5, :contentType, :digest, :batch, :creator)

    findGroupById: >-
      SELECT * FROM import WHERE content = 5 AND id = :id

    findGroupByDigest: >-
      SELECT * FROM import WHERE content = 5 AND digest = :digest

    findGroupByCreator: >-
      SELECT * FROM import WHERE content = 5 AND contentType <> 'group delete' AND creator = :creator

  instructionalResource:
    findAll: >-
      SELECT DISTINCT
        GROUP_CONCAT(DISTINCT a.label ORDER BY a.id DESC SEPARATOR ', ') AS asmt_label,
        a.type_id AS asmt_type_id,
        su.code as asmt_subject_code,
        ir.asmt_name,
        ir.performance_level,
        ir.org_level,
        ir.resource,
        ir.org_id,
        coalesce(district_group.name, district.name, school_group.name) AS org_name
      FROM instructional_resource ir
        JOIN asmt a
          ON a.name = ir.asmt_name
        JOIN subject su
          ON su.id = a.subject_id
        LEFT JOIN district_group
          ON ir.org_level = 'DistrictGroup'
          AND district_group.id = ir.org_id
        LEFT JOIN district
          ON ir.org_level = 'District'
          AND district.id = ir.org_id
        LEFT JOIN school_group
          ON ir.org_level = 'SchoolGroup'
          AND school_group.id = ir.org_id
      LEFT JOIN school sch
        ON sch.district_id = ir.org_id
        OR sch.school_group_id = ir.org_id
      WHERE ir.org_level != 'System'
        AND
        (
          1=:statewide
          OR
          (
            (ir.org_level = 'DistrictGroup' AND district_group.id in (:district_group_ids))
            OR
            (
              ir.org_level = 'District'
              AND
              (
                district.id in (:district_ids)
                OR
                (district.id = sch.district_id AND sch.district_group_id in (:district_group_ids))
              )
            )
            OR
            (
              ir.org_level = 'SchoolGroup'
              AND
              (
                school_group.id in (:school_group_ids)
                OR
                (school_group.id = sch.school_group_id AND (sch.district_id in (:district_ids) OR sch.district_group_id in (:district_group_ids)))
              )
            )
          )
        )
      GROUP BY a.type_id, su.code, ir.asmt_name, ir.performance_level, ir.org_level, ir.resource, ir.org_id, district_group.name, district.name, school_group.name

    findOne: >-
      SELECT
        GROUP_CONCAT(DISTINCT a.label ORDER BY a.id DESC SEPARATOR ', ') AS asmt_label,
        a.type_id AS asmt_type_id,
        su.code as asmt_subject_code,
        ir.asmt_name,
        ir.performance_level,
        ir.org_level,
        ir.resource,
        ir.org_id,
        coalesce(district_group.name, district.name, school_group.name) AS org_name
      FROM instructional_resource ir
        JOIN asmt a
          ON a.name = ir.asmt_name
        JOIN subject su
          ON su.id = a.subject_id
        LEFT JOIN district_group
          ON ir.org_level = 'DistrictGroup'
          AND district_group.id = ir.org_id
        LEFT JOIN district
          ON ir.org_level = 'District'
          AND district.id = ir.org_id
        LEFT JOIN school_group
          ON ir.org_level = 'SchoolGroup'
          AND school_group.id = ir.org_id
        LEFT JOIN school sch
          ON sch.district_id = ir.org_id
          OR sch.school_group_id = ir.org_id
      WHERE ir.org_level != 'System'
        AND ir.org_level = :org_level
        AND ir.asmt_name = :asmt_name
        AND ir.performance_level = :performance_level
        AND ir.org_id <=> :org_id
        AND
        (
          1=:statewide
          OR
          (
            (ir.org_level = 'DistrictGroup' AND district_group.id in (:district_group_ids))
            OR
            (
              ir.org_level = 'District'
              AND
              (
                district.id in (:district_ids)
                OR
                (district.id = sch.district_id AND sch.district_group_id in (:district_group_ids))
              )
            )
            OR
            (
              ir.org_level = 'SchoolGroup'
              AND
              (
                school_group.id in (:school_group_ids)
                OR
                (school_group.id = sch.school_group_id AND (sch.district_id in (:district_ids) OR sch.district_group_id in (:district_group_ids)))
              )
            )
          )
        )
      GROUP BY a.type_id, su.code, ir.asmt_name, ir.performance_level, ir.org_level, ir.resource, ir.org_id, district_group.name, district.name, school_group.name

    update: >-
      UPDATE instructional_resource ir
      SET
        ir.resource = :resource
      WHERE ir.org_level != 'System'
        AND ir.org_level = :org_level
        AND ir.asmt_name = :asmt_name
        AND ir.performance_level = :performance_level
        AND ir.org_id <=> :org_id

    create: >-
      INSERT INTO instructional_resource (asmt_name, resource, org_level, performance_level, org_id)
        SELECT DISTINCT
          :asmt_name,
          :resource,
          :org_level,
          :performance_level,
          :org_id
        FROM asmt a
          LEFT JOIN instructional_resource ir
            ON ir.asmt_name = a.name
              AND ir.performance_level = :performance_level
              AND ir.org_level = :org_level
              AND ir.org_id <=> :org_id
        WHERE a.name = :asmt_name
          AND ir.asmt_name IS NULL

    delete: >-
      DELETE FROM instructional_resource
      WHERE org_level != 'System'
        AND org_level = :org_level
        AND asmt_name = :asmt_name
        AND performance_level = :performance_level
        AND org_id <=> :org_id

  pipeline:
    findAll: >-
      SELECT
        id,
        code,
        input_type,
        active_version
      FROM pipeline
      ORDER BY id ASC

    findById: >-
      SELECT
        id,
        code,
        input_type,
        active_version
      FROM pipeline
      WHERE id = :id

    update:
      UPDATE pipeline
      SET active_version = :active_version
      WHERE id = :id

  pipeline-script:
    findAllByPipeline: >-
      SELECT
        id,
        pipeline_id,
        body,
        created,
        updated,
        updated_by
      FROM pipeline_script
      WHERE pipeline_id = :pipeline_id
      ORDER BY id DESC

    findById: >-
      SELECT
        id,
        pipeline_id,
        body,
        created,
        updated,
        updated_by
      FROM pipeline_script
      WHERE id = :id

    create: >-
      INSERT INTO pipeline_script (pipeline_id, body, updated_by)
      VALUES (:pipeline_id, :body, :updated_by)

    update: >-
      UPDATE pipeline_script
      SET
        body = :body,
        updated_by = :updated_by
      WHERE id = :id

  pipeline-test:
    findAllByPipeline: >-
      SELECT
        id,
        pipeline_id,
        name,
        example_input,
        expected_output,
        created,
        updated,
        updated_by
      FROM pipeline_test
      WHERE pipeline_id = :pipeline_id
      ORDER BY created DESC

    findById: >-
      SELECT
        id,
        pipeline_id,
        name,
        example_input,
        expected_output,
        created,
        updated,
        updated_by
      FROM pipeline_test
      WHERE id = :id

    create: >-
      INSERT INTO pipeline_test (pipeline_id, name, example_input, expected_output, updated_by)
      VALUES (:pipeline_id, :name, :example_input, :expected_output, :updated_by)

    update: >-
      UPDATE pipeline_test
      SET
        name = :name,
        example_input = :example_input,
        expected_output = :expected_output,
        updated_by = :updated_by
      WHERE id = :id

    deleteById: >-
      DELETE FROM pipeline_test
      WHERE id = :id

  multitenantDatabaseAdmin:
    truncateAuroraTable: >-
      TRUNCATE TABLE `$[databaseName]`.`$[tableName]`

    auroraS3LoadData: >-
      LOAD DATA FROM S3 '$[s3Uri]'
      INTO TABLE `$[databaseName]`.`$[tableName]`

    mySqlFileLoadData: >-
      LOAD DATA INFILE '$[filePath]'
      INTO TABLE `$[databaseName]`.`$[tableName]`

    useDatabase: >-
      USE $[databaseName]

    disableForeignKeyChecks: >-
      SET FOREIGN_KEY_CHECKS=0

    enableForeignKeyChecks: >-
      SET FOREIGN_KEY_CHECKS=1

    tableEmptyProbe: >-
      SELECT COUNT(*)
      FROM `$[databaseName]`.`$[tableName]`

    databaseExists: >-
      SELECT EXISTS(SELECT SCHEMA_NAME
      FROM INFORMATION_SCHEMA.SCHEMATA
      WHERE SCHEMA_NAME = :targetDatabase)

    createDatabase: >-
      CREATE DATABASE $[databaseName]
      DEFAULT CHARACTER SET 'utf8'
      COLLATE 'utf8_unicode_ci'

    userExists: >-
      SELECT EXISTS(SELECT 1
                    FROM mysql.user
                    WHERE user = :username)

    createDatabaseUser: >-
      CREATE USER :username @'%' IDENTIFIED BY :password

#    grantUserToDatabase: >-
#      GRANT ALL PRIVILEGES ON $[databaseName].* TO :username @'%'
#
#    grantUserOnSelectProc: >-
#      GRANT SELECT ON mysql.proc TO :username @'%'
#
#    grantUserLoadFromS3: >-
#      GRANT LOAD FROM S3 ON *.* TO :username @'%'
#
#    grantUserSelectIntoS3: >-
#      GRANT SELECT INTO S3 ON *.* to :username @'%'
#
#    grantUserFile: >-
#      GRANT FILE ON *.* TO :username @'%'

    grantBasicPermissions:
      - GRANT ALL PRIVILEGES ON $[databaseName].* TO :username @'%'
      - GRANT SELECT ON mysql.proc TO :username @'%'
      - GRANT LOAD FROM S3 ON *.* TO :username @'%'
      - GRANT SELECT INTO S3 ON *.* to :username @'%'

    grantBasicPermissionsLocal:
      - GRANT ALL PRIVILEGES ON $[databaseName].* TO :username @'%'
      - GRANT SELECT ON mysql.proc TO :username @'%'
      - GRANT FILE ON *.* TO :username @'%'

    dropSandboxDatabase: >-
      DROP DATABASE IF EXISTS $[databaseName]

    dropSandboxUser: >-
      DROP USER $[username]

    olapDatabaseUserExists: >-
      SELECT COUNT(usename) FROM pg_user where usename = :username;

    createOlapDatabaseUser: >-
      CREATE USER $[username] PASSWORD '$[password]'

    olapSchemaExists: >-
      SELECT COUNT(schema_name)
      FROM information_schema.schemata
      WHERE schema_name = :schema

    createOlapSchema: >-
      CREATE SCHEMA $[schema]

    grantAllOlapUserToSchema: >-
      GRANT ALL ON SCHEMA $[schema] to $[username]

    grantAllOlapUserToSchemaTables: >-
      GRANT ALL ON ALL TABLES IN SCHEMA $[schema] to $[username]

    searchPathOlapUserToSchema: >-
      ALTER USER $[username] SET SEARCH_PATH TO $[schema];

    # storing as array - may be some additional actions needed here
    revokeOlapUser:
      - REVOKE ALL ON SCHEMA $[schema] FROM $[username]

    dropSandboxOlapSchemaAndUser:
      - DROP SCHEMA IF EXISTS $[schema] CASCADE
      - DROP USER IF EXISTS $[username]

  metrics:
    findAll: >-
      SELECT m.category,
             m.school_year,
             m.subject_code,
             m.asmt_type,
             m.cnt
      FROM (
        SELECT 'Subjects' AS category,
        e.school_year  AS school_year,
        s.code AS subject_code,
        t.code AS asmt_type,
        sum(e.cnt) AS cnt
        FROM (SELECT COUNT(*) AS cnt,
                     school_year,
                     asmt_id
              FROM exam
              GROUP BY school_year, asmt_id ) e
        JOIN asmt a
          ON a.id = e.asmt_id
        JOIN asmt_type t
          ON a.type_id = t.id
        JOIN subject s
          ON s.id = a.subject_id
        GROUP BY  e.school_year, s.code, t.code
      UNION ALL
        SELECT 'Subjects' AS category,
        e.school_year  AS school_year,
        s.code AS subject_code,
        t.code AS asmt_type,
        sum(e.cnt) AS cnt
        FROM (SELECT COUNT(*) AS cnt,
                     school_year,
                     asmt_id
             FROM iab_exam
             GROUP BY school_year, asmt_id ) e
        JOIN asmt a
          ON a.id = e.asmt_id
        JOIN asmt_type t
          ON a.type_id = t.id
        JOIN subject s
          ON s.id = a.subject_id
        GROUP BY  e.school_year, s.code, t.code
      UNION ALL
        SELECT 'Students' AS category,
        s.school_year,
        NULL AS subject_code,
        NULL AS asmt_type,
        COUNT(distinct s.student_id) as cnt
        FROM (
          SELECT DISTINCT student_id,
                 school_year
                 from iab_exam
          UNION
          SELECT DISTINCT student_id,
                 school_year from exam) s
        GROUP BY s.school_year, subject_code, asmt_type
      UNION ALL
        SELECT 'Schools' AS category,
        s.school_year,
        NULL AS subject_code,
        NULL AS asmt_type,
        COUNT(distinct s.school_id) as cnt
        FROM (
          SELECT DISTINCT school_id,
                 school_year
                 from iab_exam
          UNION
          SELECT DISTINCT school_id,
                 school_year from exam) s
        GROUP BY s.school_year, subject_code, asmt_type
      ) as m
      ORDER BY m.category, m.school_year DESC, m.subject_code, m.asmt_type;
