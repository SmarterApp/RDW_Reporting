package org.opentestsystem.rdw.admin.multitenant.administration.impl;

import com.google.common.annotations.VisibleForTesting;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatusContext;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatusService;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatusSyncService;
import org.opentestsystem.rdw.admin.multitenant.configprops.ConfigpropsService;
import org.opentestsystem.rdw.admin.multitenant.configserver.ConfigServerClient;
import org.opentestsystem.rdw.multitenant.TenantProperties;
import org.springframework.scheduling.annotation.Scheduled;

import java.time.Duration;
import java.time.Instant;
import java.util.Map;
import java.util.Optional;

import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus.ACTIVE;
import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus.CREATE_PUBLISHING_CONFIGURATION_CHANGES;
import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus.DELETE_PUBLISHING_CONFIGURATION_CHANGES;
import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus.UPDATE_PUBLISHING_CONFIGURATION_CHANGES;

public class DefaultTenantAdministrationStatusSyncService implements TenantAdministrationStatusSyncService {

    private final TenantAdministrationStatusService statusService;
    private final ConfigpropsService configpropsService;
    private final ConfigServerClient configServerClient;
    private final Long createDelayMinutes;
    private final Long updateDelayMinutes;

    public DefaultTenantAdministrationStatusSyncService(TenantAdministrationStatusService statusService,
                                                        ConfigpropsService configpropsService,
                                                        ConfigServerClient configServerClient,
                                                        Long createDelayMinutes,
                                                        Long updateDelayMinutes) {
        this.statusService = statusService;
        this.configpropsService = configpropsService;
        this.configServerClient = configServerClient;
        this.createDelayMinutes = createDelayMinutes;
        this.updateDelayMinutes = updateDelayMinutes;
    }

    @Scheduled(initialDelayString = "${app.multitenant.statusSync.initialDelay.:30000}",
            fixedDelayString = "${app.multitenant.statusSync.fixedDelay.:30000}")
    @Override
    public void sync() {
        //snapshot of configured tenants in configprops
        Optional<TenantProperties> tenantPropertiesOpt = configpropsService.tenantProperties();
        if (!tenantPropertiesOpt.isPresent()) {
            return;
        }
        TenantProperties tenantProperties = tenantPropertiesOpt.get();

        //snapshot of current status
        Map<String, TenantAdministrationStatusContext> statusMap = statusService.allTenantStatusAsMap();

        //add missing tenants (startup or other reasons for being missing)
        addMissingTenants(statusMap, tenantProperties);

        //update in-process tenants
        inProcessCreateTenants(statusMap, tenantProperties);
        inProcessUpdateTenants(statusMap, tenantProperties);
        inProcessDeleteTenants(statusMap, tenantProperties);
    }

    private void addMissingTenants(Map<String, TenantAdministrationStatusContext> statusMap, TenantProperties tenantProperties) {
        tenantProperties.getTenants().forEach((tenantKey, tenant) -> {
            if (!statusMap.containsKey(tenant.getKey())) {
                statusService.putStatus(tenantKey, ACTIVE, tenant);
            }
        });
    }

    private void inProcessCreateTenants(Map<String, TenantAdministrationStatusContext> statusMap, TenantProperties tenantProperties) {
        statusMap.entrySet().stream()
                .filter(entry ->
                        entry.getValue().getTenantAdministrationStatus() == CREATE_PUBLISHING_CONFIGURATION_CHANGES
                )
                .forEach(entry -> {
                    final String tenantKey = entry.getKey();
                    final long minutesSinceUpdate = getMinutesSinceUpdate(entry.getValue());
                    //wait createDelayMinutes for migrations to finish
                    if (minutesSinceUpdate > createDelayMinutes && tenantProperties.getTenants().containsKey(tenantKey)) {
                        statusService.updateStatus(tenantKey, ACTIVE, tenantProperties.getTenants().get(tenantKey), null);
                        configServerClient.postMonitor();
                    }
                });
    }

    private void inProcessUpdateTenants(Map<String, TenantAdministrationStatusContext> statusMap, TenantProperties tenantProperties) {
        statusMap.entrySet().stream()
                .filter(entry ->
                        entry.getValue().getTenantAdministrationStatus() == UPDATE_PUBLISHING_CONFIGURATION_CHANGES
                )
                .forEach(entry -> {
                    final String tenantKey = entry.getKey();
                    final long minutesSinceUpdate = getMinutesSinceUpdate(entry.getValue());
                    //wait updateDelayMinutes for configuration to filter out to each service
                    if (minutesSinceUpdate > updateDelayMinutes && tenantProperties.getTenants().containsKey(tenantKey)) {
                        statusService.updateStatus(tenantKey, ACTIVE, tenantProperties.getTenants().get(tenantKey), null);
                    }
                });
    }

    private void inProcessDeleteTenants(Map<String, TenantAdministrationStatusContext> statusMap, TenantProperties tenantProperties) {
        statusMap.entrySet().stream()
                .filter(entry ->
                        entry.getValue().getTenantAdministrationStatus() == DELETE_PUBLISHING_CONFIGURATION_CHANGES
                )
                .forEach(entry -> {
                    final String tenantKey = entry.getKey();
                    //remove from status service once configuration is removed from tenantProperties
                    if (!tenantProperties.getTenants().containsKey(tenantKey)) {
                        statusService.remove(tenantKey);
                    }
                });
    }

    @VisibleForTesting
    protected long getMinutesSinceUpdate(TenantAdministrationStatusContext statusContext) {
        final Instant now = Instant.now();
        final Duration between = Duration.between(statusContext.getUpdated(), now);
        return between.abs().toMinutes();
    }

}
