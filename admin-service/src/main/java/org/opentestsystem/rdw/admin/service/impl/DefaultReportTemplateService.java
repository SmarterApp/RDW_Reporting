package org.opentestsystem.rdw.admin.service.impl;

import org.opentestsystem.rdw.admin.model.ReportTemplateInfo;
import org.opentestsystem.rdw.admin.repository.ReportTemplateInfoRepository;
import org.opentestsystem.rdw.admin.service.ReportTemplateService;
import org.opentestsystem.rdw.reporting.common.repository.ReportTemplateRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.InputStream;
import java.io.OutputStream;
import java.util.Date;
import java.util.List;
import java.util.Properties;
import java.util.stream.Collectors;

/**
 * Default implementation backed by template repository, and repo for subject / assessment types.
 * <p>
 * Templates are defined for a subject / assessment type combination. The contents are
 * saved as HTML files named using the subject and assessment type codes. For example
 * the math summative template would have the filename "Math_sum.html". The knowledge
 * of this pattern is in three places: this service, the ReportTemplateResolver, and
 * the "batch-reports.html" report wrapper template file.
 * </p>
 */
@Service
class DefaultReportTemplateService implements ReportTemplateService {

    private final ReportTemplateInfoRepository infoRepository;
    private final ReportTemplateRepository templateRepository;

    @Autowired
    DefaultReportTemplateService(final ReportTemplateInfoRepository infoRepository,
                                 final ReportTemplateRepository templateRepository) {
        this.infoRepository = infoRepository;
        this.templateRepository = templateRepository;
    }

    @Override
    public List<ReportTemplateInfo> getTemplateInfo() {
        // get the list of existing templates; these are filenames, e.g. "Math_sum.html"
        final List<String> existingTemplates = templateRepository.findAllTemplateNames();

        // get the comprehensive list of subject / assessment type combinations
        // then enrich with properties from template repository (if there is an existing template)
        return infoRepository.findAll().stream()
            .map(templateInfo -> {
                final String templateName = templateName(templateInfo);
                if (existingTemplates.contains(templateName)) {
                    final Properties properties = templateRepository.getProperties(templateName).orElse(null);
                    if (properties != null) {
                        return templateInfo.copy()
                            .contentType(properties.getProperty("Content-Type"))
                            .contentLength((Long) properties.get("Content-Length"))
                            .lastModified(((Date) properties.get("Last-Modified")).toInstant())
                            .build();
                    }
                }
                return templateInfo;
            })
            .collect(Collectors.toList());
    }

    @Override
    public void download(final String subjectCode, final String assessmentType, final OutputStream os) {
        templateRepository.read(ReportTemplateService.templateName(subjectCode, assessmentType), os);
    }

    @Override
    public void upload(final String subjectCode, final String assessmentType, final InputStream is) {
        templateRepository.write(ReportTemplateService.templateName(subjectCode, assessmentType), is);
    }

    @Override
    public void delete(final String subjectCode, final String assessmentType) {
        templateRepository.delete(ReportTemplateService.templateName(subjectCode, assessmentType));
    }

    private static String templateName(final ReportTemplateInfo reportTemplateInfo) {
        return ReportTemplateService.templateName(reportTemplateInfo.getSubjectCode(), reportTemplateInfo.getAssessmentType());
    }
}
