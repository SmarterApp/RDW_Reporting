package org.opentestsystem.rdw.admin.service.impl;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.collect.ImmutableMap;
import org.opentestsystem.rdw.admin.service.ActuatorServicesProperties;
import org.opentestsystem.rdw.archive.ArchivePropertiesRoot;
import org.opentestsystem.rdw.archive.ArchivePropertiesTenant;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsProperties;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsTenant;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingPropertiesRoot;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingPropertiesTenant;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemPropertiesImpl;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemSettings;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Classes to return tenant usable data from the RDW Actuator endpoint calls
 */
@Service
public class DefaultActuatorServicesProperties implements ActuatorServicesProperties {
    private static final Logger logger = LoggerFactory.getLogger(DefaultActuatorServicesProperties.class);

    private DefaultActuatorClientRdwService defaultActuatorClientRdwService;
    private ObjectMapper mapper;

    // the Default and Tenant Property object to get set whenever a refresh is called
    private Optional<ReportingSystemSettings> reportingSystemSettings;
    private Optional<DataSourceElementsProperties> readOnlyDataSourceElementsProperties;
    private Optional<DataSourceElementsProperties> writableDataSourceElementsProperties;
    private Optional<DataSourceElementsProperties> warehouseDataSourceElementsProperties;
    private Optional<DataSourceElementsProperties> olapDataSourceElementsProperties;
    private Optional<ArchivePropertiesRoot> archivePropertiesRoot;
    private Optional<AggregateReportingPropertiesRoot> aggregateReportingPropertiesRoot;

    @Autowired
    public DefaultActuatorServicesProperties(DefaultActuatorClientRdwService defaultActuatorClientRdwService,
                                        ObjectMapper objectMapper) {
        this.defaultActuatorClientRdwService = defaultActuatorClientRdwService;
        this.mapper = objectMapper.copy();
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        servicesPropertiesRefresh();
    }

    @Override
    public void servicesPropertiesRefresh() {
        List<ResponseEntity<String>> responseEntities = defaultActuatorClientRdwService.getAllResponseEntities();
        reportingSystemSettings = getReportingSystemSettings(responseEntities);
        readOnlyDataSourceElementsProperties = getReadOnlyDataSourceElementsProperties(responseEntities);
        writableDataSourceElementsProperties = getWritableDataSourceElementsProperties(responseEntities);
        warehouseDataSourceElementsProperties = getWarehouseDataSourceElementsProperties(responseEntities);
        olapDataSourceElementsProperties = getOlapDataSourceElementsProperties(responseEntities);
        archivePropertiesRoot = getArchivePropertiesRoot(responseEntities);
        aggregateReportingPropertiesRoot = getAggregateReportingPropertiesRoot(responseEntities);
    }

    // REPORTING SYSTEM SETTINGS
    @Override
    public Optional<ReportingSystemPropertiesImpl> getDefaultReportingSystemSettings() {
        if(reportingSystemSettings.isPresent()) {
            logger.debug("Response to get Default ReportingSystemProperties = {}", reportingSystemSettings.get());
            try {
                ReportingSystemPropertiesImpl reporting = mapper.readValue(mapper.writeValueAsString(reportingSystemSettings.get()), ReportingSystemPropertiesImpl.class);
                return Optional.of(reporting);
            } catch (Exception e) {
                logger.error("Error parsing ReportingSystemSettings from json: {}", reportingSystemSettings);
            }
        }
        return Optional.empty();
    }
    @Override
    public Map<String, ReportingSystemPropertiesImpl> getTenantReportingSystemSettings() {
        if(readOnlyDataSourceElementsProperties.isPresent()) {
            return reportingSystemSettings.get().getTenants();
        }
        return ImmutableMap.of();
    }
    /**
     * @param responseEntities list of responses from each rdw service
     * @return Optional ReportingSystemSettings that is found first in the responseEntities
     */    private Optional<ReportingSystemSettings> getReportingSystemSettings(List<ResponseEntity<String>> responseEntities) {
        List<ReportingSystemSettings> settings = responseEntities.stream()
                .map(this::parseReportingSystemSettings)
                .flatMap(o -> o.map(Stream::of).orElseGet(Stream::empty)) // Java 8 stinks https://stackoverflow.com/questions/22725537/using-java-8s-optional-with-streamflatmap
                .collect(Collectors.toList());
        logger.debug("ReportingSystemSettings {}", settings);
        return settings.stream().findFirst();
    }
    /**
     * @param entity specific rdw service's response to search for reporting system settings
     * @return ReportingSystemSettings if found
     */
    private Optional<ReportingSystemSettings> parseReportingSystemSettings(ResponseEntity<String> entity) {
        try {
            JsonNode rootNode = mapper.readTree(entity.getBody());
            JsonNode reportingSystemSettingsNode = rootNode.path("scopedTarget.reportingSystemSettings").path("properties");
            return Optional.of(mapper.treeToValue(reportingSystemSettingsNode, ReportingSystemSettings.class));
        } catch (Exception e) {
            logger.warn("ReportingSystemSettings not found parsing json: {}", entity);
            return Optional.empty();
        }
    }


    /// READ ONLY DATASOURCE
    @Override
    public Optional<DataSourceElementsTenant> getDefaultReadOnlyDataSourceElements() {
        if(readOnlyDataSourceElementsProperties.isPresent()) {
            logger.debug("Response to get for ReportingSystemProperties = {}", readOnlyDataSourceElementsProperties.get());
            try {
                DataSourceElementsTenant dataSource = mapper.readValue(mapper.writeValueAsString(readOnlyDataSourceElementsProperties.get()), DataSourceElementsTenant.class);
                return Optional.of(dataSource);
            } catch (Exception e) {
                logger.error("Error parsing ReadOnly dataSourceElementsTenantProperties from json: {}", readOnlyDataSourceElementsProperties.get());
            }
        }
        return Optional.empty();
    }
    @Override
    public Map<String, DataSourceElementsTenant> getTenantsReadOnlyDataSourceElements() {
        if(readOnlyDataSourceElementsProperties.isPresent()) {
            return readOnlyDataSourceElementsProperties.get().getTenants();
        }
        return ImmutableMap.of();
    }
    /**
     * @param responseEntities list of responses from each rdw service
     * @return Optional DataSourceElementsProperties the first found readOnly DataSource settings
     */
    private Optional<DataSourceElementsProperties> getReadOnlyDataSourceElementsProperties(List<ResponseEntity<String>> responseEntities) {
        List<DataSourceElementsProperties> settings = responseEntities.stream()
                .map(this::parseDataSourceElementsProperties)
                .flatMap(o -> o.map(Stream::of).orElseGet(Stream::empty)) // Java 8 stinks https://stackoverflow.com/questions/22725537/using-java-8s-optional-with-streamflatmap
                .collect(Collectors.toList());
        logger.debug("ReadOnly DataSourceElementsProperties {}", settings);
        return settings.stream().findFirst();
    }
    /**
     * @param entity specific rdw service's response to search for readonly dataSources
     * @return readonly DataSourceElementsProperties if found
     */
    private Optional<DataSourceElementsProperties> parseDataSourceElementsProperties(ResponseEntity<String> entity) {
        try {
            JsonNode rootNode = mapper.readTree(entity.getBody());
            JsonNode dataSourceElementsPropertiesNode = rootNode.path("scopedTarget.dataSourceElementsProperties").path("properties");
            return Optional.of(mapper.treeToValue(dataSourceElementsPropertiesNode, DataSourceElementsProperties.class));
        } catch (Exception e) {
            logger.warn("ReadOnly DataSourceElementsProperties not found parsing json: {}", entity);
            return Optional.empty();
        }
    }

    // WRITABLE DATASOURCES
    @Override
    public Optional<DataSourceElementsTenant> getDefaultWritableDataSourceElements() {
        if(writableDataSourceElementsProperties.isPresent()) {
            logger.debug("testing response to get for writableDataSource = {}", writableDataSourceElementsProperties.get());
            try {
                DataSourceElementsTenant writableDataSourceElementsTenant = mapper.readValue(mapper.writeValueAsString(writableDataSourceElementsProperties.get()), DataSourceElementsTenant.class);
                return Optional.of(writableDataSourceElementsTenant);
            } catch (Exception e) {
                logger.error("Error parsing writableDataSource from json: {}", writableDataSourceElementsProperties.get());
            }
        }
        return Optional.empty();
    }
    @Override
    public Map<String, DataSourceElementsTenant> getTenantsWritableDataSourceElements() {
        if(writableDataSourceElementsProperties.isPresent()) {
            return writableDataSourceElementsProperties.get().getTenants();
        }
        return ImmutableMap.of();
    }
    /**
     * @param responseEntities list of responses from each rdw service
     * @return Optional DataSourceElementsProperties first found writable DataSource settings
     */
    private Optional<DataSourceElementsProperties> getWritableDataSourceElementsProperties(List<ResponseEntity<String>> responseEntities) {
        List<DataSourceElementsProperties> settings = responseEntities.stream()
                .map(this::parseWritableDataSourceElementsProperties)
                .flatMap(o -> o.map(Stream::of).orElseGet(Stream::empty)) // Java 8 stinks https://stackoverflow.com/questions/22725537/using-java-8s-optional-with-streamflatmap
                .collect(Collectors.toList());
        logger.debug("WritableDataSourceElementsProperties {}", settings);
        return settings.stream().findFirst();
    }
    /**
     * @param entity specific rdw service's response to search for writable dataSources
     * @return Writable DataSourceElementsProperties if found
     */
    private Optional<DataSourceElementsProperties> parseWritableDataSourceElementsProperties(ResponseEntity<String> entity) {
        try {
            JsonNode rootNode = mapper.readTree(entity.getBody());
            JsonNode dataSourceWritablePropertiesNode = rootNode.path("scopedTarget.writableDataSourceElementsProperties").path("properties");
            return Optional.of(mapper.treeToValue(dataSourceWritablePropertiesNode, DataSourceElementsProperties.class));
        } catch (Exception e) {
            logger.warn("Writable DataSourceElementsProperties not found parsing json: {}", entity);
            return Optional.empty();
        }
    }

    // WAREHOUSE DATASOURCES
    @Override
    public Optional<DataSourceElementsTenant> getDefaultWarehouseDataSourceElements() {
        if(warehouseDataSourceElementsProperties.isPresent()) {
            logger.debug("Response to get for WarehouseDataSource = {}", warehouseDataSourceElementsProperties.get());
            try {
                DataSourceElementsTenant dataSourceElementsTenant = mapper.readValue(mapper.writeValueAsString(warehouseDataSourceElementsProperties.get()), DataSourceElementsTenant.class);
                return Optional.of(dataSourceElementsTenant);
            } catch (Exception e) {
                logger.error("Error parsing warehouseDataSource from json: {}", warehouseDataSourceElementsProperties.get());
            }
        }
        return Optional.empty();
    }
    @Override
    public Map<String, DataSourceElementsTenant> getTenantsWarehouseDataSourceElements() {
        if(warehouseDataSourceElementsProperties.isPresent()) {
            return warehouseDataSourceElementsProperties.get().getTenants();
        }
        return ImmutableMap.of();
    }
    /**
     * @param responseEntities list of responses from each rdw service to look through
     * @return Optional DataSourceElementsProperties the first found warehouse DataSource settings
     */
    private Optional<DataSourceElementsProperties> getWarehouseDataSourceElementsProperties(List<ResponseEntity<String>> responseEntities) {
        List<DataSourceElementsProperties> settings = responseEntities.stream()
                .map(this::parseWarehouseDataSourceElementsProperties)
                .flatMap(o -> o.map(Stream::of).orElseGet(Stream::empty)) // Java 8 stinks https://stackoverflow.com/questions/22725537/using-java-8s-optional-with-streamflatmap
                .collect(Collectors.toList());
        logger.debug("WarehouseDataSourceElementsProperties {}", settings);
        return settings.stream().findFirst();
    }
    /**
     * @param entity specific rdw service's response to search for warehouse dataSources
     * @return warehouse DataSourceElementsProperties if found
     */
    private Optional<DataSourceElementsProperties> parseWarehouseDataSourceElementsProperties(ResponseEntity<String> entity) {
        try {
            JsonNode rootNode = mapper.readTree(entity.getBody());
            JsonNode dataSourceWarehousePropertiesNode = rootNode.path("scopedTarget.warehouseDataSourceElementsProperties").path("properties");
            return Optional.of(mapper.treeToValue(dataSourceWarehousePropertiesNode, DataSourceElementsProperties.class));
        } catch (Exception e) {
            logger.warn("Warehouse DataSourceElementsProperties not found parsing json: {}", entity);
            return Optional.empty();
        }
    }

    // OLAP DATASOURCES
    @Override
    public Optional<DataSourceElementsTenant> getDefaultOlapDataSourceElements() {
        if(olapDataSourceElementsProperties.isPresent()) {
            logger.debug("Response to get for Olap DataSource = {}", olapDataSourceElementsProperties.get());
            try {
                DataSourceElementsTenant dataSourceElementsTenant = mapper.readValue(mapper.writeValueAsString(olapDataSourceElementsProperties.get()), DataSourceElementsTenant.class);
                return Optional.of(dataSourceElementsTenant);
            } catch (Exception e) {
                logger.error("Error parsing olapDataSource from json: {}", olapDataSourceElementsProperties.get());
            }
        }
        return Optional.empty();
    }
    @Override
    public Map<String, DataSourceElementsTenant> getTenantsOlapDataSourceElements() {
        if(olapDataSourceElementsProperties.isPresent()) {
            return olapDataSourceElementsProperties.get().getTenants();
        }
        return ImmutableMap.of();
    }
    /**
     * @param responseEntities list of responses from each rdw service to look through
     * @return Optional DataSourceElementsProperties the first found Olap DataSource settings
     */
    private Optional<DataSourceElementsProperties> getOlapDataSourceElementsProperties(List<ResponseEntity<String>> responseEntities) {
        List<DataSourceElementsProperties> settings = responseEntities.stream()
                .map(this::parseOlapDataSourceElementsProperties)
                .flatMap(o -> o.map(Stream::of).orElseGet(Stream::empty)) // Java 8 stinks https://stackoverflow.com/questions/22725537/using-java-8s-optional-with-streamflatmap
                .collect(Collectors.toList());
        logger.debug("Olap DataSourceElementsProperties {}", settings);
        return settings.stream().findFirst();
    }
    /**
     * @param entity specific rdw service's response to search for olap datasource
     * @return olap DataSourceElementsProperties if found
     */
    private Optional<DataSourceElementsProperties> parseOlapDataSourceElementsProperties(ResponseEntity<String> entity) {
        try {
            JsonNode rootNode = mapper.readTree(entity.getBody());
            JsonNode dataSourceWarehousePropertiesNode = rootNode.path("scopedTarget.olapDataSourceElementsProperties").path("properties");
            logger.warn("Olap DataSourceElementsProperties found parsing json: {}", entity);

            return Optional.of(mapper.treeToValue(dataSourceWarehousePropertiesNode, DataSourceElementsProperties.class));
        } catch (Exception e) {
            logger.warn("Olap DataSourceElementsProperties not found parsing json: {}", entity);
            return Optional.empty();
        }
    }

    // ARCHIVE PROPERTIES
    @Override
    public Optional<ArchivePropertiesTenant> getDefaultArchivePropertiesTenant() {
        if(archivePropertiesRoot.isPresent()) {
            logger.debug("Response to get for archivePropertiesRoot = {}", archivePropertiesRoot.get());
            try {
                ArchivePropertiesTenant archivePropertiesTenant = mapper.readValue(mapper.writeValueAsString(archivePropertiesRoot.get()), ArchivePropertiesTenant.class);
                return Optional.of(archivePropertiesTenant);
            } catch (Exception e) {
                logger.error("Error parsing archivePropertiesRoot from json: {}", archivePropertiesRoot.get());
            }
        }
        return Optional.empty();
    }
    @Override
    public Map<String, ArchivePropertiesTenant> getTenantsArchiveProperties() {
        if(archivePropertiesRoot.isPresent()) {
            return archivePropertiesRoot.get().getTenants();
        }
        return ImmutableMap.of();
    }
    /**
     * @param responseEntities list of responses from each rdw service to look through
     * @return Optional ArchivePropertiesTenant the first found ArchiveProperties
     */
    private Optional<ArchivePropertiesRoot> getArchivePropertiesRoot(List<ResponseEntity<String>> responseEntities) {
        List<ArchivePropertiesRoot> settings = responseEntities.stream()
                .map(this::parseArchiveProperties)
                .flatMap(o -> o.map(Stream::of).orElseGet(Stream::empty)) // Java 8 stinks https://stackoverflow.com/questions/22725537/using-java-8s-optional-with-streamflatmap
                .collect(Collectors.toList());
        logger.debug("Archive Properties {}", settings);
        return settings.stream().findFirst();
    }
    /**
     * @param entity specific rdw service's response to search for archive properties
     * @return ArchivePropertiesRoot if found
     */
    private Optional<ArchivePropertiesRoot> parseArchiveProperties(ResponseEntity<String> entity) {
        try {
            JsonNode rootNode = mapper.readTree(entity.getBody());
            JsonNode archivePropertiesNode = rootNode.path("archivePropertiesRoot").path("properties");
            return Optional.of(mapper.treeToValue(archivePropertiesNode, ArchivePropertiesRoot.class));
        } catch (Exception e) {
            logger.warn("ArchivePropertiesTenant not found parsing json: {}", entity);
            return Optional.empty();
        }
    }

    // AGGREGATE REPORTING PROPERTIES
    @Override
    public Optional<AggregateReportingPropertiesTenant> getDefaultAggregateReportingProperties(){
        if(aggregateReportingPropertiesRoot.isPresent()) {
            logger.debug("Response to get for AggregateReportingPropertiesTenant = {}", aggregateReportingPropertiesRoot.get());
            try {
                AggregateReportingPropertiesTenant aggregateReporting = mapper.readValue(mapper.writeValueAsString(aggregateReportingPropertiesRoot.get()), AggregateReportingPropertiesTenant.class);
                return Optional.of(aggregateReporting);
            } catch (Exception e) {
                logger.error("Error parsing AggregateReportingPropertiesTenant from json: {}", aggregateReportingPropertiesRoot.get());
            }
        }
        return Optional.empty();
    }
    @Override
    public Map<String, AggregateReportingPropertiesTenant> getTenantsAggregateReportingProperties() {
        if(aggregateReportingPropertiesRoot.isPresent()) {
            return aggregateReportingPropertiesRoot.get().getTenants();
        }
        return ImmutableMap.of();
    }
    /**
     * @param responseEntities list of responses from each rdw service to look through
     * @return Optional AggregateReportingPropertiesRoot the first found Aggregate properties
     */
    private Optional<AggregateReportingPropertiesRoot> getAggregateReportingPropertiesRoot(List<ResponseEntity<String>> responseEntities) {
        List<AggregateReportingPropertiesRoot> settings = responseEntities.stream()
                .map(this::parseAggregatorProperties)
                .flatMap(o -> o.map(Stream::of).orElseGet(Stream::empty)) // Java 8 stinks https://stackoverflow.com/questions/22725537/using-java-8s-optional-with-streamflatmap
                .collect(Collectors.toList());
        logger.debug("AggregateReportingPropertiesRoot {}", settings);
        return settings.stream().findFirst();
    }
    /**
     * @param entity specific rdw service's response to search for archive properties
     * @return ArchivePropertiesRoot if found
     */
    private Optional<AggregateReportingPropertiesRoot> parseAggregatorProperties(ResponseEntity<String> entity) {
        try {
            JsonNode rootNode = mapper.readTree(entity.getBody());
            JsonNode aggregatorPropertiesNode = rootNode.path("scopedTarget.aggregateReportingPropertiesRoot").path("properties");
            return Optional.of(mapper.treeToValue(aggregatorPropertiesNode, AggregateReportingPropertiesRoot.class));
        } catch (Exception e) {
            logger.warn("AggregateReportingPropertiesRoot not found parsing json: {}", entity);
            return Optional.empty();
        }
    }


}
