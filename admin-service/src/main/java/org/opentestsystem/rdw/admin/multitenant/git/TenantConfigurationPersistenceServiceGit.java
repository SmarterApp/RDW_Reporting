package org.opentestsystem.rdw.admin.multitenant.git;

import com.google.common.annotations.VisibleForTesting;
import org.apache.commons.io.FileUtils;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;
import org.opentestsystem.rdw.admin.model.ApplicationTenantConfiguration;
import org.opentestsystem.rdw.admin.model.ApplicationTenantConfigurationPersistence;
import org.opentestsystem.rdw.admin.model.TenantConfiguration;
import org.opentestsystem.rdw.archive.ArchivePropertiesTenant;
import org.opentestsystem.rdw.multitenant.TenantProperties;
import org.opentestsystem.rdw.multitenant.TenantProperties.Tenant;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsTenant;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceUrlParts;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemPropertiesImpl;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.yaml.snakeyaml.DumperOptions;
import org.yaml.snakeyaml.TypeDescription;
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.constructor.Constructor;
import org.yaml.snakeyaml.introspector.Property;
import org.yaml.snakeyaml.nodes.CollectionNode;
import org.yaml.snakeyaml.nodes.MappingNode;
import org.yaml.snakeyaml.nodes.Node;
import org.yaml.snakeyaml.nodes.NodeTuple;
import org.yaml.snakeyaml.nodes.SequenceNode;
import org.yaml.snakeyaml.nodes.Tag;
import org.yaml.snakeyaml.representer.Representer;

import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

public class TenantConfigurationPersistenceServiceGit implements TenantConfigurationPersistenceService {

    private static final Logger logger = LoggerFactory.getLogger(TenantConfigurationPersistenceServiceGit.class);
    private static final String configFileName = "application.yml";
    private static final String tenantsFileName = "application.yml";

    private final TenantConfigurationPersistenceProperties tenantConfigurationPersistenceProperties;
    //private final UsernamePasswordCredentialsProvider usernamePasswordCredentialsProvider;

    public TenantConfigurationPersistenceServiceGit(TenantConfigurationPersistenceProperties tenantConfigurationPersistenceProperties) {
        this.tenantConfigurationPersistenceProperties = tenantConfigurationPersistenceProperties;
    }

    @VisibleForTesting
    void forceLocalRepositoryToCleanState() {
        //TODO: right now, just wiping and cloning each time this is called, there may be a better approach: https://stackoverflow.com/questions/13586502/how-to-check-if-a-git-clone-has-been-done-already-with-jgit
        final UsernamePasswordCredentialsProvider usernamePasswordCredentialsProvider =
                new UsernamePasswordCredentialsProvider(tenantConfigurationPersistenceProperties.getGitUsername(),
                        tenantConfigurationPersistenceProperties.getGitPassword());
        try {
            FileUtils.deleteDirectory(new File(tenantConfigurationPersistenceProperties.getLocalRepositoryPath()));
        } catch (IOException e) {
            throw new TenantConfigurationPersistenceException("Unable to delete directory", e);
        }
        //do clone
        try {
            Git.cloneRepository()
                    .setURI(tenantConfigurationPersistenceProperties.getRemoteRepositoryUri())
                    .setBare(false)
                    .setBranch("master")
                    .setDirectory(getWorkingDirectory())
                    .setCredentialsProvider(usernamePasswordCredentialsProvider)
                    .call();
        } catch (GitAPIException e) {
            throw new TenantConfigurationPersistenceException("Unable to clone repository", e);
        }
    }

    @VisibleForTesting
    File getWorkingDirectory() {
        File directory = new File(tenantConfigurationPersistenceProperties.getLocalRepositoryPath());
        try {
            FileUtils.forceMkdir(directory);
        } catch (IOException e) {
            throw new TenantConfigurationPersistenceException("Unable to create working directory.", e);
        }
        return directory;
    }

    @Override
    public void saveTenantConfiguration(TenantConfiguration tenantConfiguration) {
        forceLocalRepositoryToCleanState();

        final ApplicationTenantConfiguration applicationTenantConfiguration =
                tenantConfiguration.getApplicationTenantConfiguration();
        final Tenant tenant = tenantConfiguration.getTenant();
        final String tenantKey = tenantConfiguration.getTenant().getKey();

        final UsernamePasswordCredentialsProvider usernamePasswordCredentialsProvider =
                new UsernamePasswordCredentialsProvider(tenantConfigurationPersistenceProperties.getGitUsername(),
                        tenantConfigurationPersistenceProperties.getGitPassword());

        writeApplicationTenantConfiguration(applicationTenantConfiguration, tenantKey);
        writeTenants(tenant);

        try {
            Git git = Git.open(new File(tenantConfigurationPersistenceProperties.getLocalRepositoryPath()));
            String tenantApplicationFilepattern = "tenant-" + tenantKey + File.separator + configFileName;
            logger.debug("git add {}", tenantApplicationFilepattern);
            git.add()
                    .addFilepattern(tenantApplicationFilepattern)
                    .call();

            String tenantFilepattern = "tenant" + File.separator + tenantsFileName;
            logger.debug("git add {}", tenantFilepattern);
            git.add()
                    .addFilepattern(tenantFilepattern)
                    .call();

            git.commit()
                    .setAuthor(tenantConfigurationPersistenceProperties.getAuthor(),
                            tenantConfigurationPersistenceProperties.getAuthorEmail())
                    .setMessage("saving " + tenantKey + " configuration.")
                    .call();

            git.push()
                    .setCredentialsProvider(usernamePasswordCredentialsProvider)
                    .call();
        } catch (IOException | GitAPIException e) {
            throw new TenantConfigurationPersistenceException("Unable to save changes to the remote git repository", e);
        }
    }

    @VisibleForTesting
    void writeApplicationTenantConfiguration(ApplicationTenantConfiguration applicationTenantConfiguration, String tenantKey) {

        ApplicationTenantConfigurationPersistence applicationTenantConfigurationPersistence =
                new ApplicationTenantConfigurationPersistence(tenantKey, applicationTenantConfiguration);

        final Yaml yaml = getYaml();

        final String output = yaml.dump(applicationTenantConfigurationPersistence);
        logger.debug("output yml \n{}", output);

        final File tenantDirectory =
                new File(tenantConfigurationPersistenceProperties.getLocalRepositoryPath() + File.separator + "tenant-" + tenantKey);
        logger.debug("tenantDirectory {}", tenantDirectory.getPath());
        try {
            FileUtils.forceMkdir(tenantDirectory);
        } catch (IOException e) {
            throw new TenantConfigurationPersistenceException("Unable to create tenant directory", e);
        }

        final File tenantFile = new File(tenantDirectory.getPath() + File.separator + configFileName);
        logger.debug("tenantFile {}", tenantFile.getPath());
        try {
            FileUtils.write(tenantFile, output, "UTF-8");
        } catch (IOException e) {
            throw new TenantConfigurationPersistenceException("Unable write application tenant configuration file", e);
        }
    }

    void writeTenants(Tenant tenant) {
        Constructor constructor = new Constructor(TenantPropertiesWrapper.class);
        TypeDescription tenantPropertiesWrapperDescription = new TypeDescription(TenantPropertiesWrapper.class);
        constructor.addTypeDescription(tenantPropertiesWrapperDescription);

        TypeDescription tenantPropertiesDescriptor = new TypeDescription(TenantProperties.class);
        tenantPropertiesDescriptor.putListPropertyType("tenants",Tenant.class);
        constructor.addTypeDescription(tenantPropertiesDescriptor);


        final Yaml yaml = new Yaml(constructor);

//        final Yaml yaml = new Yaml(new Constructor(TenantPropertiesWrapper.class));

        final String filePath = tenantConfigurationPersistenceProperties.getLocalRepositoryPath()
                + File.separator
                + "tenant"
                + File.separator
                + tenantsFileName;
        final File file = new File(filePath);

        //load existing or create new if missing
        TenantPropertiesWrapper currentTenantProperties;
        if (file.exists()) {
            String fileContents;
            try {
                fileContents = FileUtils.readFileToString(file, "UTF-8");
                logger.debug("tenants file contents /n {}", fileContents);
            } catch (IOException e) {
                throw new TenantConfigurationPersistenceException("Unable read tenant configuration file", e);
            }
            currentTenantProperties = yaml.loadAs(fileContents, TenantPropertiesWrapper.class);
        } else {
            currentTenantProperties = new TenantPropertiesWrapper();
            currentTenantProperties.setTenantProperties(new TenantProperties());
        }

        //remove the tenant if it already exists
        final List<Tenant> currentTenants = currentTenantProperties.getTenantProperties().getTenants();
        final List<Tenant> cleanedTenants = currentTenants.stream()
                .filter(t -> !t.getId().equals(tenant.getId()))
                .collect(Collectors.toList());

        //add the new or updated tenant
        cleanedTenants.add(tenant);
        currentTenantProperties.getTenantProperties().setTenants(cleanedTenants);

        //write back to disk
        final String output = yaml.dump(currentTenantProperties);
        logger.debug("output yml \n{}", output);
        try {
            FileUtils.write(file, output, "UTF-8");
        } catch (IOException e) {
            throw new TenantConfigurationPersistenceException("Unable write tenant configuration file", e);
        }
    }

    private Yaml getYaml() {
        DumperOptions options = new DumperOptions();
        options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
        options.setIndent(2);
        options.setCanonical(false);

        SkipEmptyRepresenter representer = new SkipEmptyRepresenter();
        representer.addClassTag(ApplicationTenantConfigurationPersistence.class, Tag.MAP);
        representer.addClassTag(ReportingSystemPropertiesImpl.class, Tag.MAP);
        representer.addClassTag(DataSourceElementsTenant.class, Tag.MAP);
        representer.addClassTag(DataSourceUrlParts.class, Tag.MAP);
        representer.addClassTag(ArchivePropertiesTenant.class, Tag.MAP);
        representer.addClassTag(TenantProperties.class, Tag.MAP);
        representer.addClassTag(TenantPropertiesWrapper.class, Tag.MAP);

        return new Yaml(representer, options);
    }

    /**
     * Remove all the nodes that are null or objects / collections that are empty to match the spring configuration style.
     */
    private class SkipEmptyRepresenter extends Representer {
        //from https://bitbucket.org/asomov/snakeyaml/src/tip/src/test/java/org/yaml/snakeyaml/issues/issue60/SkipBeanTest.java

        @Override
        protected NodeTuple representJavaBeanProperty(Object javaBean, Property property,
                                                      Object propertyValue, Tag customTag) {
            NodeTuple tuple = super.representJavaBeanProperty(javaBean, property, propertyValue,
                    customTag);
            Node valueNode = tuple.getValueNode();
            if (Tag.NULL.equals(valueNode.getTag())) {
                return null;// skip 'null' values
            }
            if (valueNode instanceof CollectionNode) {
                if (Tag.SEQ.equals(valueNode.getTag())) {
                    SequenceNode seq = (SequenceNode) valueNode;
                    if (seq.getValue().isEmpty()) {
                        return null;// skip empty lists
                    }
                }
                if (Tag.MAP.equals(valueNode.getTag())) {
                    MappingNode seq = (MappingNode) valueNode;
                    if (seq.getValue().isEmpty()) {
                        return null;// skip empty maps
                    }
                }
            }
            return tuple;
        }
    }
}
