package org.opentestsystem.rdw.admin.client;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.opentestsystem.rdw.archive.ArchivePropertiesTenant;
import org.opentestsystem.rdw.multitenant.TenantProperties;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsProperties;
import org.opentestsystem.rdw.olap.configuration.AggregateReportingProperties;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemSettings;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.RestTemplate;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

//TODO: this is not a good name - but can't think of a better one
public class TenantConfigurationLookupClient {
    private static final Logger logger = LoggerFactory.getLogger(TenantConfigurationLookupClient.class);

    private static ObjectMapper mapper = new ObjectMapper();
    private final TenantConfigurationLookupProperties tenantConfigurationLookupProperties;

    public TenantConfigurationLookupClient(TenantConfigurationLookupProperties tenantConfigurationLookupProperties) {
        this.tenantConfigurationLookupProperties = tenantConfigurationLookupProperties;
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
    }

    /**
     * Retrieve a list of Responses for each tenant aware service
     * @return List of Response Entities
     */
    public List<ResponseEntity<String>> getRawConfigurations() {
        RestTemplate restTemplate = new RestTemplate();

        List<String> serviceUrls = tenantConfigurationLookupProperties
                .getServices()
                .values()
                .stream()
                .map(RdwService::getUrl)
                .collect(Collectors.toList());
        List<ResponseEntity<String>> responses = serviceUrls.stream()
                .map(url -> restTemplate.getForEntity(url + "/configprops", String.class))
                .collect(Collectors.toList());

        return responses;
    }

    /**
     * Call and retrieve the configprops for each tenant Aware service
     * @return Map of services, and their ResponseEntities
     */
    public Map<String, ResponseEntity<String>> getRawConfigurationsByService() {
        RestTemplate restTemplate = new RestTemplate();

        Map<String, ResponseEntity<String>> responseEntityMap = new HashMap<>();
        tenantConfigurationLookupProperties.getServices()
                .forEach( (k,v) -> {
                    ResponseEntity<String> responseEntity = restTemplate.getForEntity(v.getUrl() + "/configprops", String.class);
                    responseEntityMap.put(k, responseEntity);
                });

        return responseEntityMap;
    }

    /**
     * Return the ReportingSystemSettings for the admin-service
     * @param responseEntityMap Map of services and their Responses
     * @return Optional ReportingSystemSettings
     */
    public Optional<ReportingSystemSettings> getAdminReportingSystemSetting(Map<String, ResponseEntity<String>> responseEntityMap) {
        Optional<ReportingSystemSettings> adminSettings = parseReportingSystemSettings(responseEntityMap.get("admin-service"));
        return adminSettings;
    }
    /**
     * Return the ReportingSystemSettings for the reporting-service
     * @param responseEntityMap Map of services and their Responses
     * @return Optional ReportingSystemSettings
     */
    public Optional<ReportingSystemSettings> getReportingProcessorReportingSystemSetting(Map<String, ResponseEntity<String>> responseEntityMap) {
        Optional<ReportingSystemSettings> reportingSettings = parseReportingSystemSettings(responseEntityMap.get("reporting-service"));
        return reportingSettings;
    }


    /**
     * Return the A for the report-processor
     * @param responseEntityMap Map of services and their Responses
     * @return Optional ReportingSystemSettings
     */
    public Optional<ReportingSystemSettings> getReportProcessorReportingSystemSetting(Map<String, ResponseEntity<String>> responseEntityMap) {
        Optional<ReportingSystemSettings> processorSettings = parseReportingSystemSettings(responseEntityMap.get("report-processor"));
        return processorSettings;
    }
    /**
     * Return the ReportingSystemSettings for the aggregate-service
     * @param responseEntityMap Map of services and their Responses
     * @return Optional ReportingSystemSettings
     */
    public Optional<ReportingSystemSettings> getAggregrateReportingSystemSetting(Map<String, ResponseEntity<String>> responseEntityMap) {
        Optional<ReportingSystemSettings> aggregateSettings = parseReportingSystemSettings(responseEntityMap.get("aggregate-service"));
        return aggregateSettings;
    }


    /**
     * Return the first found ReportingSystemSettings
     * @param responseEntities
     * @return Optional ReportingSystemSettings
     */
    public Optional<ReportingSystemSettings> getReportingSystemSetting(List<ResponseEntity<String>> responseEntities) {
        List<ReportingSystemSettings> settings = responseEntities.stream()
                .map(this::parseReportingSystemSettings)
                .flatMap(o -> o.map(Stream::of).orElseGet(Stream::empty)) // Java 8 stinks https://stackoverflow.com/questions/22725537/using-java-8s-optional-with-streamflatmap
                .collect(Collectors.toList());
        logger.debug("ReportingSystemSettings {}", settings);
        return settings.stream().findFirst();
    }

    /**
     * Return the first found readOnly DataSource settings
     * @param responseEntities
     * @return Optional DataSourceElementsProperties
     */
    public Optional<DataSourceElementsProperties> getDataSources(List<ResponseEntity<String>> responseEntities) {
        List<DataSourceElementsProperties> settings = responseEntities.stream()
                .map(this::parseDataSourceElementsProperties)
                .flatMap(o -> o.map(Stream::of).orElseGet(Stream::empty)) // Java 8 stinks https://stackoverflow.com/questions/22725537/using-java-8s-optional-with-streamflatmap
                .collect(Collectors.toList());
        logger.debug("DataSourceElementsProperties {}", settings);
        return settings.stream().findFirst();
    }

    /**
     * Return the first found writable DataSource settings
     * @param responseEntities
     * @return Optional DataSourceElementsProperties
     */
    public Optional<DataSourceElementsProperties> getWritableDataSources(List<ResponseEntity<String>> responseEntities) {
        List<DataSourceElementsProperties> settings = responseEntities.stream()
                .map(this::parseWritableDataSourceElementsProperties)
                .flatMap(o -> o.map(Stream::of).orElseGet(Stream::empty)) // Java 8 stinks https://stackoverflow.com/questions/22725537/using-java-8s-optional-with-streamflatmap
                .collect(Collectors.toList());
        logger.debug("WritableDataSourceElementsProperties {}", settings);
        return settings.stream().findFirst();
    }

    /**
     * Return the first found warehouse DataSource settings
     * @param responseEntities
     * @return Optional DataSourceElementsProperties
     */
    public Optional<DataSourceElementsProperties> getWarehouseDataSources(List<ResponseEntity<String>> responseEntities) {
        List<DataSourceElementsProperties> settings = responseEntities.stream()
                .map(this::parseWarehouseDataSourceElementsProperties)
                .flatMap(o -> o.map(Stream::of).orElseGet(Stream::empty)) // Java 8 stinks https://stackoverflow.com/questions/22725537/using-java-8s-optional-with-streamflatmap
                .collect(Collectors.toList());
        logger.debug("WarehouseDataSourceElementsProperties {}", settings);
        return settings.stream().findFirst();
    }

    /**
     * Return the first found Olap DataSource settings
     * @param responseEntities
     * @return Optional DataSourceElementsProperties
     */
    public Optional<DataSourceElementsProperties> getOlapDataSources(List<ResponseEntity<String>> responseEntities) {
        List<DataSourceElementsProperties> settings = responseEntities.stream()
                .map(this::parseOlapDataSourceElementsProperties)
                .flatMap(o -> o.map(Stream::of).orElseGet(Stream::empty)) // Java 8 stinks https://stackoverflow.com/questions/22725537/using-java-8s-optional-with-streamflatmap
                .collect(Collectors.toList());
        logger.debug("Olap DataSourceElementsProperties {}", settings);
        return settings.stream().findFirst();
    }

    /**
     * Return the first found Olap DataSource settings
     * @param responseEntities
     * @return Optional DataSourceElementsProperties
     */
    public Optional<ArchivePropertiesTenant> getArchiveProperties(List<ResponseEntity<String>> responseEntities) {
        List<ArchivePropertiesTenant> settings = responseEntities.stream()
                .map(this::parseArchiveProperties)
                .flatMap(o -> o.map(Stream::of).orElseGet(Stream::empty)) // Java 8 stinks https://stackoverflow.com/questions/22725537/using-java-8s-optional-with-streamflatmap
                .collect(Collectors.toList());
        logger.debug("Archive Properties {}", settings);
        return settings.stream().findFirst();
    }

    /**
     * Return the first found Olap DataSource settings
     * @param responseEntities
     * @return Optional DataSourceElementsProperties
     */
    public Optional<AggregateReportingProperties> getAggregatorProperties(List<ResponseEntity<String>> responseEntities) {
        List<AggregateReportingProperties> settings = responseEntities.stream()
                .map(this::parseAggregatorProperties)
                .flatMap(o -> o.map(Stream::of).orElseGet(Stream::empty)) // Java 8 stinks https://stackoverflow.com/questions/22725537/using-java-8s-optional-with-streamflatmap
                .collect(Collectors.toList());
        logger.debug("AggregateReportingProperties {}", settings);
        return settings.stream().findFirst();
    }

    /**
     * Return the first found Tenant settings -
     * @param responseEntities
     * @return Optional DataSourceElementsProperties
     */
    public Optional<List<TenantProperties.Tenant>> getTenantSetProperties(List<ResponseEntity<String>> responseEntities) {
        // just need one set of tenants
        for (ResponseEntity<String> response : responseEntities) {
            Optional<List<TenantProperties.Tenant>> settings = parseTenantSetProperties(response);
            if(settings.isPresent()) {
                return settings;
            }
        }
        return Optional.empty();
    }


    private Optional<ReportingSystemSettings> parseReportingSystemSettings(ResponseEntity<String> entity) {
        try {
            JsonNode rootNode = mapper.readTree(entity.getBody());
            JsonNode reportingSystemSettingsNode = rootNode.path("scopedTarget.reportingSystemSettings").path("properties");
            return Optional.of(mapper.treeToValue(reportingSystemSettingsNode, ReportingSystemSettings.class));
        } catch (Exception e) {
            logger.error("Error parsing ReportingSystemSettings from json: {}", entity);
            return Optional.empty();
        }
    }

    private Optional<DataSourceElementsProperties> parseDataSourceElementsProperties(ResponseEntity<String> entity) {
        try {
            JsonNode rootNode = mapper.readTree(entity.getBody());
            JsonNode dataSourceElementsPropertiesNode = rootNode.path("scopedTarget.dataSourceElementsProperties").path("properties");
            return Optional.of(mapper.treeToValue(dataSourceElementsPropertiesNode, DataSourceElementsProperties.class));
        } catch (Exception e) {
            logger.error("Error parsing DataSourceElementsProperties from json: {}", entity);
            return Optional.empty();
        }
    }

    private Optional<DataSourceElementsProperties> parseWritableDataSourceElementsProperties(ResponseEntity<String> entity) {
        try {
            JsonNode rootNode = mapper.readTree(entity.getBody());
            JsonNode dataSourceWritablePropertiesNode = rootNode.path("scopedTarget.writableDataSourceElementsProperties").path("properties");
            return Optional.of(mapper.treeToValue(dataSourceWritablePropertiesNode, DataSourceElementsProperties.class));
        } catch (Exception e) {
            logger.error("Error parsing WritableDataSourceElementsProperties from json: {}", entity);
            return Optional.empty();
        }
    }

    private Optional<DataSourceElementsProperties> parseWarehouseDataSourceElementsProperties(ResponseEntity<String> entity) {
        try {
            JsonNode rootNode = mapper.readTree(entity.getBody());
            JsonNode dataSourceWarehousePropertiesNode = rootNode.path("scopedTarget.warehouseDataSourceElementsProperties").path("properties");
            return Optional.of(mapper.treeToValue(dataSourceWarehousePropertiesNode, DataSourceElementsProperties.class));
        } catch (Exception e) {
            logger.error("Error parsing WarehouseDataSourceElementsProperties from json: {}", entity);
            return Optional.empty();
        }
    }


    private Optional<DataSourceElementsProperties> parseOlapDataSourceElementsProperties(ResponseEntity<String> entity) {
        try {
            JsonNode rootNode = mapper.readTree(entity.getBody());
            JsonNode dataSourceWarehousePropertiesNode = rootNode.path("scopedTarget.olapDataSourceElementsProperties").path("properties");
            return Optional.of(mapper.treeToValue(dataSourceWarehousePropertiesNode, DataSourceElementsProperties.class));
        } catch (Exception e) {
            logger.error("Error parsing OlapDataSourceElementsProperties from json: {}", entity);
            return Optional.empty();
        }
    }

    // TODO Fix to call real thing in the returned Json
    private Optional<ArchivePropertiesTenant> parseArchiveProperties(ResponseEntity<String> entity) {
        try {
            JsonNode rootNode = mapper.readTree(entity.getBody());
            JsonNode archivePropertiesNode = rootNode.path("scopedTarget.archiveProperties").path("properties");
            return Optional.of(mapper.treeToValue(archivePropertiesNode, ArchivePropertiesTenant.class));
        } catch (Exception e) {
            logger.error("Error parsing ArchivePropertiesTenant from json: {}", entity);
            return Optional.empty();
        }
    }

    // TODO Fix to call real thing in returned Json
    private Optional<AggregateReportingProperties> parseAggregatorProperties(ResponseEntity<String> entity) {
        try {
            JsonNode rootNode = mapper.readTree(entity.getBody());
            JsonNode aggregatorPropertiesNode = rootNode.path("scopedTarget.aggregatorProperties").path("properties");
            return Optional.of(mapper.treeToValue(aggregatorPropertiesNode, AggregateReportingProperties.class));
        } catch (Exception e) {
            logger.error("Error parsing AggregateReportingProperties from json: {}", entity);
            return Optional.empty();
        }
    }

    private Optional<List<TenantProperties.Tenant>> parseTenantSetProperties(ResponseEntity<String> entity) {
        try {
            JsonNode rootNode = mapper.readTree(entity.getBody());
            JsonNode tenantPropertiesNode = rootNode.path("scopedTarget.tenantProperties").path("properties");
            Tenants tenants = mapper.treeToValue(tenantPropertiesNode, Tenants.class);
            List<TenantProperties.Tenant> tenantSet = tenants.getTenants();
            return Optional.of(tenantSet);
        } catch (Exception e) {
            logger.error("Error parsing TenantProperties from json: {}", entity);
            return Optional.empty();
        }
    }


}
