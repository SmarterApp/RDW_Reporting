package org.opentestsystem.rdw.admin.client;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.opentestsystem.rdw.archive.ArchivePropertiesRoot;
import org.opentestsystem.rdw.archive.ArchivePropertiesTenant;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsProperties;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingProperties;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingPropertiesRoot;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingPropertiesTenant;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemSettings;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.RestTemplate;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Lookup client for the tenant configuration to call rdw services' actuator endpoints
 * for Default properties
 */
public class TenantConfigurationLookupClient {
    private static final Logger logger = LoggerFactory.getLogger(TenantConfigurationLookupClient.class);

    private static ObjectMapper mapper = new ObjectMapper();
    private final TenantConfigurationLookupProperties tenantConfigurationLookupProperties;

    public TenantConfigurationLookupClient(TenantConfigurationLookupProperties tenantConfigurationLookupProperties) {
        this.tenantConfigurationLookupProperties = tenantConfigurationLookupProperties;
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
    }

    /**
     * @return a List of Response Entities for each tenant aware service
     */
    public List<ResponseEntity<String>> getRawConfigurations() {
        RestTemplate restTemplate = new RestTemplate();

        List<String> serviceUrls = tenantConfigurationLookupProperties
                .getServices()
                .values()
                .stream()
                .map(RdwService::getUrl)
                .collect(Collectors.toList());
        List<ResponseEntity<String>> responses = serviceUrls.stream()
                .map(url -> restTemplate.getForEntity(url + "/configprops", String.class))
                .collect(Collectors.toList());

        return responses;
    }

    /**
     * @return a Map of services, and their ResponseEntities for each tenant Aware service
     */
    public Map<String, ResponseEntity<String>> getRawConfigurationsByService() {
        RestTemplate restTemplate = new RestTemplate();

        Map<String, ResponseEntity<String>> responseEntityMap = new HashMap<>();
        tenantConfigurationLookupProperties.getServices()
                .forEach( (k,v) -> {
                    ResponseEntity<String> responseEntity = restTemplate.getForEntity(v.getUrl() + "/configprops", String.class);
                    responseEntityMap.put(k, responseEntity);
                });

        return responseEntityMap;
    }

    /**
     * @param responseEntityMap Map of services and their Responses
     * @return Optional ReportingSystemSettings for the admin-service
     */
    public Optional<ReportingSystemSettings> getAdminReportingSystemSetting(Map<String, ResponseEntity<String>> responseEntityMap) {
        Optional<ReportingSystemSettings> adminSettings = parseReportingSystemSettings(responseEntityMap.get("admin-service"));
        return adminSettings;
    }
    /**
     * @param responseEntityMap Map of services and their Responses
     * @return Optional ReportingSystemSettings for the reporting-service
     */
    public Optional<ReportingSystemSettings> getReportingProcessorReportingSystemSetting(Map<String, ResponseEntity<String>> responseEntityMap) {
        Optional<ReportingSystemSettings> reportingSettings = parseReportingSystemSettings(responseEntityMap.get("reporting-service"));
        return reportingSettings;
    }
    /**
     * @param responseEntityMap Map of services and their Responses
     * @return Optional ReportingSystemSettings for the report-processor
     */
    public Optional<ReportingSystemSettings> getReportProcessorReportingSystemSetting(Map<String, ResponseEntity<String>> responseEntityMap) {
        Optional<ReportingSystemSettings> processorSettings = parseReportingSystemSettings(responseEntityMap.get("report-processor"));
        return processorSettings;
    }
    /**
     * @param responseEntityMap Map of services and their Responses
     * @return Optional ReportingSystemSettings or the aggregate-service
     */
    public Optional<AggregateReportingPropertiesTenant> getAggregrateReportingSystemSetting(Map<String, ResponseEntity<String>> responseEntityMap) {
        Optional<AggregateReportingPropertiesTenant> aggregateSettings = parseAggregatorProperties(responseEntityMap.get("aggregate-service"));
        return aggregateSettings;
    }


    /**
     * @param responseEntities list of responses from each rdw service
     * @return Optional ReportingSystemSettings that is found first in the responseEntities
     */
    public Optional<ReportingSystemSettings> getReportingSystemSetting(List<ResponseEntity<String>> responseEntities) {
        List<ReportingSystemSettings> settings = responseEntities.stream()
                .map(this::parseReportingSystemSettings)
                .flatMap(o -> o.map(Stream::of).orElseGet(Stream::empty)) // Java 8 stinks https://stackoverflow.com/questions/22725537/using-java-8s-optional-with-streamflatmap
                .collect(Collectors.toList());
        logger.debug("ReportingSystemSettings {}", settings);
        return settings.stream().findFirst();
    }

    /**
     * @param responseEntities list of responses from each rdw service
     * @return Optional DataSourceElementsProperties the first found readOnly DataSource settings
     */
    public Optional<DataSourceElementsProperties> getDataSources(List<ResponseEntity<String>> responseEntities) {
        List<DataSourceElementsProperties> settings = responseEntities.stream()
                .map(this::parseDataSourceElementsProperties)
                .flatMap(o -> o.map(Stream::of).orElseGet(Stream::empty)) // Java 8 stinks https://stackoverflow.com/questions/22725537/using-java-8s-optional-with-streamflatmap
                .collect(Collectors.toList());
        logger.debug("DataSourceElementsProperties {}", settings);
        return settings.stream().findFirst();
    }

    /**
     * @param responseEntities list of responses from each rdw service
     * @return Optional DataSourceElementsProperties first found writable DataSource settings
     */
    public Optional<DataSourceElementsProperties> getWritableDataSources(List<ResponseEntity<String>> responseEntities) {
        List<DataSourceElementsProperties> settings = responseEntities.stream()
                .map(this::parseWritableDataSourceElementsProperties)
                .flatMap(o -> o.map(Stream::of).orElseGet(Stream::empty)) // Java 8 stinks https://stackoverflow.com/questions/22725537/using-java-8s-optional-with-streamflatmap
                .collect(Collectors.toList());
        logger.debug("WritableDataSourceElementsProperties {}", settings);
        return settings.stream().findFirst();
    }

    /**
     * @param responseEntities list of responses from each rdw service
     * @return Optional DataSourceElementsProperties the first found warehouse DataSource settings
     */
    public Optional<DataSourceElementsProperties> getWarehouseDataSources(List<ResponseEntity<String>> responseEntities) {
        List<DataSourceElementsProperties> settings = responseEntities.stream()
                .map(this::parseWarehouseDataSourceElementsProperties)
                .flatMap(o -> o.map(Stream::of).orElseGet(Stream::empty)) // Java 8 stinks https://stackoverflow.com/questions/22725537/using-java-8s-optional-with-streamflatmap
                .collect(Collectors.toList());
        logger.debug("WarehouseDataSourceElementsProperties {}", settings);
        return settings.stream().findFirst();
    }

    /**
     * @param responseEntities list of responses from each rdw service
     * @return Optional DataSourceElementsProperties the first found Olap DataSource settings
     */
    public Optional<DataSourceElementsProperties> getOlapDataSources(List<ResponseEntity<String>> responseEntities) {
        List<DataSourceElementsProperties> settings = responseEntities.stream()
                .map(this::parseOlapDataSourceElementsProperties)
                .flatMap(o -> o.map(Stream::of).orElseGet(Stream::empty)) // Java 8 stinks https://stackoverflow.com/questions/22725537/using-java-8s-optional-with-streamflatmap
                .collect(Collectors.toList());
        logger.debug("Olap DataSourceElementsProperties {}", settings);
        return settings.stream().findFirst();
    }

    /**
     * @param responseEntities list of responses from each rdw service
     * @return Optional ArchivePropertiesTenant the first found ArchiveProperties
     */
    public Optional<ArchivePropertiesRoot> getArchiveProperties(List<ResponseEntity<String>> responseEntities) {
        List<ArchivePropertiesRoot> settings = responseEntities.stream()
                .map(this::parseArchiveProperties)
                .flatMap(o -> o.map(Stream::of).orElseGet(Stream::empty)) // Java 8 stinks https://stackoverflow.com/questions/22725537/using-java-8s-optional-with-streamflatmap
                .collect(Collectors.toList());
        logger.debug("Archive Properties {}", settings);
        return settings.stream().findFirst();
    }

    /**
     * @param responseEntities list of responses from each rdw service
     * @return Optional AggregateReportingProperties the first found Aggregate properties
     */
    public Optional<AggregateReportingPropertiesTenant> getAggregatorProperties(List<ResponseEntity<String>> responseEntities) {
        List<AggregateReportingPropertiesTenant> settings = responseEntities.stream()
                .map(this::parseAggregatorProperties)
                .flatMap(o -> o.map(Stream::of).orElseGet(Stream::empty)) // Java 8 stinks https://stackoverflow.com/questions/22725537/using-java-8s-optional-with-streamflatmap
                .collect(Collectors.toList());
        logger.debug("AggregateReportingPropertiesTenant {}", settings);
        return settings.stream().findFirst();
    }

    /**
     * @param responseEntities list of responses from each rdw service
     * @return Optional DataSourceElementsProperties the first found Tenant settings
     */
    public Optional<Tenants> getTenantSetProperties(List<ResponseEntity<String>> responseEntities) {
        for (ResponseEntity<String> response : responseEntities) {
            Optional<Tenants> settings = parseTenantSetProperties(response);
            return settings;
        }
        return Optional.empty();
    }


    private Optional<ReportingSystemSettings> parseReportingSystemSettings(ResponseEntity<String> entity) {
        try {
            JsonNode rootNode = mapper.readTree(entity.getBody());
            JsonNode reportingSystemSettingsNode = rootNode.path("scopedTarget.reportingSystemSettings").path("properties");
            return Optional.of(mapper.treeToValue(reportingSystemSettingsNode, ReportingSystemSettings.class));
        } catch (Exception e) {
            logger.error("Error parsing ReportingSystemSettings from json: {}", entity);
            return Optional.empty();
        }
    }

    private Optional<DataSourceElementsProperties> parseDataSourceElementsProperties(ResponseEntity<String> entity) {
        try {
            JsonNode rootNode = mapper.readTree(entity.getBody());
            JsonNode dataSourceElementsPropertiesNode = rootNode.path("scopedTarget.dataSourceElementsProperties").path("properties");
            return Optional.of(mapper.treeToValue(dataSourceElementsPropertiesNode, DataSourceElementsProperties.class));
        } catch (Exception e) {
            logger.error("Error parsing DataSourceElementsProperties from json: {}", entity);
            return Optional.empty();
        }
    }

    private Optional<DataSourceElementsProperties> parseWritableDataSourceElementsProperties(ResponseEntity<String> entity) {
        try {
            JsonNode rootNode = mapper.readTree(entity.getBody());
            JsonNode dataSourceWritablePropertiesNode = rootNode.path("scopedTarget.writableDataSourceElementsProperties").path("properties");
            return Optional.of(mapper.treeToValue(dataSourceWritablePropertiesNode, DataSourceElementsProperties.class));
        } catch (Exception e) {
            logger.error("Error parsing WritableDataSourceElementsProperties from json: {}", entity);
            return Optional.empty();
        }
    }

    private Optional<DataSourceElementsProperties> parseWarehouseDataSourceElementsProperties(ResponseEntity<String> entity) {
        try {
            JsonNode rootNode = mapper.readTree(entity.getBody());
            JsonNode dataSourceWarehousePropertiesNode = rootNode.path("scopedTarget.warehouseDataSourceElementsProperties").path("properties");
            return Optional.of(mapper.treeToValue(dataSourceWarehousePropertiesNode, DataSourceElementsProperties.class));
        } catch (Exception e) {
            logger.error("Error parsing WarehouseDataSourceElementsProperties from json: {}", entity);
            return Optional.empty();
        }
    }


    private Optional<DataSourceElementsProperties> parseOlapDataSourceElementsProperties(ResponseEntity<String> entity) {
        try {
            JsonNode rootNode = mapper.readTree(entity.getBody());
            JsonNode dataSourceWarehousePropertiesNode = rootNode.path("scopedTarget.olapDataSourceElementsProperties").path("properties");
            return Optional.of(mapper.treeToValue(dataSourceWarehousePropertiesNode, DataSourceElementsProperties.class));
        } catch (Exception e) {
            logger.error("Error parsing OlapDataSourceElementsProperties from json: {}", entity);
            return Optional.empty();
        }
    }

    private Optional<ArchivePropertiesRoot> parseArchiveProperties(ResponseEntity<String> entity) {
        try {
            JsonNode rootNode = mapper.readTree(entity.getBody());
            JsonNode archivePropertiesNode = rootNode.path("archivePropertiesRoot").path("properties");
            return Optional.of(mapper.treeToValue(archivePropertiesNode, ArchivePropertiesRoot.class));
        } catch (Exception e) {
            logger.error("Error parsing ArchivePropertiesTenant from json: {}", entity);
            return Optional.empty();
        }
    }

    private Optional<AggregateReportingPropertiesTenant> parseAggregatorProperties(ResponseEntity<String> entity) {
        try {
            JsonNode rootNode = mapper.readTree(entity.getBody());
            JsonNode aggregatorPropertiesNode = rootNode.path("scopedTarget.aggregateReportingPropertiesRoot").path("properties");
            return Optional.of(mapper.treeToValue(aggregatorPropertiesNode, AggregateReportingPropertiesTenant.class));
        } catch (Exception e) {
            logger.error("Error parsing AggregateReportingProperties from json: {}", entity);
            return Optional.empty();
        }
    }

    private Optional<Tenants> parseTenantSetProperties(ResponseEntity<String> entity) {
        try {
            JsonNode rootNode = mapper.readTree(entity.getBody());
            JsonNode tenantPropertiesNode = rootNode.path("scopedTarget.tenantProperties").path("properties");
            Tenants tenants = mapper.treeToValue(tenantPropertiesNode, Tenants.class);
            return Optional.of(tenants);
        } catch (Exception e) {
            logger.error("Error parsing TenantProperties from json: {}", entity);
            return Optional.empty();
        }
    }


}
