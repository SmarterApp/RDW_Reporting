package org.opentestsystem.rdw.admin.multitenant.database.impl;

import com.amazonaws.auth.AWSStaticCredentialsProvider;
import com.amazonaws.auth.BasicAWSCredentials;
import com.amazonaws.services.s3.AmazonS3;
import com.amazonaws.services.s3.AmazonS3ClientBuilder;
import com.amazonaws.services.s3.model.S3Object;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Supplier;
import com.google.common.base.Suppliers;
import com.google.common.collect.ImmutableMap;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;
import org.opentestsystem.rdw.admin.multitenant.database.MultitenantDatabaseAdmin;
import org.opentestsystem.rdw.archive.ArchivePropertiesRoot;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.JdbcOperations;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;
import org.springframework.util.PropertyPlaceholderHelper;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Properties;

/**
 * Repository for loading datasets for new Tenants.  This particular implementation
 * will only work with AWS Aurora and AWS S3.
 */
@Repository
public class JdbcMultitenantDatabaseAdmin implements MultitenantDatabaseAdmin {

    private static final Logger logger = LoggerFactory.getLogger(JdbcMultitenantDatabaseAdmin.class);

    private final String delimiter = "/";
    private final NamedParameterJdbcTemplate adminReportingJdbcTemplate;
    private final NamedParameterJdbcTemplate adminWarehouseJdbcTemplate;
    private final NamedParameterJdbcTemplate adminOlapJdbcTemplate;
    private final ArchivePropertiesRoot archivePropertiesRoot;
    private final Supplier<AmazonS3> amazonS3Supplier; //lazy
    private final PropertyPlaceholderHelper placeholderHelper;

    @Value("${sql.multitenantDatabaseAdmin.truncateAuroraTable}")
    private String truncateAuroraTable;

    @Value("${sql.multitenantDatabaseAdmin.auroraS3LoadData}")
    private String auroraS3LoadData;

    @Value("${sql.multitenantDatabaseAdmin.useDatabase}")
    private String useDatabase;

    @Value("${sql.multitenantDatabaseAdmin.disableForeignKeyChecks}")
    private String disableForeignKeyChecks;

    @Value("${sql.multitenantDatabaseAdmin.enableForeignKeyChecks}")
    private String enableForeignKeyChecks;

    @Value("${sql.multitenantDatabaseAdmin.tableEmptyProbe}")
    private String tableEmptyProbe;

    @Value("${sql.multitenantDatabaseAdmin.databaseExists}")
    private String databaseExists;

    @Value("${sql.multitenantDatabaseAdmin.createDatabase}")
    private String createDatabase;

    @Value("${sql.multitenantDatabaseAdmin.userExists}")
    private String userExists;

    @Value("${sql.multitenantDatabaseAdmin.createDatabaseUser}")
    private String createDatabaseUser;

    @Value("${sql.multitenantDatabaseAdmin.grantUserToDatabase}")
    private String grantUserToDatabase;

    @Value("${sql.multitenantDatabaseAdmin.grantUserOnSelectProc}")
    private String grantUserOnSelectProc;

    @Value("${sql.multitenantDatabaseAdmin.grantUserLoadFromS3}")
    private String grantUserLoadFromS3;

    @Value("${sql.multitenantDatabaseAdmin.grantUserSelectIntoS3}")
    private String grantUserSelectIntoS3;

    @Value("${sql.multitenantDatabaseAdmin.olapDatabaseUserExists}")
    private String olapDatabaseUserExists;

    @Value("${sql.multitenantDatabaseAdmin.createOlapDatabaseUser}")
    private String createOlapDatabaseUser;

    @Value("${sql.multitenantDatabaseAdmin.olapSchemaExists}")
    private String olapSchemaExists;

    @Value("${sql.multitenantDatabaseAdmin.createOlapSchema}")
    private String createOlapSchema;

    @Value("${sql.multitenantDatabaseAdmin.grantAllOlapUserToSchema}")
    private String grantAllOlapUserToSchema;

    @Value("${sql.multitenantDatabaseAdmin.grantAllOlapUserToSchemaTables}")
    private String grantAllOlapUserToSchemaTables;

    @Value("${sql.multitenantDatabaseAdmin.searchPathOlapUserToSchema}")
    private String searchPathOlapUserToSchema;

    @Autowired
    public JdbcMultitenantDatabaseAdmin(@Qualifier("adminReportingJdbcTemplate") final NamedParameterJdbcTemplate adminReportingJdbcTemplate,
                                        @Qualifier("adminWarehouseJdbcTemplate") final NamedParameterJdbcTemplate adminWarehouseJdbcTemplate,
                                        @Qualifier("adminOlapJdbcTemplate") final NamedParameterJdbcTemplate adminOlapJdbcTemplate,
                                        final ArchivePropertiesRoot archivePropertiesRoot) {
        this.adminReportingJdbcTemplate = adminReportingJdbcTemplate;
        this.adminWarehouseJdbcTemplate = adminWarehouseJdbcTemplate;
        this.adminOlapJdbcTemplate = adminOlapJdbcTemplate;
        this.archivePropertiesRoot = archivePropertiesRoot;
        this.placeholderHelper = new PropertyPlaceholderHelper("$[", "]");
        amazonS3Supplier = Suppliers.memoize(() -> AmazonS3ClientBuilder.standard()
                .withRegion(archivePropertiesRoot.getS3RegionStatic())
                .withCredentials(
                        new AWSStaticCredentialsProvider(
                                new BasicAWSCredentials(
                                        archivePropertiesRoot.getS3AccessKey(),
                                        archivePropertiesRoot.getS3SecretKey()
                                )
                        )
                )
                .build());
    }

    @Override
    public void createDatabase(String targetDatabase, RdwDatabaseType databaseType) {
        Map<String, String> replacements = ImmutableMap.<String, String>builder()
                .put("databaseName", targetDatabase)
                .build();
        resolveTemplate(databaseType).getJdbcOperations()
                .update(amendSqlWithPlaceholder(replacements, createDatabase));

    }

    @Override
    public void createDatabaseUser(String username, String password, RdwDatabaseType databaseType) {
        resolveTemplate(databaseType).update(createDatabaseUser, new MapSqlParameterSource()
                .addValue("username", username)
                .addValue("password", password));
    }

    @Override
    public boolean isDatabaseExists(String targetDatabase, RdwDatabaseType databaseType) {
        return resolveTemplate(databaseType).queryForObject(databaseExists,
                new MapSqlParameterSource()
                        .addValue("targetDatabase", targetDatabase),
                Boolean.class);
    }

    @Override
    public boolean isDatabaseUserExists(String username, RdwDatabaseType databaseType) {
        return resolveTemplate(databaseType).queryForObject(userExists,
                new MapSqlParameterSource()
                        .addValue("username", username),
                Boolean.class);
    }

    @Override
    public void grantUserToDatabase(String username, String targetDatabase, RdwDatabaseType databaseType) {
        Map<String, String> replacements = ImmutableMap.<String, String>builder()
                .put("databaseName", targetDatabase)
                .build();
        resolveTemplate(databaseType).update(amendSqlWithPlaceholder(replacements, grantUserToDatabase),
                new MapSqlParameterSource()
                        .addValue("username", username));
    }

    @Override
    public void grantUserOnSelectProc(String username, RdwDatabaseType databaseType) {
        resolveTemplate(databaseType).update(grantUserOnSelectProc,
                new MapSqlParameterSource()
                        .addValue("username", username));
    }

    @Override
    public void grantUserLoadFromS3(String username, RdwDatabaseType databaseType) {
        resolveTemplate(databaseType).update(grantUserLoadFromS3,
                new MapSqlParameterSource()
                        .addValue("username", username));
    }

    @Override
    public void grantUserSelectIntoS3(String username, RdwDatabaseType databaseType) {
        resolveTemplate(databaseType).update(grantUserSelectIntoS3,
                new MapSqlParameterSource()
                        .addValue("username", username));
    }

    @Override
    public void createOlapSchema(String schema) {
        final Properties properties = new Properties();
        properties.put("schema", schema);
        final String sql = placeholderHelper.replacePlaceholders(createOlapSchema, properties);
        adminOlapJdbcTemplate.getJdbcOperations().execute(sql);
    }

    @Override
    public void createOlapDatabaseUser(String username, String password) {
        final Properties properties = new Properties();
        properties.put("username", username);
        properties.put("password", password);
        final String sql = placeholderHelper
                .replacePlaceholders(createOlapDatabaseUser, properties);
        adminOlapJdbcTemplate.getJdbcOperations().execute(sql);
    }

    @Override
    public boolean isOlapSchemaExists(String schema) {
        return adminOlapJdbcTemplate.queryForObject(olapSchemaExists,
                new MapSqlParameterSource()
                        .addValue("schema", schema),
                Boolean.class);
    }

    @Override
    public boolean isOlapDatabaseUserExists(String username) {
        return adminOlapJdbcTemplate.queryForObject(olapDatabaseUserExists,
                new MapSqlParameterSource()
                        .addValue("username", username),
                Boolean.class);
    }

    @Override
    public void grantAllOlapUserToSchema(String schema, String username) {
        final Properties properties = new Properties();
        properties.put("schema", schema);
        properties.put("username", username);
        final String sql = placeholderHelper
                .replacePlaceholders(grantAllOlapUserToSchema, properties);
        adminOlapJdbcTemplate.getJdbcOperations().execute(sql);
    }

    @Override
    public void grantAllOlapUserToSchemaTables(String schema, String username) {
        final Properties properties = new Properties();
        properties.put("schema", schema);
        properties.put("username", username);
        final String sql = placeholderHelper
                .replacePlaceholders(grantAllOlapUserToSchemaTables, properties);
        adminOlapJdbcTemplate.getJdbcOperations().execute(sql);
    }

    @Override
    public void searchPathOlapUserToSchema(String schema, String username) {
        final Properties properties = new Properties();
        properties.put("schema", schema);
        properties.put("username", username);
        final String sql = placeholderHelper
                .replacePlaceholders(searchPathOlapUserToSchema, properties);
        adminOlapJdbcTemplate.getJdbcOperations().execute(sql);
    }

    @Override
    public void loadDataset(String targetDatabase, String datasetName, String importDatabase, RdwDatabaseType databaseType) {
        if (!isDatabaseEmpty(targetDatabase, importDatabase, databaseType)) {
            throw new RuntimeException("Unable to load dataset, target database " + targetDatabase + " not empty.");
        }
        final JdbcOperations operations = resolveTemplate(databaseType).getJdbcOperations();

        Map<String, String> useDatabaseReplacements = ImmutableMap.<String, String>builder()
                .put("databaseName", targetDatabase)
                .build();

        final String useDatabaseSql = amendSqlWithPlaceholder(useDatabaseReplacements, useDatabase);
        logger.debug(useDatabaseSql);
        operations.execute(useDatabaseSql);

        logger.debug(disableForeignKeyChecks);
        operations.execute(disableForeignKeyChecks);

        manifest(datasetName, importDatabase).forEach(tableFileName -> {
            logger.debug("tableFileName: {}", tableFileName);
            final String s3Uri = archivePropertiesRoot.getUriRoot() +
                    delimiter + datasetPath(datasetName, importDatabase) + delimiter + tableFileName;
            final String tableName = FilenameUtils.removeExtension(tableFileName);

            Map<String, String> replacements = ImmutableMap.<String, String>builder()
                    .put("databaseName", targetDatabase)
                    .put("tableName", tableName)
                    .put("s3Uri", s3Uri)
                    .build();

            final String truncateTableSql = amendSqlWithPlaceholder(replacements, truncateAuroraTable);
            logger.debug(truncateTableSql);
            operations.update(truncateTableSql);

            final String s3LoadDataSql = amendSqlWithPlaceholder(replacements, auroraS3LoadData);
            logger.debug(s3LoadDataSql);
            operations.update(s3LoadDataSql);

        });
        operations.execute(enableForeignKeyChecks);
        logger.debug(enableForeignKeyChecks);
    }


    /**
     * Probe for target database, ensure that it is empty.
     *
     * @param targetDatabase database to be populated
     * @param importDatabase source database
     * @return true if empty
     */
    @VisibleForTesting
    boolean isDatabaseEmpty(String targetDatabase, String importDatabase, RdwDatabaseType databaseType) {
        if (importDatabase.contains("warehouse")) {
            Map<String, String> replacements = ImmutableMap.<String, String>builder()
                    .put("databaseName", targetDatabase)
                    .put("tableName", "exam")
                    .build();
            final String sql = amendSqlWithPlaceholder(replacements, tableEmptyProbe);
            int count = resolveTemplate(databaseType).getJdbcOperations()
                    .queryForObject(sql, Integer.class);
            return count == 0;
        }
        //currently only support warehouse
        throw new RuntimeException("Unsupported import database " + importDatabase);
    }

    /**
     * Fetch the manifest file from S3.
     *
     * @param datasetName    The name of the dataset
     * @param importDatabase The name of the database being imported from.
     * @return List of each item in the manifest (table_name.txt)
     */
    @VisibleForTesting
    List<String> manifest(String datasetName, String importDatabase) {
        try {
            final AmazonS3 amazonS3 = amazonS3Supplier.get();
            final String bucketName = archivePropertiesRoot.getUriRoot().substring("s3://".length());
            logger.debug("bucketName: {}", bucketName);
            final String key = datasetPath(datasetName, importDatabase) + delimiter + "manifest.txt";
            logger.debug("key: {}", key);
            final S3Object s3Object = amazonS3.getObject(bucketName, key);
            final String manifestFile = IOUtils.toString(s3Object.getObjectContent(), "UTF-8");
            logger.debug("manifestFile: {}", manifestFile);
            return Arrays.asList(manifestFile.split("\n"));
        } catch (Exception e) {
            throw new IllegalStateException(e);
        }
    }

    private String datasetPath(String datasetName, String importDatabase) {
        return "sandbox-datasets/" +
                datasetName + "/" +
                importDatabase;
    }

    private String amendSqlWithPlaceholder(Map<String, String> replacements, String sql) {
        final Properties properties = new Properties();
        properties.putAll(replacements);
        return placeholderHelper.replacePlaceholders(sql, properties);
    }

    private NamedParameterJdbcTemplate resolveTemplate(RdwDatabaseType rdwDatabaseType) {
        switch (rdwDatabaseType) {
            case REPORTING:
            case MIGRATE_OLAP:
                return adminReportingJdbcTemplate;
            case WAREHOUSE:
                return adminWarehouseJdbcTemplate;
            case REPORTING_OLAP:
                return adminOlapJdbcTemplate;
        }
        throw new RuntimeException("Unhandled RdwDatabaseType " + rdwDatabaseType);
    }

}
