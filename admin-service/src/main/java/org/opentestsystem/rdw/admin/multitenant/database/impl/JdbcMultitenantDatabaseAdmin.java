package org.opentestsystem.rdw.admin.multitenant.database.impl;

import com.amazonaws.auth.AWSStaticCredentialsProvider;
import com.amazonaws.auth.BasicAWSCredentials;
import com.amazonaws.services.s3.AmazonS3;
import com.amazonaws.services.s3.AmazonS3ClientBuilder;
import com.amazonaws.services.s3.model.S3Object;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Supplier;
import com.google.common.base.Suppliers;
import com.google.common.collect.ImmutableMap;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.core.JdbcOperations;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;
import org.springframework.util.PropertyPlaceholderHelper;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import org.opentestsystem.rdw.admin.multitenant.database.MultitenantAdminConfiguration;
import org.opentestsystem.rdw.admin.multitenant.database.MultitenantDatabaseAdmin;
import org.opentestsystem.rdw.archive.ArchivePropertiesRoot;

/**
 * Repository for loading datasets for new Tenants.  This particular implementation
 * will only work with AWS Aurora and AWS S3.
 */
@Repository
public class JdbcMultitenantDatabaseAdmin implements MultitenantDatabaseAdmin {

    private static final Logger logger = LoggerFactory.getLogger(JdbcMultitenantDatabaseAdmin.class);

    private final String filePrefix = "file://";
    private final String delimiter = "/";
    private final String datasetRoot = "sandbox-datasets/";
    private final NamedParameterJdbcTemplate adminReportingJdbcTemplate;
    private final NamedParameterJdbcTemplate adminWarehouseJdbcTemplate;
    private final NamedParameterJdbcTemplate adminOlapJdbcTemplate;
    private final ArchivePropertiesRoot archivePropertiesRoot;
    private final Supplier<AmazonS3> amazonS3Supplier; //lazy
    private final PropertyPlaceholderHelper placeholderHelper;
    private final MultitenantAdminConfiguration configuration;

    @Autowired
    public JdbcMultitenantDatabaseAdmin(@Qualifier("adminReportingJdbcTemplate") final NamedParameterJdbcTemplate adminReportingJdbcTemplate,
                                        @Qualifier("adminWarehouseJdbcTemplate") final NamedParameterJdbcTemplate adminWarehouseJdbcTemplate,
                                        @Qualifier("adminOlapJdbcTemplate") final NamedParameterJdbcTemplate adminOlapJdbcTemplate,
                                        final ArchivePropertiesRoot archivePropertiesRoot,
                                        final MultitenantAdminConfiguration configuration) {
        this.adminReportingJdbcTemplate = adminReportingJdbcTemplate;
        this.adminWarehouseJdbcTemplate = adminWarehouseJdbcTemplate;
        this.adminOlapJdbcTemplate = adminOlapJdbcTemplate;
        this.archivePropertiesRoot = archivePropertiesRoot;
        this.placeholderHelper = new PropertyPlaceholderHelper("$[", "]");
        this.configuration = configuration;

        amazonS3Supplier = Suppliers.memoize(() -> AmazonS3ClientBuilder.standard()
                .withRegion(archivePropertiesRoot.getS3RegionStatic())
                .withCredentials(
                        new AWSStaticCredentialsProvider(
                                new BasicAWSCredentials(
                                        archivePropertiesRoot.getS3AccessKey(),
                                        archivePropertiesRoot.getS3SecretKey()
                                )
                        )
                )
                .build());
    }

    @Override
    public void createDatabase(String targetDatabase, RdwDatabaseType databaseType) {
        Map<String, String> replacements = ImmutableMap.<String, String>builder()
                .put("databaseName", targetDatabase)
                .build();
        resolveTemplate(databaseType).getJdbcOperations()
                .update(amendSqlWithPlaceholder(replacements, configuration.getCreateDatabase()));

    }

    @Override
    public void createDatabaseUser(String username, String password, RdwDatabaseType databaseType) {
        resolveTemplate(databaseType).update(configuration.getCreateDatabaseUser(), new MapSqlParameterSource()
                .addValue("username", username)
                .addValue("password", password));
    }

    @Override
    public boolean isDatabaseExists(String targetDatabase, RdwDatabaseType databaseType) {
        return resolveTemplate(databaseType).queryForObject(configuration.getDatabaseExists(),
                new MapSqlParameterSource()
                        .addValue("targetDatabase", targetDatabase),
                Boolean.class);
    }

    @Override
    public boolean isDatabaseUserExists(String username, RdwDatabaseType databaseType) {
        return resolveTemplate(databaseType).queryForObject(configuration.getUserExists(),
                new MapSqlParameterSource()
                        .addValue("username", username),
                Boolean.class);
    }

    @Override
    public void grantAllBasicPermissions(String username, String targetDatabase, RdwDatabaseType databaseType) {
        Map<String, String> replacements =
                ImmutableMap.<String, String>builder().put("databaseName", targetDatabase).build();

        // Filter out blank strings. (May occur with trailing comma in SQL config file)
        configuration.getGrantAllBasicPermissions()
                .stream()
                .filter(StringUtils::isNotBlank)
                .forEach(grant ->
                    resolveTemplate(databaseType).update(amendSqlWithPlaceholder(replacements, grant),
                        new MapSqlParameterSource()
                            .addValue("username", username))
                );
    }

    @Override
    public void grantUserToDatabase(String username, String targetDatabase, RdwDatabaseType databaseType) {
        Map<String, String> replacements = ImmutableMap.<String, String>builder()
                .put("databaseName", targetDatabase)
                .build();
        resolveTemplate(databaseType).update(amendSqlWithPlaceholder(replacements, configuration.getGrantUserToDatabase()),
                new MapSqlParameterSource()
                        .addValue("username", username));
    }

    @Override
    public void grantUserOnSelectProc(String username, RdwDatabaseType databaseType) {
        resolveTemplate(databaseType).update(configuration.getGrantUserOnSelectProc(),
                new MapSqlParameterSource()
                        .addValue("username", username));
    }

    @Override
    public void grantUserLoadFromS3(String username, RdwDatabaseType databaseType) {
        resolveTemplate(databaseType).update(configuration.getGrantUserLoadFromS3(),
                new MapSqlParameterSource()
                        .addValue("username", username));
    }

    @Override
    public void grantUserSelectIntoS3(String username, RdwDatabaseType databaseType) {
        resolveTemplate(databaseType).update(configuration.getGrantUserSelectIntoS3(),
                new MapSqlParameterSource()
                        .addValue("username", username));
    }

    @Override
    public void grantUserFile(String username, RdwDatabaseType databaseType) {
        resolveTemplate(databaseType).update(configuration.getGrantUserFile(),
                new MapSqlParameterSource()
                        .addValue("username", username));
    }

    @Override
    public void createOlapSchema(String schema) {
        final Properties properties = new Properties();
        properties.put("schema", schema);
        final String sql = placeholderHelper.replacePlaceholders(configuration.getCreateOlapSchema(), properties);
        adminOlapJdbcTemplate.getJdbcOperations().execute(sql);
    }

    @Override
    public void createOlapDatabaseUser(String username, String password) {
        final Properties properties = new Properties();
        properties.put("username", username);
        properties.put("password", password);
        final String sql = placeholderHelper
                .replacePlaceholders(configuration.getCreateOlapDatabaseUser(), properties);
        adminOlapJdbcTemplate.getJdbcOperations().execute(sql);
    }

    @Override
    public boolean isOlapSchemaExists(String schema) {
        return adminOlapJdbcTemplate.queryForObject(configuration.getOlapSchemaExists(),
                new MapSqlParameterSource()
                        .addValue("schema", schema),
                Boolean.class);
    }

    @Override
    public boolean isOlapDatabaseUserExists(String username) {
        return adminOlapJdbcTemplate.queryForObject(configuration.getOlapDatabaseUserExists(),
                new MapSqlParameterSource()
                        .addValue("username", username),
                Boolean.class);
    }

    @Override
    public void grantAllOlapUserToSchema(String schema, String username) {
        final Properties properties = new Properties();
        properties.put("schema", schema);
        properties.put("username", username);
        final String sql = placeholderHelper
                .replacePlaceholders(configuration.getGrantAllOlapUserToSchema(), properties);
        adminOlapJdbcTemplate.getJdbcOperations().execute(sql);
    }

    @Override
    public void grantAllOlapUserToSchemaTables(String schema, String username) {
        final Properties properties = new Properties();
        properties.put("schema", schema);
        properties.put("username", username);
        final String sql = placeholderHelper
                .replacePlaceholders(configuration.getGrantAllOlapUserToSchemaTables(), properties);
        adminOlapJdbcTemplate.getJdbcOperations().execute(sql);
    }

    @Override
    public void searchPathOlapUserToSchema(String schema, String username) {
        final Properties properties = new Properties();
        properties.put("schema", schema);
        properties.put("username", username);
        final String sql = placeholderHelper
                .replacePlaceholders(configuration.getSearchPathOlapUserToSchema(), properties);
        adminOlapJdbcTemplate.getJdbcOperations().execute(sql);
    }

    @Override
    public void loadDataset(String targetDatabase, String datasetName, String importDatabase, RdwDatabaseType databaseType) {
        if (!isDatabaseEmpty(targetDatabase, importDatabase, databaseType)) {
            throw new RuntimeException("Unable to load dataset, target database " + targetDatabase + " not empty.");
        }
        final JdbcOperations operations = resolveTemplate(databaseType).getJdbcOperations();

        Map<String, String> useDatabaseReplacements = ImmutableMap.<String, String>builder()
                .put("databaseName", targetDatabase)
                .build();

        final String useDatabaseSql = amendSqlWithPlaceholder(useDatabaseReplacements, configuration.getUseDatabase());
        logger.debug(useDatabaseSql);
        operations.execute(useDatabaseSql);

        logger.debug(configuration.getDisableForeignKeyChecks());
        operations.execute(configuration.getDisableForeignKeyChecks());

        manifest(datasetName, importDatabase).forEach(tableFileName -> {
            logger.debug("tableFileName: {}", tableFileName);

            if (isLocalMode()) {
                loadTableFromLocalFile(targetDatabase, datasetName, importDatabase, operations, tableFileName);
            } else {
                loadTableFromS3(targetDatabase, datasetName, importDatabase, operations, tableFileName);
            }

        });
        operations.execute(configuration.getEnableForeignKeyChecks());
        logger.debug(configuration.getEnableForeignKeyChecks());
    }

    private void loadTableFromLocalFile(String targetDatabase, String datasetName, String importDatabase, JdbcOperations operations, String tableFileName) {
        final String filePath = localFilePath(datasetName, importDatabase, tableFileName);
        final String tableName = FilenameUtils.removeExtension(tableFileName);

        Map<String, String> replacements = ImmutableMap.<String, String>builder()
                .put("databaseName", targetDatabase)
                .put("tableName", tableName)
                .put("filePath", filePath)
                .build();

        final String truncateTableSql = amendSqlWithPlaceholder(replacements, configuration.getTruncateAuroraTable());
        logger.debug(truncateTableSql);
        operations.update(truncateTableSql);

        final String mySqlFileLoadDataSql = amendSqlWithPlaceholder(replacements, configuration.getMySqlFileLoadData());
        logger.debug(mySqlFileLoadDataSql);
        operations.update(mySqlFileLoadDataSql);
    }

    private void loadTableFromS3(String targetDatabase, String datasetName, String importDatabase, JdbcOperations operations, String tableFileName) {
        final String s3Uri = archivePropertiesRoot.getUriRoot() +
                delimiter + datasetPath(datasetName, importDatabase) + delimiter + tableFileName;
        final String tableName = FilenameUtils.removeExtension(tableFileName);

        Map<String, String> replacements = ImmutableMap.<String, String>builder()
                .put("databaseName", targetDatabase)
                .put("tableName", tableName)
                .put("s3Uri", s3Uri)
                .build();

        final String truncateTableSql = amendSqlWithPlaceholder(replacements, configuration.getTruncateAuroraTable());
        logger.debug(truncateTableSql);
        operations.update(truncateTableSql);

        final String s3LoadDataSql = amendSqlWithPlaceholder(replacements, configuration.getAuroraS3LoadData());
        logger.debug(s3LoadDataSql);
        operations.update(s3LoadDataSql);
    }


    /**
     * Probe for target database, ensure that it is empty.
     *
     * @param targetDatabase database to be populated
     * @param importDatabase source database
     * @return true if empty
     */
    @VisibleForTesting
    boolean isDatabaseEmpty(String targetDatabase, String importDatabase, RdwDatabaseType databaseType) {
        if (importDatabase.contains("warehouse")) {
            Map<String, String> replacements = ImmutableMap.<String, String>builder()
                    .put("databaseName", targetDatabase)
                    .put("tableName", "exam")
                    .build();
            final String sql = amendSqlWithPlaceholder(replacements, configuration.getTableEmptyProbe());
            int count = resolveTemplate(databaseType).getJdbcOperations()
                    .queryForObject(sql, Integer.class);
            return count == 0;
        }
        //currently only support warehouse
        throw new RuntimeException("Unsupported import database " + importDatabase);
    }

    /**
     * Fetch the manifest file from S3.
     *
     * @param datasetName    The name of the dataset
     * @param importDatabase The name of the database being imported from.
     * @return List of each item in the manifest (table_name.txt)
     */
    @VisibleForTesting
    List<String> manifest(String datasetName, String importDatabase) {
        try {
            String manifestFile;
            if (isLocalMode()) {
                manifestFile = readManifestLocal(datasetName, importDatabase);
            } else {
                manifestFile = readManifestS3(datasetName, importDatabase);
            }

            logger.debug("manifestFile: {}", manifestFile);
            return Arrays.asList(manifestFile.split("\n"));
        } catch (Exception e) {
            throw new IllegalStateException(e);
        }
    }

    @VisibleForTesting
    String readManifestLocal(String datasetName, String importDatabase) throws IOException {
        File manifestFile = new File(localFilePath(datasetName, importDatabase, "manifest.txt"));
        return FileUtils.readFileToString(manifestFile, "UTF-8");
    }

    private String localFilePath(String datasetName, String importDatabase, String fileName) {
        final String rootDirectoryName = FilenameUtils.normalize(
                archivePropertiesRoot.getUriRoot().substring(filePrefix.length() - 1));
        logger.debug("rootDirectoryName {}", rootDirectoryName);
        final String relativeFilePath = FilenameUtils.concat(datasetPath(datasetName, importDatabase), fileName);
        logger.debug("relativeFilePath {}", relativeFilePath);
        final String fullPath = FilenameUtils.concat(rootDirectoryName, relativeFilePath);
        logger.debug("fullPath {}", fullPath);
        return fullPath;
    }

    @VisibleForTesting
    String readManifestS3(String datasetName, String importDatabase) throws IOException {
        final AmazonS3 amazonS3 = amazonS3Supplier.get();
        final String bucketName = archivePropertiesRoot.getUriRoot().substring("s3://".length());
        logger.debug("bucketName: {}", bucketName);
        final String key = datasetPath(datasetName, importDatabase) + delimiter + "manifest.txt";
        logger.debug("key: {}", key);
        final S3Object s3Object = amazonS3.getObject(bucketName, key);
        return IOUtils.toString(s3Object.getObjectContent(), "UTF-8");
    }


    public boolean isLocalMode() {
        return archivePropertiesRoot.getUriRoot().startsWith(filePrefix);
    }

    private String datasetPath(String datasetName, String importDatabase) {
        return datasetRoot +
                datasetName + "/" +
                importDatabase;
    }

    private String amendSqlWithPlaceholder(Map<String, String> replacements, String sql) {
        final Properties properties = new Properties();
        properties.putAll(replacements);
        return placeholderHelper.replacePlaceholders(sql, properties);
    }

    private NamedParameterJdbcTemplate resolveTemplate(RdwDatabaseType rdwDatabaseType) {
        switch (rdwDatabaseType) {
            case REPORTING:
            case MIGRATE_OLAP:
                return adminReportingJdbcTemplate;
            case WAREHOUSE:
                return adminWarehouseJdbcTemplate;
            case REPORTING_OLAP:
                return adminOlapJdbcTemplate;
        }
        throw new RuntimeException("Unhandled RdwDatabaseType " + rdwDatabaseType);
    }
}

