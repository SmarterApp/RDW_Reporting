package org.opentestsystem.rdw.admin.multitenant.model;

import com.fasterxml.jackson.annotation.JsonAlias;
import com.google.common.collect.ImmutableMap;
import org.opentestsystem.rdw.archive.ArchivePropertiesTenant;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsTenant;
import org.opentestsystem.rdw.multitenant.task.ArtClientPropertiesTenant;
import org.opentestsystem.rdw.multitenant.task.ImportServiceClientPropertiesTenant;
import org.opentestsystem.rdw.multitenant.task.SendReconciliationReportPropertiesTenant;
import org.opentestsystem.rdw.multitenant.validation.ExamProcessorValidationPropertiesTenant;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingPropertiesTenant;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemPropertiesImpl;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

/**
 * Write specific model directly corresponds to config server tenant-*\/application.yml file.
 * Sample:
 *
 * <pre>
 * archive:
 *   tenants:
 *     CAX:
 *       pathPrefix: /CA
 *       uriRoot: s3://ca-archive
 * datasources:
 *   reporting_ro:
 *     tenants:
 *       CAX:
 *         urlParts:
 *           database: catestdb
 *           hosts: catesthost
 * reporting:
 *   tenants:
 *     CAX:
 *       reportLanguages:
 *       - en
 *       schoolYear: 2019
 * tenantProperties:
 *   tenants:
 *     CAX:
 *       id: CAX
 *       key: CAX
 *       name: California Test
 * validation:
 *   tenants:
 *     CAX:
 *       requiredDataElements:
 *         - FirstName
 *         - LastOrSurname
 *         - Birthdate
 * taskUpdateOrganizationsArtClient:
 *   tenants:
 *     CAX:
 *       oauth2:
 *         username: cax.user@example.com
 *         password: caxPwd!
 * taskUpdateOrganizationsImportServiceClient:
 *   tenants:
 *     CAX:
 *       oauth2:
 *         username: cax.user@example.com
 *         password: caxPwd!
 * taskSendReconciliationReport:
 *   tenants:
 *     CAX:
 *       log: false
 *       query: status=PROCESSED&after=-PT24H
 *       archives:
 *         - uri-root: file:///tmp/
 *         - uri-root: s3:///bucket
 *           s3-access-key: AccessKey
 *           s3-secret-key: SecretKey
 *           s3-region-static: us-west-2
 *           s3-sse: AES256
 * </pre>
 */
public class ApplicationTenantConfigurationPersistence {

    private Map<String, Map<String, Tenant>> tenantProperties;
    private Map<String, Map<String, ReportingSystemPropertiesImpl>> reporting;
    private Map<String, Map<String, AggregateReportingPropertiesTenant>> aggregateReporting;
    private Map<String, Map<String, Map<String, DataSourceElementsTenant>>> datasources;
    private Map<String, Map<String, ArchivePropertiesTenant>> archive;
    private Map<String, Map<String, ExamProcessorValidationPropertiesTenant>> validation = new HashMap<>();
    private Map<String, Map<String, ArtClientPropertiesTenant>> taskUpdateOrganizationsArtClient = new HashMap<>();
    private Map<String, Map<String, ImportServiceClientPropertiesTenant>> taskUpdateOrganizationsImportServiceClient = new HashMap<>();
    private Map<String, Map<String, SendReconciliationReportPropertiesTenant>> taskSendReconciliationReport = new HashMap<>();

    public ApplicationTenantConfigurationPersistence() {
    }

    public ApplicationTenantConfigurationPersistence(TenantConfiguration tenantConfiguration) {
        Tenant tenant = tenantConfiguration.getTenant();

        reporting = ImmutableMap.of("tenants",
                ImmutableMap.of(tenant.getKey(),
                        Optional.ofNullable(tenantConfiguration.getReporting())
                                .orElse(new ReportingSystemPropertiesImpl())));

        aggregateReporting = ImmutableMap.of("tenants",
                ImmutableMap.of(tenant.getKey(),
                        Optional.ofNullable(tenantConfiguration.getAggregateReportingProperties())
                                .orElse(new AggregateReportingPropertiesTenant())));

        final ImmutableMap.Builder<String, Map<String, Map<String, DataSourceElementsTenant>>> datasourcesBuilder =
                ImmutableMap.builder();
        tenantConfiguration.getDataSources().forEach((datasourceName, dataSourceElements) ->
                datasourcesBuilder.put(datasourceName,
                        ImmutableMap.of("tenants", ImmutableMap.of(tenant.getKey(), dataSourceElements))));
        datasources = datasourcesBuilder.build();

        archive = ImmutableMap.of("tenants",
                ImmutableMap.of(tenant.getKey(),
                        Optional.ofNullable(tenantConfiguration.getArchiveProperties())
                                .orElse(new ArchivePropertiesTenant())));

        tenantProperties = ImmutableMap.of("tenants",
                ImmutableMap.of(tenant.getKey(), tenant));

        Optional.ofNullable(tenantConfiguration.getValidation()).ifPresent(validationPropertiesTenant -> {
            validation = ImmutableMap.of("tenants",
                    ImmutableMap.of(tenant.getKey(), validationPropertiesTenant));
        });

        Optional.ofNullable(tenantConfiguration.getArtClient()).ifPresent(artClientPropertiesTenant -> {
            taskUpdateOrganizationsArtClient = ImmutableMap.of("tenants",
                    ImmutableMap.of(tenant.getKey(), artClientPropertiesTenant));
        });

        Optional.ofNullable(tenantConfiguration.getImportServiceClient()).ifPresent(importServiceClientPropertiesTenant -> {
            taskUpdateOrganizationsImportServiceClient = ImmutableMap.of("tenants",
                    ImmutableMap.of(tenant.getKey(), importServiceClientPropertiesTenant));
        });

        Optional.ofNullable(tenantConfiguration.getSendReconciliationReport()).ifPresent(sendReconciliationReport -> {
            taskSendReconciliationReport = ImmutableMap.of("tenants",
                    ImmutableMap.of(tenant.getKey(), sendReconciliationReport));
        });
    }

    /**
     * To match this .yml format
     * <pre>
     * aggregateReporting:
     *   tenants:
     *     CAX:
     *       assessmentTypes: ica,sum,iab
     *       statewideUserAssessmentTypes: sum
     *       stateAggregateAssessmentTypes: sum
     * </pre>
     *
     * @return reporting
     */
    public Map<String, Map<String, AggregateReportingPropertiesTenant>> getAggregateReporting() {
        return aggregateReporting;
    }

    public void setAggregateReporting(Map<String, Map<String, AggregateReportingPropertiesTenant>> aggregateReporting) {
        this.aggregateReporting = aggregateReporting;
    }

    /**
     * To match this .yml format
     * <pre>
     *  reporting:
     *   tenants:
     *     CAX:
     *       reportLanguages:
     *       - en
     *       schoolYear: 2019
     * </pre>
     *
     * @return reporting
     */
    public Map<String, Map<String, ReportingSystemPropertiesImpl>> getReporting() {
        return reporting;
    }

    public void setReporting(Map<String, Map<String, ReportingSystemPropertiesImpl>> reporting) {
        this.reporting = reporting;
    }

    /**
     * To match this .yml format
     * <pre>
     * datasources:
     *   reporting_ro:
     *     tenants:
     *       CAX:
     *         urlParts:
     *           database: catestdb
     *           hosts: catesthost
     * </pre>
     *
     * @return datasources
     */
    public Map<String, Map<String, Map<String, DataSourceElementsTenant>>> getDatasources() {
        return datasources;
    }

    public void setDatasources(Map<String, Map<String, Map<String, DataSourceElementsTenant>>> datasources) {
        this.datasources = datasources;
    }

    /**
     * To match this .yml format
     * <pre>
     * archive:
     *   tenants:
     *     CAX:
     *       pathPrefix: /CA
     *       uriRoot: s3://ca-archive
     * </pre>
     *
     * @return archive
     */
    public Map<String, Map<String, ArchivePropertiesTenant>> getArchive() {
        return archive;
    }

    public void setArchive(Map<String, Map<String, ArchivePropertiesTenant>> archive) {
        this.archive = archive;
    }

    /**
     * To match this .yml format
     * <pre>
     * tenantProperties:
     *   tenants:
     *     CAX:
     *       id: CAX
     *       key: CAX
     *       name: California Test
     * </pre>
     *
     * @return tenantProperties
     */
    public Map<String, Map<String, Tenant>> getTenantProperties() {
        return tenantProperties;
    }

    @JsonAlias({"tenant-properties", "tenant_properties"})
    public void setTenantProperties(Map<String, Map<String, Tenant>> tenantProperties) {
        this.tenantProperties = tenantProperties;
    }

    /**
     * To match this .yml format
     * <pre>
     * validation:
     *   tenants:
     *     CAX:
     *       requiredDataElements:
     *         - FirstName
     *         - LastOrSurname
     *         - Birthdate
     * </pre>
     *
     * @return validation
     */
    public Map<String, Map<String, ExamProcessorValidationPropertiesTenant>> getValidation() {
        return validation;
    }

    public void setValidation(Map<String, Map<String, ExamProcessorValidationPropertiesTenant>> validation) {
        this.validation = validation;
    }

    /**
     * To match this .yml format
     * <pre>
     * taskUpdateOrganizationsArtClient:
     *   tenants:
     *     CAX:
     *       oauth2:
     *         username: cax.user@example.com
     *         password: caxPwd!
     * </pre>
     */
    public Map<String, Map<String, ArtClientPropertiesTenant>> getTaskUpdateOrganizationsArtClient() {
        return taskUpdateOrganizationsArtClient;
    }

    public void setTaskUpdateOrganizationsArtClient(Map<String, Map<String, ArtClientPropertiesTenant>> taskUpdateOrganizationsArtClient) {
        this.taskUpdateOrganizationsArtClient = taskUpdateOrganizationsArtClient;
    }

    /**
     * To match this .yml format
     * <pre>
     * taskUpdateOrganizationsImportServiceClient:
     *   tenants:
     *     CAX:
     *       oauth2:
     *         username: cax.user@example.com
     *         password: caxPwd!
     * </pre>
     */
    public Map<String, Map<String, ImportServiceClientPropertiesTenant>> getTaskUpdateOrganizationsImportServiceClient() {
        return taskUpdateOrganizationsImportServiceClient;
    }

    public void setTaskUpdateOrganizationsImportServiceClient(Map<String, Map<String, ImportServiceClientPropertiesTenant>> taskUpdateOrganizationsImportServiceClient) {
        this.taskUpdateOrganizationsImportServiceClient = taskUpdateOrganizationsImportServiceClient;
    }

    /**
     * To match this .yml format
     * <pre>
     * taskSendReconciliationReport:
     *   tenants:
     *     CAX:
     *       log: false
     *       query: status=PROCESSED&after=-PT24H
     *       archives:
     *         - uri-root: file:///tmp/
     *         - uri-root: s3:///bucket
     *           s3-access-key: AccessKey
     *           s3-secret-key: SecretKey
     *           s3-region-static: us-west-2
     *           s3-sse: AES256
     * </pre>
     */
    public Map<String, Map<String, SendReconciliationReportPropertiesTenant>> getTaskSendReconciliationReport() {
        return taskSendReconciliationReport;
    }

    public void setTaskSendReconciliationReport(Map<String, Map<String, SendReconciliationReportPropertiesTenant>> taskSendReconciliationReport) {
        this.taskSendReconciliationReport = taskSendReconciliationReport;
    }

    /**
     * Reverse operation of constructor converts instance to a TenantConfiguration
     *
     * @return newly created and populated tenant configuration
     */
    public TenantConfiguration toTenantConfiguration() {
        TenantConfiguration.Builder builder = TenantConfiguration.builder();

        if (tenantProperties != null && tenantProperties.containsKey("tenants")) {
            tenantProperties.get("tenants").values()
                    .forEach(builder::tenant);
        }

        if (reporting != null && reporting.containsKey("tenants")) {
            reporting.get("tenants").values()
                    .forEach(builder::reporting);
        }

        if (aggregateReporting != null && aggregateReporting.containsKey("tenants")) {
            aggregateReporting.get("tenants").values()
                    .forEach(builder::aggregateReportingProperties);
        }

        if (archive != null && archive.containsKey("tenants")) {
            archive.get("tenants").values()
                    .forEach(builder::archiveProperties);
        }

        final ImmutableMap.Builder<String, DataSourceElementsTenant> datasourcesBuilder = ImmutableMap.builder();
        if (datasources != null && !datasources.isEmpty()) {
            datasources.keySet().forEach(dataSourceName -> datasources.get(dataSourceName)
                    .get("tenants")
                    .values()
                    .forEach(dataSourceElementsTenant -> datasourcesBuilder
                            .put(dataSourceName, dataSourceElementsTenant)));
        }
        builder.dataSources(datasourcesBuilder.build());

        if (validation != null && validation.containsKey("tenants")) {
            validation.get("tenants").values()
                    .forEach(builder::validation);
        }

        if (taskUpdateOrganizationsArtClient != null && taskUpdateOrganizationsArtClient.containsKey("tenants")) {
            taskUpdateOrganizationsArtClient.get("tenants").values()
                    .forEach(builder::artClient);
        }

        if (taskUpdateOrganizationsImportServiceClient != null && taskUpdateOrganizationsImportServiceClient.containsKey("tenants")) {
            taskUpdateOrganizationsImportServiceClient.get("tenants").values()
                    .forEach(builder::importServiceClient);
        }

        if (taskSendReconciliationReport != null && taskSendReconciliationReport.containsKey("tenants")) {
            taskSendReconciliationReport.get("tenants").values()
                    .forEach(builder::sendReconciliationReport);
        }

        return builder.build();
    }

}
