package org.opentestsystem.rdw.admin.multitenant.administration.impl;

import com.google.common.annotations.VisibleForTesting;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationMessage;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationProcessor;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationRequestHandler;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationRequestType;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatusService;
import org.opentestsystem.rdw.admin.multitenant.configserver.ConfigServerClient;
import org.opentestsystem.rdw.admin.multitenant.database.TenantDatabaseAdminOrchestrationService;
import org.opentestsystem.rdw.admin.multitenant.git.TenantConfigurationPersistenceService;
import org.opentestsystem.rdw.admin.multitenant.model.TenantConfiguration;
import org.opentestsystem.rdw.reporting.common.security.User;
import org.opentestsystem.rdw.reporting.common.security.Users;
import org.opentestsystem.rdw.reporting.common.stream.MessageSecurityService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.support.MessageBuilder;

import java.util.HashMap;

import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus.CREATE_FAILED;
import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus.CREATE_PERSISTING_CONFIGURATION;
import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus.CREATE_PUBLISHING_CONFIGURATION_CHANGES;
import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus.CREATE_SETTING_UP_DATABASES;
import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus.CREATE_STARTED;
import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus.DELETE_CLEARING_DATABASE_RESOURCES;
import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus.DELETE_FAILED;
import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus.DELETE_PERSISTING_CONFIGURATION;
import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus.DELETE_PUBLISHING_CONFIGURATION_CHANGES;
import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus.DELETE_STARTED;
import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus.UPDATE_FAILED;
import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus.UPDATE_PERSISTING_CONFIGURATION;
import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus.UPDATE_PUBLISHING_CONFIGURATION_CHANGES;
import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus.UPDATE_STARTED;

public class DefaultTenantAdministrationRequestHandler implements TenantAdministrationRequestHandler {

    private static final Logger logger = LoggerFactory.getLogger(DefaultTenantAdministrationRequestHandler.class);

    private final MessageSecurityService messageSecurityService;
    private final TenantAdministrationProcessor tenantAdministrationProcessor;
    private final TenantDatabaseAdminOrchestrationService tenantDatabaseAdminOrchestrationService;
    private final TenantConfigurationPersistenceService tenantConfigurationPersistenceService;
    private final ConfigServerClient configServerClient;
    private final TenantAdministrationStatusService tenantAdministrationStatusService;

    public DefaultTenantAdministrationRequestHandler(MessageSecurityService messageSecurityService,
                                                     TenantAdministrationProcessor tenantAdministrationProcessor,
                                                     TenantDatabaseAdminOrchestrationService tenantDatabaseAdminOrchestrationService,
                                                     TenantConfigurationPersistenceService tenantConfigurationPersistenceService,
                                                     ConfigServerClient configServerClient,
                                                     TenantAdministrationStatusService tenantAdministrationStatusService) {
        this.messageSecurityService = messageSecurityService;
        this.tenantAdministrationProcessor = tenantAdministrationProcessor;
        this.tenantDatabaseAdminOrchestrationService = tenantDatabaseAdminOrchestrationService;
        this.tenantConfigurationPersistenceService = tenantConfigurationPersistenceService;
        this.configServerClient = configServerClient;
        this.tenantAdministrationStatusService = tenantAdministrationStatusService;
    }

    @Override
    public void createTenant(TenantConfiguration tenantConfiguration) {
        logger.debug("Sending CREATE_TENANT {}", tenantConfiguration);
        sendAdministrationMessage(tenantConfiguration, TenantAdministrationRequestType.CREATE_TENANT);
    }

    @Override
    public void createSandbox(TenantConfiguration tenantConfiguration) {
        logger.debug("Sending CREATE_SANDBOX {}", tenantConfiguration);
        sendAdministrationMessage(tenantConfiguration, TenantAdministrationRequestType.CREATE_SANDBOX);
    }

    @Override
    public void updateTenant(TenantConfiguration tenantConfiguration) {
        logger.debug("Sending UPDATE_TENANT {}", tenantConfiguration);
        sendAdministrationMessage(tenantConfiguration, TenantAdministrationRequestType.UPDATE_TENANT);
    }

    @Override
    public void updateSandbox(TenantConfiguration tenantConfiguration) {
        logger.debug("Sending UPDATE_SANDBOX {}", tenantConfiguration);
        sendAdministrationMessage(tenantConfiguration, TenantAdministrationRequestType.UPDATE_SANDBOX);
    }

    @Override
    public void deleteSandbox(TenantConfiguration tenantConfiguration) {
        logger.debug("Sending DELETE_SANDBOX {}", tenantConfiguration);
        sendAdministrationMessage(tenantConfiguration, TenantAdministrationRequestType.DELETE_SANDBOX);
    }

    private void sendAdministrationMessage(TenantConfiguration tenantConfiguration,
                                           TenantAdministrationRequestType tenantAdministrationRequestType) {
        User user = getCurrentUser();
        TenantAdministrationMessage payload = TenantAdministrationMessage.builder()
                .tenantAdministrationRequestType(tenantAdministrationRequestType)
                .tenantConfiguration(tenantConfiguration)
                .build();

        final Message<TenantAdministrationMessage> message = messageSecurityService.withUser(
                MessageBuilder.createMessage(payload, new MessageHeaders(new HashMap<>())),
                user);
        tenantAdministrationProcessor.tenantAdministrationOutput().send(message);
    }

    @StreamListener(TenantAdministrationProcessor.TenantAdministrationInput)
    public void tenantAdministrationDispatcher(final Message<TenantAdministrationMessage> message) {
        try {
            TenantAdministrationMessage payload = message.getPayload();
            final TenantConfiguration tenantConfiguration = payload.getTenantConfiguration();
            switch (payload.getTenantAdministrationRequestType()) {
                case CREATE_TENANT:
                    createTenantAsync(tenantConfiguration);
                    break;
                case CREATE_SANDBOX:
                    createSandboxAsync(tenantConfiguration);
                    break;
                case DELETE_SANDBOX:
                    deleteSandboxAsync(tenantConfiguration);
                    break;
                case UPDATE_TENANT:
                    updateTenantAsync(tenantConfiguration);
                    break;
                case UPDATE_SANDBOX:
                    updateSandboxAsync(tenantConfiguration);
                    break;
            }
        } catch (Exception e) {
            //no end user logging only
            logger.warn("Error processing tenant administration request {}", message, e);
        }
    }

    private void createTenantAsync(final TenantConfiguration tenantConfiguration) {
        final String tenantKey = tenantConfiguration.getTenant().getKey();
        try {
            tenantAdministrationStatusService.putStatus(tenantKey, CREATE_STARTED, tenantConfiguration);
            logger.debug("Processing TenantCreationInput {} {}", tenantKey, tenantConfiguration);

            tenantAdministrationStatusService.updateStatus(tenantKey, CREATE_SETTING_UP_DATABASES);
            logger.debug("Processing TenantCreationInput createTenantDatabases {}", tenantKey);
            tenantDatabaseAdminOrchestrationService.createTenantDatabases(tenantConfiguration);

            tenantAdministrationStatusService.updateStatus(tenantKey, CREATE_PERSISTING_CONFIGURATION);
            logger.debug("Processing TenantCreationInput saveTenantConfiguration {}", tenantKey);
            tenantConfigurationPersistenceService.saveTenantConfiguration(tenantConfiguration);

            tenantAdministrationStatusService.updateStatus(tenantKey, CREATE_PUBLISHING_CONFIGURATION_CHANGES);
            logger.debug("Processing TenantCreationInput postMonitor {}", tenantKey);
            configServerClient.postMonitor();
        } catch (Exception e) {
            //catch all / rethrow to update status
            String stackTrace = ExceptionUtils.getStackTrace(e);
            tenantAdministrationStatusService.updateStatus(tenantKey, CREATE_FAILED, stackTrace);
            throw e;
        }
    }


    @VisibleForTesting
    void createSandboxAsync(TenantConfiguration tenantConfiguration) {
        final String tenantKey = tenantConfiguration.getTenant().getKey();
        try {
            tenantAdministrationStatusService.putStatus(tenantKey, CREATE_STARTED, tenantConfiguration);
            logger.debug("create sandbox starting {} {}", tenantKey, tenantConfiguration);

            tenantAdministrationStatusService.updateStatus(tenantKey, CREATE_SETTING_UP_DATABASES);
            logger.debug("create sandbox create database {}", tenantKey);
            tenantDatabaseAdminOrchestrationService.createSandboxDatabases(tenantConfiguration);

            tenantAdministrationStatusService.updateStatus(tenantKey, CREATE_PERSISTING_CONFIGURATION);
            logger.debug("create sandbox save git {}", tenantKey);
            tenantConfigurationPersistenceService.saveTenantConfiguration(tenantConfiguration);

            tenantAdministrationStatusService.updateStatus(tenantKey, CREATE_PUBLISHING_CONFIGURATION_CHANGES);
            logger.debug("create sandbox postMonitor {}", tenantKey);
            configServerClient.postMonitor();
        } catch (Exception e) {
            //catch all / rethrow to update status
            String stackTrace = ExceptionUtils.getStackTrace(e);
            tenantAdministrationStatusService.updateStatus(tenantKey, CREATE_FAILED, stackTrace);
            throw e;
        }
    }

    private void updateTenantAsync(TenantConfiguration tenantConfiguration) {
        final String tenantKey = tenantConfiguration.getTenant().getKey();
        try {
            tenantAdministrationStatusService.putStatus(tenantKey, UPDATE_STARTED, tenantConfiguration);
            logger.debug("update tenant starting {} {}", tenantKey, tenantConfiguration);

            tenantAdministrationStatusService.putStatus(tenantKey, UPDATE_PERSISTING_CONFIGURATION, tenantConfiguration);
            logger.debug("update tenant save git {}", tenantKey);
            tenantConfigurationPersistenceService.saveTenantConfiguration(tenantConfiguration);

            tenantAdministrationStatusService.updateStatus(tenantKey, UPDATE_PUBLISHING_CONFIGURATION_CHANGES);
            logger.debug("update tenant postMonitor {}", tenantKey);
            configServerClient.postMonitor();
        } catch (Exception e) {
            //catch all / rethrow to update status
            String stackTrace = ExceptionUtils.getStackTrace(e);
            tenantAdministrationStatusService.updateStatus(tenantKey, UPDATE_FAILED, stackTrace);
            throw e;
        }
    }

    private void updateSandboxAsync(TenantConfiguration tenantConfiguration) {
        final String tenantKey = tenantConfiguration.getTenant().getKey();
        try {
            tenantAdministrationStatusService.putStatus(tenantKey, UPDATE_STARTED, tenantConfiguration);
            logger.debug("update sandbox starting {} {}", tenantKey, tenantConfiguration);

            tenantAdministrationStatusService.putStatus(tenantKey, UPDATE_PERSISTING_CONFIGURATION, tenantConfiguration);
            logger.debug("update sandbox save git {}", tenantKey);
            tenantConfigurationPersistenceService.saveTenantConfiguration(tenantConfiguration);

            tenantAdministrationStatusService.updateStatus(tenantKey, UPDATE_PUBLISHING_CONFIGURATION_CHANGES);
            logger.debug("update sandbox postMonitor {}", tenantKey);
            configServerClient.postMonitor();
        } catch (Exception e) {
            //catch all / rethrow to update status
            String stackTrace = ExceptionUtils.getStackTrace(e);
            tenantAdministrationStatusService.updateStatus(tenantKey, UPDATE_FAILED, stackTrace);
            throw e;
        }
    }

    private void deleteSandboxAsync(final TenantConfiguration tenantConfiguration) {
        final String tenantKey = tenantConfiguration.getTenant().getKey();
        try {
            tenantAdministrationStatusService.putStatus(tenantKey, DELETE_STARTED, tenantConfiguration);
            logger.debug("delete sandbox starting {} {}", tenantKey, tenantConfiguration);

            logger.debug("delete sandbox database resources {}", tenantKey);
            tenantAdministrationStatusService.putStatus(tenantKey, DELETE_CLEARING_DATABASE_RESOURCES, tenantConfiguration);
            tenantDatabaseAdminOrchestrationService.deleteSandboxDatabases(tenantConfiguration);

            //TODO: S3 delete here

            logger.debug("delete sandbox remove configuration {}", tenantKey);
            tenantAdministrationStatusService.putStatus(tenantKey, DELETE_PERSISTING_CONFIGURATION, tenantConfiguration);
            tenantConfigurationPersistenceService.deleteSandbox(tenantKey);

            logger.debug("delete sandbox publish changes {}", tenantKey);
            tenantAdministrationStatusService.putStatus(tenantKey, DELETE_PUBLISHING_CONFIGURATION_CHANGES, tenantConfiguration);
            configServerClient.postMonitor();

            logger.debug("delete sandbox remove {}", tenantKey);
            tenantAdministrationStatusService.remove(tenantKey);
        } catch (Exception e) {
            //catch all / rethrow to update status
            String stackTrace = ExceptionUtils.getStackTrace(e);
            tenantAdministrationStatusService.updateStatus(tenantKey, DELETE_FAILED, stackTrace);
            throw e;
        }
    }

    @VisibleForTesting
    User getCurrentUser() {
        return Users.getCurrentUser();
    }

}
