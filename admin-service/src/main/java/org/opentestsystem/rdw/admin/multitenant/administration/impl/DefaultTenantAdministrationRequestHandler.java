package org.opentestsystem.rdw.admin.multitenant.administration.impl;

import com.google.common.annotations.VisibleForTesting;
import org.opentestsystem.rdw.admin.client.ConfigServerClient;
import org.opentestsystem.rdw.admin.model.TenantConfiguration;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationProcessor;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationRequestHandler;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatusService;
import org.opentestsystem.rdw.admin.multitenant.database.TenantDatabaseCreationService;
import org.opentestsystem.rdw.admin.multitenant.git.TenantConfigurationPersistenceService;
import org.opentestsystem.rdw.reporting.common.security.User;
import org.opentestsystem.rdw.reporting.common.security.Users;
import org.opentestsystem.rdw.reporting.common.stream.MessageSecurityService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.support.MessageBuilder;

import java.util.HashMap;

import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationProcessor.SandboxCreationRequest;
import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationProcessor.TenantCreationRequest;
import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus.CREATING_DATABASES;
import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus.FAILED;
import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus.NOTIFYING_CONFIG_SERVER;
import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus.PERSISTING_CONFIGURATION;
import static org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus.STARTED;

public class DefaultTenantAdministrationRequestHandler implements TenantAdministrationRequestHandler {

    private static final Logger logger = LoggerFactory.getLogger(DefaultTenantAdministrationRequestHandler.class);

    private final MessageSecurityService messageSecurityService;
    private final TenantAdministrationProcessor tenantAdministrationProcessor;
    private final TenantDatabaseCreationService tenantDatabaseCreationService;
    private final TenantConfigurationPersistenceService tenantConfigurationPersistenceService;
    private final ConfigServerClient configServerClient;
    private final TenantAdministrationStatusService tenantAdministrationStatusService;

    public DefaultTenantAdministrationRequestHandler(MessageSecurityService messageSecurityService,
                                                     TenantAdministrationProcessor tenantAdministrationProcessor,
                                                     TenantDatabaseCreationService tenantDatabaseCreationService,
                                                     TenantConfigurationPersistenceService tenantConfigurationPersistenceService,
                                                     ConfigServerClient configServerClient,
                                                     TenantAdministrationStatusService tenantAdministrationStatusService) {
        this.messageSecurityService = messageSecurityService;
        this.tenantAdministrationProcessor = tenantAdministrationProcessor;
        this.tenantDatabaseCreationService = tenantDatabaseCreationService;
        this.tenantConfigurationPersistenceService = tenantConfigurationPersistenceService;
        this.configServerClient = configServerClient;
        this.tenantAdministrationStatusService = tenantAdministrationStatusService;
    }

    @Override
    public void createTenant(TenantConfiguration tenantConfiguration) {
        logger.debug("Sending TenantCreationRequest");
        User user = getCurrentUser();
        final Message<TenantConfiguration> createTenantMessage = messageSecurityService.withUser(
                MessageBuilder.createMessage(tenantConfiguration, new MessageHeaders(new HashMap<>())),
                user);
        tenantAdministrationProcessor.tenantCreationRequest().send(createTenantMessage);
    }

    @StreamListener(TenantCreationRequest)
    @VisibleForTesting
    void createTenantAsync(final Message<TenantConfiguration> createTenantMessage) {
        TenantConfiguration tenantConfiguration = createTenantMessage.getPayload();
        final String tenantKey = tenantConfiguration.getTenant().getKey();
        try {
            tenantAdministrationStatusService.putStatus(tenantKey, STARTED, tenantConfiguration);
            logger.debug("Processing TenantCreationRequest");

            tenantAdministrationStatusService.updateStatus(tenantKey, CREATING_DATABASES);
            tenantDatabaseCreationService.createTenantDatabases(tenantConfiguration);

            tenantAdministrationStatusService.updateStatus(tenantKey, PERSISTING_CONFIGURATION);
            tenantConfigurationPersistenceService.saveTenantConfiguration(tenantConfiguration);

            tenantAdministrationStatusService.updateStatus(tenantKey, NOTIFYING_CONFIG_SERVER);
            configServerClient.postMonitor();
        } catch (Exception e) {
            //catch all / rethrow to update status
            tenantAdministrationStatusService.updateStatus(tenantKey, FAILED);
            logger.warn("Error creating tenant", e);
            throw e;
        }
    }

    @Override
    public void createSandbox(TenantConfiguration tenantConfiguration) {
        User user = getCurrentUser();
        final Message<TenantConfiguration> createTenantMessage = messageSecurityService.withUser(
                MessageBuilder.createMessage(tenantConfiguration, new MessageHeaders(new HashMap<>())),
                user);
        tenantAdministrationProcessor.sandboxCreationRequest().send(createTenantMessage);
    }

    @StreamListener(SandboxCreationRequest)
    @VisibleForTesting
    void createSandboxAsync(final Message<TenantConfiguration> createSandboxMessage) {
        TenantConfiguration tenantConfiguration = createSandboxMessage.getPayload();
        final String tenantKey = tenantConfiguration.getTenant().getKey();
        try {
            tenantAdministrationStatusService.putStatus(tenantKey, STARTED, tenantConfiguration);
            logger.debug("Processing SandboxCreationRequest");

            tenantAdministrationStatusService.updateStatus(tenantKey, CREATING_DATABASES);
            tenantDatabaseCreationService.createSandboxDatabases(tenantConfiguration);

            tenantAdministrationStatusService.updateStatus(tenantKey, PERSISTING_CONFIGURATION);
            tenantConfigurationPersistenceService.saveTenantConfiguration(tenantConfiguration);

            tenantAdministrationStatusService.updateStatus(tenantKey, NOTIFYING_CONFIG_SERVER);
            configServerClient.postMonitor();
        } catch (Exception e) {
            //catch all / rethrow to update status
            tenantAdministrationStatusService.updateStatus(tenantKey, FAILED);
            logger.warn("Error creating sandbox", e);
            throw e;
        }
    }

    @VisibleForTesting
    User getCurrentUser() {
        return Users.getCurrentUser();
    }
}
