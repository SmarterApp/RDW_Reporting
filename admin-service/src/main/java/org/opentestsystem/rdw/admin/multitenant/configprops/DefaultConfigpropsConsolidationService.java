package org.opentestsystem.rdw.admin.multitenant.configprops;


import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Sets;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.text.CaseUtils;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class DefaultConfigpropsConsolidationService implements ConfigpropsConsolidationService {

    private final ObjectMapper mapper;
    private final ConfigpropsClient configpropsClient;

    public DefaultConfigpropsConsolidationService(ObjectMapper mapper,
                                                  ConfigpropsClient configpropsClient) {
        this.mapper = mapper.copy();
        this.configpropsClient = configpropsClient;
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        mapper.setSerializationInclusion(JsonInclude.Include.ALWAYS);
    }

    @Override
    public Map<String, Map<String, JsonNode>> extractServicePrefixProperties() {
        return configpropsClient.getRawServiceConfigurations()
                .entrySet()
                .stream()
                .map(entry -> ImmutablePair.of(entry.getKey(), extractPrefixProperties(entry.getValue())))
                .collect(Collectors.toMap(ImmutablePair::getLeft, ImmutablePair::getRight));
    }

    @VisibleForTesting
    Map<String, JsonNode> extractPrefixProperties(String json) {
        //break down configprops into map "key" -> {"prefix: "x", "properties": "x"}
        Map<String, JsonNode> map = null;
        try {
            map = mapper.readValue(json, new TypeReference<Map<String, JsonNode>>() {
            });
        } catch (IOException e) {
            throw new IllegalStateException("Unable to parse JSON", e);
        }
        //remove anything we aren't interested in, return a map of prefix -> properties
        return map.values().stream()
                .filter(node -> {
                    String prefix = node.path("prefix").asText();
                    return prefix.equals("archive")
                            || prefix.equals("reporting")
                            || prefix.startsWith("datasources.")
                            || prefix.equals("aggregate-reporting")
                            || prefix.equals("aggregateReporting")
                            || prefix.equals("tenantProperties")
                            || prefix.equals("tenant-properties")
                            || prefix.equals("validation")
                            || prefix.equals("taskUpdateOrganizationsArtClient")
                            || prefix.equals("task-update-organizations-art-client")
                            || prefix.equals("taskUpdateOrganizationsImportServiceClient")
                            || prefix.equals("task-update-organizations-import-service-client")
                            || prefix.equals("taskSendReconciliationReport")
                            || prefix.equals("task-send-reconciliation-report");
                })
                .map(node -> ImmutablePair.of(normalizeToCamelCase(node.path("prefix").asText()), node.path("properties")))
                .filter(pair -> {
                    //workaround for duplicate top level key for both ExamProcessorValidationPropertiesRoot
                    //and SbacScoreConfiguration ExamProcessorValidationPropertiesRoot will have requiredDataElements
                    Set<String> fieldNames = Sets.newHashSet(pair.getRight().fieldNames());
                    boolean hasRequiredDataElements = fieldNames.contains("requiredDataElements");
                    return !pair.getLeft().equals("validation") || hasRequiredDataElements;
                })
                .collect(Collectors.toMap(ImmutablePair::getLeft, ImmutablePair::getRight));
    }

    //we have a mix of snake and camel case normalize keys
    private String normalizeToCamelCase(String prefix) {
        if (prefix.contains("-")) {
            return CaseUtils.toCamelCase(prefix, false, new char[]{'-'});
        }
        return prefix;
    }

}
