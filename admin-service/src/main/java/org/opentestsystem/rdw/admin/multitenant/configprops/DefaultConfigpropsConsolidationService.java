package org.opentestsystem.rdw.admin.multitenant.configprops;


import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.annotations.VisibleForTesting;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.Map;
import java.util.stream.Collectors;

@Service
public class DefaultConfigpropsConsolidationService implements ConfigpropsConsolidationService {

    private final ObjectMapper mapper;

    public DefaultConfigpropsConsolidationService(ObjectMapper mapper) {
        this.mapper = mapper.copy();
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        mapper.setSerializationInclusion(JsonInclude.Include.ALWAYS);
    }

    @Override
    public Map<String, Map<String, JsonNode>> extractServicePrefixProperties(Map<String, String> serviceConfigpropsJson) {
        return serviceConfigpropsJson.entrySet().stream()
                .map(entry -> ImmutablePair.of(entry.getKey(), extractPrefixProperties(entry.getValue())))
                .collect(Collectors.toMap(ImmutablePair::getLeft, ImmutablePair::getRight));
    }

    @VisibleForTesting
    Map<String, JsonNode> extractPrefixProperties(String json) {
        //break down configprops into map "key" -> {"prefix: "x", "properties": "x"}
        Map<String, JsonNode> map = null;
        try {
            map = mapper.readValue(json, new TypeReference<Map<String, JsonNode>>() {
            });
        } catch (IOException e) {
            throw new IllegalStateException("Unable to parse JSON", e);
        }
        //remove anything we aren't interested in, return a map of prefix -> properties
        return map.values().stream()
                .filter(node -> {
                    String prefix = node.path("prefix").asText();
                    return prefix.equals("archive")
                            || prefix.equals("reporting")
                            || prefix.startsWith("datasources.")
                            || prefix.startsWith("aggregate")
                            || prefix.equals("tenantProperties");
                })
                .map(node -> ImmutablePair.of(node.path("prefix").asText(), node.path("properties")))
                .collect(Collectors.toMap(ImmutablePair::getLeft, ImmutablePair::getRight));
    }

}
