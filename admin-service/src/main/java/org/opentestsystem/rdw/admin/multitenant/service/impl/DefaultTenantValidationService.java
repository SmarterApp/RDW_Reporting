package org.opentestsystem.rdw.admin.multitenant.service.impl;

import org.opentestsystem.rdw.admin.exception.DuplicateTenantException;
import org.opentestsystem.rdw.admin.multitenant.model.TenantConfiguration;
import org.opentestsystem.rdw.admin.repository.TenantConfigurationRepository;
import org.opentestsystem.rdw.admin.multitenant.service.TenantConfigurationViewService;
import org.opentestsystem.rdw.admin.multitenant.service.TenantValidationService;
import org.opentestsystem.rdw.admin.service.impl.RDWDataSourceNames;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsTenant;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Map;
import java.util.NoSuchElementException;

@Service
public class DefaultTenantValidationService implements TenantValidationService {

    private static final Logger logger = LoggerFactory.getLogger(DefaultTenantValidationService.class);

    @Deprecated
    private final TenantConfigurationRepository tenantConfigurationRepository;
    
    private final TenantConfigurationViewService tenantConfigurationViewService;

    @Autowired
    public DefaultTenantValidationService(TenantConfigurationRepository tenantConfigurationRepository,
                                          TenantConfigurationViewService tenantConfigurationViewService) {
        this.tenantConfigurationRepository = tenantConfigurationRepository;
        this.tenantConfigurationViewService = tenantConfigurationViewService;
    }

    public void tenantCreationValidation(final TenantConfiguration tenantConfiguration) {
        verifyNewTenantExists(tenantConfiguration.getTenant());
        verifyTenantArchive(tenantConfiguration);
        verifyTenantDataSources(tenantConfiguration);
    }

    @Override
    public void sandboxCreationValidation(TenantConfiguration tenantConfiguration) {
        verifyNewTenantExists(tenantConfiguration.getTenant());
        // TODO update with full if exists checks
//        if (!sandboxConfigurationRepository.exists(sandboxConfiguration.getSandbox().getKey())) {
//            String errorMsg = "Sandbox: " + sandboxConfiguration.getSandbox().getName() +
//                    " key: " + sandboxConfiguration.getSandbox().getKey() + " not found.";
//            logger.error(errorMsg);
//            throw new NoSuchElementException(errorMsg);
//        }
    }

    public void tenantUpdateValidation(TenantConfiguration tenantConfiguration) {
        // make sure tenant key is in app settings and in tenant storage
        if (!tenantConfigurationRepository.tenantExists(tenantConfiguration.getTenant().getKey()) ||
                !tenantConfigurationRepository.tenantExists(tenantConfiguration.getTenant().getKey())) {
            String errorMsg = String.format("Tenant: %s, key: %s not found.",
                    tenantConfiguration.getTenant().getName(), tenantConfiguration.getTenant().getKey());
            logger.error(errorMsg);
            throw new NoSuchElementException(errorMsg);
        }
    }

    @Override
    public void sandboxUpdateValidation(TenantConfiguration tenantConfiguration) {
//        // TODO update with full if exists checks
//        if (!sandboxConfigurationRepository.exists(sandboxConfiguration.getSandbox().getKey())) {
//            String errorMsg = "Sandbox: " + sandboxConfiguration.getSandbox().getName() +
//                    " key: " + sandboxConfiguration.getSandbox().getKey() + " not found.";
//            logger.error(errorMsg);
//            throw new NoSuchElementException(errorMsg);
//        }
    }

    /**
     * @param tenant to check if it exists
     */
    private void verifyNewTenantExists(final Tenant tenant) {
        if (tenantConfigurationRepository.tenantExists(tenant.getKey())) {
            String errorMsg = String.format("Tenant: %s, key: %s exists already. Please update existing tenant, or add another tenant key.",
                    tenant.getName(), tenant.getKey());
            logger.error(errorMsg);
            //TODO: more generic?
            throw new DuplicateTenantException(errorMsg);
        }
    }

    /**
     * Verifies that the tenant's Archive S3 are unique
     *
     * @param tenantConfiguration the new tenantConfiguration to validate its archive properties
     */
    private void verifyTenantArchive(final TenantConfiguration tenantConfiguration) {
        if (archivePrefixExists(
                tenantConfiguration.getArchiveProperties().getPathPrefix())) {
            String errorMsg = String.format("Tenant: %s, key: %s, the archive property :prefix exists already. " +
                            "Please use another Archive prefix for the new Tenant.",
                    tenantConfiguration.getTenant().getName(), tenantConfiguration.getTenant().getKey());
            logger.error(errorMsg);
            throw new IllegalArgumentException(errorMsg);
        }
    }

    /**
     * Verifies if the given Tenant's DataSources already exist in a configured Tenant
     * Throws an exception with the specific datasource name where the database was found
     *
     * @param tenantConfiguration the new tenantConfiguration to validate its databases
     */
    private void verifyTenantDataSources(final TenantConfiguration tenantConfiguration) {
        // check each datasource
        for (Map.Entry<String, DataSourceElementsTenant> dataSource : tenantConfiguration.getDataSources().entrySet()) {
            if (dataSource.getValue().getUrlParts() == null) {
                // default tenant information is not configured properly
                String errorMsg = String.format("Cannot create Tenant: %s, key: %s, the Database property %s is not configure correctly." +
                                " Please contact your admin.",
                        tenantConfiguration.getTenant().getName(), tenantConfiguration.getTenant().getKey(),
                        dataSource.getKey());
                logger.error(errorMsg);
                throw new IllegalArgumentException(errorMsg);
            }
            if (dataSourceExists(dataSource.getKey(), dataSource.getValue().getUrlParts().getDatabase())) {
                String errorMsg = String.format("Cannot create Tenant: %s, key: %s, the Database property %s exists already for DataSource %s." +
                                " Please use another database for the new Tenant.",
                        tenantConfiguration.getTenant().getName(), tenantConfiguration.getTenant().getKey(),
                        dataSource.getValue().getUrlParts().getDatabase(), dataSource.getKey());
                logger.error(errorMsg);
                throw new IllegalArgumentException(errorMsg);
            }
            if (dataSource.getKey().equals(RDWDataSourceNames.OLAP_RO.getName()) &&
                    dataSourceOlapExists(
                            dataSource.getValue().getUrlParts().getDatabase(), dataSource.getValue().getUsername())) {
                String errorMsg = String.format("Cannot create Tenant: %s key: %s, the Olap DataSource's userName %s already exists " +
                                "or the database %s does not match the default database. Please use a unique username and the same database for the new Tenant.",
                        tenantConfiguration.getTenant().getName(), tenantConfiguration.getTenant().getKey(),
                        dataSource.getValue().getUsername(), dataSource.getValue().getUrlParts().getDatabase());
                logger.error(errorMsg);
                throw new IllegalArgumentException(errorMsg);
            }
        }
    }

    private boolean archivePrefixExists(String prefix) {
        //TODO: implement
        return false;
    }
    //TODO: moving this stuff here
//    @Override
//    public boolean archivePrefixExists(String prefix) {
//        final Map<String, ArchivePropertiesTenant> tenantsArchiveProperties = rdwServiceConfigPropsAccessor.getTenantsArchiveProperties();
//        for (Map.Entry<String, ArchivePropertiesTenant> archive : tenantsArchiveProperties.entrySet()) {
//            if (archive.getValue().getPathPrefix().equals(prefix)) {
//                return true;
//            }
//        }
//        return false;
//    }

    private boolean dataSourceExists(String dataSource, String dataSourceDatabase) {
        //TODO: implement
        return false;
    }

//    @Override
//    public boolean dataSourceExists(String dataSource, String dataSourceDatabase) {
//        // TODO Add the DBADmin checks to the Aurua db
//        if (dataSource.equals(RDWDataSourceNames.REPORTING_RO.getName())) {
//            return databaseExists(dataSourceDatabase, rdwServiceConfigPropsAccessor.getTenantsReadOnlyDataSourceElements());
//        }
//        if (dataSource.equals(RDWDataSourceNames.REPORTING_RW.getName())) {
//            return databaseExists(dataSourceDatabase, rdwServiceConfigPropsAccessor.getTenantsWritableDataSourceElements());
//        }
//        if (dataSource.equals(RDWDataSourceNames.WAREHOUSE_RW.getName())) {
//            return databaseExists(dataSourceDatabase, rdwServiceConfigPropsAccessor.getTenantsWarehouseDataSourceElements());
//        }
//        return false;
//    }

    public boolean dataSourceOlapExists(String dataSourceDatabase, String userName) {
        //TODO: implement
        return false;
    }
//    @Override
//    public boolean dataSourceOlapExists(String dataSourceDatabase, String userName) {
//        // check that the database exist
//        // the database is the same as the default
//        // and the username is unique
//        // todo add redshift check
//        boolean dbExists = databaseExists(dataSourceDatabase, rdwServiceConfigPropsAccessor.getTenantsOlapDataSourceElements());
//        boolean userNameExists = databaseUserNameExists(userName, rdwServiceConfigPropsAccessor.getTenantsOlapDataSourceElements());
//        // false means it's Ok to create, abd verify the userName length
//        return userNameExists || !dbExists || userName.length() > USERNAME_MAX_SIZE ? false : true;
//    }

    private boolean databaseUserNameExists(final String userName, final Map<String, DataSourceElementsTenant> tenantsReadOnlyDataSourceElements) {
        //TODO: implement
        return false;
    }

    //    /**
//     * TODO Add search on configured S3 settings
//     *
//     * @param userName                          the userName to search for
//     * @param tenantsReadOnlyDataSourceElements Map of tenant specific dataSources to search
//     * @return true if the userName of the database is found in the list of current tenants
//     */
//    private boolean databaseUserNameExists(final String userName, final Map<String, DataSourceElementsTenant> tenantsReadOnlyDataSourceElements) {
//        for (Map.Entry<String, DataSourceElementsTenant> dataSource : tenantsReadOnlyDataSourceElements.entrySet()) {
//            if (dataSource.getValue().getUsername().equals(userName)) {
//                return true;
//            }
//        }
//        return false;
//    }

    private boolean databaseExists(final String dataSourceDatabase, final Map<String, DataSourceElementsTenant> tenantsReadOnlyDataSourceElements) {
        //TODO: implement
        return false;
    }

//    /**
//     * TODO Search databases
//     *
//     * @param dataSourceDatabase                the database to search for
//     * @param tenantsReadOnlyDataSourceElements Map of dataSources to search
//     * @return true if the dataSource database is found in the list of current tenants
//     */
//    private boolean databaseExists(final String dataSourceDatabase, final Map<String, DataSourceElementsTenant> tenantsReadOnlyDataSourceElements) {
//        for (Map.Entry<String, DataSourceElementsTenant> dataSource : tenantsReadOnlyDataSourceElements.entrySet()) {
//            if (dataSource.getValue().getUrlParts().getDatabase().equals(dataSourceDatabase)) {
//                return true;
//            }
//        }
//        return false;
//    }


}
