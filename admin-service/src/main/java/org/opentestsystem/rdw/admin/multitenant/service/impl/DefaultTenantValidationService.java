package org.opentestsystem.rdw.admin.multitenant.service.impl;

import com.google.common.annotations.VisibleForTesting;
import org.apache.commons.lang3.tuple.ImmutablePair;

import org.opentestsystem.rdw.admin.multitenant.TenantType;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus;
import org.opentestsystem.rdw.admin.multitenant.database.impl.RdwDatabaseType;
import org.opentestsystem.rdw.admin.multitenant.model.TenantConfiguration;
import org.opentestsystem.rdw.admin.multitenant.service.TenantConfigurationViewService;
import org.opentestsystem.rdw.admin.multitenant.service.TenantValidationService;
import org.opentestsystem.rdw.admin.service.impl.RDWDataSourceNames;
import org.opentestsystem.rdw.archive.ArchivePropertiesTenant;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsTenant;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemPropertiesImpl;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Map;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;

@Service
public class DefaultTenantValidationService implements TenantValidationService {

    private static final Logger logger = LoggerFactory.getLogger(DefaultTenantValidationService.class);

    private final int USERNAME_MAX_SIZE = 16;

    private final TenantConfigurationViewService tenantConfigurationViewService;

    @Autowired
    public DefaultTenantValidationService(TenantConfigurationViewService tenantConfigurationViewService) {
        this.tenantConfigurationViewService = tenantConfigurationViewService;
    }

    public void tenantCreationValidation(final TenantConfiguration tenantConfiguration) {
        final Map<String, TenantConfiguration> knownTenantConfigurations = tenantConfigurationViewService.allTenantConfigurations(TenantType.TENANT);
        verifyTenantRequiredFields(tenantConfiguration);
        verifyNotExists(tenantConfiguration.getTenant(), knownTenantConfigurations);
        verifyTenantArchive(tenantConfiguration, knownTenantConfigurations);
        verifyTenantDataSources(tenantConfiguration, knownTenantConfigurations);
    }

    @Override
    public void sandboxCreationValidation(TenantConfiguration tenantConfiguration) {
        verifySandboxRequiredFields(tenantConfiguration);
        final Map<String, TenantConfiguration> knownTenantConfigurations = tenantConfigurationViewService.allTenantConfigurations(TenantType.SANDBOX);
        verifyNotExists(tenantConfiguration.getTenant(), knownTenantConfigurations);
    }

    @Override
    public void tenantUpdateValidation(TenantConfiguration tenantConfiguration) {
        final Map<String, TenantConfiguration> knownTenantConfigurations = tenantConfigurationViewService.allTenantConfigurations(TenantType.TENANT);
        verifyTenantExistsForUpdate(tenantConfiguration.getTenant(), knownTenantConfigurations);
        verifyTenantTypeMatchesExisting(tenantConfiguration.getTenant(), knownTenantConfigurations);
    }

    @Override
    public void sandboxUpdateValidation(TenantConfiguration tenantConfiguration) {
        final Map<String, TenantConfiguration> knownTenantConfigurations = tenantConfigurationViewService.allTenantConfigurations(TenantType.SANDBOX);
        verifyTenantExistsForUpdate(tenantConfiguration.getTenant(), knownTenantConfigurations);
        verifyTenantTypeMatchesExisting(tenantConfiguration.getTenant(), knownTenantConfigurations);
    }

    @VisibleForTesting
    void verifySandboxRequiredFields(TenantConfiguration tenantConfiguration) {
        if (tenantConfiguration.getTenant() == null) {
            String errorMsg = "Required field 'tenant' missing";
            throw new IllegalArgumentException(errorMsg);
        }
        if (!tenantConfiguration.getTenant().isSandbox()) {
            String errorMsg = "Required field 'tenant.sandbox' must be 'true'";
            throw new IllegalArgumentException(errorMsg);
        }
        if (tenantConfiguration.getTenant().getSandboxDataset() == null) {
            String errorMsg = "Required field 'tenant.sandboxDataset' must be not be null";
            throw new IllegalArgumentException(errorMsg);
        }
    }

    /**
     * @param tenantConfiguration verifies required fields
     */
    private void verifyTenantRequiredFields(TenantConfiguration tenantConfiguration) {
        verifyTenantKeyAndIdFields(tenantConfiguration.getTenant());
        verifyReportingRequiredFields(tenantConfiguration.getReporting());
    }

    /**
     * @param reporting verifies the required ReportingSystemSettings fields
     */
    private void verifyReportingRequiredFields(final ReportingSystemPropertiesImpl reporting) {
        if (reporting == null) {
            String errorMsg = "Required field 'tenant.reporting' must be not be null";
            throw new IllegalArgumentException(errorMsg);
        }
        if (reporting.getState() == null) {
            String errorMsg = "Required field 'reporting.state' must be not be null";
            throw new IllegalArgumentException(errorMsg);
        }
        if (reporting.getState().getCode() == null) {
            String errorMsg = "Required field 'reporting.state.code' must be not be null";
            throw new IllegalArgumentException(errorMsg);
        }
        if (reporting.getState().getName() == null) {
            String errorMsg = "Required field 'reporting.state.name' must be not be null";
            throw new IllegalArgumentException(errorMsg);
        }
    }

    /**
     * @param tenant verify key & id fields exist and are not null
     */
    private void verifyTenantKeyAndIdFields(final Tenant tenant) {
        if (tenant.getKey() == null || tenant.getKey().isEmpty() || tenant.getId() == null || tenant.getId().isEmpty()) {
            String errorMsg = String.format("Cannot create a tenant if either the key (%s) or the id (%s) is empty.",
                    tenant.getKey(), tenant.getId());
            logger.error(errorMsg);
            throw new IllegalArgumentException(errorMsg);
        }
    }

    /**
     * @param tenant                    or sandbox to verify if may previously exists
     * @param knownTenantConfigurations all current Tenant & sandbox Configurations
     */
    private void verifyNotExists(final Tenant tenant, final Map<String, TenantConfiguration> knownTenantConfigurations) {
        String tenantType = tenant.isSandbox() ? "Sandox" : "Tenant";
        //ignore failed for the purpose of existence detection
        Map<String, TenantConfiguration> filteredConfigurations = knownTenantConfigurations.entrySet().stream()
                .filter(entry -> entry.getValue().getAdministrationStatus().getTenantAdministrationStatus() != TenantAdministrationStatus.FAILED)
                .map(entry -> ImmutablePair.of(entry.getKey(), entry.getValue()))
                .collect(Collectors.toMap(ImmutablePair::getLeft, ImmutablePair::getRight));
        if (filteredConfigurations.containsKey(tenant.getKey())) {
            String errorMsg = String.format("%s: %s, key: %s exists already. Use a unique key (or UPDATE the existing %s)",
                    tenantType, tenant.getName(), tenant.getKey(), tenantType);
            throw new IllegalArgumentException(errorMsg);
        }
    }

    /**
     * @param tenant                    or sandbox to verify if it exists
     * @param knownTenantConfigurations all current Tenant & sandbox Configurations
     */
    private void verifyTenantExistsForUpdate(final Tenant tenant, final Map<String, TenantConfiguration> knownTenantConfigurations) {
        String tenantType = tenant.isSandbox() ? "Sandox" : "Tenant";
        if (!knownTenantConfigurations.containsKey(tenant.getKey())) {
            String errorMsg = String.format("%s: %s, key: %s does not exist. Please update another %s, or create a new one.",
                    tenantType, tenant.getName(), tenant.getKey(), tenantType);
            throw new NoSuchElementException(errorMsg);
        }
    }

    /**
     * @param tenant                    or sandbox to verify if it exists
     * @param knownTenantConfigurations all current Tenant & sandbox Configurations
     */
    private void verifyTenantTypeMatchesExisting(final Tenant tenant, final Map<String, TenantConfiguration> knownTenantConfigurations) {
        TenantConfiguration knownTenantConfiguration = knownTenantConfigurations.get(tenant.getKey());
        if (knownTenantConfiguration.getTenant().isSandbox() != tenant.isSandbox()) {
            String errorMsg = String.format("Tenant %s with key %s is not marked as the same tenant type as existing configuration.",
                    tenant.getName(), tenant.getKey());
            throw new IllegalArgumentException(errorMsg);
        }
    }


    /**
     * @param tenantConfiguration       the new tenantConfiguration to validate its Archive S3 properties are unique
     * @param knownTenantConfigurations all current Tenant & sandbox Configurations
     */
    private void verifyTenantArchive(final TenantConfiguration tenantConfiguration, final Map<String, TenantConfiguration> knownTenantConfigurations) {
        final ArchivePropertiesTenant archiveProperties = tenantConfiguration.getArchiveProperties();
        if (archiveProperties != null && archivePrefixExists(archiveProperties.getPathPrefix(), knownTenantConfigurations)) {
            String errorMsg = String.format("Tenant: %s, key: %s, the archive property :prefix exists already. " +
                            "Please use another Archive prefix for the new Tenant.",
                    tenantConfiguration.getTenant().getName(), tenantConfiguration.getTenant().getKey());
            throw new IllegalArgumentException(errorMsg);
        }
    }

    /**
     * Verifies if the given Tenant's DataSources already exist in a configured Tenant, except for OlAP datasources
     * which have their own set of validation rules to adhere too.
     * Throws an exception with the specific datasource name where the database was found
     *
     * @param tenantConfiguration       the new tenantConfiguration to validate its databases
     * @param knownTenantConfigurations all current Tenant & sandbox Configurations
     */
    private void verifyTenantDataSources(final TenantConfiguration tenantConfiguration, final Map<String, TenantConfiguration> knownTenantConfigurations) {
        // check each datasource
        for (Map.Entry<String, DataSourceElementsTenant> dataSource : tenantConfiguration.getDataSources().entrySet()) {
            if (dataSource.getValue().getUrlParts() == null) {
                // default tenant information is not configured properly
                String errorMsg = String.format("Cannot create Tenant: %s, key: %s, the Database property %s is not configure correctly." +
                                " Please contact your admin.",
                        tenantConfiguration.getTenant().getName(), tenantConfiguration.getTenant().getKey(),
                        dataSource.getKey());
                throw new IllegalArgumentException(errorMsg);
            }
            if (!isOlapDatasource(dataSource.getKey())) {
                if (dataSourceExists(dataSource.getKey(), dataSource.getValue().getUrlParts().getDatabase(), knownTenantConfigurations)) {
                    String errorMsg = String.format("Cannot create Tenant: %s, key: %s, the Database property %s exists already for DataSource %s." +
                                    " Please use another database for the new Tenant.",
                            tenantConfiguration.getTenant().getName(), tenantConfiguration.getTenant().getKey(),
                            dataSource.getValue().getUrlParts().getDatabase(), dataSource.getKey());
                    logger.error(errorMsg);
                    throw new IllegalArgumentException(errorMsg);
                }
            } else if (!dataSourceOlapDataSourceIsValid(dataSource.getValue(), knownTenantConfigurations)) {
                // it the Olap datasource
                String errorMsg = String.format("Cannot create Tenant: %s key: %s, the Olap DataSource's userName %s already exists " +
                                "or the database %s does not match the default database. Please use a unique username and the same database for the new Tenant.",
                        tenantConfiguration.getTenant().getName(), tenantConfiguration.getTenant().getKey(),
                        dataSource.getValue().getUsername(), dataSource.getValue().getUrlParts().getDatabase());
                throw new IllegalArgumentException(errorMsg);
            }
        }
    }

    /**
     * @param prefix                    of the archive property to validate, it must contain a value
     * @param knownTenantConfigurations all current Tenant & sandbox Configurations
     * @return true if the prefix currently exists in the known tenantConfigurations or is null or empty
     */
    private boolean archivePrefixExists(final String prefix, final Map<String, TenantConfiguration> knownTenantConfigurations) {
        if (prefix == null || prefix.isEmpty()) {
            return true;
        }
        for (Map.Entry<String, TenantConfiguration> tenant : knownTenantConfigurations.entrySet()) {
            if (tenant.getValue().getArchiveProperties() != null &&
                    tenant.getValue().getArchiveProperties().getPathPrefix().equals(prefix)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Do not check the olap dataSource.urParts.database as unique - it actually need to exist
     * will be tested in another method
     *
     * @param dataSource                name of the database to validate
     * @param dataSourceDatabase        name, should be unique across all tenants for this dataSource
     * @param knownTenantConfigurations all current Tenant & sandbox Configurations
     * @return true if the database exists in another tenant's same dataSource, or is null or empty
     */
    private boolean dataSourceExists(final String dataSource, final String dataSourceDatabase, final Map<String, TenantConfiguration> knownTenantConfigurations) {
        if (dataSourceDatabase == null || dataSourceDatabase.isEmpty()) {
            return true;
        }
        for (Map.Entry<String, TenantConfiguration> tenant : knownTenantConfigurations.entrySet()) {
            // now check each tenant's dataSource Map to see if the database exists.
            // But do not check the olap dataSources
            if (!isOlapDatasource(tenant.getKey())) {
                // non olap dataSource - check there are url parts to check, if not log a warning and continue
                if (tenant.getValue().getDataSources().get(dataSource) == null ||
                        tenant.getValue().getDataSources().get(dataSource).getUrlParts() == null ||
                        tenant.getValue().getDataSources().get(dataSource).getUrlParts().getDatabase() == null) {
                    logger.warn("DataSource {} for existing tenant {} is not configured correctly. Please contact your admin.", dataSource, tenant.getKey());
                } else if (tenant.getValue().getDataSources().get(dataSource).getUrlParts().getDatabase().equals(dataSourceDatabase)) {
                    return true;
                }
            } // ignore olap dataSource - olap has its own validation
        }
        return false;
    }

    /**
     * @param olapDataSource            to verify. The username cannot exist in another olap dataSource and must be 16 chars or less,
     *                                  and the schemaSearchPath MUST exist in another olap dataSource.
     *                                  Neither username nor schemaSearchPath can be null or empty
     * @param knownTenantConfigurations all current Tenant & sandbox Configurations
     * @return true means it is ok to create, returns false if the dataSource is not valid to create a tenant
     */
    private boolean dataSourceOlapDataSourceIsValid(final DataSourceElementsTenant olapDataSource,
                                                    final Map<String, TenantConfiguration> knownTenantConfigurations) {
        if (olapDataSource.getUsername() == null || olapDataSource.getUsername().isEmpty() ||
                olapDataSource.getSchemaSearchPath() == null || olapDataSource.getSchemaSearchPath().isEmpty()) {
            return false;
        }
        boolean olapDSIsValid = olapDataSourceIsValid(olapDataSource, knownTenantConfigurations);
        // also verify the userName length, false means it's Ok to create, and true means do not create
        return olapDSIsValid && olapDataSource.getUsername().length() <= USERNAME_MAX_SIZE;
    }

    /**
     * @param olapDataSource check if username exists, it must be unique to create a new olap dataSource
     *                       and check that schemaSearchPath exists in an existing olapDataSource
     * @return true if username does not exist in another tenant's olap_ro datasource and
     * if the schemaSearchPath does exist in another tenant's olap_ro datasource
     */
    private boolean olapDataSourceIsValid(final DataSourceElementsTenant olapDataSource,
                                          final Map<String, TenantConfiguration> knownTenantConfigurations) {
        for (Map.Entry<String, TenantConfiguration> tenant : knownTenantConfigurations.entrySet()) {
            // now check each tenant's dataSource Map to check the olap_ro datasource's username - it must be unique
            for (Map.Entry<String, DataSourceElementsTenant> dataSource : tenant.getValue().getDataSources().entrySet()) {
                // both the user name must be unique and the schemaSearchPath must exist - invalid if either is true
                if (isOlapDatasource(dataSource.getKey()) &&
                        (dataSource.getValue().getUsername().equals(olapDataSource.getUsername()) ||
                                !dataSource.getValue().getSchemaSearchPath().equals(olapDataSource.getSchemaSearchPath()))) {
                    return false;
                }
            }
        }
        // it is a valid olap datasource to use for create
        return true;
    }

    /**
     * @param dataSourceName to validate if olap dataSource
     * @return true if an olap dataSource
     */
    private boolean isOlapDatasource(String dataSourceName) {
        return dataSourceName.contains(RdwDatabaseType.REPORTING_OLAP.datasourceNameHint);
    }
}
