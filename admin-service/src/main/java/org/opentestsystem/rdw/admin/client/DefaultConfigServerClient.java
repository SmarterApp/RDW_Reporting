package org.opentestsystem.rdw.admin.client;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.RestTemplate;

import java.util.Optional;

/**
 * Client to retrieve the config server's uri to call the encrypt decrypt and monitor endpoints
 */
public class DefaultConfigServerClient implements ConfigServerClient {
    private static final Logger logger = LoggerFactory.getLogger(DefaultConfigServerClient.class);

    //@Value("${spring.cloud.config.uri}")
    private String configServerUri;
    private RestTemplate restTemplate = new RestTemplate();

    @Autowired
    public DefaultConfigServerClient(@Value("${spring.cloud.config.uri}") final String configServerUri) {
        this.configServerUri = configServerUri;
    }

    @Override
    public void postMonitor() {
        try {
            // todo fix this
            HttpHeaders headers = getHeaders();
            HttpEntity<String> request = new HttpEntity<>("path=*", headers);
            ResponseEntity<String> responseEntity = restTemplate.postForEntity(configServerUri + "/monitor", request, String.class);
            logger.debug("Successfully called {}/encrypt returned {}.", configServerUri, responseEntity.getStatusCode());
        } catch (Exception e) {
            logger.debug("Cannot contact {}/monitor at this time.", configServerUri);
        }
    }

    @Override
    public Optional<String> getActualServicePassword(final String service, final String dataSource) {
        // will need to know which service is being called - or I go get all of the passwords
        //todo work on this call
        try {
            ResponseEntity<String> responseEntity = restTemplate.getForEntity(configServerUri + service +"/awsuat", String.class);
            logger.debug("Successfully called {}/tbd returned {}.", configServerUri, responseEntity.getStatusCode());
            return Optional.of(responseEntity.getBody());
        } catch (Exception e) {
            logger.debug("Cannot contact {}/tbd at this time.", configServerUri);
        }
        return Optional.empty();
    }

    @Override
    public Optional<String> encryptedPassword(final String encryptedPassword) {
        try {
            HttpHeaders headers = getHeaders();
            HttpEntity<String> request = new HttpEntity<>(encryptedPassword, headers);
            ResponseEntity<String> responseEntity = restTemplate.postForEntity(configServerUri + "/encrypt", request, String.class);
            logger.debug("Successfully called {}/encrypt returned {}.", configServerUri, responseEntity.getStatusCode());
            return Optional.of(responseEntity.getBody());
        } catch (Exception e) {
            logger.debug("Cannot contact {}/monitor at this time.", configServerUri);
        }
        return Optional.empty();
    }

    /**
     * @return httpHeaders for Text plain contentType
     */
    private HttpHeaders getHeaders() {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.TEXT_PLAIN);
        return headers;
    }

    @Override
    public Optional<String> decryptedPassword(final String password) {
        // remove a {cipher} prefix if exists

        try {
            HttpHeaders headers = getHeaders();
            HttpEntity<String> request = new HttpEntity<>(password, headers);
            ResponseEntity<String> responseEntity = restTemplate.postForEntity(configServerUri + "/decrypt", request, String.class);
            logger.debug("Successfully called {}/decrypt returned {}.", configServerUri, responseEntity.getStatusCode());
            return Optional.of(responseEntity.getBody());
        } catch (Exception e) {
            logger.debug("Cannot contact {} for /monitor at this time.", configServerUri);
        }
        return Optional.empty();
    }
}
