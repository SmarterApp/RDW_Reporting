package org.opentestsystem.rdw.admin.service.impl;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import org.apache.commons.lang.RandomStringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.opentestsystem.rdw.admin.client.ConfigServerClient;
import org.opentestsystem.rdw.admin.model.ApplicationSandboxConfigurations;
import org.opentestsystem.rdw.admin.model.SandboxConfiguration;
import org.opentestsystem.rdw.admin.model.SandboxConfigurationPackage;
import org.opentestsystem.rdw.admin.model.TenantConfiguration;
import org.opentestsystem.rdw.admin.model.TenantConfigurationStubs;
import org.opentestsystem.rdw.admin.multitenant.DataSet;
import org.opentestsystem.rdw.admin.multitenant.SandboxDataSets;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationRequestHandler;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatusService;
import org.opentestsystem.rdw.admin.repository.SandboxConfigurationRepository;
import org.opentestsystem.rdw.admin.service.SandboxService;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.multitenant.TenantProperties;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsTenant;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceUrlParts;
import org.opentestsystem.rdw.reporting.common.multitenant.ReportingTenantIdResolver;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;


/**
 * Default service to manage Sandbox Configurations
 *
 * @deprecated Please use {@link DefaultTenantService} instead
 */
@Service
@Deprecated
public class DefaultSandboxService implements SandboxService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultSandboxService.class);


    private final SandboxConfigurationRepository sandboxConfigurationRepository;
    private final ReportingTenantIdResolver reportingTenantIdResolver;
    private final DefaultTenantConfigPropsService defaultTenantConfigPropsService;
    private final TenantProperties tenantProperties;
    private final SandboxDataSets sandboxDatasets;
    private final TenantAdministrationRequestHandler tenantAdministrationRequestHandler;
    private final TenantAdministrationStatusService tenantAdministrationStatusService;
    private final ConfigServerClient configServerClient;

    @Autowired
    DefaultSandboxService(SandboxConfigurationRepository sandboxConfigurationRepository,
                          ReportingTenantIdResolver reportingTenantIdResolver,
                          DefaultTenantConfigPropsService defaultTenantConfigPropsService,
                          TenantProperties tenantProperties,
                          SandboxDataSets sandboxDatasets,
                          TenantAdministrationRequestHandler tenantAdministrationRequestHandler,
                          TenantAdministrationStatusService tenantAdministrationStatusService,
                          ConfigServerClient configServerClient) {
        this.sandboxConfigurationRepository = sandboxConfigurationRepository;
        this.reportingTenantIdResolver = reportingTenantIdResolver;
        this.defaultTenantConfigPropsService = defaultTenantConfigPropsService;
        this.tenantProperties = tenantProperties;
        this.sandboxDatasets = sandboxDatasets;
        this.tenantAdministrationRequestHandler = tenantAdministrationRequestHandler;
        this.tenantAdministrationStatusService = tenantAdministrationStatusService;
        this.configServerClient = configServerClient;
    }

    @Override
    public ApplicationSandboxConfigurations getAll() {
        ApplicationSandboxConfigurations applicationSandboxConfigurations = new ApplicationSandboxConfigurations();
        Map<String, SandboxConfiguration> sandboxConfigurationMap = getSandboxConfigurationFromTenantProperties();
        //todo remove once calling real create
        if (sandboxConfigurationRepository.getAll().isEmpty()) {
            sandboxConfigurationMap.forEach((k, v) -> sandboxConfigurationRepository.create(v));
        }
        // todo replace with sandboxConfigurationMap  once calling real create
        applicationSandboxConfigurations.setSandboxes(sandboxConfigurationRepository.getAll());

        final SandboxConfigurationPackage sandboxConfigurationPackage = getCurrentDefaultSandboxPackage();
        applicationSandboxConfigurations.setSandboxConfigurationPackage(sandboxConfigurationPackage);
        logger.debug("Returning default tenantKey {} and the current sandbox configurations with {} sandboxes configured.",
                getCurrentTenantKey(), applicationSandboxConfigurations.getSandboxes().size());
        return applicationSandboxConfigurations;
    }

    @Override
    public SandboxConfiguration create(final SandboxConfiguration sandboxConfiguration) {
        String sandboxKey = generateKey(sandboxConfiguration.getParentTenantKey());
        sandboxConfiguration.getSandbox().setKey(sandboxKey);
        sandboxConfiguration.getSandbox().setId(sandboxKey);
        logger.debug("Creating sandbox with new key and id {}", sandboxKey);

        //TODO: remove in memory, use live data, check for unique
        validateNewSandbox(sandboxConfiguration);


        //TODO: need to set up a "base" sandbox datasource elements config that has lowered resources compared to tenants
        //TODO: these will need to be encrypted prior to saving to git, but decrypted during creation?
        String sandboxDbPassword = createRandomPassword();
        Map<String, DataSourceElementsTenant> generateDataSourceElementsMap =
                generateDataSourceElementsMap(sandboxKey, sandboxDbPassword);

        //TODO: Set S3 prefix

        //TODO: get parent config for reporting / internationalization, overlay with provided? (is this being handled client side?)

        //TODO: actually all the sandbox creation
        return sandboxConfigurationRepository.create(sandboxConfiguration);
    }

    @Override
    public SandboxConfiguration update(final SandboxConfiguration sandboxConfiguration) {
        logger.debug("Updating with sandbox with key = {}", sandboxConfiguration.getSandbox().getKey());
        validateExistingSandbox(sandboxConfiguration);
        // TODO actually all the sandbox update
        return sandboxConfigurationRepository.update(sandboxConfiguration);
    }

    @Override
    public void delete(final String key) {
        logger.debug("removing the sandbox key {}", key);
        // TODO actually all the sandbox delete
        sandboxConfigurationRepository.delete(key);
    }

    @Override
    public void resetDataSet(String key) {
        logger.info("Resetting the DataSet for the Sandbox key {}", key);
        // todo actually reset the data - just calling a inMemory func for now
        sandboxConfigurationRepository.reset(key);
    }

    @Override
    public List<DataSet> getSandboxDataSets() {
        return sandboxDatasets == null ? ImmutableList.of() : ImmutableList.copyOf(sandboxDatasets.getSandboxDatasets());
    }

    // TODO Remove this method once the SandboxPackage is removed
    private Set<DataSet> getDataSets() {
        return ImmutableSet.copyOf(getSandboxDataSets());
    }

//    private Function<ApplicationTenantConfiguration, ApplicationSandboxConfiguration> applicationTenantConfigurationToApplicationSandboxConfiguration = applicationTenantConfiguration -> {
//        ApplicationSandboxConfiguration applicationSandboxConfiguration = new ApplicationSandboxConfiguration();
//        applicationSandboxConfiguration.setReporting(applicationTenantConfiguration.getReporting());
//        applicationSandboxConfiguration.setAggregateReportingPropertiesTenant(applicationTenantConfiguration.getAggregateReportingPropertiesTenant());
//        return applicationSandboxConfiguration;
//    };

    /**
     * Create a SandboxConfiguration from a TenantConfiguration
     */
    private Function<Pair<TenantAdministrationStatus, TenantConfiguration>, SandboxConfiguration> tenantConfigurationToSandboxConfiguration = tenantConfiguration -> {
        SandboxConfiguration sandboxConfiguration = new SandboxConfiguration();
        sandboxConfiguration.setTenantAdministrationStatus(tenantConfiguration.getLeft());
        sandboxConfiguration.setSandbox(tenantConfiguration.getRight().getTenant());
        sandboxConfiguration.setLocalization(tenantConfiguration.getRight().getLocalization());
//        ApplicationSandboxConfiguration applicationSandboxConfiguration = applicationTenantConfigurationToApplicationSandboxConfiguration
//                //.apply(tenantConfiguration.getRight().getApplicationTenantConfiguration());
//        .apply(null);
//        sandboxConfiguration.setApplicationSandboxConfiguration(applicationSandboxConfiguration);
        return sandboxConfiguration;
    };

    /**
     * Create a TenantConfiguration from a SandboxConfiguration to send to create and update sandbox functions
     */
    //TODO: this is only used in Tests, remove from here?
    public Function<SandboxConfiguration, TenantConfiguration> sandboxConfigurationToTenantConfiguration = sandboxConfiguration -> {
        TenantConfiguration tenantConfiguration = new TenantConfiguration();
        tenantConfiguration.setTenant(sandboxConfiguration.getSandbox());
        tenantConfiguration.getTenant().setSandbox(true);
        tenantConfiguration.setAggregateReportingPropertiesTenant(sandboxConfiguration.getApplicationSandboxConfiguration().getAggregateReportingPropertiesTenant());
        tenantConfiguration.setReporting(sandboxConfiguration.getApplicationSandboxConfiguration().getReporting());
        return tenantConfiguration;
    };

    /**
     * If active sandboxKey is found in the tenantAdministrationStatusService then this needs to remove that entry
     *
     * @return a map of SandboxConfiguration created from the tenantProperties & tenantAdministrationStatusService
     */
    private Map<String, SandboxConfiguration> getSandboxConfigurationFromTenantProperties() {

        //gather sandbox tenants currently configured in tenantProperties
        Map<String, Tenant> currentSandboxTenants = tenantProperties.getTenants()
                .entrySet()
                .stream()
                .filter(entry -> entry.getValue().isSandbox())
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));

        //snapshot of tenant status service state
        ImmutableMap<String, Pair<TenantAdministrationStatus, TenantConfiguration>> currentAllTenantStatus =
                tenantAdministrationStatusService
                        .allTenantStatusAsMap();

        //gather sandbox tenant status currently in the status service
        Map<String, TenantAdministrationStatus> currentSandboxTenantStatus = currentAllTenantStatus
                .entrySet()
                .stream()
                .filter(entry -> entry.getValue().getRight().getTenant().isSandbox())
                .collect(Collectors.toMap(Map.Entry::getKey,
                        e -> e.getValue().getLeft()));

        //set of keys that have a status and also exist in the current set of tenants
        Set<String> statusStaleKeysWithExistingTenant = currentSandboxTenantStatus
                .keySet()
                .stream()
                .filter(currentSandboxTenants::containsKey)
                .collect(Collectors.toSet());

        //side effect: clean up the status for sandbox tenants that are stale
        statusStaleKeysWithExistingTenant.forEach(k -> tenantAdministrationStatusService.remove(k));

        //sandbox tenant status with no matching current sandbox tenants
        Map<String, TenantAdministrationStatus> activeCurrentSandboxTenantStatus = currentSandboxTenantStatus
                .entrySet()
                .stream()
                .filter(entry -> !statusStaleKeysWithExistingTenant.contains(entry.getKey()))
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));

        //TODO: consolidating types will remove most of this
        Map<String, SandboxConfiguration> inProcessSanboxConfigurations = activeCurrentSandboxTenantStatus.entrySet()
                .stream()
                .map(entry -> {
                    String key = entry.getKey();
                    TenantAdministrationStatus status = entry.getValue();
                    TenantConfiguration configuration = currentAllTenantStatus.get(key).getRight();
                    SandboxConfiguration sandboxConfiguration = new SandboxConfiguration();
                    sandboxConfiguration.setTenantAdministrationStatus(status);
                    sandboxConfiguration.setSandbox(configuration.getTenant());
                    sandboxConfiguration.setLocalization(configuration.getLocalization());
                    //ApplicationSandboxConfiguration applicationSandboxConfiguration = applicationTenantConfigurationToApplicationSandboxConfiguration
                    //        .apply(configuration.getApplicationTenantConfiguration());
                    //'/.apply(null);
                    //sandboxConfiguration.setApplicationSandboxConfiguration(applicationSandboxConfiguration);
                    return ImmutablePair.of(key, sandboxConfiguration);
                })
                .collect(Collectors.toMap(Pair::getLeft, Pair::getRight));

        //TODO: consolidating types will remove most of this
        Map<String, SandboxConfiguration> existingProcessSanboxConfigurations = currentSandboxTenants
                .entrySet()
                .stream()
                .map(entry -> {
                    String key = entry.getKey();
                    Tenant tenant = entry.getValue();
                    //ApplicationTenantConfiguration applicationTenantConfiguration = defaultTenantConfigPropsService.getTenantAppConfiguration(key);
                    SandboxConfiguration sandboxConfiguration = new SandboxConfiguration();
                    sandboxConfiguration.setSandbox(tenant);
                    //TODO: where do I get localization?
                    //sandboxConfiguration.setLocalization();
//                    ApplicationSandboxConfiguration applicationSandboxConfiguration = applicationTenantConfigurationToApplicationSandboxConfiguration
//                            .apply(applicationTenantConfiguration);
//                    sandboxConfiguration.setApplicationSandboxConfiguration(applicationSandboxConfiguration);
                    return ImmutablePair.of(key, sandboxConfiguration);
                })
                .collect(Collectors.toMap(Pair::getLeft, Pair::getRight));

        Stream<Map.Entry<String, SandboxConfiguration>> combined =
                Stream.concat(inProcessSanboxConfigurations.entrySet().stream(),
                        existingProcessSanboxConfigurations.entrySet().stream());

        return combined.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    /**
     * @return SandboxConfigurationPackage containing the default sandbox properties, the datasets and the list of current sandboxes
     */
    private SandboxConfigurationPackage getCurrentDefaultSandboxPackage() {
        defaultTenantConfigPropsService.servicesPropertiesRefresh();
        final SandboxConfigurationPackage sandboxConfigurationPackage = new SandboxConfigurationPackage();
        //ApplicationSandboxConfiguration applicationSandboxConfiguration = defaultTenantConfigPropsService.getDefaultApplicationSandboxConfiguration("XX");

        // Add the preconfigured DatSets to default package
        sandboxConfigurationPackage.setDataSets(getDataSets());

        //sandboxConfigurationPackage.setApplicationSandboxConfiguration(applicationSandboxConfiguration);
        final Optional<Tenant> tenant = tenantProperties.findTenantById(getCurrentTenantKey());
        if (tenant.isPresent()) {
            sandboxConfigurationPackage.setTenant(tenant.get());
        } else {
            logger.error("Cannot retrieve the current Tenant Info, only setting key & Id, and the rest with mock CA data");
            sandboxConfigurationPackage.setTenant(TenantConfigurationStubs.getTenantCA());
            sandboxConfigurationPackage.getTenant().setKey(getCurrentTenantKey());
            sandboxConfigurationPackage.getTenant().setId(getCurrentTenantKey());
        }

        return sandboxConfigurationPackage;
    }

    /**
     * @param sandboxConfiguration to validate if it's ok to create a new sandbox
     */
    private void validateNewSandbox(final SandboxConfiguration sandboxConfiguration) {
        // TODO update with full if exists checks
        if (sandboxConfigurationRepository.exists(sandboxConfiguration.getSandbox().getKey())) {
            String errorMsg = "Sandbox: " + sandboxConfiguration.getSandbox().getName() +
                    " key: " + sandboxConfiguration.getSandbox().getKey() + " exists already. Please update existing sandbox, or create another sandbox.";
            logger.error(errorMsg);
            throw new IllegalArgumentException(errorMsg);
        }
    }

    /**
     * @return the current TenantKey
     */
    private String getCurrentTenantKey() {
        //TODO: not sure this will always work need to discuss with team
        if (reportingTenantIdResolver.getTenantId().isPresent()) {
            return reportingTenantIdResolver.getTenantId().get();
        }
        String errorMsg = "A Tenant must be configured to create a Sandbox.";
        logger.error(errorMsg);
        throw new IllegalArgumentException(errorMsg);
    }

    /**
     * @param sandboxConfiguration to validate if it's ok to update the sandbox
     */
    private void validateExistingSandbox(final SandboxConfiguration sandboxConfiguration) {
        // TODO update with full if exists checks
        if (!sandboxConfigurationRepository.exists(sandboxConfiguration.getSandbox().getKey())) {
            String errorMsg = "Sandbox: " + sandboxConfiguration.getSandbox().getName() +
                    " key: " + sandboxConfiguration.getSandbox().getKey() + " not found.";
            logger.error(errorMsg);
            throw new NoSuchElementException(errorMsg);
        }
    }

    /**
     * @return a tenant based key
     */
    @VisibleForTesting
    String generateKey(String parentTenantKey) {
        final int maxConfigured = tenantProperties.getTenants().values().stream()
                .filter(Tenant::isSandbox)
                .filter(tenant -> tenant.getKey().startsWith(parentTenantKey))
                .map(Tenant::getKey)
                .filter(key -> key.length() > 2)
                .map(key -> key.substring(key.length() - 3))
                .map(Integer::parseInt)
                .max(Integer::compare)
                .orElse(0);

        final int maxStatus = tenantAdministrationStatusService.allTenantKeys().stream()
                .filter(key -> key.contains(parentTenantKey + "_S"))
                .filter(key -> key.length() > 2)
                .map(key -> key.substring(key.length() - 3))
                .map(Integer::parseInt)
                .max(Integer::compare)
                .orElse(0);

        final int max = Integer.max(maxConfigured, maxStatus);

        return parentTenantKey + "_" + "S" + String.format("%03d", max + 1);
    }

    @VisibleForTesting
    Map<String, DataSourceElementsTenant> generateDataSourceElementsMap(String sandboxKey, String databasePassword) {
        String dbUsername = sandboxKey.replaceAll("_", "").toLowerCase();
        String dbPostfix = "_" + sandboxKey.toLowerCase();

        return new ImmutableMap.Builder<String, DataSourceElementsTenant>()
                .put("olap_ro", createDataSourceElements(dbUsername, databasePassword, "reporting" + dbPostfix, null))
                .put("olap_rw", createDataSourceElements(dbUsername, databasePassword, "reporting" + dbPostfix, null))
                .put("reporting_ro", createDataSourceElements(dbUsername, databasePassword, null, "reporting" + dbPostfix))
                .put("reporting_rw", createDataSourceElements(dbUsername, databasePassword, null, "reporting" + dbPostfix))
                .put("warehouse_ro", createDataSourceElements(dbUsername, databasePassword, null, "warehouse" + dbPostfix))
                .put("warehouse_rw", createDataSourceElements(dbUsername, databasePassword, null, "warehouse" + dbPostfix))
                .put("migrate_rw", createDataSourceElements(dbUsername, databasePassword, null, "migrate_olap" + dbPostfix))
                .build();
    }

    private DataSourceElementsTenant createDataSourceElements(String username,
                                                              String password,
                                                              String schemaSearchPath,
                                                              String databaseName) {
        DataSourceElementsTenant dataSourceElementsTenant = new DataSourceElementsTenant();
        dataSourceElementsTenant.setUsername(username);
        dataSourceElementsTenant.setPassword(password);
        dataSourceElementsTenant.setSchemaSearchPath(schemaSearchPath);
        DataSourceUrlParts dataSourceUrlParts = new DataSourceUrlParts();
        dataSourceUrlParts.setDatabase(databaseName);
        dataSourceElementsTenant.setUrlParts(dataSourceUrlParts);
        return dataSourceElementsTenant;
    }

    private String createRandomPassword() {
        //Match the Redshift requirements
        final String letters = RandomStringUtils.random(1, true, false).toUpperCase() +
                RandomStringUtils.random(5, true, false).toLowerCase();
        final String numbers = RandomStringUtils.random(2, false, true);
        return letters + numbers;
    }

}
