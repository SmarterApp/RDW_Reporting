package org.opentestsystem.rdw.admin.service.impl;

import org.apache.commons.lang3.tuple.Pair;
import org.opentestsystem.rdw.admin.model.ApplicationSandboxConfiguration;
import org.opentestsystem.rdw.admin.model.ApplicationSandboxConfigurations;
import org.opentestsystem.rdw.admin.model.ApplicationTenantConfiguration;
import org.opentestsystem.rdw.admin.model.SandboxConfiguration;
import org.opentestsystem.rdw.admin.model.SandboxConfigurationPackage;
import org.opentestsystem.rdw.admin.model.TenantConfiguration;
import org.opentestsystem.rdw.admin.model.TenantConfigurationStubs;
import org.opentestsystem.rdw.admin.multitenant.SandboxDataSets;
import org.opentestsystem.rdw.admin.multitenant.TenantAdministrationStatus;
import org.opentestsystem.rdw.admin.multitenant.TenantAdministrationStatusService;
import org.opentestsystem.rdw.admin.repository.SandboxConfigurationRepository;
import org.opentestsystem.rdw.admin.service.SandboxService;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.multitenant.TenantProperties;
import org.opentestsystem.rdw.reporting.common.multitenant.ReportingTenantIdResolver;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.function.Function;

/**
 * Default service to manage Sandbox Configurations
 */
@Service
public class DefaultSandboxService implements SandboxService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultSandboxService.class);

    private SandboxConfigurationRepository sandboxConfigurationRepository;
    private ReportingTenantIdResolver reportingTenantIdResolver;
    private DefaultTenantConfigPropsService defaultTenantConfigPropsService;
    private TenantProperties tenantProperties;
    private SandboxDataSets sandboxDatasets;
    private TenantAdministrationStatusService tenantAdministrationStatusService;


    @Autowired
    DefaultSandboxService(SandboxConfigurationRepository sandboxConfigurationRepository,
                          ReportingTenantIdResolver reportingTenantIdResolver, DefaultTenantConfigPropsService defaultTenantConfigPropsService,
                          TenantProperties tenantProperties, SandboxDataSets sandboxDatasets,
                          TenantAdministrationStatusService tenantAdministrationStatusService) {
        this.sandboxConfigurationRepository = sandboxConfigurationRepository;
        this.reportingTenantIdResolver = reportingTenantIdResolver;
        this.defaultTenantConfigPropsService = defaultTenantConfigPropsService;
        this.tenantProperties = tenantProperties;
        this.sandboxDatasets = sandboxDatasets;
        this.tenantAdministrationStatusService = tenantAdministrationStatusService;
    }

    @Override
    public ApplicationSandboxConfigurations getAll() {
        ApplicationSandboxConfigurations applicationSandboxConfigurations = new ApplicationSandboxConfigurations();
        Map<String, SandboxConfiguration> sandboxConfigurationMap = getSandboxConfigurationFromTenantProperties();
        //todo remove once calling real create
        if (sandboxConfigurationRepository.getAll().isEmpty()) {
            sandboxConfigurationMap.forEach((k, v) -> {
                sandboxConfigurationRepository.create(v);
            });
        }
        // todo replace with sandboxConfigurationMap  once calling real create
        applicationSandboxConfigurations.setSandboxes(sandboxConfigurationRepository.getAll());

        final SandboxConfigurationPackage sandboxConfigurationPackage = getCurrentDefaultSandboxPackage();
        applicationSandboxConfigurations.setSandboxConfigurationPackage(sandboxConfigurationPackage);
        logger.debug("Returning default tenantKey {} and the current sandbox configurations with {} sandboxes configured.",
                getCurrentTenantKey(), applicationSandboxConfigurations.getSandboxes().size());
        return applicationSandboxConfigurations;
    }

    @Override
    public SandboxConfiguration create(final SandboxConfiguration sandboxConfiguration) {
        //generate a new sandbox id with the current TenantKey
        String newId = generateId(getCurrentTenantKey());
        logger.info("Creating sandbox with new Id {}", newId);
        // make the id & key the same value
        // setting in sandboxConfiguration for validation
        sandboxConfiguration.getSandbox().setKey(newId);
        sandboxConfiguration.getSandbox().setId(newId);
        sandboxConfiguration.setParentTenantKey(getCurrentTenantKey());
        validateNewSandbox(sandboxConfiguration);
        // TODO actually all the sandbox creation
        return sandboxConfigurationRepository.create(sandboxConfiguration);
    }

    @Override
    public SandboxConfiguration update(final SandboxConfiguration sandboxConfiguration) {
        logger.debug("Updating with sandbox with key = {}", sandboxConfiguration.getSandbox().getKey());
        validateExistingSandbox(sandboxConfiguration);
        // TODO actually all the sandbox update
        return sandboxConfigurationRepository.update(sandboxConfiguration);
    }

    @Override
    public void delete(final String key) {
        logger.debug("removing the sandbox key {}", key);
        // TODO actually all the sandbox delete
        sandboxConfigurationRepository.delete(key);
    }

    @Override
    public void resetDataSet(String key) {
        logger.info("Resetting the DataSet for the Sandbox key {}", key);
        // todo actually reset the data - just calling a inMemory func for now
        sandboxConfigurationRepository.reset(key);
    }

    /**
     * Create a SandboxConfiguration from a TenantConfiguration
     */
    private Function<TenantConfiguration, SandboxConfiguration> tenantConfigurationToSandboxConfiguration = tenantConfiguration -> {
        SandboxConfiguration sandboxConfiguration = new SandboxConfiguration();
        sandboxConfiguration.setSandbox(tenantConfiguration.getTenant());
        sandboxConfiguration.setLocalization(tenantConfiguration.getLocalization());
        ApplicationSandboxConfiguration applicationSandboxConfiguration = new ApplicationSandboxConfiguration();
        applicationSandboxConfiguration.setReporting(tenantConfiguration.getApplicationTenantConfiguration().getReporting());
        applicationSandboxConfiguration.setAggregateReportingPropertiesTenant(tenantConfiguration.getApplicationTenantConfiguration().getAggregateReportingPropertiesTenant());
        sandboxConfiguration.setApplicationSandboxConfiguration(applicationSandboxConfiguration);
        return sandboxConfiguration;
    };

    /**
     * Create a TenantConfiguration from a SandboxConfiguration to send to create and update sandbox functions
     */
    //TODO: this is only used in Tests, remove from here?
    public Function<SandboxConfiguration, TenantConfiguration> sandboxConfigurationToTenantConfiguration = sandboxConfiguration -> {
        TenantConfiguration tenantConfiguration = new TenantConfiguration();
        tenantConfiguration.setTenant(sandboxConfiguration.getSandbox());
        tenantConfiguration.getTenant().setSandbox(true);
        ApplicationTenantConfiguration applicationTenantConfiguration = new ApplicationTenantConfiguration();
        applicationTenantConfiguration.setAggregateReportingPropertiesTenant(sandboxConfiguration.getApplicationSandboxConfiguration().getAggregateReportingPropertiesTenant());
        applicationTenantConfiguration.setReporting(sandboxConfiguration.getApplicationSandboxConfiguration().getReporting());
        tenantConfiguration.setApplicationTenantConfiguration(applicationTenantConfiguration);
        return tenantConfiguration;
    };

    /**
     * If active sandboxKey is found in the tenantAdministrationStatusService then this needs to remove that entry
     *
     * @return a map of SandboxConfiguration created from the tenantProperties & tenantAdministrationStatusService
     */
    private Map<String, SandboxConfiguration> getSandboxConfigurationFromTenantProperties() {
        Map<String, SandboxConfiguration> sandboxConfigurationMap = new HashMap<>();
        // need the list of tenant/sandboxes Status being created
        Map<String, TenantAdministrationStatus> createTenantMap = tenantAdministrationStatusService.getTenants();

        // create SandboxConfiguration for active sandboxes
        Map<String, Tenant> tenants = tenantProperties.getTenants();
        tenants.forEach((key, t) -> {

            // only want sandboxes
            if (t.isSandbox()) {
                SandboxConfiguration sandboxConfiguration = new SandboxConfiguration();

                sandboxConfiguration.setSandbox(t);
                // sandbox.setTenantKey(); where to get

                // see the any of the currents exist in the createTenantMap
                if (createTenantMap.containsKey(t.getKey())) {
                    // if sandbox exists need to remove that tenant from the status Service
                    tenantAdministrationStatusService.remove(t.getKey());
                    createTenantMap.remove(t.getKey());
                }

                // each sandbox has it's own SandboxConfigurationPackage
                ApplicationSandboxConfiguration applicationSandboxConfiguration = new ApplicationSandboxConfiguration();
                sandboxConfiguration.setApplicationSandboxConfiguration(applicationSandboxConfiguration);
                // add to return list
                sandboxConfigurationMap.put(key, sandboxConfiguration);
            }
        });

        // now we can add any tenants/sandboxes found in the statusMap into the returned sandboxConfigurationMap
        createTenantMap.forEach((k, v) -> {
            Optional<Pair<TenantAdministrationStatus, TenantConfiguration>> tenantStatusMap = tenantAdministrationStatusService.findStatus(k);
            if (tenantStatusMap.isPresent()) {
                TenantConfiguration wipTenant = tenantStatusMap.get().getRight();
                if (wipTenant.getTenant().isSandbox()) {
                    logger.debug("Tenant's create from the status service is {} and if its a sandbox = {}",
                            wipTenant.getTenant().getCreated(), wipTenant.getTenant().isSandbox());
                    SandboxConfiguration sandboxConfiguration = tenantConfigurationToSandboxConfiguration.apply(wipTenant);
                    sandboxConfigurationMap.put(k, sandboxConfiguration);
                } // skip tenants in create status
            }
        });
        return sandboxConfigurationMap;
    }

    /**
     * @return SandboxConfigurationPackage containing the default sandbox properties, the datasets and the list of current sandboxes
     */
    private SandboxConfigurationPackage getCurrentDefaultSandboxPackage() {
        defaultTenantConfigPropsService.servicesPropertiesRefresh();
        final SandboxConfigurationPackage sandboxConfigurationPackage = new SandboxConfigurationPackage();
        ApplicationSandboxConfiguration applicationSandboxConfiguration = defaultTenantConfigPropsService.getDefaultApplicationSandboxConfiguration();

        // Add the preconfigured DatSets to default package
        sandboxConfigurationPackage.setDataSets(new HashSet<>(sandboxDatasets.getSandboxDatasets()));

        sandboxConfigurationPackage.setApplicationSandboxConfiguration(applicationSandboxConfiguration);
        final Optional<Tenant> tenant = tenantProperties.findTenantById(getCurrentTenantKey());
        if (tenant.isPresent()) {
            sandboxConfigurationPackage.setTenant(tenant.get());
        } else {
            logger.error("Cannot retrieve the current Tenant Info, only setting key & Id, and the rest with mock CA data");
            sandboxConfigurationPackage.setTenant(TenantConfigurationStubs.getTenantCA());
            sandboxConfigurationPackage.getTenant().setKey(getCurrentTenantKey());
            sandboxConfigurationPackage.getTenant().setId(getCurrentTenantKey());
        }

        return sandboxConfigurationPackage;
    }

    /**
     * @param sandboxConfiguration to validate if it's ok to create a new sandbox
     */
    private void validateNewSandbox(final SandboxConfiguration sandboxConfiguration) {
        // TODO update with full if exists checks
        if (sandboxConfigurationRepository.exists(sandboxConfiguration.getSandbox().getKey())) {
            String errorMsg = "Sandbox: " + sandboxConfiguration.getSandbox().getName() +
                    " key: " + sandboxConfiguration.getSandbox().getKey() + " exists already. Please update existing sandbox, or create another sandbox.";
            logger.error(errorMsg);
            throw new IllegalArgumentException(errorMsg);
        }
    }

    /**
     * @return the current TenantKey
     */
    private String getCurrentTenantKey() {
        if (reportingTenantIdResolver.getTenantId().isPresent()) {
            return reportingTenantIdResolver.getTenantId().get();
        }
        String errorMsg = "A Tenant must be configured to create a Sandbox.";
        logger.error(errorMsg);
        throw new IllegalArgumentException(errorMsg);
    }

    /**
     * @param sandboxConfiguration to validate if it's ok to update the sandbox
     */
    private void validateExistingSandbox(final SandboxConfiguration sandboxConfiguration) {
        // TODO update with full if exists checks
        if (!sandboxConfigurationRepository.exists(sandboxConfiguration.getSandbox().getKey())) {
            String errorMsg = "Sandbox: " + sandboxConfiguration.getSandbox().getName() +
                    " key: " + sandboxConfiguration.getSandbox().getKey() + " not found.";
            logger.error(errorMsg);
            throw new NoSuchElementException(errorMsg);
        }
    }

    /**
     * @return a tenant based ID - using a hash of the current time TODO Update or remove
     */
    private String generateId(String tenantId) {
        String ms = String.valueOf(System.currentTimeMillis());
        String ts = String.valueOf(ms.substring(7, 10).hashCode());
        logger.debug("hasCode is = {}", ts);
        return tenantId + "-" + ts;
    }
}
