package org.opentestsystem.rdw.admin.service.impl;

import org.opentestsystem.rdw.admin.model.ApplicationSandboxConfiguration;
import org.opentestsystem.rdw.admin.model.ApplicationSandboxConfigurations;
import org.opentestsystem.rdw.admin.model.SandboxConfiguration;
import org.opentestsystem.rdw.admin.model.SandboxConfigurationPackage;
import org.opentestsystem.rdw.admin.model.SandboxConfigurationStubs;
import org.opentestsystem.rdw.admin.model.TenantConfigurationStubs;
import org.opentestsystem.rdw.admin.repository.impl.InMemorySandboxConfigurationRepository;
import org.opentestsystem.rdw.admin.service.SandboxService;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.multitenant.TenantProperties;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingPropertiesTenant;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemPropertiesImpl;
import org.opentestsystem.rdw.reporting.common.multitenant.ReportingTenantIdResolver;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.NoSuchElementException;
import java.util.Optional;

/**
 * Default service to manage Sandbox Configurations
 */
@Service
public class DefaultSandboxService implements SandboxService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultSandboxService.class);

    private InMemorySandboxConfigurationRepository inMemorySandboxConfigurationRepository;
    private ReportingTenantIdResolver reportingTenantIdResolver;
    private DefaultTenantConfigPropsService defaultTenantConfigPropsService;
    private TenantProperties tenantProperties;


    @Autowired
    DefaultSandboxService(InMemorySandboxConfigurationRepository inMemorySandboxConfigurationRepository,
                          ReportingTenantIdResolver reportingTenantIdResolver, DefaultTenantConfigPropsService defaultTenantConfigPropsService,
                          TenantProperties tenantProperties) {
        this.inMemorySandboxConfigurationRepository = inMemorySandboxConfigurationRepository;
        this.reportingTenantIdResolver = reportingTenantIdResolver;
        this.defaultTenantConfigPropsService = defaultTenantConfigPropsService;
        this.tenantProperties = tenantProperties;
        // todo: remove mock - Populate with mock sandboxConfigurations at service start
        addMockData();
    }

    /**
     * TODO remove once retrieving real data
     */
    private void addMockData() {
        if(inMemorySandboxConfigurationRepository.getAll().isEmpty()) {
            SandboxConfiguration caSandbox = SandboxConfigurationStubs.getCaInterimSandboxConfiguration();
            caSandbox.getSandbox().setTenantKey(getCurrentTenantKey());
            SandboxConfiguration miSandbox = SandboxConfigurationStubs.getMiInterimSandboxConfiguration();
            miSandbox.getSandbox().setTenantKey(getCurrentTenantKey());
            inMemorySandboxConfigurationRepository.create(caSandbox);
            inMemorySandboxConfigurationRepository.create(miSandbox);
        }
    }

    @Override
    public ApplicationSandboxConfigurations getAll() {
        ApplicationSandboxConfigurations applicationSandboxConfigurations = new ApplicationSandboxConfigurations();
        applicationSandboxConfigurations.setSandboxes(inMemorySandboxConfigurationRepository.getAll());
        final SandboxConfigurationPackage sandboxConfigurationPackage = getCurrentDefaultSandboxPackage();
        applicationSandboxConfigurations.setSandboxConfigurationPackage(sandboxConfigurationPackage);
        logger.debug("Returning default tenantKey {} and the current sandbox configurations with {} sandboxes configured.",
                getCurrentTenantKey(), applicationSandboxConfigurations.getSandboxes().size());
        return applicationSandboxConfigurations;
    }

    @Override
    public SandboxConfiguration create(final SandboxConfiguration sandboxConfiguration) {
        //generate a new sandbox id with the current TenantKey
        String newId = generateId(getCurrentTenantKey());
        logger.info("Creating sandbox with new Id {}", newId);
        // make the id & key the same value
        // setting in sandboxConfiguration for validation
        sandboxConfiguration.getSandbox().setKey(newId);
        sandboxConfiguration.getSandbox().setId(newId);
        sandboxConfiguration.getSandbox().setTenantKey(getCurrentTenantKey());
        validateNewSandbox(sandboxConfiguration);
        return inMemorySandboxConfigurationRepository.create(sandboxConfiguration);
    }

    @Override
    public SandboxConfiguration update(final SandboxConfiguration sandboxConfiguration) {
        logger.debug("Updating with sandbox with key = {}", sandboxConfiguration.getSandbox().getKey());
        validateExistingSandbox(sandboxConfiguration);
        return inMemorySandboxConfigurationRepository.update(sandboxConfiguration);
    }

    @Override
    public void delete(final String key) {
        logger.debug("removing the sandbox key {}",key);
        inMemorySandboxConfigurationRepository.delete(key);
    }

    @Override
    public void resetDataSet(String key) {
        logger.info("Resetting the DataSet for the Sandbox key {}",key);
        // todo actually reset the data - just calling a inMemory func for now
        inMemorySandboxConfigurationRepository.reset(key);
    }

    private SandboxConfigurationPackage getCurrentDefaultSandboxPackage() {
        defaultTenantConfigPropsService.servicesPropertiesRefresh();
        final SandboxConfigurationPackage sandboxConfigurationPackage = new SandboxConfigurationPackage();
        ApplicationSandboxConfiguration applicationSandboxConfiguration = defaultTenantConfigPropsService.getDefaultApplicationSandboxConfiguration();
        // TODO remove mock
        if(applicationSandboxConfiguration.getReporting() == null) {
            logger.error("Cannot retrieve the current reporting system settings :: Using MOCK Data");
            applicationSandboxConfiguration.setReporting(
                    SandboxConfigurationStubs.getApplicationSandboxConfigurationDefault().getApplicationSandboxConfiguration().getReporting());
        }
        if(applicationSandboxConfiguration.getAggregateReportingPropertiesTenant() == null) {
            logger.error("Cannot retrieve the current AggregateReportingProperties :: Using MOCK Data");
            applicationSandboxConfiguration.setAggregateReportingPropertiesTenant(
                    SandboxConfigurationStubs.getApplicationSandboxConfigurationDefault()
                            .getApplicationSandboxConfiguration().getAggregateReportingPropertiesTenant());

        }
        //TODO Replace with real dataSets call
        sandboxConfigurationPackage.setDataSets(SandboxConfigurationStubs.getDataSets());
        sandboxConfigurationPackage.setApplicationSandboxConfiguration(applicationSandboxConfiguration);
        final Optional<Tenant> tenant = tenantProperties.findTenantById(getCurrentTenantKey());
        if(tenant.isPresent()) {
            sandboxConfigurationPackage.setTenant(tenant.get());
        } else {
            logger.error("Cannot retrieve the current Tenant Info, only setting key & Id, and the rest with mock CA data");
            sandboxConfigurationPackage.setTenant(TenantConfigurationStubs.getTenantCA());
            sandboxConfigurationPackage.getTenant().setKey(getCurrentTenantKey());
            sandboxConfigurationPackage.getTenant().setId(getCurrentTenantKey());
        }

        return sandboxConfigurationPackage;
    }

    /**
     * @param sandboxConfiguration to validate if it's ok to create a new sandbox
     */
    private void validateNewSandbox(final SandboxConfiguration sandboxConfiguration) {
        // TODO update with full if exists checks
        if (inMemorySandboxConfigurationRepository.exists(sandboxConfiguration.getSandbox().getKey())) {
            String errorMsg = "Sandbox: " + sandboxConfiguration.getSandbox().getName() +
                    " key: " + sandboxConfiguration.getSandbox().getKey() + " exists already. Please update existing sandbox, or create another sandbox.";
            logger.error(errorMsg);
            throw new IllegalArgumentException(errorMsg);
        }
    }

    /**
     * @return the current TenantKey - and if null the mock tenant for now.
     */
    private String getCurrentTenantKey() {
        // todo replace else with something else
        return reportingTenantIdResolver.getTenantId().orElse(SandboxConfigurationStubs.getSandboxCAInfo().getTenantKey());
    }

    /**
     * @param sandboxConfiguration to validate if it's ok to update the sandbox
     */
    private void validateExistingSandbox(final SandboxConfiguration sandboxConfiguration) {
        // TODO update with full if exists checks
        if (!inMemorySandboxConfigurationRepository.exists(sandboxConfiguration.getSandbox().getKey())) {
            String errorMsg = "Sandbox: " + sandboxConfiguration.getSandbox().getName() +
                    " key: " + sandboxConfiguration.getSandbox().getKey() + " not found.";
            logger.error(errorMsg);
            throw new NoSuchElementException(errorMsg);
        }
    }

    /**
     * @return a tenant based ID - using a hash of the current time
     */
    private String generateId(String tenantId) {
        String ms = String.valueOf(System.currentTimeMillis());
        String ts = String.valueOf(ms.substring(7, 10).hashCode());
        logger.debug("hasCode is = {}", ts );
        return tenantId + "-" + ts;
    }
}
