package org.opentestsystem.rdw.admin.multitenant.administration.impl;


import org.apache.commons.lang3.StringUtils;
import org.opentestsystem.rdw.admin.multitenant.administration.SandboxTemplateInheritService;
import org.opentestsystem.rdw.archive.ArchiveProperties;
import org.opentestsystem.rdw.archive.ArchivePropertiesResolver;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.opentestsystem.rdw.archive.ArchiveServiceDecorator;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.multitenant.TenantContextHolder;
import org.opentestsystem.rdw.multitenant.TenantProperties;
import org.opentestsystem.rdw.reporting.common.repository.ReportTemplateRepository;
import org.opentestsystem.rdw.reporting.common.repository.impl.ArchiveBackedReportTemplateRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.util.List;

import static org.apache.commons.lang3.StringUtils.defaultIfBlank;

public class DefaultSandboxTemplateInheritService implements SandboxTemplateInheritService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultSandboxTemplateInheritService.class);

    private final ArchivePropertiesResolver archivePropertiesResolver;
    private final ArchiveService archiveService;
    private final TenantProperties tenantProperties;

    public DefaultSandboxTemplateInheritService(ArchivePropertiesResolver archivePropertiesResolver,
                                                ArchiveService archiveService,
                                                TenantProperties tenantProperties) {
        this.archivePropertiesResolver = archivePropertiesResolver;
        this.archiveService = archiveService;
        this.tenantProperties = tenantProperties;
    }

    @Override
    public void copyTemplates(final String parentKey, final ArchiveProperties sandboxOverrides) {
        // This is a bit tricky since the ArchiveService is meant to work with the current tenant only,
        // and we need to copy files from the tenant's folder to the sandbox's folder. The sandbox
        // tenant does not actually exist at this point, so we have to create our own ArchiveService
        // based on the archive properties the sandbox will have.
        try {
            final Tenant tenant = tenantProperties.getTenants().get(parentKey);
            TenantContextHolder.setTenantId(tenant.getId());

            final ReportTemplateRepository tenantTemplateRepository =
                new ArchiveBackedReportTemplateRepository(archiveService);

            final List<String> templateNames = tenantTemplateRepository.findAllTemplateNames();
            if (templateNames == null || templateNames.isEmpty()) {
                // Nothing to do.
                return;
            }

            // Get a full set of sandbox archive properties by merging the sandbox overrides with the tenant's.
            final ArchiveProperties sandboxProperties = merge(sandboxOverrides, archivePropertiesResolver);

            // For safety, verify resolved archived properties contain a valid sandbox prefix
            final String prefix = sandboxProperties.getPathPrefix();
            if (StringUtils.isBlank(prefix) || !prefix.toLowerCase().contains("_s")) {
                throw new IllegalStateException("Invalid path prefix: " + prefix);
            }

            // Use sandbox properties to create an ArchiveService configured as it will be when the sandbox exists.
            final ArchiveService archiveService = new ArchiveServiceDecorator(sandboxProperties);

            final ReportTemplateRepository sandboxTemplateRepository =
                new ArchiveBackedReportTemplateRepository(archiveService);

            for (final String templateName : templateNames) {
                byte [] buffer;

                try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {
                    tenantTemplateRepository.read(templateName, out);
                    out.close();
                    buffer = out.toByteArray();
                }

                try (ByteArrayInputStream in = new ByteArrayInputStream(buffer)) {
                    sandboxTemplateRepository.write(templateName, in);
                }
            }
        } catch (final Exception e) {
            logger.warn("Failed to inherit templates from tenant with tenant key {}: {}", parentKey, e.getMessage());
        } finally {
            TenantContextHolder.clear();
        }
    }

    private ArchiveProperties merge(final ArchiveProperties sandboxProperties,
                                    final ArchiveProperties tenantProperties) {
        return new ArchiveProperties() {

            @Override
            public String getUriRoot() {
                return defaultIfBlank(sandboxProperties.getUriRoot(), tenantProperties.getUriRoot());
            }

            @Override
            public String getPathPrefix() {
                return defaultIfBlank(sandboxProperties.getPathPrefix(), tenantProperties.getPathPrefix());
            }

            @Override
            public String getS3AccessKey() {
                return defaultIfBlank(sandboxProperties.getS3AccessKey(), tenantProperties.getS3AccessKey());
            }

            @Override
            public String getS3SecretKey() {
                return defaultIfBlank(sandboxProperties.getS3SecretKey(), tenantProperties.getS3SecretKey());
            }

            @Override
            public String getS3RegionStatic() {
                return defaultIfBlank(sandboxProperties.getS3RegionStatic(), tenantProperties.getS3RegionStatic());
            }

            @Override
            public String getS3Sse() {
                return defaultIfBlank(sandboxProperties.getS3Sse(), tenantProperties.getS3Sse());
            }

            @Override
            public boolean isConfiguredFile() {
                return  tenantProperties.isConfiguredFile();
            }

            @Override
            public boolean isConfiguredS3() {
                return tenantProperties.isConfiguredS3();
            }
        };
    }
}

