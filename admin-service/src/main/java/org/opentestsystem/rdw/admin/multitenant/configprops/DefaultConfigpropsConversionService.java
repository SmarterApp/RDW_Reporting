package org.opentestsystem.rdw.admin.multitenant.configprops;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.TreeNode;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Sets;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemPropertiesImpl;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemSettings;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashSet;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

public class DefaultConfigpropsConversionService implements ConfigpropsConversionService {

    private static final Logger logger = LoggerFactory.getLogger(DefaultConfigpropsConversionService.class);

    private final ConfigpropsClient configpropsClient;
    private final ConfigpropsConsolidationService configpropsConsolidationService;
    private final ObjectMapper mapper;

    public DefaultConfigpropsConversionService(ConfigpropsClient configpropsClient,
                                               ConfigpropsConsolidationService configpropsConsolidationService,
                                               ObjectMapper mapper) {
        this.configpropsClient = configpropsClient;
        this.configpropsConsolidationService = configpropsConsolidationService;
        this.mapper = mapper;
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        mapper.setSerializationInclusion(JsonInclude.Include.ALWAYS);
    }

    @Override
    public Optional<ReportingSystemSettings> defaultReportingSystemProperties() {
        Map<String, ReportingSystemSettings> reportingSystemSettings =
                findJsonByKey("reporting")
                        .entrySet()
                        .stream()
                        .map(entry -> ImmutablePair.of(entry.getKey(), treeToValue(entry.getValue(), ReportingSystemSettings.class)))
                        .filter(pair -> pair.getRight().isPresent())
                        .collect(Collectors.toMap(ImmutablePair::getLeft, pair -> pair.getRight().get()));

        HashSet<ReportingSystemSettings> set = Sets.newHashSet(reportingSystemSettings.values());
        if (set.size() > 1) {
            logger.warn("More than one ReportingSystemSettings resolved count[{}] {}", set.size(), set);
            //TODO: workaround until fix for RP-548
            if (reportingSystemSettings.containsKey("reporting-webapp") && reportingSystemSettings.containsKey("reporting-service")) {
                ReportingSystemSettings webappSettings = reportingSystemSettings.get("reporting-service");
                ReportingSystemSettings reportingServiceSettings = reportingSystemSettings.get("reporting-service");
                //prefer webapp add school year and state from reporting-service
                webappSettings.setSchoolYear(reportingServiceSettings.getSchoolYear());
                webappSettings.setState(reportingServiceSettings.getState());
                return Optional.of(webappSettings);
            }
        }
        return set.stream().findFirst();
    }

    @Override
    public Optional<ReportingSystemPropertiesImpl> reportingSystemProperties(String key) {
        return defaultReportingSystemProperties()
                .map(reportingSystemSettings -> reportingSystemSettings.getTenants()
                        .get(key));
    }

    private Map<String, Map<String, JsonNode>> getConsolidatedConfigprops() {
        return configpropsConsolidationService.extractServicePrefixProperties(
                configpropsClient.getRawServiceConfigurations());
    }

    @VisibleForTesting
    Map<String, JsonNode> findJsonByKey(String key) {
        return getConsolidatedConfigprops()
                .entrySet()
                .stream()
                .map(m -> ImmutablePair.of(m.getKey(), m.getValue().get(key)))
                .collect(Collectors.toMap(ImmutablePair::getLeft, ImmutablePair::getRight));
    }

    @VisibleForTesting
    <T> Optional<T> treeToValue(TreeNode n, Class<T> valueType) {
        try {
            return Optional.ofNullable(mapper.treeToValue(n, valueType));
        } catch (JsonProcessingException e) {
            logger.warn("Error parsing JSON", e);
            return Optional.empty();
        }
    }
}
