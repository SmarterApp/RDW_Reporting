package org.opentestsystem.rdw.admin.multitenant.configprops;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.TreeNode;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Sets;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.opentestsystem.rdw.archive.ArchivePropertiesRoot;
import org.opentestsystem.rdw.archive.ArchivePropertiesTenant;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingPropertiesRoot;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingPropertiesTenant;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemPropertiesImpl;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemSettings;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashSet;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

public class DefaultConfigpropsConversionService implements ConfigpropsConversionService {

    private static final Logger logger = LoggerFactory.getLogger(DefaultConfigpropsConversionService.class);

    private final ConfigpropsClient configpropsClient;
    private final ConfigpropsConsolidationService configpropsConsolidationService;
    private final ObjectMapper mapper;

    public DefaultConfigpropsConversionService(ConfigpropsClient configpropsClient,
                                               ConfigpropsConsolidationService configpropsConsolidationService,
                                               ObjectMapper mapper) {
        this.configpropsClient = configpropsClient;
        this.configpropsConsolidationService = configpropsConsolidationService;
        this.mapper = mapper;
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        mapper.setSerializationInclusion(JsonInclude.Include.ALWAYS);
    }

    @Override
    public Optional<ReportingSystemSettings> defaultReportingSystemProperties() {
        Map<String, ReportingSystemSettings> reportingSystemSettings =
                serviceConfigurationMap("reporting", ReportingSystemSettings.class);

        HashSet<ReportingSystemSettings> set = Sets.newHashSet(reportingSystemSettings.values());
        if (set.size() > 1) {
            logger.warn("More than one ReportingSystemSettings resolved count[{}] {}", set.size(), set);
            //TODO: workaround until fix for RP-548
            if (reportingSystemSettings.containsKey("reporting-webapp") && reportingSystemSettings.containsKey("reporting-service")) {
                ReportingSystemSettings webappSettings = reportingSystemSettings.get("reporting-service");
                ReportingSystemSettings reportingServiceSettings = reportingSystemSettings.get("reporting-service");
                //prefer webapp add school year and state from reporting-service
                webappSettings.setSchoolYear(reportingServiceSettings.getSchoolYear());
                webappSettings.setState(reportingServiceSettings.getState());
                return Optional.of(webappSettings);
            }
        }
        return set.stream().findFirst();
    }

    @Override
    public Optional<ReportingSystemPropertiesImpl> reportingSystemProperties(String tenantKey) {
        return defaultReportingSystemProperties()
                .map(reportingSystemSettings -> reportingSystemSettings.getTenants()
                        .get(tenantKey));
    }

    public Optional<ArchivePropertiesRoot> defaultArchiveProperties() {
        Map<String, ArchivePropertiesRoot> reportingSystemSettings =
                serviceConfigurationMap("archive", ArchivePropertiesRoot.class);
        HashSet<ArchivePropertiesRoot> set = Sets.newHashSet(reportingSystemSettings.values());
        if (set.size() > 1) {
            logger.warn("More than one ReportingSystemSettings resolved count[{}] {}", set.size(), set);
        }
        return set.stream().findFirst();
    }

    public Optional<ArchivePropertiesTenant> archiveProperties(String tenantKey) {
        return defaultArchiveProperties()
                .map(reportingSystemSettings -> reportingSystemSettings.getTenants()
                        .get(tenantKey));
    }

    public Optional<AggregateReportingPropertiesRoot> defaultAggregateReportingProperties() {
        Map<String, AggregateReportingPropertiesRoot> aggregateReportingPropertiesSettings =
                serviceConfigurationMap("aggregateReporting", AggregateReportingPropertiesRoot.class);
        HashSet<AggregateReportingPropertiesRoot> set = Sets.newHashSet(aggregateReportingPropertiesSettings.values());
        if (set.size() > 1) {
            logger.warn("More than one AggregateReportingPropertiesRoot resolved count[{}] {}", set.size(), set);
        }
        return set.stream().findFirst();
    }

    public Optional<AggregateReportingPropertiesTenant> aggregateReportingProperties(String tenantKey) {
        return defaultAggregateReportingProperties()
                .map(aggregateReportingPropertiesRoot -> aggregateReportingPropertiesRoot.getTenants().get(tenantKey));
    }

    //"aggregate-reporting"
    //"tenantProperties"
    //"datasources."

    private Map<String, Map<String, JsonNode>> getConsolidatedConfigprops() {
        return configpropsConsolidationService.extractServicePrefixProperties(
                configpropsClient.getRawServiceConfigurations());
    }

    /**
     * Get a Map of service names to matching parsed objects
     *
     * @param configTypeKey The type of configuration to extract ("reporting", "archive", "aggregate-reporting", etc)
     * @param valueType     Type to parse to
     * @param <T>           Type
     * @return Map of service names to parsed objects
     */
    private <T> Map<String, T> serviceConfigurationMap(String configTypeKey, Class<T> valueType) {
        return findJsonByKey(configTypeKey)
                .entrySet()
                .stream()
                .map(entry -> ImmutablePair.of(entry.getKey(), treeToValue(entry.getValue(), valueType)))
                .filter(pair -> pair.getRight().isPresent())
                .collect(Collectors.toMap(ImmutablePair::getLeft, pair -> pair.getRight().get()));
    }

    /**
     * Get a Map of service names to matching JsonNode configurations for a particular configuration type.
     *
     * @param configTypeKey The type of configuration to extract ("reporting", "archive", "aggregate-reporting", etc)
     * @return Map of service names to {@link JsonNode} configuration
     */
    @VisibleForTesting
    Map<String, JsonNode> findJsonByKey(String configTypeKey) {
        return getConsolidatedConfigprops()
                .entrySet()
                .stream()
                .map(m -> ImmutablePair.of(m.getKey(), m.getValue().get(configTypeKey)))
                .filter(pair -> pair.getRight() != null)
                .collect(Collectors.toMap(ImmutablePair::getLeft, ImmutablePair::getRight));
    }

    /**
     * Parse a {@link JsonNode} to a class, will not throw an exception (logs warning)
     *
     * @param n         Node to parse
     * @param valueType Type to parse to
     * @param <T>       Type
     * @return The parsed type or Optional empty
     */
    @VisibleForTesting
    <T> Optional<T> treeToValue(TreeNode n, Class<T> valueType) {
        try {
            return Optional.ofNullable(mapper.treeToValue(n, valueType));
        } catch (JsonProcessingException e) {
            logger.warn("Error parsing JSON", e);
            return Optional.empty();
        }
    }
}
