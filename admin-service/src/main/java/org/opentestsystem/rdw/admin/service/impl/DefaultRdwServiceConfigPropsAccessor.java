package org.opentestsystem.rdw.admin.service.impl;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.collect.ImmutableMap;
import org.opentestsystem.rdw.admin.model.RdwServiceConfigProps;
import org.opentestsystem.rdw.admin.service.RdwServiceConfigPropsAccessor;
import org.opentestsystem.rdw.archive.ArchivePropertiesRoot;
import org.opentestsystem.rdw.archive.ArchivePropertiesTenant;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsProperties;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsTenant;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingPropertiesRoot;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingPropertiesTenant;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemPropertiesImpl;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemSettings;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.Map;
import java.util.Optional;

/**
 * Accessor for the ConfigProps from the actuator endpoint
 */
@Component
public class DefaultRdwServiceConfigPropsAccessor implements RdwServiceConfigPropsAccessor {
    private static final Logger logger = LoggerFactory.getLogger(DefaultTenantConfigPropsService.class);

    private RdwServiceConfigProps configProps;
    private ObjectMapper mapper;

    @Autowired
    public DefaultRdwServiceConfigPropsAccessor(RdwServiceConfigProps configProps, ObjectMapper mapper) {
        this.mapper = mapper.copy();
        this.configProps = configProps;
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
    }

    public static DefaultRdwServiceConfigPropsAccessor wrap(RdwServiceConfigProps configProps, ObjectMapper mapper) {
        return new DefaultRdwServiceConfigPropsAccessor(configProps, mapper);
    }


    // REPORTING SYSTEM SETTINGS
    @Override
    public Optional<ReportingSystemPropertiesImpl> getDefaultReportingSystemSettings() {
        Optional<ReportingSystemSettings> reportingSystemSettings = parseReportingSystemSettings();
        if(reportingSystemSettings.isPresent()) {
            logger.debug("Response to get Default ReportingSystemProperties = {}", reportingSystemSettings.get());
            try {
                String node = mapper.writeValueAsString(reportingSystemSettings.get());
                ReportingSystemPropertiesImpl reporting = mapper.readValue(node, ReportingSystemPropertiesImpl.class);
                return Optional.of(reporting);
            } catch (Exception e) {
                logger.error("Error parsing ReportingSystemSettings from json: {}", reportingSystemSettings);
            }
        }
        return Optional.empty();
    }
    @Override
    public Map<String, ReportingSystemPropertiesImpl> getTenantReportingSystemSettings() {
        Optional<ReportingSystemSettings> reportingSystemSettings = parseReportingSystemSettings();
        if(reportingSystemSettings.isPresent()) {
            return reportingSystemSettings.get().getTenants();
        }
        return ImmutableMap.of();
    }
    /**
     * Search for reporting system settings in the configProps
     * @return ReportingSystemSettings if found
     */
    private Optional<ReportingSystemSettings> parseReportingSystemSettings() {
        try {
            Optional<JsonNode> settingsNode = findPropertySetting("scopedTarget.reportingSystemSettings");
            if(settingsNode.isPresent()) {
                return Optional.of(mapper.treeToValue(settingsNode.get(), ReportingSystemSettings.class));
            }
        } catch (Exception e) {
            logger.warn("ReportingSystemSettings not found in ConfigProps");
        }
        return Optional.empty();
    }

    /**
     * each wanted propertySetting must have a 'properties' field
     * @param propertySetting to search for Looking in each of the configProps Responses
     * @return if found, the first found jsonNode of the propertySetting
     */
    private Optional<JsonNode> findPropertySetting(String propertySetting) {
        // stop looking once setting is found
        for(String response : configProps.getConfigProps() ) {
            try {
                JsonNode rootNode = mapper.readTree(response);
                JsonNode settingsNode = rootNode.path(propertySetting).path("properties");
                if(!settingsNode.isMissingNode()) {
                    logger.info("Property {} found parsing json: {}", settingsNode, response);
                    return Optional.of(settingsNode);
                } // keep looking, not found
            } catch (Exception e) {
                logger.warn("{} not found parsing specific json response", propertySetting,  response);
                // keep looking if not found
            }
        }
        return Optional.empty();
    }

    /**
     * @param dataSourceElementsProperties  Found datasource with default & tenant speecific info
     * @param dataSourceName the specific dataSource
     * @return DataSourceElementsTenant for the dataSourceName
     */
    private Optional<DataSourceElementsTenant> getDataSourceElementsTenant(DataSourceElementsProperties dataSourceElementsProperties, String dataSourceName) {
        logger.debug("Response to get for ReportingSystemProperties = {}", dataSourceElementsProperties);
        try {
            DataSourceElementsTenant dataSource = mapper.readValue(mapper.writeValueAsString(dataSourceElementsProperties), DataSourceElementsTenant.class);
            return Optional.of(dataSource);
        } catch (Exception e) {
            logger.error("Error parsing {} dataSourceElementsTenantProperties from {}", dataSourceName, dataSourceElementsProperties);
        }
        return Optional.empty();
    }
    /**
     * parses result for parseKey and map the result to the corresponding class
     * @param parseKey which dataSource to find
     * @return DataSourceElementsProperties with default & tenent Info
     */
    private Optional<DataSourceElementsProperties> parseDataSourceConfigProps(String parseKey ) {
        try {
            final Optional<JsonNode> propertySetting = findPropertySetting(parseKey);
            if(propertySetting.isPresent()) {
                DataSourceElementsProperties dataSourceElementsProperties =
                        mapper.treeToValue(propertySetting.get(), DataSourceElementsProperties.class);
                return Optional.of(dataSourceElementsProperties);
            }
        } catch (Exception e) {
            logger.warn("{} not found in ConfigProps",parseKey);
        }
        return Optional.empty();
    }

    /// READ ONLY DATASOURCE
    @Override
    public Optional<DataSourceElementsTenant> getDefaultReadOnlyDataSourceElements() {
        Optional<DataSourceElementsProperties> readOnlyDataSourceElementsProperties = parseDataSourceConfigProps("scopedTarget.dataSourceElementsProperties");
        if(readOnlyDataSourceElementsProperties.isPresent()) {
            return getDataSourceElementsTenant(readOnlyDataSourceElementsProperties.get(), "ReadOnlyDataSource");
        }
        return Optional.empty();
    }
    @Override
    public Map<String, DataSourceElementsTenant> getTenantsReadOnlyDataSourceElements() {
        Optional<DataSourceElementsProperties> readOnlyDataSourceElementsProperties = parseDataSourceConfigProps("scopedTarget.dataSourceElementsProperties");
        if(readOnlyDataSourceElementsProperties.isPresent()) {
            return readOnlyDataSourceElementsProperties.get().getTenants();
        }
        return ImmutableMap.of();
    }

    // WRITABLE DATASOURCES
    public Optional<DataSourceElementsTenant> getDefaultWritableDataSourceElements() {
        Optional<DataSourceElementsProperties> writableDataSourceElementsProperties = parseDataSourceConfigProps("scopedTarget.writableDataSourceElementsProperties");
        if (writableDataSourceElementsProperties.isPresent()) {
            return getDataSourceElementsTenant(writableDataSourceElementsProperties.get(), "WritableDataSource");
        }
        return Optional.empty();
    }
    public Map<String, DataSourceElementsTenant> getTenantsWritableDataSourceElements() {
        Optional<DataSourceElementsProperties> writableDataSourceElementsProperties = parseDataSourceConfigProps("scopedTarget.writableDataSourceElementsProperties");
        if (writableDataSourceElementsProperties.isPresent()) {
            return writableDataSourceElementsProperties.get().getTenants();
        }
        return ImmutableMap.of();
    }

    // WAREHOUSE DATASOURCES
    @Override
    public Optional<DataSourceElementsTenant> getDefaultWarehouseDataSourceElements() {
        Optional<DataSourceElementsProperties> warehouseDataSourceElementsProperties = parseDataSourceConfigProps("scopedTarget.warehouseDataSourceElementsProperties");
        if (warehouseDataSourceElementsProperties.isPresent()) {
            return getDataSourceElementsTenant(warehouseDataSourceElementsProperties.get(), "WarehouseDataSource");
        }
        return Optional.empty();
    }
    @Override
    public Map<String, DataSourceElementsTenant> getTenantsWarehouseDataSourceElements() {
        Optional<DataSourceElementsProperties> warehouseDataSourceElementsProperties = parseDataSourceConfigProps("scopedTarget.warehouseDataSourceElementsProperties");
        if(warehouseDataSourceElementsProperties.isPresent()) {
            return warehouseDataSourceElementsProperties.get().getTenants();
        }
        return ImmutableMap.of();
    }

    // OLAP DATASOURCES
    @Override
    public Optional<DataSourceElementsTenant> getDefaultOlapDataSourceElements() {
        Optional<DataSourceElementsProperties> olapDataSourceElementsProperties = parseDataSourceConfigProps("scopedTarget.olapDataSourceElementsProperties");
        if (olapDataSourceElementsProperties.isPresent()) {
            return getDataSourceElementsTenant(olapDataSourceElementsProperties.get(), "OlapDataSource");
        }
        return Optional.empty();
    }
    @Override
    public Map<String, DataSourceElementsTenant> getTenantsOlapDataSourceElements() {
        Optional<DataSourceElementsProperties> olapDataSourceElementsProperties = parseDataSourceConfigProps("scopedTarget.olapDataSourceElementsProperties");
        if(olapDataSourceElementsProperties.isPresent()) {
            return olapDataSourceElementsProperties.get().getTenants();
        }
        return ImmutableMap.of();
    }



    // ARCHIVE PROPERTIES
    @Override
    public Optional<ArchivePropertiesTenant> getDefaultArchivePropertiesTenant() {
        Optional<ArchivePropertiesRoot> archivePropertiesRoot = parseArchiveProperties();
        if(archivePropertiesRoot.isPresent()) {
            logger.debug("Response to get for archivePropertiesRoot = {}", archivePropertiesRoot.get());
            try {
                ArchivePropertiesTenant archivePropertiesTenant = mapper.readValue(mapper.writeValueAsString(archivePropertiesRoot.get()), ArchivePropertiesTenant.class);
                return Optional.of(archivePropertiesTenant);
            } catch (Exception e) {
                logger.error("Error parsing archivePropertiesRoot from json: {}", archivePropertiesRoot.get());
            }
        }
        return Optional.empty();
    }
    @Override
    public Map<String, ArchivePropertiesTenant> getTenantsArchiveProperties() {
        Optional<ArchivePropertiesRoot> archivePropertiesRoot = parseArchiveProperties();
        if(archivePropertiesRoot.isPresent()) {
            return archivePropertiesRoot.get().getTenants();
        }
        return ImmutableMap.of();
    }
    /**
     * @return ArchivePropertiesRoot if found
     */
    private Optional<ArchivePropertiesRoot> parseArchiveProperties() {
        try {
            Optional<JsonNode> settingsNode = findPropertySetting("archivePropertiesRoot");
            if(settingsNode.isPresent()) {
                return Optional.of(mapper.treeToValue(settingsNode.get(), ArchivePropertiesRoot.class));
            }
        } catch (Exception e) {
            logger.warn("ArchivePropertiesTenant failed to be mapped properly");
        }
        return Optional.empty();
    }

    // AGGREGATE REPORTING PROPERTIES
    @Override
    public Optional<AggregateReportingPropertiesTenant> getDefaultAggregateReportingProperties(){
        Optional<AggregateReportingPropertiesRoot> aggregateReportingPropertiesRoot = parseAggregatorProperties();
        if(aggregateReportingPropertiesRoot.isPresent()) {
            logger.debug("Response to get for AggregateReportingPropertiesTenant = {}", aggregateReportingPropertiesRoot.get());
            try {
                AggregateReportingPropertiesTenant aggregateReporting =
                        mapper.readValue(mapper.writeValueAsString(aggregateReportingPropertiesRoot.get()), AggregateReportingPropertiesTenant.class);
                return Optional.of(aggregateReporting);
            } catch (Exception e) {
                logger.error("Error parsing AggregateReportingPropertiesTenant from json: {}", aggregateReportingPropertiesRoot.get());
            }
        }
        return Optional.empty();
    }
    @Override
    public Map<String, AggregateReportingPropertiesTenant> getTenantsAggregateReportingProperties() {
        Optional<AggregateReportingPropertiesRoot> aggregateReportingPropertiesRoot = parseAggregatorProperties();
        if(aggregateReportingPropertiesRoot.isPresent()) {
            return aggregateReportingPropertiesRoot.get().getTenants();
        }
        return ImmutableMap.of();
    }
    /**
     * @return ArchivePropertiesRoot if found
     */
    private Optional<AggregateReportingPropertiesRoot> parseAggregatorProperties() {
        try {
            final Optional<JsonNode> propertySetting = findPropertySetting("scopedTarget.aggregateReportingPropertiesRoot");
            if(propertySetting.isPresent()) {
                return Optional.of(mapper.treeToValue(propertySetting.get(), AggregateReportingPropertiesRoot.class));
            }
        } catch (Exception e) {
            logger.warn("AggregateReportingPropertiesRoot not found parsing configProps");
        }
        return Optional.empty();
    }
}
