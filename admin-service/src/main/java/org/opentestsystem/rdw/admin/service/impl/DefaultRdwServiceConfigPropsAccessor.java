package org.opentestsystem.rdw.admin.service.impl;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.collect.ImmutableMap;

import org.opentestsystem.rdw.admin.model.RdwServiceConfigProps;
import org.opentestsystem.rdw.admin.service.RdwServiceConfigPropsAccessor;
import org.opentestsystem.rdw.archive.ArchivePropertiesRoot;
import org.opentestsystem.rdw.archive.ArchivePropertiesTenant;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsProperties;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsTenant;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingPropertiesRoot;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingPropertiesTenant;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemPropertiesImpl;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemSettings;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.Map;
import java.util.Optional;

/**
 * Accessor for the ConfigProps from the rdw services actuator /configprops endpoints
 */
@Component
public class DefaultRdwServiceConfigPropsAccessor implements RdwServiceConfigPropsAccessor {
    private static final Logger logger = LoggerFactory.getLogger(DefaultTenantConfigurationViewService.class);

    private RdwServiceConfigProps configProps;
    private ObjectMapper mapper;

    @Autowired
    public DefaultRdwServiceConfigPropsAccessor(RdwServiceConfigProps configProps, ObjectMapper mapper) {
        this.mapper = mapper.copy();
        this.configProps = configProps;
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        mapper.setSerializationInclusion(JsonInclude.Include.ALWAYS);
    }

    public static DefaultRdwServiceConfigPropsAccessor wrap(RdwServiceConfigProps configProps, ObjectMapper mapper) {
        return new DefaultRdwServiceConfigPropsAccessor(configProps, mapper);
    }

    // REPORTING SYSTEM SETTINGS
    @Override
    public Optional<ReportingSystemPropertiesImpl> getDefaultReportingSystemSettings() {
        Optional<ReportingSystemSettings> reportingSystemSettings = parseReportingSystemSettings();
        if (reportingSystemSettings.isPresent()) {
            logger.debug("Response to get Default ReportingSystemProperties = {}", reportingSystemSettings.get());
            try {
                ReportingSystemPropertiesImpl reporting = mapper.convertValue(reportingSystemSettings.get(), ReportingSystemPropertiesImpl.class);
                return Optional.of(reporting);
            } catch (Exception e) {
                logger.error("Error parsing ReportingSystemSettings from json: {}", reportingSystemSettings);
            }
        }
        return Optional.empty();
    }

    @Override
    public Map<String, ReportingSystemPropertiesImpl> getTenantReportingSystemSettings() {
        Optional<ReportingSystemSettings> reportingSystemSettings = parseReportingSystemSettings();
        if (reportingSystemSettings.isPresent()) {
            return reportingSystemSettings.get().getTenants();
        }
        return ImmutableMap.of();
    }

    /**
     * Search for reporting system settings in the configProps
     *
     * @return ReportingSystemSettings if found
     */
    private Optional<ReportingSystemSettings> parseReportingSystemSettings() {
        try {
            Optional<JsonNode> settingsNode = findPropertySetting("scopedTarget.reportingSystemSettings");
            if (settingsNode.isPresent()) {
                return Optional.of(mapper.treeToValue(settingsNode.get(), ReportingSystemSettings.class));
            }
        } catch (Exception e) {
            logger.warn("ReportingSystemSettings not found in ConfigProps");
        }
        return Optional.empty();
    }

    /**
     * each wanted propertySetting must have a 'properties' field
     *
     * @param propertySetting to search for Looking in each of the configProps Responses
     * @return if found, the first found jsonNode of the propertySetting
     */
    private Optional<JsonNode> findPropertySetting(String propertySetting) {
        // stop looking once setting is found
        for (String response : configProps.getConfigProps()) {
            try {
                JsonNode rootNode = mapper.readTree(response);
                JsonNode settingsNode = rootNode.path(propertySetting).path("properties");
                if (!settingsNode.isMissingNode()) {
                    logger.debug("Property {} found parsing json: {}", settingsNode, response);
                    return Optional.of(settingsNode);
                } // keep looking, not found
            } catch (Exception e) {
                logger.warn("{} not found parsing specific json response", propertySetting, response);
                // keep looking if not found
            }
        }
        return Optional.empty();
    }

    /**
     * @param dataSourceElementsProperties Found datasource with default & tenant speecific info
     * @param dataSourceName               the specific dataSource
     * @return DataSourceElementsTenant for the dataSourceName
     */
    private Optional<DataSourceElementsTenant> getDataSourceElementsTenant(DataSourceElementsProperties dataSourceElementsProperties, String dataSourceName) {
        logger.debug("Response to get for ReportingSystemProperties = {}", dataSourceElementsProperties);
        try {
            //DataSourceElementsTenant dataSource = mapper.readValue(mapper.writeValueAsString(dataSourceElementsProperties), DataSourceElementsTenant.class);
            DataSourceElementsTenant dataSource = mapper.convertValue(dataSourceElementsProperties, DataSourceElementsTenant.class);
            return Optional.of(dataSource);
        } catch (Exception e) {
            logger.error("Error parsing {} dataSourceElementsTenantProperties from {}", dataSourceName, dataSourceElementsProperties);
        }
        return Optional.empty();
    }

    /**
     * parses result for parseKey and map the result to the corresponding class
     *
     * @param parseKey which dataSource to find
     * @return DataSourceElementsProperties with default & tenent Info
     */
    private Optional<DataSourceElementsProperties> parseDataSourceConfigProps(String parseKey) {
        try {
            final Optional<JsonNode> propertySetting = findPropertySetting(parseKey);
            if (propertySetting.isPresent()) {
                DataSourceElementsProperties dataSourceElementsProperties =
                        mapper.treeToValue(propertySetting.get(), DataSourceElementsProperties.class);
                return Optional.of(dataSourceElementsProperties);
            }
        } catch (Exception e) {
            logger.warn("{} not found in ConfigProps", parseKey);
        }
        return Optional.empty();
    }

    /// READ ONLY DATASOURCE
    @Override
    public Optional<DataSourceElementsTenant> getDefaultReadOnlyDataSourceElements() {
        Optional<DataSourceElementsProperties> readOnlyDataSourceElementsProperties = parseDataSourceConfigProps("scopedTarget.dataSourceElementsProperties");
        if (readOnlyDataSourceElementsProperties.isPresent()) {
            return getDataSourceElementsTenant(readOnlyDataSourceElementsProperties.get(), "ReadOnlyDataSource");
        }
        return Optional.empty();
    }

    @Override
    public Map<String, DataSourceElementsTenant> getTenantsReadOnlyDataSourceElements() {
        return parseDataSourceConfigProps("scopedTarget.dataSourceElementsProperties")
                .map(x -> x.getTenants())
                .orElse(ImmutableMap.of());
    }

    // WRITABLE DATASOURCES
    public Optional<DataSourceElementsTenant> getDefaultWritableDataSourceElements() {
        Optional<DataSourceElementsProperties> writableDataSourceElementsProperties = parseDataSourceConfigProps("scopedTarget.writableDataSourceElementsProperties");
        if (writableDataSourceElementsProperties.isPresent()) {
            return getDataSourceElementsTenant(writableDataSourceElementsProperties.get(), "WritableDataSource");
        }
        return Optional.empty();
    }

    public Map<String, DataSourceElementsTenant> getTenantsWritableDataSourceElements() {
        return parseDataSourceConfigProps("scopedTarget.writableDataSourceElementsProperties")
                .map(x -> x.getTenants())
                .orElse(ImmutableMap.of());
    }

    // WAREHOUSE DATASOURCES
    @Override
    public Optional<DataSourceElementsTenant> getDefaultWarehouseDataSourceElements() {
        Optional<DataSourceElementsProperties> warehouseDataSourceElementsProperties = parseDataSourceConfigProps("scopedTarget.warehouseDataSourceElementsProperties");
        if (warehouseDataSourceElementsProperties.isPresent()) {
            return getDataSourceElementsTenant(warehouseDataSourceElementsProperties.get(), "WarehouseDataSource");
        }
        return Optional.empty();
    }

    @Override
    public Map<String, DataSourceElementsTenant> getTenantsWarehouseDataSourceElements() {
        return parseDataSourceConfigProps("scopedTarget.warehouseDataSourceElementsProperties")
                .map(x -> x.getTenants())
                .orElse(ImmutableMap.of());
    }

    // OLAP DATASOURCES
    @Override
    public Optional<DataSourceElementsTenant> getDefaultOlapDataSourceElements() {
        Optional<DataSourceElementsProperties> olapDataSourceElementsProperties = parseDataSourceConfigProps("scopedTarget.olapDataSourceElementsProperties");
        if (olapDataSourceElementsProperties.isPresent()) {
            return getDataSourceElementsTenant(olapDataSourceElementsProperties.get(), "OlapDataSource");
        }
        return Optional.empty();
    }

    @Override
    public Map<String, DataSourceElementsTenant> getTenantsOlapDataSourceElements() {
        return parseDataSourceConfigProps("scopedTarget.olapDataSourceElementsProperties")
                .map(x -> x.getTenants())
                .orElse(ImmutableMap.of());
    }

    // ARCHIVE PROPERTIES
    @Override
    public Optional<ArchivePropertiesTenant> getDefaultArchivePropertiesTenant() {
        Optional<ArchivePropertiesRoot> archivePropertiesRoot = parseArchiveProperties();
        if (archivePropertiesRoot.isPresent()) {
            logger.debug("Response to get for archivePropertiesRoot = {}", archivePropertiesRoot.get());
            try {
                ArchivePropertiesTenant archivePropertiesTenant = mapper.convertValue(archivePropertiesRoot.get(), ArchivePropertiesTenant.class);
                return Optional.of(archivePropertiesTenant);
            } catch (Exception e) {
                logger.error("Error parsing archivePropertiesRoot from json: {}", archivePropertiesRoot.get());
            }
        }
        return Optional.empty();
    }

    @Override
    public Map<String, ArchivePropertiesTenant> getTenantsArchiveProperties() {
        Optional<ArchivePropertiesRoot> archivePropertiesRoot = parseArchiveProperties();
        if (archivePropertiesRoot.isPresent()) {
            return archivePropertiesRoot.get().getTenants();
        }
        return ImmutableMap.of();
    }

    /**
     * @return ArchivePropertiesRoot if found
     */
    private Optional<ArchivePropertiesRoot> parseArchiveProperties() {
        try {
            Optional<JsonNode> settingsNode = findPropertySetting("archivePropertiesRoot");
            if (settingsNode.isPresent()) {
                return Optional.of(mapper.treeToValue(settingsNode.get(), ArchivePropertiesRoot.class));
            }
        } catch (Exception e) {
            logger.warn("ArchivePropertiesTenant failed to be mapped properly");
        }
        return Optional.empty();
    }

    // AGGREGATE REPORTING PROPERTIES
    @Override
    public Optional<AggregateReportingPropertiesTenant> getDefaultAggregateReportingProperties() {
        Optional<AggregateReportingPropertiesRoot> aggregateReportingPropertiesRoot = parseAggregatorProperties();
        if (aggregateReportingPropertiesRoot.isPresent()) {
            logger.debug("Response to get for AggregateReportingPropertiesTenant = {}", aggregateReportingPropertiesRoot.get());
            try {
                AggregateReportingPropertiesTenant aggregateReporting = mapper.convertValue(aggregateReportingPropertiesRoot.get(), AggregateReportingPropertiesTenant.class);
                return Optional.of(aggregateReporting);
            } catch (Exception e) {
                logger.error("Error parsing AggregateReportingPropertiesTenant from json: {}", aggregateReportingPropertiesRoot.get());
            }
        }
        return Optional.empty();
    }

    @Override
    public Map<String, AggregateReportingPropertiesTenant> getTenantsAggregateReportingProperties() {
        Optional<AggregateReportingPropertiesRoot> aggregateReportingPropertiesRoot = parseAggregatorProperties();
        if (aggregateReportingPropertiesRoot.isPresent()) {
            return aggregateReportingPropertiesRoot.get().getTenants();
        }
        return ImmutableMap.of();
    }

    /**
     * @return ArchivePropertiesRoot if found
     */
    private Optional<AggregateReportingPropertiesRoot> parseAggregatorProperties() {
        try {
            final Optional<JsonNode> propertySetting = findPropertySetting("scopedTarget.aggregateReportingPropertiesRoot");
            if (propertySetting.isPresent()) {
                return Optional.of(mapper.treeToValue(propertySetting.get(), AggregateReportingPropertiesRoot.class));
            }
        } catch (Exception e) {
            logger.warn("AggregateReportingPropertiesRoot not found parsing configProps");
        }
        return Optional.empty();
    }

    @Override
    public Optional<String> getActualReportingROPassword(final String key) {
        String propertyTenantPassword = String.format("datasources.reporting_ro.tenants.%s.password", key);
        return getActualDataSourcePassword(propertyTenantPassword);
    }

    @Override
    public Optional<String> getActualReportingRWPassword(final String key)  {
        String propertyTenantPassword = String.format("datasources.reporting_rw.tenants.%s.password", key);
        return getActualDataSourcePassword(propertyTenantPassword);
    }

    @Override
    public Optional<String> getActualWarehouseRWPassword(final String key) throws IllegalArgumentException {
        String propertyTenantPassword = String.format("datasources.warehouse_rw.tenants.%s.password", key);
        return getActualDataSourcePassword(propertyTenantPassword);
    }

    @Override
    public Optional<String> getActualOlapROPassword(final String key) throws IllegalArgumentException {
        String propertyTenantPassword = String.format("datasources.olap_ro.tenants.%s.password", key);
        return getActualDataSourcePassword(propertyTenantPassword);
    }

    /**
     * this looks for the "propertySources" array in the configProps,
     * then it searches each sources property for the tenant specific password
     * @param propertyTenantPassword the tenant specific password property to look up
     * @return the unmask, unencrypted password for the tenant's dataSource
     */
    private Optional<String> getActualDataSourcePassword(final String propertyTenantPassword) {
        for (String response : configProps.getConfigProps()) {
            try {
                JsonNode arrayNode = mapper.readTree(response).get("propertySources");
                if (!arrayNode.isArray()) {
                    // now look for the source with the tenant specific datasource i.e. datasources.reporting_ro.tenants.CA.password
                    for (final JsonNode objNode : arrayNode) {
                        JsonNode settingsNode = objNode.path("source").path(propertyTenantPassword);
                        if (!settingsNode.isMissingNode()) {
                            return Optional.of(settingsNode.textValue());
                        } // keep looking, not found
                    }
                } // keep looking, not found
            } catch (Exception e) {
                logger.debug("propertySources.sources {} not found parsing responses json", propertyTenantPassword);
                // keep looking if not found
            }
        }
        return Optional.empty();
    }
}
