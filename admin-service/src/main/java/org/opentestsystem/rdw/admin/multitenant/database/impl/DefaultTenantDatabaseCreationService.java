package org.opentestsystem.rdw.admin.multitenant.database.impl;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Objects;
import com.google.common.collect.ImmutableSet;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.opentestsystem.rdw.admin.model.TenantConfiguration;
import org.opentestsystem.rdw.admin.multitenant.database.MultitenantDatabaseAdmin;
import org.opentestsystem.rdw.admin.multitenant.database.TenantDatabaseCreationService;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsTenant;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class DefaultTenantDatabaseCreationService implements TenantDatabaseCreationService {

    private final MultitenantDatabaseAdmin multitenantDatabaseAdmin;

    @Autowired
    public DefaultTenantDatabaseCreationService(MultitenantDatabaseAdmin multitenantDatabaseAdmin) {
        this.multitenantDatabaseAdmin = multitenantDatabaseAdmin;
    }

    @Override
    public void createTenantDatabases(TenantConfiguration tenantConfiguration) {
        Set<DatabaseInformation> databaseInformationSet = gatherDatabaseInformation(tenantConfiguration);
        preCheck(databaseInformationSet);
        createDatabaseAndUsers(databaseInformationSet);
        createOlapDatabaseAndUsers(databaseInformationSet);
        //Run Migrations
        //Load Data Set (only sandbox)
        //Save Git Config
        //Post to  cloud-config /monitor endpoint
    }

    @Override
    public void createSandboxDatabases(TenantConfiguration tenantConfiguration) {
        //TODO: implement
    }

    @VisibleForTesting
    void createDatabaseAndUsers(Set<DatabaseInformation> databaseInformationSet) {
        Set<DatabaseInformation> databaseInfoSet = databaseInformationSet.stream()
                .filter(info -> !info.isOlap).collect(Collectors.toSet());

        //create databases
        databaseInfoSet.stream()
                .map(DatabaseInformation::getDatabaseOrSchemaName)
                .distinct()
                .forEach(multitenantDatabaseAdmin::createDatabase);

        //create users apply global grants
        databaseInfoSet.stream()
                .map(info -> new ImmutablePair<>(info.getUsername(), info.getPassword()))
                .distinct()
                .forEach(userNamePwdPair -> {
                    multitenantDatabaseAdmin.createDatabaseUser(userNamePwdPair.getLeft(), userNamePwdPair.getRight());
                    multitenantDatabaseAdmin.grantUserLoadFromS3(userNamePwdPair.getLeft());
                    multitenantDatabaseAdmin.grantUserSelectIntoS3(userNamePwdPair.getLeft());
                    multitenantDatabaseAdmin.grantUserOnSelectProc(userNamePwdPair.getLeft());
                });

        //apply user to database grants
        databaseInfoSet.stream()
                .map(info -> new ImmutablePair<>(info.getUsername(), info.getDatabaseOrSchemaName()))
                .distinct()
                .forEach(userDatabasePair ->
                        multitenantDatabaseAdmin.grantUserToDatabase(userDatabasePair.getLeft(), userDatabasePair.getRight())
                );

    }

    @VisibleForTesting
    void createOlapDatabaseAndUsers(Set<DatabaseInformation> databaseInformationSet) {
        Set<DatabaseInformation> olapDatabaseInfoSet = databaseInformationSet.stream()
                .filter(info -> info.isOlap).collect(Collectors.toSet());

        //create users apply global grants
        olapDatabaseInfoSet.stream()
                .map(info -> new ImmutablePair<>(info.getUsername(), info.getPassword()))
                .distinct()
                .forEach(userNamePwdPair ->
                        multitenantDatabaseAdmin.createOlapDatabaseUser(userNamePwdPair.getLeft(), userNamePwdPair.getRight()));

        //create schemas
        olapDatabaseInfoSet.stream()
                .map(DatabaseInformation::getDatabaseOrSchemaName)
                .distinct()
                .forEach(multitenantDatabaseAdmin::createOlapSchema);

        //per schema user grants and search path
        olapDatabaseInfoSet.stream()
                .map(info -> new ImmutablePair<>(info.getUsername(), info.getDatabaseOrSchemaName()))
                .distinct()
                .forEach(userSchemaPair -> {
                    multitenantDatabaseAdmin.grantAllOlapUserToSchema(userSchemaPair.getLeft(), userSchemaPair.getRight());
                    multitenantDatabaseAdmin.grantAllOlapUserToSchemaTables(userSchemaPair.getLeft(), userSchemaPair.getRight());
                    multitenantDatabaseAdmin.searchPathOlapUserToSchema(userSchemaPair.getLeft(), userSchemaPair.getRight());
                });
    }

    @VisibleForTesting
    void preCheck(Set<DatabaseInformation> databaseInformationSet) {

        //TODO: should be exactly 4 databases
        //TODO: should be at least 1 user / password per database (can be more for rw/ro etc)

        databaseInformationSet.stream()
                .filter(x -> x.isOlap)
                .map(DatabaseInformation::getDatabaseOrSchemaName)
                .distinct()
                .forEach(schemaName -> {
                    if (multitenantDatabaseAdmin.isOlapSchemaExists(schemaName)) {
                        throw new RuntimeException("Database schema " + schemaName + " already exists");
                    }
                });

        databaseInformationSet.stream()
                .filter(x -> x.isOlap)
                .map(DatabaseInformation::getUsername)
                .distinct()
                .forEach(username -> {
                    if (multitenantDatabaseAdmin.isOlapDatabaseUserExists(username)) {
                        throw new RuntimeException("Database user " + username + " already exists");
                    }
                });

        databaseInformationSet.stream()
                .filter(x -> !x.isOlap)
                .map(DatabaseInformation::getDatabaseOrSchemaName)
                .distinct()
                .forEach(databaseName -> {
                    if (multitenantDatabaseAdmin.isDatabaseExists(databaseName)) {
                        throw new RuntimeException("Database " + databaseName + " already exists");
                    }
                });

        databaseInformationSet.stream()
                .filter(x -> !x.isOlap)
                .map(DatabaseInformation::getUsername)
                .distinct()
                .forEach(userName -> {
                    if (multitenantDatabaseAdmin.isDatabaseUserExists(userName)) {
                        throw new RuntimeException("Database schema " + userName + " already exists");
                    }
                });

    }


    @VisibleForTesting
    RdwDatabaseType dataSourceNameToRdwDatabaseType(String dataSourceName) {
        if (dataSourceName.contains(RdwDatabaseType.MIGRATE_OLAP.datasourceNameHint)) {
            return RdwDatabaseType.MIGRATE_OLAP;
        } else if (dataSourceName.contains(RdwDatabaseType.REPORTING.datasourceNameHint)) {
            return RdwDatabaseType.REPORTING;
        } else if (dataSourceName.contains(RdwDatabaseType.REPORTING_OLAP.datasourceNameHint)) {
            return RdwDatabaseType.REPORTING_OLAP;
        } else if (dataSourceName.contains(RdwDatabaseType.WAREHOUSE.datasourceNameHint)) {
            return RdwDatabaseType.WAREHOUSE;
        } else {
            throw new RuntimeException("Unknown matching RDW Database Type for DataSourceName " + dataSourceName);
        }
    }

    @VisibleForTesting
    Set<DatabaseInformation> gatherDatabaseInformation(TenantConfiguration tenantConfiguration) {
        Map<String, DataSourceElementsTenant> dataSources =
                tenantConfiguration.getApplicationTenantConfiguration().getDataSources();

        HashSet<DatabaseInformation> databaseInformation = new HashSet<>();
        dataSources.forEach((key, value) -> {
            RdwDatabaseType dbType = dataSourceNameToRdwDatabaseType(key);
            String name;
            if (dbType.isOlap) {
                name = value.getSchemaSearchPath();
            } else {
                name = value.getUrlParts().getDatabase();
            }
            String username = value.getUsername();
            String password = value.getPassword();
            boolean isRw = key.toLowerCase().contains("rw");
            databaseInformation.add(new DatabaseInformation(name, username, password, dbType.isOlap, isRw, dbType));
        });
        return ImmutableSet.copyOf(databaseInformation);
    }

    @VisibleForTesting
    enum RdwDatabaseType {
        REPORTING_OLAP("olap_r", true),
        MIGRATE_OLAP("migrate_r", false),
        REPORTING("reporting_r", false),
        WAREHOUSE("warehouse_r", false);

        private final String datasourceNameHint;
        private final boolean isOlap;

        RdwDatabaseType(String datasourceNameHint, boolean isOlap) {
            this.datasourceNameHint = datasourceNameHint;
            this.isOlap = isOlap;
        }
    }

    @VisibleForTesting
    static class DatabaseInformation {
        private final String databaseOrSchemaName;
        private final String username;
        private final String password;
        private final boolean isOlap;
        private final boolean isRw;
        private final RdwDatabaseType rdwDatabaseType;

        DatabaseInformation(String databaseOrSchemaName,
                            String username,
                            String password,
                            boolean isOlap,
                            boolean isRw,
                            RdwDatabaseType rdwDatabaseType) {
            this.databaseOrSchemaName = databaseOrSchemaName;
            this.username = username;
            this.password = password;
            this.isOlap = isOlap;
            this.isRw = isRw;
            this.rdwDatabaseType = rdwDatabaseType;
        }

        String getDatabaseOrSchemaName() {
            return databaseOrSchemaName;
        }

        String getUsername() {
            return username;
        }

        String getPassword() {
            return password;
        }

        boolean isOlap() {
            return isOlap;
        }

        boolean isRw() {
            return isRw;
        }

        RdwDatabaseType getRdwDatabaseType() {
            return rdwDatabaseType;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof DatabaseInformation)) return false;
            DatabaseInformation that = (DatabaseInformation) o;
            return isOlap() == that.isOlap() &&
                    isRw() == that.isRw() &&
                    Objects.equal(getDatabaseOrSchemaName(), that.getDatabaseOrSchemaName()) &&
                    Objects.equal(getUsername(), that.getUsername()) &&
                    Objects.equal(getPassword(), that.getPassword()) &&
                    getRdwDatabaseType() == that.getRdwDatabaseType();
        }

        @Override
        public int hashCode() {
            return Objects.hashCode(getDatabaseOrSchemaName(), getUsername(), getPassword(), isOlap(), isRw(), getRdwDatabaseType());
        }

        @Override
        public String toString() {
            return "DatabaseInformation{" +
                    "databaseOrSchemaName='" + databaseOrSchemaName + '\'' +
                    ", username='" + username + '\'' +
                    ", password='" + password + '\'' +
                    ", isOlap=" + isOlap +
                    ", isRw=" + isRw +
                    ", rdwDatabaseType=" + rdwDatabaseType +
                    '}';
        }
    }

}
