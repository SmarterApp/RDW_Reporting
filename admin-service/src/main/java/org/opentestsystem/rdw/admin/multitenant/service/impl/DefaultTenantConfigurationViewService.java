package org.opentestsystem.rdw.admin.multitenant.service.impl;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Maps;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.opentestsystem.rdw.admin.multitenant.TenantType;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatusContext;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatusService;
import org.opentestsystem.rdw.admin.multitenant.configprops.ConfigpropsService;
import org.opentestsystem.rdw.admin.multitenant.configserver.ConfigServerClient;
import org.opentestsystem.rdw.admin.multitenant.model.TenantConfiguration;
import org.opentestsystem.rdw.admin.multitenant.service.TenantConfigurationViewService;
import org.opentestsystem.rdw.archive.ArchivePropertiesTenant;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.multitenant.TenantProperties;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsTenant;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemPropertiesImpl;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Classes to return tenant and sandbox properties from the RDW Actuator endpoint calls
 * This is the service the tenant & sandbox service use to retrieve default and tenant specific properties & settings
 */
@Service
//TODO: refresh scope this for TenantProperties?  don't think so but verify
public class DefaultTenantConfigurationViewService implements TenantConfigurationViewService {

    private static final Logger logger = LoggerFactory.getLogger(DefaultTenantConfigurationViewService.class);

    private final ObjectMapper mapper;
    private final ConfigpropsService configpropsService;
    private final TenantAdministrationStatusService tenantAdministrationStatusService;
    private final ConfigServerClient configServerClient;

    @Autowired
    public DefaultTenantConfigurationViewService(ObjectMapper objectMapper,
                                                 ConfigpropsService configpropsService,
                                                 TenantAdministrationStatusService tenantAdministrationStatusService,
                                                 ConfigServerClient configServerClient) {
        this.mapper = objectMapper.copy();
        JavaTimeModule javaTimeModule = new JavaTimeModule();
        this.mapper.registerModule(javaTimeModule);
        this.mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

        this.configpropsService = configpropsService;
        this.tenantAdministrationStatusService = tenantAdministrationStatusService;
        this.configServerClient = configServerClient;
    }

    @Override
    public TenantConfiguration defaultTenantConfiguration() {
        final TenantConfiguration.Builder tenantConfigurationBuilder = TenantConfiguration.builder();

        configpropsService.defaultAggregateReportingProperties()
                .ifPresent(tenantConfigurationBuilder::aggregateReportingProperties);

        configpropsService.defaultArchiveProperties()
                .ifPresent(archiveProperties -> {
                    //TODO: better solution, should have is-a relationship
                    tenantConfigurationBuilder.archiveProperties(mapper.convertValue(archiveProperties,
                            ArchivePropertiesTenant.class));
                });

        configpropsService.defaultReportingSystemProperties()
                .ifPresent(reportingSystemSettings -> {
                    tenantConfigurationBuilder.reporting(mapper.convertValue(reportingSystemSettings,
                            ReportingSystemPropertiesImpl.class));
                });

        tenantConfigurationBuilder.dataSources(
                //TODO: better solution, should have is-a relationship
                configpropsService.defaultDataSourceElements()
                        .entrySet()
                        .stream()
                        .map(entry -> ImmutablePair.of(entry.getKey(), mapper.convertValue(entry.getValue(), DataSourceElementsTenant.class)))
                        .collect(Collectors.toMap(ImmutablePair::getLeft, ImmutablePair::getRight))
        );

        return tenantConfigurationBuilder.build();
    }

    @Override
    public TenantConfiguration initialSandboxTenantConfiguration(String parentKey) {
        Optional<TenantConfiguration> parentTenantConfigurationOptional = findActiveTenantConfiguration(parentKey);
        if (!parentTenantConfigurationOptional.isPresent()) {
            throw new IllegalStateException("Unable to create sandbox without valid parent tenantKey.  not found: " + parentKey);
        }
        TenantConfiguration parentTenantConfiguration = parentTenantConfigurationOptional.get();
        TenantConfiguration.Builder tenantConfigurationBuilder = TenantConfiguration.builder();

        tenantConfigurationBuilder.reporting(parentTenantConfiguration.getReporting());
        tenantConfigurationBuilder.aggregateReportingProperties(parentTenantConfiguration.getAggregateReportingProperties());

        tenantConfigurationBuilder.parentTenantKey(parentKey);
        return tenantConfigurationBuilder.build();
    }

    @Override
    public Optional<TenantConfiguration> findActiveTenantConfiguration(final String tenantKey) {
        return activeTenantConfiguration(tenantKey);
    }

    @Override
    public Map<String, TenantConfiguration> allTenantConfigurations(TenantType tenantType) {
        final Map<String, TenantConfiguration> activeTenantConfigurationMap =
                activeTenantConfigurationsByType(tenantType);
        final Map<String, TenantConfiguration> inProcessTenantConfigurationMap =
                inProcessTenantConfigurationsByType(tenantType);
        Stream<Map.Entry<String, TenantConfiguration>> combined =
                Stream.concat(activeTenantConfigurationMap.entrySet().stream(),
                        inProcessTenantConfigurationMap.entrySet().stream());

        return combined.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    @Override
    public boolean exists(final String key) {
        return activeTenants().containsKey(key)
                || inProcessTenants().containsKey(key);
    }

    @VisibleForTesting
    Optional<TenantConfiguration> activeTenantConfiguration(String tenantKey) {
        final Map<String, Tenant> tenants = activeTenants();
        if (!tenants.containsKey(tenantKey)) {
            return Optional.empty();
        }

        final Tenant tenant = tenants.get(tenantKey);
        final boolean isSandbox = tenant.isSandbox();
        final TenantConfiguration.Builder tenantConfigurationBuilder = TenantConfiguration.builder();

        //both sandbox and non-sandbox
        tenantConfigurationBuilder.tenant(tenant);
        tenantConfigurationBuilder.administrationStatus(
                TenantAdministrationStatusContext
                        .builder()
                        .tenantAdministrationStatus(TenantAdministrationStatus.ACTIVE)
                        .build());


        configpropsService.reportingSystemProperties(tenantKey).ifPresent(reporting -> {
            tenantConfigurationBuilder.reporting(reporting);
            final String translationLocation = reporting.getTranslationLocation();
            final String languageCode = getLanguageCode(reporting.getUiLanguages());
            configServerClient.getLocalization(translationLocation, languageCode)
                    .ifPresent(tenantConfigurationBuilder::localizaton);
        });

        configpropsService.aggregateReportingProperties(tenantKey)
                .ifPresent(tenantConfigurationBuilder::aggregateReportingProperties);

        if (isSandbox) {
            //sandbox only
            tenantConfigurationBuilder.parentTenantKey(parentTenantKey(tenantKey));
        } else {
            //non-sandbox only
            configpropsService.archiveProperties(tenantKey).ifPresent(tenantConfigurationBuilder::archiveProperties);
            tenantConfigurationBuilder.dataSources(configpropsService.dataSourceElements(tenantKey));
        }
        return Optional.of(tenantConfigurationBuilder.build());
    }

    /**
     * ATM will return the first configured uiLanguage,
     * Expect entry to be the same name as the i18n json file (minus the json extension)
     *
     * @param uiLanguages list of uiLanguages, can be an empty list
     * @return uiLanguage code if set,  "en" as default and for not specifically configured
     */
    private String getLanguageCode(final List<String> uiLanguages) {
        // todo: needs review if this makes sense for now.
        // how to handle list of uiLanguages, how to pick which to use
        // for now return the first non "en" uiLanguage
        if (!uiLanguages.isEmpty()) {
            return uiLanguages.get(0);
        }
        // otherwise
        return "en";
    }

    @VisibleForTesting
    Map<String, TenantConfiguration> activeTenantConfigurationsByType(TenantType tenantType) {
        return activeTenantsByType(tenantType)
                .keySet()
                .stream()
                .map(tenantKey -> ImmutablePair.of(tenantKey, findActiveTenantConfiguration(tenantKey)))
                .filter(pair -> pair.getRight().isPresent())
                .collect(Collectors.toMap(ImmutablePair::getLeft, pair -> pair.getRight().get()));
    }

    @VisibleForTesting
    Map<String, Tenant> activeTenants() {
        return configpropsService
                .tenantProperties()
                .map(TenantProperties::getTenants)
                .orElse(Maps.newHashMap());
    }

    @VisibleForTesting
    Map<String, Tenant> activeTenantsByType(TenantType tenantType) {
        return activeTenants()
                .entrySet()
                .stream()
                .filter(entry -> entry.getValue().isSandbox() == (tenantType == TenantType.SANDBOX))
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    @VisibleForTesting
    Map<String, Tenant> inProcessTenants() {
        return allInProcessTenantConfigurations()
                .entrySet()
                .stream()
                .map(entry -> ImmutablePair.of(entry.getKey(), entry.getValue().getTenant()))
                .collect(Collectors.toMap(ImmutablePair::getLeft, ImmutablePair::getRight));
    }

    @VisibleForTesting
    Map<String, TenantConfiguration> inProcessTenantConfigurationsByType(final TenantType tenantType) {
        return allInProcessTenantConfigurations()
                .entrySet()
                .stream()
                .filter(entry -> entry.getValue().getTenant().isSandbox() == (tenantType == TenantType.SANDBOX))
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    @VisibleForTesting
    Map<String, TenantConfiguration> allInProcessTenantConfigurations() {
        //grab a list of current tenant to compare against, in process list may be slightly stale
        //this allow removal as side effect if that's the case
        final Map<String, Tenant> activeTenants = activeTenants();

        //snapshot of tenant status service state
        final ImmutableMap<String, TenantAdministrationStatusContext> currentAllTenantStatus =
                tenantAdministrationStatusService
                        .allTenantStatusAsMap();

        //gather tenant tenant status currently in the status service
        final Map<String, TenantAdministrationStatusContext> currentSandboxTenantStatus = currentAllTenantStatus
                .entrySet()
                .stream()
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));

        //set of keys that have a status and also exist in the current set of tenants
        final Set<String> statusStaleKeysWithExistingTenant = currentSandboxTenantStatus
                .keySet()
                .stream()
                .filter(activeTenants::containsKey)
                .collect(Collectors.toSet());

        //side effect: clean up the status for tenant tenants that are stale
        statusStaleKeysWithExistingTenant.forEach(k -> tenantAdministrationStatusService.remove(k));

        //tenant status with stale tenants removed
        final Map<String, TenantAdministrationStatusContext> activeCurrentSandboxTenantStatus = currentSandboxTenantStatus
                .entrySet()
                .stream()
                .filter(entry -> !statusStaleKeysWithExistingTenant.contains(entry.getKey()))
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));

        //construct result
        return activeCurrentSandboxTenantStatus.entrySet()
                .stream()
                .map(entry -> {
                    String key = entry.getKey();
                    TenantAdministrationStatusContext status = entry.getValue();
                    TenantConfiguration currentTenantConfiguration = currentAllTenantStatus.get(key).getTenantConfiguration();
                    TenantConfiguration.Builder tenantConfigurationBuilder =
                            TenantConfiguration.builder().copy(currentTenantConfiguration);
                    tenantConfigurationBuilder.administrationStatus(status);
                    return ImmutablePair.of(key, tenantConfigurationBuilder.build());
                })
                .collect(Collectors.toMap(Pair::getLeft, Pair::getRight));
    }

    @VisibleForTesting
    String parentTenantKey(final String tenantKey) {
        final String sandboxPattern = "_S";
        if (tenantKey.contains(sandboxPattern)) {
            return tenantKey.substring(0, tenantKey.indexOf(sandboxPattern));
        }
        return null;
    }

}
