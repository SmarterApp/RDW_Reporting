package org.opentestsystem.rdw.admin.multitenant.service.impl;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Maps;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.opentestsystem.rdw.admin.multitenant.TenantType;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatusService;
import org.opentestsystem.rdw.admin.multitenant.configprops.ConfigpropsService;
import org.opentestsystem.rdw.admin.multitenant.model.TenantConfiguration;
import org.opentestsystem.rdw.admin.multitenant.service.TenantConfigurationViewService;
import org.opentestsystem.rdw.archive.ArchivePropertiesTenant;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.multitenant.TenantProperties;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsTenant;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemPropertiesImpl;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Service
public class DefaultTenantConfigurationViewService implements TenantConfigurationViewService {

    private static final Logger logger = LoggerFactory.getLogger(DefaultTenantConfigurationViewService.class);

    private final ObjectMapper mapper;
    private final ConfigpropsService configpropsService;
    private final TenantAdministrationStatusService tenantAdministrationStatusService;

    @Autowired
    public DefaultTenantConfigurationViewService(ObjectMapper objectMapper,
                                                 ConfigpropsService configpropsService,
                                                 TenantAdministrationStatusService tenantAdministrationStatusService) {
        this.mapper = objectMapper.copy();
        this.configpropsService = configpropsService;
        this.tenantAdministrationStatusService = tenantAdministrationStatusService;
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
    }

    @Override
    public TenantConfiguration defaultTenantConfiguration() {
        final TenantConfiguration tenantConfiguration = new TenantConfiguration();

        configpropsService.defaultAggregateReportingProperties()
                .ifPresent(tenantConfiguration::setAggregateReportingProperties);

        configpropsService.defaultArchiveProperties()
                .ifPresent(archiveProperties -> {
                    //TODO: better solution, should have is-a relationship
                    tenantConfiguration
                            .setArchiveProperties(mapper.convertValue(archiveProperties,
                                    ArchivePropertiesTenant.class));
                });

        configpropsService.defaultReportingSystemProperties()
                .ifPresent(reportingSystemSettings -> {
                    //TODO: better solution, should have is-a relationship
                    tenantConfiguration
                            .setReporting(mapper.convertValue(reportingSystemSettings,
                                    ReportingSystemPropertiesImpl.class));
                });

        tenantConfiguration.setDataSources(
                //TODO: better solution, should have is-a relationship
                configpropsService.defaultDataSourceElements()
                        .entrySet()
                        .stream()
                        .map(entry -> ImmutablePair.of(entry.getKey(), mapper.convertValue(entry.getValue(), DataSourceElementsTenant.class)))
                        .collect(Collectors.toMap(ImmutablePair::getLeft, ImmutablePair::getRight))
        );

        return tenantConfiguration;
    }

    @Override
    public TenantConfiguration initialSandboxTenantConfiguration(String parentKey) {
        TenantConfiguration parentTenantConfiguration = tenantConfiguration(parentKey);
        TenantConfiguration tenantConfiguration = new TenantConfiguration();

        tenantConfiguration.setReporting(parentTenantConfiguration.getReporting());
        tenantConfiguration.setAggregateReportingProperties(parentTenantConfiguration.getAggregateReportingProperties());

        tenantConfiguration.setParentTenantKey(parentKey);
        return tenantConfiguration;
    }

    @Override
    public TenantConfiguration tenantConfiguration(final String tenantKey) {
        //TODO: should this also merge in-process?
        return activeTenantConfiguration(tenantKey);
    }

    @Override
    public Map<String, TenantConfiguration> allTenantConfigurations(TenantType tenantType) {
        Stream<Map.Entry<String, TenantConfiguration>> combined =
                Stream.concat(activeTenantConfigurationsByType(tenantType).entrySet().stream(),
                        inProcessTenantConfigurationsByType(tenantType).entrySet().stream());

        return combined.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    @VisibleForTesting
    TenantConfiguration activeTenantConfiguration(String tenantKey) {
        final Map<String, Tenant> tenants = activeTenants();
        if (!tenants.containsKey(tenantKey)) {
            throw new IllegalArgumentException("No tenant with key " + tenantKey + "found");
        }

        final Tenant tenant = tenants.get(tenantKey);
        final boolean isSandbox = tenant.isSandbox();
        final TenantConfiguration tenantConfiguration = new TenantConfiguration();

        //both sandbox and non-sandbox
        tenantConfiguration.setTenant(tenant);
        tenantConfiguration.setAdministrationStatus(TenantAdministrationStatus.ACTIVE);

        //TODO: Add localization fetch API
        //tenantConfiguration.setLocalization();

        configpropsService.reportingSystemProperties(tenantKey)
                .ifPresent(tenantConfiguration::setReporting);
        configpropsService.aggregateReportingProperties(tenantKey)
                .ifPresent(tenantConfiguration::setAggregateReportingProperties);

        if (isSandbox) {
            //sandbox only
            tenantConfiguration.setParentTenantKey(parentTenantKey(tenantKey));
        } else {
            //non-sandbox only
            configpropsService.archiveProperties(tenantKey).ifPresent(tenantConfiguration::setArchiveProperties);
            tenantConfiguration.setDataSources(configpropsService.dataSourceElements(tenantKey));
        }
        return tenantConfiguration;
    }

    @VisibleForTesting
    Map<String, TenantConfiguration> activeTenantConfigurationsByType(TenantType tenantType) {
        return activeTenantsByType(tenantType)
                .keySet()
                .stream()
                .map(tenantKey -> ImmutablePair.of(tenantKey, tenantConfiguration(tenantKey)))
                .collect(Collectors.toMap(ImmutablePair::getLeft, ImmutablePair::getRight));
    }

    @VisibleForTesting
    Map<String, Tenant> activeTenants() {
        return configpropsService
                .tenantProperties()
                .map(TenantProperties::getTenants)
                .orElse(Maps.newHashMap());
    }

    @VisibleForTesting
    Map<String, Tenant> activeTenantsByType(TenantType tenantType) {
        return activeTenants()
                .entrySet()
                .stream()
                .filter(entry -> entry.getValue().isSandbox() == (tenantType == TenantType.SANDBOX))
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    @VisibleForTesting
    Map<String, TenantConfiguration> inProcessTenantConfigurationsByType(final TenantType tenantType) {
        final Map<String, Tenant> currentSandboxTenants = activeTenantsByType(tenantType);

        //snapshot of tenant status service state
        final ImmutableMap<String, Pair<TenantAdministrationStatus, TenantConfiguration>> currentAllTenantStatus =
                tenantAdministrationStatusService
                        .allTenantStatusAsMap();

        //gather tenant tenant status currently in the status service
        final Map<String, TenantAdministrationStatus> currentSandboxTenantStatus = currentAllTenantStatus
                .entrySet()
                .stream()
                .filter(entry -> entry.getValue().getRight().getTenant().isSandbox() == (tenantType == TenantType.SANDBOX))
                .collect(Collectors.toMap(Map.Entry::getKey,
                        e -> e.getValue().getLeft()));

        //set of keys that have a status and also exist in the current set of tenants
        final Set<String> statusStaleKeysWithExistingTenant = currentSandboxTenantStatus
                .keySet()
                .stream()
                .filter(currentSandboxTenants::containsKey)
                .collect(Collectors.toSet());

        //side effect: clean up the status for tenant tenants that are stale
        statusStaleKeysWithExistingTenant.forEach(k -> tenantAdministrationStatusService.remove(k));

        //tenant status with stale tenants removed
        final Map<String, TenantAdministrationStatus> activeCurrentSandboxTenantStatus = currentSandboxTenantStatus
                .entrySet()
                .stream()
                .filter(entry -> !statusStaleKeysWithExistingTenant.contains(entry.getKey()))
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));

        //construct result
        final Map<String, TenantConfiguration> inProcessTenantConfigurations = activeCurrentSandboxTenantStatus.entrySet()
                .stream()
                .map(entry -> {
                    String key = entry.getKey();
                    TenantAdministrationStatus status = entry.getValue();
                    TenantConfiguration tenantConfiguration = currentAllTenantStatus.get(key).getRight();
                    tenantConfiguration.setAdministrationStatus(status);
                    return ImmutablePair.of(key, tenantConfiguration);
                })
                .collect(Collectors.toMap(Pair::getLeft, Pair::getRight));

        return inProcessTenantConfigurations;
    }

    @VisibleForTesting
    String parentTenantKey(final String tenantKey) {
        final String sandboxPattern = "_S";
        if (tenantKey.contains(sandboxPattern)) {
            return tenantKey.substring(0, tenantKey.indexOf(sandboxPattern));
        } else {
            return null;
        }
    }

}
