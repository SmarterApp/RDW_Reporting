package org.opentestsystem.rdw.admin.multitenant.service.impl;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableMap;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.opentestsystem.rdw.admin.multitenant.TenantType;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatusContext;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatusService;
import org.opentestsystem.rdw.admin.multitenant.configprops.ConfigpropsService;
import org.opentestsystem.rdw.admin.multitenant.configserver.ConfigServerClient;
import org.opentestsystem.rdw.admin.multitenant.model.TenantConfiguration;
import org.opentestsystem.rdw.admin.multitenant.service.TenantConfigurationViewService;
import org.opentestsystem.rdw.archive.ArchivePropertiesTenant;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsTenant;
import org.opentestsystem.rdw.multitenant.task.ArtClientPropertiesTenant;
import org.opentestsystem.rdw.multitenant.task.ImportServiceClientPropertiesTenant;
import org.opentestsystem.rdw.multitenant.validation.ExamProcessorValidationPropertiesTenant;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemPropertiesImpl;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Classes to return tenant and sandbox properties from the RDW Actuator endpoint calls
 * This is the service the tenant & sandbox service use to retrieve default and tenant specific properties & settings
 */
@Service
public class DefaultTenantConfigurationViewService implements TenantConfigurationViewService {

    private static final Logger logger = LoggerFactory.getLogger(DefaultTenantConfigurationViewService.class);

    private final ObjectMapper mapper;
    private final ConfigpropsService configpropsService;
    private final TenantAdministrationStatusService tenantAdministrationStatusService;
    private final ConfigServerClient configServerClient;

    @Autowired
    public DefaultTenantConfigurationViewService(ObjectMapper objectMapper,
                                                 ConfigpropsService configpropsService,
                                                 TenantAdministrationStatusService tenantAdministrationStatusService,
                                                 ConfigServerClient configServerClient) {
        this.mapper = objectMapper.copy();
        JavaTimeModule javaTimeModule = new JavaTimeModule();
        this.mapper.registerModule(javaTimeModule);
        this.mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

        this.configpropsService = configpropsService;
        this.tenantAdministrationStatusService = tenantAdministrationStatusService;
        this.configServerClient = configServerClient;
    }

    @Override
    public TenantConfiguration defaultTenantConfiguration() {
        final TenantConfiguration.Builder tenantConfigurationBuilder = TenantConfiguration.builder();

        configpropsService.defaultAggregateReportingProperties()
                .ifPresent(tenantConfigurationBuilder::aggregateReportingProperties);

        configpropsService.defaultArchiveProperties()
                .ifPresent(archiveProperties -> {
                    //TODO: better solution, should have is-a relationship
                    tenantConfigurationBuilder.archiveProperties(mapper.convertValue(archiveProperties,
                            ArchivePropertiesTenant.class));
                });

        configpropsService.defaultReportingSystemProperties()
                .ifPresent(reportingSystemSettings -> {
                    tenantConfigurationBuilder.reporting(mapper.convertValue(reportingSystemSettings,
                            ReportingSystemPropertiesImpl.class));
                });

        tenantConfigurationBuilder.dataSources(
                //TODO: better solution, should have is-a relationship
                configpropsService.defaultDataSourceElements()
                        .entrySet()
                        .stream()
                        .map(entry -> ImmutablePair.of(entry.getKey(), mapper.convertValue(entry.getValue(), DataSourceElementsTenant.class)))
                        .collect(Collectors.toMap(ImmutablePair::getLeft, ImmutablePair::getRight))
        );

        configpropsService.defaultValidation()
                .ifPresent(validation -> {
                    tenantConfigurationBuilder.validation(mapper.convertValue(validation,
                            ExamProcessorValidationPropertiesTenant.class));
                });

        configpropsService.defaultArtClient().ifPresent(artClient -> {
            tenantConfigurationBuilder.artClient(mapper.convertValue(artClient,
                    ArtClientPropertiesTenant.class));
        });

        configpropsService.defaultImportServiceClient().ifPresent(importServiceClient -> {
            tenantConfigurationBuilder.importServiceClient(mapper.convertValue(importServiceClient,
                    ImportServiceClientPropertiesTenant.class));
        });

        return tenantConfigurationBuilder.build();
    }

    @Override
    public Optional<TenantConfiguration> findActiveTenantConfiguration(final String tenantKey) {
        return configServerClient.findApplicationTenantConfigurationPersistence(tenantKey)
                .map(configurationPersistence -> {
                    final TenantConfiguration baseTenantConfiguration =
                            configurationPersistence.toTenantConfiguration();
                    TenantConfiguration.Builder builder =
                            TenantConfiguration.builder().copy(baseTenantConfiguration);
                    final boolean isSandbox = baseTenantConfiguration.getTenant().isSandbox();
                    Optional.ofNullable(baseTenantConfiguration.getReporting())
                            .map(ReportingSystemPropertiesImpl::getTranslationLocation)
                            .flatMap(translationLocation -> configServerClient.getLocalization(translationLocation, "en"))
                            .ifPresent(builder::localizaton);
                    if (isSandbox) {
                        //sandbox only, derived value
                        builder.parentTenantKey(parentTenantKey(tenantKey));
                    }
                    builder.administrationStatus(
                            TenantAdministrationStatusContext
                                    .builder()
                                    .tenantAdministrationStatus(TenantAdministrationStatus.ACTIVE)
                                    .build());
                    return builder.build();
                });
    }

    @Override
    public Map<String, TenantConfiguration> allTenantConfigurations(TenantType tenantType) {
        final ImmutableMap<String, TenantAdministrationStatusContext> currentAllTenantStatus =
                tenantAdministrationStatusService
                        .allTenantStatusAsMap();

        return currentAllTenantStatus.entrySet().stream()
                .filter(entry -> entry.getValue().getTenant().isSandbox() == (tenantType == TenantType.SANDBOX))
                .collect(Collectors.toMap(
                        Map.Entry::getKey,
                        entry -> TenantConfiguration.builder()
                                .tenant(entry.getValue().getTenant())
                                .administrationStatus(TenantAdministrationStatusContext.builder()
                                        .tenantAdministrationStatus(entry.getValue().getTenantAdministrationStatus())
                                        .message(entry.getValue().getMessage())
                                        .stackTrace(entry.getValue().getStackTrace())
                                        .build())
                                .build()));
    }

    @Override
    public boolean exists(final String key) {
        return tenantAdministrationStatusService.findStatus(key).isPresent();
    }

    @Override
    public boolean existsId(final String id) {
        return tenantAdministrationStatusService.findStatusById(id).isPresent();
    }

    @VisibleForTesting
    String parentTenantKey(final String tenantKey) {
        final String sandboxPattern = "_S";
        if (tenantKey.contains(sandboxPattern)) {
            return tenantKey.substring(0, tenantKey.indexOf(sandboxPattern));
        }
        return null;
    }

}
