package org.opentestsystem.rdw.admin.multitenant.configprops;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.TreeNode;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Sets;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.opentestsystem.rdw.archive.ArchivePropertiesRoot;
import org.opentestsystem.rdw.archive.ArchivePropertiesTenant;
import org.opentestsystem.rdw.multitenant.TenantProperties;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsProperties;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsTenant;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingPropertiesRoot;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingPropertiesTenant;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemPropertiesImpl;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemSettings;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashSet;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

public class DefaultConfigpropsService implements ConfigpropsService {

    private static final Logger logger = LoggerFactory.getLogger(DefaultConfigpropsService.class);

    private final ConfigpropsConsolidationService configpropsConsolidationService;
    private final ObjectMapper mapper;

    //TODO: investigate externalizing/making consistent two sets of keys, may be an enum, or may be configuration, or may leave as inferred
    //  1) the service names (they should match spring.application.name and possibly some instance identifier (multiple webapps for instance)
    //  2) root configuration keys "reporting",  "aggregateReporting" (or "aggregate-reporting"!), the datasource.* some are partial matches

    public DefaultConfigpropsService(final ConfigpropsConsolidationService configpropsConsolidationService,
                                     final ObjectMapper mapper) {

        this.configpropsConsolidationService = configpropsConsolidationService;
        this.mapper = mapper;
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        mapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);
    }

    @Override
    public Optional<ReportingSystemSettings> defaultReportingSystemProperties() {
        Map<String, ReportingSystemSettings> reportingSystemSettings =
                serviceConfigurationMap("reporting", ReportingSystemSettings.class);

        //special case not using condenseConfigurations for RP-548 workaround
        HashSet<ReportingSystemSettings> set = Sets.newHashSet(reportingSystemSettings.values());
        if (set.size() > 1) {
            logger.info("More than one ReportingSystemSettings resolved, please ensure all tenant aware default configurations are identical, count[{}] {}", set.size(), set);
            //TODO: workaround until fix for RP-548
            if (reportingSystemSettings.containsKey("reporting-webapp") && reportingSystemSettings.containsKey("reporting-service")) {
                ReportingSystemSettings webappSettings = reportingSystemSettings.get("reporting-service");
                ReportingSystemSettings reportingServiceSettings = reportingSystemSettings.get("reporting-service");
                //prefer webapp add school year and state from reporting-service
                webappSettings.setSchoolYear(reportingServiceSettings.getSchoolYear());
                webappSettings.setState(reportingServiceSettings.getState());
                return Optional.of(webappSettings);
            }
        }
        return set.stream().findFirst();
    }

    @Override
    public Optional<ReportingSystemPropertiesImpl> reportingSystemProperties(final String tenantKey) {
        return defaultReportingSystemProperties()
                .map(reportingSystemSettings -> reportingSystemSettings.getTenants()
                        .get(tenantKey));
    }

    @Override
    public Optional<ArchivePropertiesRoot> defaultArchiveProperties() {
        final String configTypeKey = "archive";
        return condenseConfigurations(
                serviceConfigurationMap(configTypeKey, ArchivePropertiesRoot.class),
                configTypeKey);
    }

    @Override
    public Optional<ArchivePropertiesTenant> archiveProperties(final String tenantKey) {
        return defaultArchiveProperties()
                .map(reportingSystemSettings -> reportingSystemSettings.getTenants()
                        .get(tenantKey));
    }

    @Override
    public Optional<AggregateReportingPropertiesRoot> defaultAggregateReportingProperties() {
        final String configTypeKey = "aggregateReporting";
        return condenseConfigurations(
                serviceConfigurationMap(configTypeKey, AggregateReportingPropertiesRoot.class),
                configTypeKey);
    }

    @Override
    public Optional<AggregateReportingPropertiesTenant> aggregateReportingProperties(final String tenantKey) {
        return defaultAggregateReportingProperties()
                .map(aggregateReportingPropertiesRoot -> aggregateReportingPropertiesRoot.getTenants().get(tenantKey));
    }

    @Override
    public Optional<TenantProperties> tenantProperties() {
        final String configTypeKey = "tenantProperties";
        return condenseConfigurations(
                serviceConfigurationMap(configTypeKey, TenantProperties.class),
                configTypeKey);
    }

    @Override
    public Map<String, DataSourceElementsProperties> defaultDataSourceElements() {
        final String configTypeKeyPrefix = "datasources.";
        return configuredDataSourceKeys()
                .stream()
                .map(key -> ImmutablePair.of(StringUtils.removeStart(key, configTypeKeyPrefix),
                        defaultDataSourceElementsByConfigType(key)))
                .filter(pair -> pair.getRight().isPresent())
                .collect(Collectors.toMap(ImmutablePair::getLeft, pair -> pair.getRight().get()));
    }

    @Override
    public Map<String, DataSourceElementsTenant> dataSourceElements(final String tenantKey) {
        return defaultDataSourceElements()
                .entrySet()
                .stream()
                .map(entry -> ImmutablePair.of(entry.getKey(), entry.getValue().getTenants().get(tenantKey)))
                .filter(pair -> pair.getRight() != null)
                .collect(Collectors.toMap(ImmutablePair::getLeft, ImmutablePair::getRight));
    }

    /**
     * Default configuration for a datasource
     *
     * @param configTypeKey specific configuration
     * @return datasource elements
     */
    private Optional<DataSourceElementsProperties> defaultDataSourceElementsByConfigType(final String configTypeKey) {
        return condenseConfigurations(
                serviceConfigurationMap(configTypeKey, DataSourceElementsProperties.class),
                configTypeKey);
    }

    /**
     * All keys that are prefixed by "datasource."
     *
     * @return Set of configTypeKey
     */
    private Set<String> configuredDataSourceKeys() {
        final String configTypeKeyPrefix = "datasources.";
        return configpropsConsolidationService
                .extractServicePrefixProperties()
                .values()
                .stream()
                .flatMap(stringJsonNodeMap -> stringJsonNodeMap.keySet().stream())
                .filter(configTypeKey -> configTypeKey.startsWith(configTypeKeyPrefix))
                .collect(Collectors.toSet());
    }

    /**
     * Convert a map of serviceName to configuration into a single optional configuration
     * warns if there are duplicate configurations
     *
     * @param configurations serviceName to configuration map
     * @param configTypeKey  The type of configuration to extract ("reporting", "archive", "aggregate-reporting", etc)
     * @param <T>            Type
     * @return a single optional configuration
     */
    private <T> Optional<T> condenseConfigurations(final Map<String, T> configurations, final String configTypeKey) {
        HashSet<T> configurationSet = Sets.newHashSet(configurations.values());
        //one or none are expected
        if (configurationSet.size() > 1) {
            logger.info("More than one {} resolved, please ensure all tenant aware default configurations are identical, count[{}] {}", configTypeKey, configurationSet.size(), configurationSet);
        }
        return configurationSet.stream().findFirst();
    }

    /**
     * Get a Map of service names to matching parsed objects
     *
     * @param configTypeKey The type of configuration to extract ("reporting", "archive", "aggregate-reporting", etc)
     * @param valueType     Type to parse to
     * @param <T>           Type
     * @return Map of service names to parsed objects
     */
    private <T> Map<String, T> serviceConfigurationMap(final String configTypeKey, final Class<T> valueType) {
        return findJsonByKey(configTypeKey)
                .entrySet()
                .stream()
                .map(entry -> ImmutablePair.of(entry.getKey(), treeToValue(entry.getValue(), valueType)))
                .filter(pair -> pair.getRight().isPresent())
                .collect(Collectors.toMap(ImmutablePair::getLeft, pair -> pair.getRight().get()));
    }

    /**
     * Get a Map of service names to matching JsonNode configurations for a particular configuration type.
     *
     * @param configTypeKey The type of configuration to extract ("reporting", "archive", "aggregate-reporting", etc)
     * @return Map of service names to {@link JsonNode} configuration
     */
    @VisibleForTesting
    Map<String, JsonNode> findJsonByKey(final String configTypeKey) {
        return configpropsConsolidationService
                .extractServicePrefixProperties()
                .entrySet()
                .stream()
                .map(m -> ImmutablePair.of(m.getKey(), m.getValue().get(configTypeKey)))
                .filter(pair -> pair.getRight() != null)
                .collect(Collectors.toMap(ImmutablePair::getLeft, ImmutablePair::getRight));
    }

    /**
     * Parse a {@link JsonNode} to a class, will not throw an exception (logs warning)
     *
     * @param n         Node to parse
     * @param valueType Type to parse to
     * @param <T>       Type
     * @return The parsed type or Optional empty
     */
    @VisibleForTesting
    <T> Optional<T> treeToValue(final TreeNode n, final Class<T> valueType) {
        try {
            return Optional.ofNullable(mapper.treeToValue(n, valueType));
        } catch (JsonProcessingException e) {
            logger.warn("Error parsing JSON", e);
            return Optional.empty();
        }
    }
}
