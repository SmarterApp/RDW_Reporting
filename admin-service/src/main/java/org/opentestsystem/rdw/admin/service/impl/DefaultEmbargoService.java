package org.opentestsystem.rdw.admin.service.impl;

import org.apache.commons.codec.digest.DigestUtils;
import org.apache.tomcat.util.buf.HexUtils;
import org.opentestsystem.rdw.admin.model.Embargo;
import org.opentestsystem.rdw.admin.repository.EmbargoRepository;
import org.opentestsystem.rdw.admin.repository.ImportRepository;
import org.opentestsystem.rdw.admin.service.EmbargoService;
import org.opentestsystem.rdw.common.model.ImportContent;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemSettings;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.model.OrganizationQuery;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.repository.OrganizationRepository;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.opentestsystem.rdw.security.Permission;
import org.opentestsystem.rdw.security.PermissionScope;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.util.Collection;
import java.util.EnumSet;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.stream.Collectors;

import static org.opentestsystem.rdw.admin.security.AdminPermission.EmbargoWrite;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.District;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.State;

/**
 * Repository-backed implementation of EmbargoService.
 */
@Service
public class DefaultEmbargoService implements EmbargoService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultEmbargoService.class);

    private final EmbargoRepository repository;
    private final OrganizationRepository organizationRepository;
    private final ImportRepository importRepository;
    private final ReportingSystemSettings systemSettings;

    @Autowired
    public DefaultEmbargoService(final EmbargoRepository repository,
                                 @Qualifier("warehouseOrganizationRepository") final OrganizationRepository organizationRepository,
                                 final ImportRepository importRepository,
                                 final ReportingSystemSettings systemSettings) {
        this.repository = repository;
        this.organizationRepository = organizationRepository;
        this.importRepository = importRepository;
        this.systemSettings = systemSettings;
    }

    @Transactional(transactionManager = "warehouseTxManager")
    @Override
    public void save(final User user, final Embargo embargo) {
        if (embargo.isIndividualEnabled() == null && embargo.isAggregateEnabled() == null) {
            logger.info("Ignoring embargo update with no flags set");
            return;
        }

        // this may throw
        checkAccess(user, embargo);

        final int currentSchoolYear = systemSettings.getSchoolYear();
        final Embargo existing = (embargo.getOrganizationType() == State) ?
                repository.findOneBySchoolYearAndState(currentSchoolYear) :
                repository.findOneBySchoolYearAndDistrictId(currentSchoolYear, embargo.getOrganizationId());

        if (existing != null
         && existing.isIndividualEnabled() == embargo.isIndividualEnabled()
         && existing.isAggregateEnabled() == embargo.isAggregateEnabled()) {
            logger.info("Ignoring equivalent embargo settings for {} {} {}",
                    embargo.getOrganizationType(), embargo.getOrganizationName(), embargo.getOrganizationId());
            return;
        }

        final String digest = HexUtils.toHexString(DigestUtils.md5(user.getEmail() + Instant.now().toString()));
        final long importId = importRepository.create(ImportContent.EMBARGO, "admin embargo modification", digest, "embargo update");
        try {
            final Embargo.Builder builder = embargo.copy().schoolYear(currentSchoolYear);
            if (existing == null) {
                repository.create(builder.build(), user.getUsername());
            }
            else {
                if (embargo.isAggregateEnabled() == null) builder.aggregateEnabled(existing.isAggregateEnabled());
                if (embargo.isIndividualEnabled() == null) builder.individualEnabled(existing.isIndividualEnabled());
                repository.update(builder.build(), user.getUsername());
            }
            importRepository.setProcessed(importId);
        } catch (final Exception e) {
            logger.warn("Error updating embargo settings for {} {} {}: ",
                    embargo.getOrganizationType(), embargo.getOrganizationName(), embargo.getOrganizationId(), e.getMessage());
            importRepository.setStatus(importId, ImportStatus.INVALID, "Error: " + e.getMessage());
        }
    }

    @Override
    public Collection<Embargo> findAll(final User user) {
        // fetch Embargo for state and all districts
        final Collection<Embargo> embargos =
                repository.findAllBySchoolYear(systemSettings.getSchoolYear(), getDistrictIdsForUser(user));

        // we have to copy the collection to finish populating the state info
        final PermissionScope permissionScope = user.getPermissionsById().get(EmbargoWrite).getScope();
        return embargos.stream().map(embargo ->
                (embargo.getOrganizationType() != State) ? embargo : embargo.copy()
                    .organizationName(systemSettings.getState().getName())
                    .readOnly(!permissionScope.isStatewide())
                    .build())
                .collect(Collectors.toList());
    }

    /**
     * @param user user user
     * @param embargo embargo embargo
     * @throws NoSuchElementException if user doesn't have permission to write
     */
    private void checkAccess(final User user, final Embargo embargo) {
        final Permission permission = user.getPermissionsById().get(EmbargoWrite);
        if (permission == null) {
            throw new NoSuchElementException();
        }

        if (embargo.getOrganizationType() == State) {
            if (!permission.getScope().isStatewide()) {
                throw new NoSuchElementException();
            }
        } else if (embargo.getOrganizationType() == District) {
            final Set<Long> districtIds = getDistrictIdsForUser(user);
            if (!districtIds.contains(embargo.getOrganizationId())) {
                throw new NoSuchElementException();
            }
        } else {
            throw new IllegalArgumentException("Invalid embargo organization type");
        }
    }

    /**
     * @param user the user
     * @return list of ids of district that the user has embargo write permission
     */
    private Set<Long> getDistrictIdsForUser(final User user) {
        final PermissionScope permissionScope = user.getPermissionsById().get(EmbargoWrite).getScope();

        // We don't want to get districts inherited because of state permissions (because, for
        // embargo, state-level permissions do NOT imply permissions for districts) so copy the
        // permissions with statewide disabled.
        final Collection<Organization> districts = organizationRepository.findAll(
                permissionScope.copy().statewide(false).build(),
                OrganizationQuery.builder().types(EnumSet.of(OrganizationType.District)).build());

        return districts.stream().map(Organization::getId).collect(Collectors.toSet());
    }
}
