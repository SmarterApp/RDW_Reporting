package org.opentestsystem.rdw.admin.service.impl;

import org.apache.commons.codec.digest.DigestUtils;
import org.apache.tomcat.util.buf.HexUtils;
import org.opentestsystem.rdw.admin.model.Embargo;
import org.opentestsystem.rdw.admin.model.EmbargoAuditRecord;
import org.opentestsystem.rdw.admin.model.EmbargoQuery;
import org.opentestsystem.rdw.admin.model.TestResultAvailability;
import org.opentestsystem.rdw.admin.model.TestResultAvailabilityOptions;
import org.opentestsystem.rdw.admin.model.TestResultsReportType;
import org.opentestsystem.rdw.admin.model.TestResultsStatus;
import org.opentestsystem.rdw.admin.repository.EmbargoAuditRepository;
import org.opentestsystem.rdw.admin.repository.EmbargoRepository;
import org.opentestsystem.rdw.admin.repository.SchoolYearRepository;
import org.opentestsystem.rdw.admin.repository.SubjectRepository;
import org.opentestsystem.rdw.admin.repository.DistrictRepository;
import org.opentestsystem.rdw.admin.repository.ImportRepository;
import org.opentestsystem.rdw.admin.service.EmbargoService;
import org.opentestsystem.rdw.common.model.ImportContent;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemProperties;
import org.opentestsystem.rdw.reporting.common.model.CodedEntity;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.model.OrganizationQuery;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.repository.OrganizationRepository;
import org.opentestsystem.rdw.reporting.common.security.User;
import org.opentestsystem.rdw.security.Permission;
import org.opentestsystem.rdw.security.PermissionScope;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

import static org.opentestsystem.rdw.admin.model.TestResultsStatus.Loading;
import static org.opentestsystem.rdw.admin.model.TestResultsStatus.Released;
import static org.opentestsystem.rdw.admin.model.TestResultsStatus.Reviewing;
import static org.opentestsystem.rdw.admin.security.AdminPermission.EmbargoWrite;
import static org.opentestsystem.rdw.admin.security.AdminPermission.TestDataLoadingWrite;
import static org.opentestsystem.rdw.admin.security.AdminPermission.TestDataReviewingWrite;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.District;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.State;
import static org.opentestsystem.rdw.reporting.common.util.CollectionUtils.safeIsEmpty;

/**
 * Repository-backed implementation of EmbargoService.
 */
@Service
public class DefaultEmbargoService implements EmbargoService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultEmbargoService.class);

    private final EmbargoRepository repository;
    private final EmbargoAuditRepository auditRepository;
    private final OrganizationRepository organizationRepository;
    private final ImportRepository importRepository;
    private final ReportingSystemProperties reportingSystemProperties;
    private final SubjectRepository subjectRepository;
    private final SchoolYearRepository schoolYearRepository;

    @Autowired
    public DefaultEmbargoService(final EmbargoRepository repository,
                                 final EmbargoAuditRepository auditRepository,
                                 @Qualifier("warehouseOrganizationRepository") final OrganizationRepository organizationRepository,
                                 final ImportRepository importRepository,
                                 @Qualifier("reportingSystemPropertiesResolver") final ReportingSystemProperties reportingSystemProperties,
                                 final SubjectRepository subjectRepository,
                                 final SchoolYearRepository schoolYearRepository) {
        this.repository = repository;
        this.auditRepository = auditRepository;
        this.organizationRepository = organizationRepository;
        this.importRepository = importRepository;
        this.reportingSystemProperties = reportingSystemProperties;
        this.subjectRepository = subjectRepository;
        this.schoolYearRepository = schoolYearRepository;
    }

    @Transactional(transactionManager = "warehouseTxManager")
    @Override
    public void save(final User user, final Embargo embargo) {
        if (embargo.isIndividualEnabled() == null && embargo.isAggregateEnabled() == null) {
            logger.info("Ignoring embargo update with no flags set");
            return;
        }

        // this may throw
        checkAccess(user, embargo);

        final int currentSchoolYear = reportingSystemProperties.getSchoolYear();
        final Embargo existing = (embargo.getOrganizationType() == State) ?
                repository.findOneBySchoolYearAndState(currentSchoolYear) :
                repository.findOneBySchoolYearAndDistrictId(currentSchoolYear, embargo.getOrganizationId());

        if (existing != null
         && Objects.equals(existing.isIndividualEnabled(), embargo.isIndividualEnabled())
         && Objects.equals(existing.isAggregateEnabled(), embargo.isAggregateEnabled())) {
            logger.info("Ignoring equivalent embargo settings for {} {} {}",
                    embargo.getOrganizationType(), embargo.getOrganizationName(), embargo.getOrganizationId());
            return;
        }

        final String digest = HexUtils.toHexString(DigestUtils.md5(user.getEmail() + Instant.now().toString()));
        final long importId = importRepository.create(ImportContent.EMBARGO, "admin embargo modification", digest, "embargo update");
        try {
            final Embargo.Builder builder = embargo.copy().schoolYear(currentSchoolYear);
            if (existing == null) {
                repository.create(builder.build(), user.getUsername());
            }
            else {
                if (embargo.isAggregateEnabled() == null) builder.aggregateEnabled(existing.isAggregateEnabled());
                if (embargo.isIndividualEnabled() == null) builder.individualEnabled(existing.isIndividualEnabled());
                repository.update(builder.build(), user.getUsername());
            }
            importRepository.setProcessed(importId);
        } catch (final Exception e) {
            logger.warn("Error updating embargo settings for {} {} {}: {}",
                    embargo.getOrganizationType(), embargo.getOrganizationName(), embargo.getOrganizationId(), e.getMessage());
            importRepository.setStatus(importId, ImportStatus.INVALID, "Error: " + e.getMessage());
        }
    }

    @Override
    public Collection<Embargo> findAll(final User user) {
        // fetch Embargo for state and all districts
        final Collection<Embargo> embargos =
                repository.findAllBySchoolYear(reportingSystemProperties.getSchoolYear(), getDistrictIdsForUser(user));

        // we have to copy the collection to finish populating the state info
        final PermissionScope permissionScope = user.getPermissionsById().get(EmbargoWrite).getScope();
        return embargos.stream().map(embargo ->
                (embargo.getOrganizationType() != State) ? embargo : embargo.copy()
                    .organizationName(reportingSystemProperties.getState().getName())
                    .readOnly(!permissionScope.isStatewide())
                    .build())
                .collect(Collectors.toList());
    }

    @Override
    public List<TestResultAvailability> findTestResults(final EmbargoQuery query, final User user) {
        return repository.findTestResultsAvailability(
            reconcileQueryWithUserPermissions(query, user));
    }


    @Override
    public int countTestResults(EmbargoQuery query, User user) {
        return repository.countByQuery(
            reconcileQueryWithUserPermissions(query, user));
    }

    /***
     * Reconciles the query with the permissions of the user. Errors if the query is not permitted at all.
     * Otherwise returns a possibly modified query with status and district restrictions approprite for the
     * user.
     *
     * @param query the original requested query
     * @param user the user
     * @return modified query compatible with user permissions.
     */
    private EmbargoQuery reconcileQueryWithUserPermissions(EmbargoQuery query, User user) {
        final boolean loader = user.getPermissionsById().get(TestDataLoadingWrite) != null;

        final boolean stateReviewer =
            user.getPermissionsById().get(TestDataReviewingWrite) != null &&
            user.getPermissionsById().get(TestDataReviewingWrite).getScope().isStatewide();

        final boolean districtReviewer =
            user.getPermissionsById().get(TestDataReviewingWrite) != null &&
            !user.getPermissionsById().get(TestDataReviewingWrite).getScope().isStatewide();

        if (!(loader || stateReviewer || districtReviewer)) {
            throw new NoSuchElementException("Not authorized to change test results availability");
        }

        if (loader && districtReviewer) {
            throw new NoSuchElementException("Unsupported: cannot have Loading and District Reviewing Permissions");
        }

        final Set<Long> allowedDistricts = !districtReviewer ? null :
                user.getPermissionsById().get(TestDataReviewingWrite).getScope().getDistrictIds();

        if (districtReviewer && allowedDistricts.isEmpty()) {
            throw new NoSuchElementException("Not authorized to change test results availability");
        }

        // Reconcile permitted districts with the requested filter
        final Set<Long> filterDistrictIds = districtFilters(allowedDistricts, query.getDistrictIds());

        // Reconcile permitted statuses with the requested filter
        final Set<TestResultsStatus> filterStatuses = statusFilters(
            loader, districtReviewer || stateReviewer, query.getStatuses());

        return query.copy()
            .districtIds(filterDistrictIds)
            .statuses(filterStatuses)
            .build();
    }

    private Set<Long> districtFilters(Set<Long> allowedDistrictIds, Set<Long> queryDistrictIds) {
        if (allowedDistrictIds == null) {
            // All are allowed. Return requested query filters.
            return queryDistrictIds;
        }

        if (safeIsEmpty(queryDistrictIds)) {
            // No query filters set. Return all allowed.
            return allowedDistrictIds;
        }

        // Confirm all requested districts in query are allowed to the user. This would only occur
        // if the user is trying to bypass the client UI.
        List<Long> queryList = new ArrayList<>(queryDistrictIds);
        queryList.removeAll(allowedDistrictIds);
        if (!queryList.isEmpty()) {
            throw new NoSuchElementException("User not allowed access to some of the requested districts");
        }

        return queryDistrictIds;
    }

    private Set<TestResultsStatus> statusFilters(final boolean loader, final boolean reviewer,
                                                 final Set<TestResultsStatus> queryStatuses) {
        final Set<TestResultsStatus> allowedStatuses = new HashSet<>();
        if (loader) {
            allowedStatuses.add(Loading);
            allowedStatuses.add(Reviewing);
        }
        if (reviewer) {
            allowedStatuses.add(Reviewing);
            allowedStatuses.add(Released);
        }

        if (safeIsEmpty(queryStatuses)) {
            return allowedStatuses;
        }

        for (TestResultsStatus status : queryStatuses) {
            if (!allowedStatuses.contains(status)) {
                throw new NoSuchElementException("User does not have access to status " + status.name());
            }
        }

        return queryStatuses;
    }

    @Override
    public List<EmbargoAuditRecord> findAuditRecords(final User user, final Date startDate) {
        // Check permission
        final Permission loadingPermission = user.getPermissionsById().get(TestDataLoadingWrite);
        if (loadingPermission == null) {
            throw new NoSuchElementException("Audit log not available");
        }

        return splitByReportType(auditRepository.findEmbargoAuditRecords(startDate));
    }

    /**
     * Splits record into rows for Aggregate and Individual results. Filters out any that haven't changed status.
     *
     * The database record has both Individual and Aggregate statuses in a single row, but the audit log
     * has a separate row for each type. This method splits the single record into the two types, and discards
     * any where the status hasn't changed since the previous entry.
     *
     * @param embargoAuditRecords the list of EmbargoAuditRecord
     * @return a new list with EmbargoAuditRecords of specific report types (Individual or Aggregate)
     */
    private List<EmbargoAuditRecord> splitByReportType(final List<EmbargoAuditRecord> embargoAuditRecords) {
        final List<EmbargoAuditRecord> split = new ArrayList<>(2 * embargoAuditRecords.size());
        embargoAuditRecords.forEach(r -> {
            if (!statusMatch(r.getIndividualStatus(), r.getPreviousIndividualStatus())) {
                split.add(r.copy().reportType("Individual").build());
            }
            if (!statusMatch(r.getAggregateStatus(), r.getPreviousAggregateStatus())) {
                split.add(r.copy().reportType("Aggregate").build());
            }
        });

        return split;
    }

    // Lack of embargo status is equivalent to Loading.
    private boolean statusMatch(final TestResultsStatus a, final TestResultsStatus b) {
        return (a == null ? Loading : a) == (b == null ? Loading : b);
    }

    @Override
    public TestResultAvailabilityOptions getFilterOptions(final User user) {
        final Permission loadingPermission = user.getPermissionsById().get(TestDataLoadingWrite);
        final Permission reviewingPermission = user.getPermissionsById().get(TestDataReviewingWrite);

        if (loadingPermission == null && reviewingPermission == null) {
            throw new NoSuchElementException("Not authorized to retrieve filter options");
        }

        final boolean districtAdmin = reviewingPermission != null && !reviewingPermission.getScope().isStatewide();

        // TODO: for statewide users, we should populate the list if there are fewer than n total districts.
        final Collection<Organization> districts =  districtAdmin ?
            getDistrictsForReview(reviewingPermission.getScope()) :
            Collections.emptyList();

        final List<CodedEntity> subjects = subjectRepository.findAll();
        final List<Integer> schoolYears = schoolYearRepository.findAll();
        final boolean viewAudit = loadingPermission != null;
        final Set<TestResultsStatus> statuses = getIncludeStatuses(loadingPermission, reviewingPermission);

        return TestResultAvailabilityOptions.builder()
            .districtAdmin(districtAdmin)
            .districts(districts)
            .subjects(subjects)
            .schoolYears(schoolYears)
            .statuses(statuses)
            .reportTypes(TestResultsReportType.values())
            .viewAudit(viewAudit)
            .build();
    }

    /**
     * @param user user user
     * @param embargo embargo embargo
     * @throws NoSuchElementException if user doesn't have permission to write
     */
    private void checkAccess(final User user, final Embargo embargo) {
        final Permission permission = user.getPermissionsById().get(EmbargoWrite);
        if (permission == null) {
            throw new NoSuchElementException();
        }

        if (embargo.getOrganizationType() == State) {
            if (!permission.getScope().isStatewide()) {
                throw new NoSuchElementException();
            }
        } else if (embargo.getOrganizationType() == District) {
            final Set<Long> districtIds = getDistrictIdsForUser(user);
            if (!districtIds.contains(embargo.getOrganizationId())) {
                throw new NoSuchElementException();
            }
        } else {
            throw new IllegalArgumentException("Invalid embargo organization type");
        }
    }

    // Gets the set of statuses that the given permissions allow access to.
    private Set<TestResultsStatus> getIncludeStatuses(
        final Permission loadingPermission,
        final Permission reviewingPermission
    ) {
        final Set<TestResultsStatus> includeStatuses = new HashSet<>();

        if (loadingPermission != null) {
            includeStatuses.add(Loading);
            includeStatuses.add(Reviewing);
        }

        if (reviewingPermission != null) {
            includeStatuses.add(Reviewing);
            includeStatuses.add(Released);
        }

        return includeStatuses;
    }

    /**
     * @param user the user
     * @return list of ids of district that the user has embargo write permission
     */
    private Set<Long> getDistrictIdsForUser(final User user) {
        final PermissionScope permissionScope = user.getPermissionsById().get(EmbargoWrite).getScope();

        // We don't want to get districts inherited because of state permissions (because, for
        // embargo, state-level permissions do NOT imply permissions for districts) so copy the
        // permissions with statewide disabled.
        final Collection<Organization> districts = organizationRepository.findAll(
                permissionScope.copy().statewide(false).build(),
                OrganizationQuery.builder().types(EnumSet.of(OrganizationType.District)).build());

        return districts.stream().map(Organization::getId).collect(Collectors.toSet());
    }

    // Return district information for district admins.
    private Collection<Organization> getDistrictsForReview(final PermissionScope permissionScope) {
        return organizationRepository.findAll(
            permissionScope,
            OrganizationQuery.builder().types(EnumSet.of(OrganizationType.District)).build());
    }
}
