package org.opentestsystem.rdw.admin.service.impl;

import com.google.common.collect.ImmutableSet;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.tomcat.util.buf.HexUtils;
import org.opentestsystem.rdw.admin.exception.EmbargoException;
import org.opentestsystem.rdw.admin.model.EmbargoAuditRecord;
import org.opentestsystem.rdw.admin.model.EmbargoQuery;
import org.opentestsystem.rdw.admin.model.EmbargoUpdate;
import org.opentestsystem.rdw.admin.model.TestResultAvailability;
import org.opentestsystem.rdw.admin.model.TestResultAvailabilityOptions;
import org.opentestsystem.rdw.admin.model.TestResultsReportType;
import org.opentestsystem.rdw.reporting.common.model.EmbargoStatus;
import org.opentestsystem.rdw.admin.repository.EmbargoAuditRepository;
import org.opentestsystem.rdw.admin.repository.EmbargoRepository;
import org.opentestsystem.rdw.admin.repository.ImportRepository;
import org.opentestsystem.rdw.admin.repository.SchoolYearRepository;
import org.opentestsystem.rdw.admin.repository.SubjectRepository;
import org.opentestsystem.rdw.admin.service.EmbargoService;
import org.opentestsystem.rdw.common.model.ImportContent;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.reporting.common.configuration.EmbargoPropertiesResolver;
import org.opentestsystem.rdw.reporting.common.model.CodedEntity;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.model.OrganizationQuery;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.repository.OrganizationRepository;
import org.opentestsystem.rdw.reporting.common.security.User;
import org.opentestsystem.rdw.reporting.common.util.CollectionUtils;
import org.opentestsystem.rdw.security.Permission;
import org.opentestsystem.rdw.security.PermissionScope;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Set;


import static org.opentestsystem.rdw.reporting.common.model.EmbargoStatus.Loading;
import static org.opentestsystem.rdw.reporting.common.model.EmbargoStatus.Released;
import static org.opentestsystem.rdw.reporting.common.model.EmbargoStatus.Reviewing;
import static org.opentestsystem.rdw.admin.security.AdminPermission.TestDataLoadingWrite;
import static org.opentestsystem.rdw.admin.security.AdminPermission.TestDataReviewingWrite;
import static org.opentestsystem.rdw.reporting.common.util.CollectionUtils.safeIsEmpty;
import static java.time.temporal.ChronoUnit.DAYS;

/**
 * Repository-backed implementation of EmbargoService.
 */
@Service
public class DefaultEmbargoService implements EmbargoService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultEmbargoService.class);
    private static final int DistrictLimit = 50;

    private final EmbargoRepository repository;
    private final EmbargoAuditRepository auditRepository;
    private final OrganizationRepository organizationRepository;
    private final ImportRepository importRepository;
    private final SubjectRepository subjectRepository;
    private final SchoolYearRepository schoolYearRepository;
    private final EmbargoPropertiesResolver embargoPropertiesResolver;

    @Autowired
    public DefaultEmbargoService(final EmbargoRepository repository,
                                 final EmbargoAuditRepository auditRepository,
                                 @Qualifier("warehouseOrganizationRepository") final OrganizationRepository organizationRepository,
                                 final ImportRepository importRepository,
                                 final SubjectRepository subjectRepository,
                                 final SchoolYearRepository schoolYearRepository,
                                 final EmbargoPropertiesResolver embargoPropertiesResolver) {
        this.repository = repository;
        this.auditRepository = auditRepository;
        this.organizationRepository = organizationRepository;
        this.importRepository = importRepository;
        this.subjectRepository = subjectRepository;
        this.schoolYearRepository = schoolYearRepository;
        this.embargoPropertiesResolver = embargoPropertiesResolver;
    }

    @Override
    public void saveStatusChanges(final User user, final EmbargoUpdate update) {
        EmbargoUpdate reconciledUpdate;
        try {
           reconciledUpdate = reconcileUpdateWithUserPermissions(update, user);
        } catch (final Exception e) {
            logger.warn("Un-permitted update from user {}: {}. {}",
                user.getUsername(),
                format(update),
                e.getMessage());

            throw new EmbargoException("User not permitted to make the requested update.");
        }

        final String digest = HexUtils.toHexString(DigestUtils.md5(user.getEmail() + Instant.now().toString()));
        final long importId = importRepository.create(
            ImportContent.EMBARGO,
            "admin embargo modification",
            digest,
            "embargo update");

        try {
            int updateCount = repository.update(reconciledUpdate, user.getUsername());

            if (updateCount == 0) {
                logger.info("No updates needed for {}", format(reconciledUpdate));
            } else {
                importRepository.setProcessed(importId);
            }
        } catch (final Exception e) {
            logger.warn("Error updating embargo status {}: {}", format(reconciledUpdate), e.getMessage());
            importRepository.setStatus(importId, ImportStatus.INVALID, "Error: " + e.getMessage());

            throw new EmbargoException("Server error, please see administrator.");
        }
    }

    private String format(final EmbargoUpdate update) {
        return String.format("embargo status %s to %s for filters: school year %s, district ids %s, subject id %s, report type %s",
            update.getStatus().name(),
            update.getNewStatus().name(),
            update.getSchoolYear() == null ? "All" : Integer.toString(update.getSchoolYear()),
            CollectionUtils.safeIsEmpty(update.getDistrictIds()) ?
                "All" : StringUtils.join(update.getDistrictIds(), ","),
            update.getSubjectId() == null ? "All" : Integer.toString(update.getSubjectId()),
            update.getReportType() == null ? "All" : update.getReportType().name()
        );
    }

    @Override
    public List<TestResultAvailability> findTestResults(final EmbargoQuery query, final User user) {
        return repository.findTestResultsAvailability(
            reconcileQueryWithUserPermissions(query, user));
    }


    @Override
    public int countTestResults(EmbargoQuery query, User user) {
        return repository.countByQuery(
            reconcileQueryWithUserPermissions(query, user));
    }

    /***
     * Reconciles the query with the permissions of the user. Errors if the query is not permitted at all.
     * Otherwise returns a possibly modified query with status and district restrictions approprite for the
     * user.
     *
     * @param query the original requested query
     * @param user the user
     * @return modified query compatible with user permissions.
     */
    private EmbargoQuery reconcileQueryWithUserPermissions(final EmbargoQuery query, final User user) {
        final boolean loader = user.getPermissionsById().get(TestDataLoadingWrite) != null;

        final boolean stateReviewer =
            user.getPermissionsById().get(TestDataReviewingWrite) != null &&
            user.getPermissionsById().get(TestDataReviewingWrite).getScope().isStatewide();

        final boolean districtReviewer =
            user.getPermissionsById().get(TestDataReviewingWrite) != null &&
            !user.getPermissionsById().get(TestDataReviewingWrite).getScope().isStatewide();

        if (!(loader || stateReviewer || districtReviewer)) {
            throw new NoSuchElementException("Not authorized to change test results availability");
        }

        if (loader && districtReviewer) {
            throw new NoSuchElementException("Unsupported: cannot have Loading and District Reviewing Permissions");
        }

        final Set<Long> allowedDistricts = !districtReviewer ? null :
                user.getPermissionsById().get(TestDataReviewingWrite).getScope().getDistrictIds();

        if (districtReviewer && allowedDistricts.isEmpty()) {
            throw new NoSuchElementException("Not authorized to change test results availability");
        }

        // Reconcile permitted districts with the requested filter
        final Set<Long> filterDistrictIds = districtFilters(allowedDistricts, query.getDistrictIds());

        // Reconcile permitted statuses with the requested filter
        final Set<EmbargoStatus> filterStatuses = statusFilters(
            loader, districtReviewer || stateReviewer, query.getStatuses());

        return query.copy()
            .districtIds(filterDistrictIds)
            .statuses(filterStatuses)
            .build();
    }

    private EmbargoUpdate reconcileUpdateWithUserPermissions(final EmbargoUpdate update, final User user) {
        final boolean loader = user.getPermissionsById().get(TestDataLoadingWrite) != null;

        final boolean stateReviewer =
            user.getPermissionsById().get(TestDataReviewingWrite) != null &&
                user.getPermissionsById().get(TestDataReviewingWrite).getScope().isStatewide();

        final boolean districtReviewer =
            user.getPermissionsById().get(TestDataReviewingWrite) != null &&
                !user.getPermissionsById().get(TestDataReviewingWrite).getScope().isStatewide();

        if (!(loader || stateReviewer || districtReviewer)) {
            throw new NoSuchElementException("Not authorized to change test results availability");
        }

        if (loader && districtReviewer) {
            throw new NoSuchElementException("Unsupported: cannot have Loading and District Reviewing Permissions");
        }

        final Set<Long> allowedDistricts = !districtReviewer ? null :
            user.getPermissionsById().get(TestDataReviewingWrite).getScope().getDistrictIds();

        if (districtReviewer && allowedDistricts.isEmpty()) {
            throw new NoSuchElementException("Not authorized to change test results availability");
        }

        // Reconcile permitted districts with the requested filter
        final Set<Long> filterDistrictIds = districtFilters(allowedDistricts, update.getDistrictIds());

        // Reconcile permitted statuses with the requested filter
        statusFilters(
            loader, districtReviewer || stateReviewer,
            Arrays.asList(update.getStatus(), update.getNewStatus()));

        return update.copy()
            .districtIds(filterDistrictIds)
            .build();
    }

    private Set<Long> districtFilters(Set<Long> allowedDistrictIds, Set<Long> queryDistrictIds) {
        if (allowedDistrictIds == null) {
            // All are allowed. Return requested query filters.
            return queryDistrictIds;
        }

        if (safeIsEmpty(queryDistrictIds)) {
            // No query filters set. Return all allowed.
            return allowedDistrictIds;
        }

        // Confirm all requested districts in query are allowed to the user. This would only occur
        // if the user is trying to bypass the client UI.
        List<Long> queryList = new ArrayList<>(queryDistrictIds);
        queryList.removeAll(allowedDistrictIds);
        if (!queryList.isEmpty()) {
            throw new NoSuchElementException("User not allowed access to some of the requested districts");
        }

        return queryDistrictIds;
    }

    private Set<EmbargoStatus> statusFilters(final boolean loader, final boolean reviewer,
                                             final Collection<EmbargoStatus> queryStatuses) {
        final Set<EmbargoStatus> allowedStatuses = new HashSet<>();
        if (loader) {
            allowedStatuses.add(Loading);
            allowedStatuses.add(Reviewing);
        }
        if (reviewer) {
            allowedStatuses.add(Reviewing);
            allowedStatuses.add(Released);
        }

        if (safeIsEmpty(queryStatuses)) {
            return allowedStatuses;
        }

        for (EmbargoStatus status : queryStatuses) {
            if (!allowedStatuses.contains(status)) {
                throw new NoSuchElementException("User does not have access to status " + status.name());
            }
        }

        return new HashSet<>(queryStatuses);
    }

    @Override
    public List<EmbargoAuditRecord> findAuditRecords(final User user) {
        // Check permissions
        final Permission loadingPermission = user.getPermissionsById().get(TestDataLoadingWrite);
        if (loadingPermission == null) {
            throw new NoSuchElementException("Audit log not available");
        }

        final Date startDate = Date.from(Instant.now().minus(embargoPropertiesResolver.getAuditLogDays(), DAYS));
        return splitByReportType(auditRepository.findEmbargoAuditRecords(startDate));
    }

    @Override
    public String getAuditFileName() {
        return embargoPropertiesResolver.getAuditLogFileName();
    }

    /**
     * Splits record into rows for Aggregate and Individual results. Filters out any that haven't changed status.
     *
     * The database record has both Individual and Aggregate statuses in a single row, but the audit log
     * has a separate row for each type. This method splits the single record into the two types, and discards
     * any where the status hasn't changed since the previous entry.
     *
     * @param embargoAuditRecords the list of EmbargoAuditRecord
     * @return a new list with EmbargoAuditRecords of specific report types (Individual or Aggregate)
     */
    private List<EmbargoAuditRecord> splitByReportType(final List<EmbargoAuditRecord> embargoAuditRecords) {
        final List<EmbargoAuditRecord> split = new ArrayList<>(2 * embargoAuditRecords.size());
        embargoAuditRecords.forEach(r -> {
            if (statusChanged(r.getIndividualStatus(), r.getPreviousIndividualStatus())) {
                split.add(r.copy().reportType("Individual").build());
            }
            if (statusChanged(r.getAggregateStatus(), r.getPreviousAggregateStatus())) {
                split.add(r.copy().reportType("Aggregate").build());
            }
        });

        return split;
    }

    // Lack of embargo status is equivalent to Loading.
    private boolean statusChanged(final EmbargoStatus a, final EmbargoStatus b) {
        return (a == null ? Loading : a) != (b == null ? Loading : b);
    }

    @Override
    public TestResultAvailabilityOptions getFilterOptions(final User user) {
        final Permission loadingPermission = user.getPermissionsById().get(TestDataLoadingWrite);
        final Permission reviewingPermission = user.getPermissionsById().get(TestDataReviewingWrite);

        if (loadingPermission == null && reviewingPermission == null) {
            throw new NoSuchElementException("Not authorized to retrieve filter options");
        }

        final boolean districtAdmin = loadingPermission == null && !reviewingPermission.getScope().isStatewide();

        Collection<Organization> districts;
        boolean districtsOverflow = false;
        if (districtAdmin) {
            districts = getDistrictsForReview(reviewingPermission.getScope());
        } else {
            districts = getDistrictsForState();
            if (districts.size() > DistrictLimit) {
                districtsOverflow = true;
                districts = Collections.emptyList();
            }
        }

        final List<CodedEntity> subjects = subjectRepository.findAll();
        final List<Integer> schoolYears = schoolYearRepository.findAll();
        final boolean viewAudit = loadingPermission != null;
        final Set<EmbargoStatus> statuses = getIncludeStatuses(loadingPermission, reviewingPermission);

        return TestResultAvailabilityOptions.builder()
            .districtAdmin(districtAdmin)
            .districts(districts)
            .districtsOverflow(districtsOverflow)
            .subjects(subjects)
            .schoolYears(schoolYears)
            .statuses(statuses)
            .reportTypes(TestResultsReportType.values())
            .viewAudit(viewAudit)
            .pageSize(embargoPropertiesResolver.getPageSize())
            .build();
    }

    @Override
    public List<Organization> getDistrictFiltersByName(final User user, final String name) {
        final Permission loading = user.getPermissionsById().get(TestDataLoadingWrite);
        final Permission reviewing = user.getPermissionsById().get(TestDataReviewingWrite);

        if (loading == null && reviewing == null) {
            return Collections.emptyList();
        }

        final PermissionScope scope = loading != null ? loading.getScope() : reviewing.getScope();

        final OrganizationQuery query = OrganizationQuery.builder()
            .types(ImmutableSet.of(OrganizationType.District))
            .name(name)
            .limit(DistrictLimit)
            .build();

        return organizationRepository.findAll(scope, query);
    }

    // Gets the set of statuses that the given permissions allow access to.
    private Set<EmbargoStatus> getIncludeStatuses(
        final Permission loadingPermission,
        final Permission reviewingPermission
    ) {
        final Set<EmbargoStatus> includeStatuses = new HashSet<>();

        if (loadingPermission != null) {
            includeStatuses.add(Loading);
            includeStatuses.add(Reviewing);
        }

        if (reviewingPermission != null) {
            includeStatuses.add(Reviewing);
            includeStatuses.add(Released);
        }

        return includeStatuses;
    }

    // Return district information for district admins.
    private Collection<Organization> getDistrictsForReview(final PermissionScope permissionScope) {
        return organizationRepository.findAll(
            permissionScope,
            OrganizationQuery.builder().types(EnumSet.of(OrganizationType.District)).build());
    }

    // Return district information for state admins and devops, unless this would be more than the district limit.
    private Collection<Organization> getDistrictsForState() {
        return organizationRepository.findAll(
            PermissionScope.STATEWIDE,
            OrganizationQuery.builder()
                .types(EnumSet.of(OrganizationType.District))
                .limit(DistrictLimit + 1)
                .build());
    }
}
