package org.opentestsystem.rdw.admin.service.impl;

import org.apache.commons.codec.digest.DigestUtils;
import org.apache.tomcat.util.buf.HexUtils;
import org.opentestsystem.rdw.admin.model.Embargo;
import org.opentestsystem.rdw.admin.model.EmbargoAuditRecord;
import org.opentestsystem.rdw.admin.model.TestResultAvailability;
import org.opentestsystem.rdw.admin.model.TestResultAvailabilityOptions;
import org.opentestsystem.rdw.admin.model.TestResultsStatus;
import org.opentestsystem.rdw.admin.repository.EmbargoRepository;
import org.opentestsystem.rdw.admin.repository.ImportRepository;
import org.opentestsystem.rdw.admin.service.EmbargoService;
import org.opentestsystem.rdw.common.model.ImportContent;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemProperties;
import org.opentestsystem.rdw.reporting.common.model.Organization;
import org.opentestsystem.rdw.reporting.common.model.OrganizationQuery;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.repository.OrganizationRepository;
import org.opentestsystem.rdw.reporting.common.security.User;
import org.opentestsystem.rdw.security.Permission;
import org.opentestsystem.rdw.security.PermissionScope;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

import static org.opentestsystem.rdw.admin.model.TestResultsStatus.Loading;
import static org.opentestsystem.rdw.admin.model.TestResultsStatus.Released;
import static org.opentestsystem.rdw.admin.model.TestResultsStatus.Reviewing;
import static org.opentestsystem.rdw.admin.security.AdminPermission.EmbargoWrite;
import static org.opentestsystem.rdw.admin.security.AdminPermission.TestDataLoadingWrite;
import static org.opentestsystem.rdw.admin.security.AdminPermission.TestDataReviewingWrite;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.District;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.State;

/**
 * Repository-backed implementation of EmbargoService.
 */
@Service
public class DefaultEmbargoService implements EmbargoService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultEmbargoService.class);

    private final EmbargoRepository repository;
    private final OrganizationRepository organizationRepository;
    private final ImportRepository importRepository;
    private final ReportingSystemProperties reportingSystemProperties;

    @Autowired
    public DefaultEmbargoService(final EmbargoRepository repository,
                                 @Qualifier("warehouseOrganizationRepository") final OrganizationRepository organizationRepository,
                                 final ImportRepository importRepository,
                                 @Qualifier("reportingSystemPropertiesResolver") final ReportingSystemProperties reportingSystemProperties) {
        this.repository = repository;
        this.organizationRepository = organizationRepository;
        this.importRepository = importRepository;
        this.reportingSystemProperties = reportingSystemProperties;
    }

    @Transactional(transactionManager = "warehouseTxManager")
    @Override
    public void save(final User user, final Embargo embargo) {
        if (embargo.isIndividualEnabled() == null && embargo.isAggregateEnabled() == null) {
            logger.info("Ignoring embargo update with no flags set");
            return;
        }

        // this may throw
        checkAccess(user, embargo);

        final int currentSchoolYear = reportingSystemProperties.getSchoolYear();
        final Embargo existing = (embargo.getOrganizationType() == State) ?
                repository.findOneBySchoolYearAndState(currentSchoolYear) :
                repository.findOneBySchoolYearAndDistrictId(currentSchoolYear, embargo.getOrganizationId());

        if (existing != null
         && Objects.equals(existing.isIndividualEnabled(), embargo.isIndividualEnabled())
         && Objects.equals(existing.isAggregateEnabled(), embargo.isAggregateEnabled())) {
            logger.info("Ignoring equivalent embargo settings for {} {} {}",
                    embargo.getOrganizationType(), embargo.getOrganizationName(), embargo.getOrganizationId());
            return;
        }

        final String digest = HexUtils.toHexString(DigestUtils.md5(user.getEmail() + Instant.now().toString()));
        final long importId = importRepository.create(ImportContent.EMBARGO, "admin embargo modification", digest, "embargo update");
        try {
            final Embargo.Builder builder = embargo.copy().schoolYear(currentSchoolYear);
            if (existing == null) {
                repository.create(builder.build(), user.getUsername());
            }
            else {
                if (embargo.isAggregateEnabled() == null) builder.aggregateEnabled(existing.isAggregateEnabled());
                if (embargo.isIndividualEnabled() == null) builder.individualEnabled(existing.isIndividualEnabled());
                repository.update(builder.build(), user.getUsername());
            }
            importRepository.setProcessed(importId);
        } catch (final Exception e) {
            logger.warn("Error updating embargo settings for {} {} {}: {}",
                    embargo.getOrganizationType(), embargo.getOrganizationName(), embargo.getOrganizationId(), e.getMessage());
            importRepository.setStatus(importId, ImportStatus.INVALID, "Error: " + e.getMessage());
        }
    }

    @Override
    public Collection<Embargo> findAll(final User user) {
        // fetch Embargo for state and all districts
        final Collection<Embargo> embargos =
                repository.findAllBySchoolYear(reportingSystemProperties.getSchoolYear(), getDistrictIdsForUser(user));

        // we have to copy the collection to finish populating the state info
        final PermissionScope permissionScope = user.getPermissionsById().get(EmbargoWrite).getScope();
        return embargos.stream().map(embargo ->
                (embargo.getOrganizationType() != State) ? embargo : embargo.copy()
                    .organizationName(reportingSystemProperties.getState().getName())
                    .readOnly(!permissionScope.isStatewide())
                    .build())
                .collect(Collectors.toList());
    }

    @Override
    public Collection<TestResultAvailability> findTestResults(final User user) {
        // Loading permission allows the user to administer results in loading and reviewing statuses.
        // It can only be general, not specific to districts.
        final Permission loadingPermission = user.getPermissionsById().get(TestDataLoadingWrite);

        // Reviewing permission allows the user to administer results in reviewing and released statuses.
        // It can be statewide or specific to a set of districts.
        final Permission reviewingPermission = user.getPermissionsById().get(TestDataReviewingWrite);

        if (loadingPermission == null && reviewingPermission == null) {
            throw new NoSuchElementException("Not authorized to change test results availability");
        }

        if (loadingPermission == null &&
            !reviewingPermission.getScope().isStatewide() &&
            reviewingPermission.getScope().getDistrictIds().isEmpty()) {
            throw new NoSuchElementException("Not authorized to change test results availability");
        }

        final Set<Integer> includeStatuses =
            getIncludeStatuses(loadingPermission, reviewingPermission)
            .stream()
            .map(TestResultsStatus::getStatusCode)
            .collect(Collectors.toSet());

        final Set<Integer> filterStatuses = new HashSet<>();
        final Set<Long> districtIds = new HashSet<>();

        if (reviewingPermission != null) {
            if (!reviewingPermission.getScope().isStatewide()) {
                filterStatuses.add(Reviewing.getStatusCode());
                filterStatuses.add(Released.getStatusCode());

                districtIds.addAll(reviewingPermission.getScope().getDistrictIds());
            }
        }

        if (loadingPermission != null) {
            // This is edge case of user have global write permissions for loading <--> reviewing,
            // but only district write permissions on reviewing <--> released.
            filterStatuses.remove(Reviewing.getStatusCode());
        }

        return repository.findTestResultsAvailability(includeStatuses, filterStatuses, districtIds);
    }

    @Override
    public List<EmbargoAuditRecord> findAuditRecords(final User user, final Date startDate) {
        // Check permission
        final Permission loadingPermission = user.getPermissionsById().get(TestDataLoadingWrite);
        if (loadingPermission == null) {
            throw new NoSuchElementException("Audit log not available");
        }

        return splitByReportType(repository.findEmbargoAuditRecords(startDate));
    }

    // Splits record into rows for Aggregate and Individual results. Filters out any that haven't changed status.
    private List<EmbargoAuditRecord> splitByReportType(List<EmbargoAuditRecord> embargoAuditRecords) {
        final List<EmbargoAuditRecord> split = new ArrayList<>(2 * embargoAuditRecords.size());
        embargoAuditRecords.forEach(r -> {
            if (r.getIndividualStatus() != r.getPreviousIndividualStatus()) {
                split.add(r.copy().reportType("Individual").build());
            }
            if (r.getAggregateStatus() != r.getPreviousAggregateStatus()) {
                split.add(r.copy().reportType("Aggregate").build());
            }
        });

        return split;
    }

    @Override
    public TestResultAvailabilityOptions getFilterOptions(final User user) {
        final Permission loadingPermission = user.getPermissionsById().get(TestDataLoadingWrite);
        final Permission reviewingPermission = user.getPermissionsById().get(TestDataReviewingWrite);

        final boolean districtAdmin = reviewingPermission != null && !reviewingPermission.getScope().isStatewide();
        final Collection<Organization> districts = districtAdmin ?
            getDistrictsForReview(reviewingPermission.getScope()) :
            Collections.emptyList();

        final boolean viewAudit = loadingPermission != null;
        final Set<TestResultsStatus> statuses = getIncludeStatuses(loadingPermission, reviewingPermission);

        return TestResultAvailabilityOptions.builder()
            .districtAdmin(districtAdmin)
            .districts(districts)
            .viewAudit(viewAudit)
            .statuses(statuses)
            .build();
    }

    /**
     * @param user user user
     * @param embargo embargo embargo
     * @throws NoSuchElementException if user doesn't have permission to write
     */
    private void checkAccess(final User user, final Embargo embargo) {
        final Permission permission = user.getPermissionsById().get(EmbargoWrite);
        if (permission == null) {
            throw new NoSuchElementException();
        }

        if (embargo.getOrganizationType() == State) {
            if (!permission.getScope().isStatewide()) {
                throw new NoSuchElementException();
            }
        } else if (embargo.getOrganizationType() == District) {
            final Set<Long> districtIds = getDistrictIdsForUser(user);
            if (!districtIds.contains(embargo.getOrganizationId())) {
                throw new NoSuchElementException();
            }
        } else {
            throw new IllegalArgumentException("Invalid embargo organization type");
        }
    }

    // Gets the set of statuses that the given permissions allow access to.
    private Set<TestResultsStatus> getIncludeStatuses(
        final Permission loadingPermission,
        final Permission reviewingPermission
    ) {
        final Set<TestResultsStatus> includeStatuses = new HashSet<>();

        if (loadingPermission != null) {
            includeStatuses.add(Loading);
            includeStatuses.add(Reviewing);
        }

        if (reviewingPermission != null) {
            includeStatuses.add(Reviewing);
            includeStatuses.add(Released);
        }

        return includeStatuses;
    }

    /**
     * @param user the user
     * @return list of ids of district that the user has embargo write permission
     */
    private Set<Long> getDistrictIdsForUser(final User user) {
        final PermissionScope permissionScope = user.getPermissionsById().get(EmbargoWrite).getScope();

        // We don't want to get districts inherited because of state permissions (because, for
        // embargo, state-level permissions do NOT imply permissions for districts) so copy the
        // permissions with statewide disabled.
        final Collection<Organization> districts = organizationRepository.findAll(
                permissionScope.copy().statewide(false).build(),
                OrganizationQuery.builder().types(EnumSet.of(OrganizationType.District)).build());

        return districts.stream().map(Organization::getId).collect(Collectors.toSet());
    }

    // Return district information for district admins.
    private Collection<Organization> getDistrictsForReview(final PermissionScope permissionScope) {
        return organizationRepository.findAll(
            permissionScope,
            OrganizationQuery.builder().types(EnumSet.of(OrganizationType.District)).build());
    }
}
