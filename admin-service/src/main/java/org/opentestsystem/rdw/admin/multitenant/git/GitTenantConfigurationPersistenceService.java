package org.opentestsystem.rdw.admin.multitenant.git;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;
import com.fasterxml.jackson.dataformat.yaml.YAMLGenerator;
import com.google.common.annotations.VisibleForTesting;
import org.apache.commons.io.FileUtils;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;
import org.opentestsystem.rdw.admin.multitenant.configserver.ConfigServerClient;
import org.opentestsystem.rdw.admin.multitenant.model.ApplicationTenantConfigurationPersistence;
import org.opentestsystem.rdw.admin.multitenant.model.TenantConfiguration;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.multitenant.task.ArtClientPropertiesTenant;
import org.opentestsystem.rdw.multitenant.task.ImportServiceClientPropertiesTenant;
import org.opentestsystem.rdw.multitenant.task.ResourceOwnerPasswordResourceDetailsMixin;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.oauth2.client.token.grant.password.ResourceOwnerPasswordResourceDetails;

import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Optional;

public class GitTenantConfigurationPersistenceService implements TenantConfigurationPersistenceService {

    private static final Logger logger = LoggerFactory.getLogger(GitTenantConfigurationPersistenceService.class);
    private static final String ConfigFileName = "application.yml";
    private static final String LocalizationName = "en.json";
    private static final String CIPHER = "{cipher}";
    private static final int ARCHIVE_RETRIES = 10;

    private final ObjectMapper ymlMapper;

    private final TenantConfigurationPersistenceProperties tenantConfigurationPersistenceProperties;
    private final ConfigServerClient configServerClient;

    public GitTenantConfigurationPersistenceService(final TenantConfigurationPersistenceProperties tenantConfigurationPersistenceProperties,
                                                    final ConfigServerClient configServerClient) {
        this.tenantConfigurationPersistenceProperties = tenantConfigurationPersistenceProperties;
        this.configServerClient = configServerClient;
        this.ymlMapper = createObjectMapper();
    }

    @VisibleForTesting
    static ObjectMapper createObjectMapper() {
        final ObjectMapper mapper = new ObjectMapper(new YAMLFactory().disable(YAMLGenerator.Feature.WRITE_DOC_START_MARKER));
        mapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);
        mapper.findAndRegisterModules();
        mapper.addMixIn(ResourceOwnerPasswordResourceDetails.class, ResourceOwnerPasswordResourceDetailsMixin.class);
        return mapper;
    }

    @VisibleForTesting
    void forceLocalRepositoryToCleanState() {
        //TODO: right now, just wiping and cloning each time this is called
        // there may be a better approach:
        // https://stackoverflow.com/questions/13586502/how-to-check-if-a-git-clone-has-been-done-already-with-jgit
        //RepositoryCache.FileKey.isGitRepository(new File(tenantConfigurationPersistenceProperties.getLocalRepositoryUri() + "application.yml"), FS_DETECTED));
        final UsernamePasswordCredentialsProvider credentialsProvider = credentialsProvider();
        try {
            FileUtils.deleteDirectory(localRepository());
        } catch (final IOException e) {
            throw new TenantConfigurationPersistenceException("Unable to delete directory", e);
        }
        //do clone
        try {
            Git.cloneRepository()
                    .setURI(tenantConfigurationPersistenceProperties.getRemoteRepositoryUri())
                    .setBare(false)
                    .setBranch("master")
                    .setDirectory(getWorkingDirectory())
                    .setCredentialsProvider(credentialsProvider)
                    .call();
        } catch (final GitAPIException e) {
            throw new TenantConfigurationPersistenceException("Unable to clone repository", e);
        }
    }


    @VisibleForTesting
    File getWorkingDirectory() {
        try {
            FileUtils.forceMkdir(localRepository());
        } catch (final IOException e) {
            throw new TenantConfigurationPersistenceException("Unable to create working directory.", e);
        }
        return localRepository();
    }

    @Override
    public synchronized void saveTenantConfiguration(final TenantConfiguration tenantConfiguration) {
        //TODO: synchronized is the fastest way to ensure this is only called one-at-a-time
        // non-blocking channel based approach possibly preferable
        forceLocalRepositoryToCleanState();

        updateConfigurationPasswords(tenantConfiguration);

        final String tenantKey = tenantConfiguration.getTenant().getKey();
        final UsernamePasswordCredentialsProvider credentialsProvider = credentialsProvider();

        makeTenantDirectory(tenantKey);
        writeApplicationTenantConfiguration(tenantConfiguration);
        writeLocalization(tenantConfiguration.getLocalization(), tenantKey);

        try {
            final Git git = Git.open(localRepository());

            final String applicationYmlRelativePath = applicationYmlRelativePath(tenantKey);
            logger.debug("git add {}", applicationYmlRelativePath);
            git.add()
                    .addFilepattern(applicationYmlRelativePath)
                    .call();

            final String localizationJsonRelativePath = localizationJsonRelativePath(tenantKey);
            logger.debug("git add {}", localizationJsonRelativePath);
            git.add()
                    .addFilepattern(localizationJsonRelativePath)
                    .call();

            git.commit()
                    .setAuthor(tenantConfigurationPersistenceProperties.getAuthor(),
                            tenantConfigurationPersistenceProperties.getAuthorEmail())
                    .setMessage("saving " + tenantKey + " configuration.")
                    .call();

            git.push()
                    .setCredentialsProvider(credentialsProvider)
                    .call();
        } catch (final IOException | GitAPIException e) {
            throw new TenantConfigurationPersistenceException("Unable to save changes to the remote git repository", e);
        }
    }

    @Override
    public void deleteSandbox(final String tenantKey) {
        if (tenantKey == null) {
            throw new IllegalArgumentException("Sandbox key may not be null");
        }

        forceLocalRepositoryToCleanState();

        final UsernamePasswordCredentialsProvider credentialsProvider = credentialsProvider();
        final String applicationYmlRelativePath = applicationYmlRelativePath(tenantKey);
        final String localizationJsonRelativePath = localizationJsonRelativePath(tenantKey);

        try {
            final Git git = Git.open(localRepository());
            logger.debug("git rm {}", applicationYmlRelativePath);
            git.rm()
                    .addFilepattern(applicationYmlRelativePath)
                    .call();

            logger.debug("git rm {}", localizationJsonRelativePath);
            git.rm()
                    .addFilepattern(localizationJsonRelativePath)
                    .call();


            git.commit()
                    .setAuthor(tenantConfigurationPersistenceProperties.getAuthor(),
                            tenantConfigurationPersistenceProperties.getAuthorEmail())
                    .setMessage("deleting sandbox " + tenantKey + " configuration.")
                    .call();

            logger.debug("git push");
            git.push()
                    .setCredentialsProvider(credentialsProvider)
                    .call();
        } catch (final IOException | GitAPIException e) {
            throw new TenantConfigurationPersistenceException("Unable to delete sandbox configuration " + tenantKey, e);
        }
    }

    @Override
    public void deleteTenant(final String tenantKey) {
        if (tenantKey == null) {
            throw new IllegalArgumentException("Tenant key may not be null");
        }

        forceLocalRepositoryToCleanState();

        final UsernamePasswordCredentialsProvider credentialsProvider = credentialsProvider();

        try {
            final File tenantDirectory = tenantDirectory(tenantKey);
            final File archiveDirectory = nextAvailableArchiveDirectory(tenantKey);

            logger.debug("git mv {} {} (not currently implemented by library so broken into steps)",
                    tenantDirectory.getName(), archiveDirectory.getName());

            logger.debug("mv {} {}", tenantDirectory.getName(), archiveDirectory.getName());
            FileUtils.moveDirectory(tenantDirectory, archiveDirectory);

            final Git git = Git.open(localRepository());
            logger.debug("git rm -r {}", tenantDirectory.getName());
            git.rm()
                    .addFilepattern(tenantDirectory.getName())
                    .call();

            logger.debug("git add {}", archiveDirectory.getName());
            git.add()
                    .addFilepattern(archiveDirectory.getName())
                    .call();

            git.commit()
                    .setAuthor(tenantConfigurationPersistenceProperties.getAuthor(),
                            tenantConfigurationPersistenceProperties.getAuthorEmail())
                    .setMessage("archiving tenant " + tenantKey + " configuration.")
                    .call();

            logger.debug("git push");
            git.push()
                    .setCredentialsProvider(credentialsProvider)
                    .call();
        } catch (final IOException | GitAPIException | IllegalStateException e) {
            throw new TenantConfigurationPersistenceException("Unable to delete tenant " + tenantKey, e);
        }
    }

    /**
     * @param tenantConfiguration to update the tenantConfig with encrypted passwords and archive s3 key data
     */
    private void updateConfigurationPasswords(final TenantConfiguration tenantConfiguration) {
        // all dataSource password need to be save as encrypted
        tenantConfiguration.getDataSources().forEach((k, v) -> {
            // todo how to handle a when the configServer is not available : atm will catch any
            try {
                // skip if pwd doesn't exist, or is empty or if it is already encrypted : will have (cipher) prefix
                if (isOkToEncrypt(v.getPassword())) {
                    // have a non-encrypted pwd, let's encrypt it
                    final String encryptedPassword = encryptString(v.getPassword());
                    v.setPassword(encryptedPassword);
                }
            } catch (Exception e) {
                // if there is a problem, store the pwd as is - so it could be in the clear
                // not changing password at this time
                logger.warn("Failed to contact the ConfigServer at this time, will store {}'s the password for {} as is.",
                        tenantConfiguration.getTenant().getKey(), k);
            }

        });
        // all s3 archive secret keys need to be saved as encrypted
        if (isOkToEncrypt(tenantConfiguration.getArchiveProperties().getS3SecretKey())) {
            try {
                final String encryptedPassword = encryptString(tenantConfiguration.getArchiveProperties().getS3SecretKey());
                tenantConfiguration.getArchiveProperties().setS3SecretKey(encryptedPassword);
            } catch (Exception e) {
                // if there is a problem, store the pwd as is - so it could be in the clear
                // not changing password at this time
                logger.warn("Failed to contact the ConfigServer at this time, will store the archive data for {} as is.",
                        tenantConfiguration.getTenant().getKey());
            }
        }

        Optional.ofNullable(tenantConfiguration.getArtClient())
                .map(ArtClientPropertiesTenant::getOauth2)
                .ifPresent(this::encryptOauth2Secrets);

        Optional.ofNullable(tenantConfiguration.getImportServiceClient())
                .map(ImportServiceClientPropertiesTenant::getOauth2)
                .ifPresent(this::encryptOauth2Secrets);

    }

    private void encryptOauth2Secrets(ResourceOwnerPasswordResourceDetails oauth2) {
        if (isOkToEncrypt(oauth2.getPassword())) {
            try {
                final String encryptedPassword = encryptString(oauth2.getPassword());
                oauth2.setPassword(encryptedPassword);
            } catch (Exception e) {
                logger.warn("Unable to encrypt artClient oauth2 password", e);
            }
        }

        if (isOkToEncrypt(oauth2.getClientSecret())) {
            try {
                final String encryptedClientSecret = encryptString(oauth2.getClientSecret());
                oauth2.setClientSecret(encryptedClientSecret);
            } catch (Exception e) {
                logger.warn("Unable to encrypt artClient oauth2 clientSecret", e);
            }
        }
    }

    private String encryptString(String target) {
        return CIPHER + configServerClient.encryptPassword(target);
    }

    /**
     * @param key the key to verify it is not null, empty or already encrypted, it will start with CIPHER
     * @return true if is ok to encrypt the key
     */
    private boolean isOkToEncrypt(final String key) {
        return key != null && !key.startsWith(CIPHER);
    }

    @VisibleForTesting
    void writeApplicationTenantConfiguration(final TenantConfiguration tenantConfiguration) {

        final Tenant tenant = tenantConfiguration.getTenant();
        final String tenantKey = tenant.getKey();

        final ApplicationTenantConfigurationPersistence applicationTenantConfigurationPersistence =
                new ApplicationTenantConfigurationPersistence(tenantConfiguration);

        try {
            String output = ymlMapper.writeValueAsString(applicationTenantConfigurationPersistence);
            logger.debug("output yml \n{}", output);

            final File applicationYmlFile = applicationYmlFile(tenantKey);
            logger.debug("applicationYmlFile {}", applicationYmlFile.getPath());

            FileUtils.write(applicationYmlFile, output, "UTF-8");
        } catch (final Exception e) {
            throw new TenantConfigurationPersistenceException("Unable write application tenant configuration file", e);
        }
    }

    @VisibleForTesting
    void writeLocalization(final String localization, final String tenantKey) {
        final File localizationJsonFile = localizationJsonFile(tenantKey);

        try {
            final ObjectMapper mapper = new ObjectMapper();
            if (localization != null) {
                final Object json = mapper.readValue(localization, Object.class);
                final String output = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(json);
                FileUtils.write(localizationJsonFile, output, "UTF-8");
            }
        } catch (final IOException e) {
            throw new TenantConfigurationPersistenceException("Unable write tenant localization file", e);
        }
    }

    private void makeTenantDirectory(final String tenantKey) {
        final File tenantDirectory = tenantDirectory(tenantKey);
        logger.debug("tenantDirectory {}", tenantDirectory.getPath());
        try {
            FileUtils.forceMkdir(tenantDirectory);
        } catch (final IOException e) {
            throw new TenantConfigurationPersistenceException("Unable to create tenant directory", e);
        }
    }

    private File localRepository() {
        try {
            final URL localRepositoryUrl = new URL(tenantConfigurationPersistenceProperties.getLocalRepositoryUri());
            return FileUtils.toFile(localRepositoryUrl);
        } catch (final MalformedURLException e) {
            throw new TenantConfigurationPersistenceException("Configuration error for local directory", e);
        }
    }

    private UsernamePasswordCredentialsProvider credentialsProvider() {
        return new UsernamePasswordCredentialsProvider(tenantConfigurationPersistenceProperties.getGitUsername(),
                tenantConfigurationPersistenceProperties.getGitPassword());
    }

    private File tenantDirectory(final String tenantKey) {
        final String pathname = localRepository().getPath() + File.separator + "tenant-" + tenantKey;
        return new File(pathname);
    }

    private File nextAvailableArchiveDirectory(final String tenantKey) {
        File archiveDir = new File(localRepository(), "archive-" + tenantKey);
        if (!archiveDir.exists()) {
            return archiveDir;
        }

        // This will rarely if ever happen. It would be caused if a tenant was deleted, the archived
        // configuration not cleaned up, another tenant with the same key created, and then that
        // tenant also deleted. In this case we'll try to archive to archive-<n>-<tenantKey>, where
        // <n> is a number between 1 and 9. If all these folders already exist, throw an error.
        for (int i = 1; i < ARCHIVE_RETRIES; i++) {
            archiveDir = new File(localRepository(), "archive-" + i + "-" + tenantKey);
            if (!archiveDir.exists()) {
                return archiveDir;
            }
        }

        throw new IllegalStateException("Exceeded retries; cannot archive configuration file");
    }

    private File applicationYmlFile(final String tenantKey) {
        return new File(tenantDirectory(tenantKey).getPath() + File.separator + ConfigFileName);
    }

    private File localizationJsonFile(final String tenantKey) {
        return new File(tenantDirectory(tenantKey).getPath() + File.separator + LocalizationName);
    }

    private static String applicationYmlRelativePath(final String tenantKey) {
        return "tenant-" + tenantKey + File.separator + ConfigFileName;
    }

    private static String localizationJsonRelativePath(final String tenantKey) {
        return "tenant-" + tenantKey + File.separator + LocalizationName;
    }

}
