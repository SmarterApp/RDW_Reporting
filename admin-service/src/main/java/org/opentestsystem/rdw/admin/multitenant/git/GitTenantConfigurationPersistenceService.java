package org.opentestsystem.rdw.admin.multitenant.git;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.annotations.VisibleForTesting;
import org.apache.commons.io.FileUtils;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;
import org.opentestsystem.rdw.admin.multitenant.configserver.ConfigServerClient;
import org.opentestsystem.rdw.admin.multitenant.model.ApplicationTenantConfigurationPersistence;
import org.opentestsystem.rdw.admin.multitenant.model.TenantConfiguration;
import org.opentestsystem.rdw.archive.ArchivePropertiesTenant;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.multitenant.TenantProperties;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsTenant;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceUrlParts;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingPropertiesTenant;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemPropertiesImpl;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.yaml.snakeyaml.DumperOptions;
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.introspector.Property;
import org.yaml.snakeyaml.nodes.CollectionNode;
import org.yaml.snakeyaml.nodes.MappingNode;
import org.yaml.snakeyaml.nodes.Node;
import org.yaml.snakeyaml.nodes.NodeTuple;
import org.yaml.snakeyaml.nodes.SequenceNode;
import org.yaml.snakeyaml.nodes.Tag;
import org.yaml.snakeyaml.representer.Representer;

import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;

public class GitTenantConfigurationPersistenceService implements TenantConfigurationPersistenceService {

    private static final Logger logger = LoggerFactory.getLogger(GitTenantConfigurationPersistenceService.class);
    private static final String ConfigFileName = "application.yml";
    private static final String LocalizationName = "en.json";
    private static final String CIPHER = "{cipher}";

    private final TenantConfigurationPersistenceProperties tenantConfigurationPersistenceProperties;
    private final ConfigServerClient configServerClient;

    public GitTenantConfigurationPersistenceService(final TenantConfigurationPersistenceProperties tenantConfigurationPersistenceProperties,
                                                    final ConfigServerClient configServerClient) {
        this.tenantConfigurationPersistenceProperties = tenantConfigurationPersistenceProperties;
        this.configServerClient = configServerClient;
    }

    @VisibleForTesting
    void forceLocalRepositoryToCleanState() {
        //TODO: right now, just wiping and cloning each time this is called
        // there may be a better approach:
        // https://stackoverflow.com/questions/13586502/how-to-check-if-a-git-clone-has-been-done-already-with-jgit
        //RepositoryCache.FileKey.isGitRepository(new File(tenantConfigurationPersistenceProperties.getLocalRepositoryUri() + "application.yml"), FS_DETECTED));
        final UsernamePasswordCredentialsProvider credentialsProvider = credentialsProvider();
        try {
            FileUtils.deleteDirectory(localRepository());
        } catch (final IOException e) {
            throw new TenantConfigurationPersistenceException("Unable to delete directory", e);
        }
        //do clone
        try {
            Git.cloneRepository()
                    .setURI(tenantConfigurationPersistenceProperties.getRemoteRepositoryUri())
                    .setBare(false)
                    .setBranch("master")
                    .setDirectory(getWorkingDirectory())
                    .setCredentialsProvider(credentialsProvider)
                    .call();
        } catch (final GitAPIException e) {
            throw new TenantConfigurationPersistenceException("Unable to clone repository", e);
        }
    }


    @VisibleForTesting
    File getWorkingDirectory() {
        try {
            FileUtils.forceMkdir(localRepository());
        } catch (final IOException e) {
            throw new TenantConfigurationPersistenceException("Unable to create working directory.", e);
        }
        return localRepository();
    }

    @Override
    public synchronized void saveTenantConfiguration(final TenantConfiguration tenantConfiguration) {
        //TODO: synchronized is the fastest way to ensure this is only called one-at-a-time
        // non-blocking channel based approach possibly preferable
        forceLocalRepositoryToCleanState();

        updateConfigurationPasswords(tenantConfiguration);

        final String tenantKey = tenantConfiguration.getTenant().getKey();
        final UsernamePasswordCredentialsProvider credentialsProvider = credentialsProvider();

        makeTenantDirectory(tenantKey);
        writeApplicationTenantConfiguration(tenantConfiguration);
        writeLocalization(tenantConfiguration.getLocalization(), tenantKey);

        try {
            final Git git = Git.open(localRepository());

            final String applicationYmlRelativePath = applicationYmlRelativePath(tenantKey);
            logger.debug("git add {}", applicationYmlRelativePath);
            git.add()
                    .addFilepattern(applicationYmlRelativePath)
                    .call();

            final String localizationJsonRelativePath = localizationJsonRelativePath(tenantKey);
            logger.debug("git add {}", localizationJsonRelativePath);
            git.add()
                    .addFilepattern(localizationJsonRelativePath)
                    .call();

            git.commit()
                    .setAuthor(tenantConfigurationPersistenceProperties.getAuthor(),
                            tenantConfigurationPersistenceProperties.getAuthorEmail())
                    .setMessage("saving " + tenantKey + " configuration.")
                    .call();

            git.push()
                    .setCredentialsProvider(credentialsProvider)
                    .call();
        } catch (final IOException | GitAPIException e) {
            throw new TenantConfigurationPersistenceException("Unable to save changes to the remote git repository", e);
        }
    }

    public void deleteSandbox(final String tenantKey) {
        if (tenantKey == null || !tenantKey.contains("_S")) {
            throw new TenantConfigurationPersistenceException("Only sandboxes can be deleted, invalid tenant key " + tenantKey);
        }

        forceLocalRepositoryToCleanState();

        final UsernamePasswordCredentialsProvider credentialsProvider = credentialsProvider();
        final String applicationYmlRelativePath = applicationYmlRelativePath(tenantKey);
        final String localizationJsonRelativePath = localizationJsonRelativePath(tenantKey);

        try {
            final Git git = Git.open(localRepository());
            logger.debug("git rm {}", applicationYmlRelativePath);
            git.rm()
                    .addFilepattern(applicationYmlRelativePath)
                    .call();

            logger.debug("git rm {}", localizationJsonRelativePath);
            git.rm()
                    .addFilepattern(localizationJsonRelativePath)
                    .call();


            git.commit()
                    .setAuthor(tenantConfigurationPersistenceProperties.getAuthor(),
                            tenantConfigurationPersistenceProperties.getAuthorEmail())
                    .setMessage("deleting sandbox " + tenantKey + " configuration.")
                    .call();

            logger.debug("git push");
            git.push()
                    .setCredentialsProvider(credentialsProvider)
                    .call();
        } catch (final IOException | GitAPIException e) {
            throw new TenantConfigurationPersistenceException("Unable to delete sandbox configuration " + tenantKey, e);
        }
    }

    /**
     * @param tenantConfiguration to update the tenantConfig with encrypted passwords and archive s3 key data
     */
    private void updateConfigurationPasswords(final TenantConfiguration tenantConfiguration) {
        // all dataSource password need to be save as encrypted
        tenantConfiguration.getDataSources().forEach((k, v) -> {
            // todo how to handle a when the configServer is not available : atm will catch any
            try {
                // skip if pwd doesn't exist, or is empty or if it is already encrypted : will have (cipher) prefix
                if (isOkToEncrypt(v.getPassword())) {
                    // have a non-encrypted pwd, let's encrypt it
                    final String encryptedPassword = configServerClient.encryptPassword(v.getPassword());
                    v.setPassword(CIPHER + encryptedPassword);
                }
            } catch (Exception e) {
                // if there is a problem, store the pwd as is - so it could be in the clear
                // not changing password at this time
                logger.warn("Failed to contact the ConfigServer at this time, will store {}'s the password for {} as is.",
                        tenantConfiguration.getTenant().getKey(), k);
            }

        });
        // all s3 archive secret keys need to be saved as encrypted
        if (isOkToEncrypt(tenantConfiguration.getArchiveProperties().getS3SecretKey())) {
            try {
                final String encryptedPassword = configServerClient.encryptPassword(tenantConfiguration.getArchiveProperties().getS3SecretKey());
                tenantConfiguration.getArchiveProperties().setS3SecretKey(CIPHER + encryptedPassword);
            } catch (Exception e) {
                // if there is a problem, store the pwd as is - so it could be in the clear
                // not changing password at this time
                logger.warn("Failed to contact the ConfigServer at this time, will store the archive data for {} as is.",
                        tenantConfiguration.getTenant().getKey());
            }
        }
    }

    /**
     * @param key the key to verify it is not null, empty or already encrypted, it will start with CIPHER
     * @return true if is ok to encrypt the key
     */
    private boolean isOkToEncrypt(final String key) {
        return key != null && !key.startsWith(CIPHER);
    }

    @VisibleForTesting
    void writeApplicationTenantConfiguration(final TenantConfiguration tenantConfiguration) {

        final Tenant tenant = tenantConfiguration.getTenant();
        final String tenantKey = tenant.getKey();

        final ApplicationTenantConfigurationPersistence applicationTenantConfigurationPersistence =
                new ApplicationTenantConfigurationPersistence(tenantConfiguration);

        final Yaml yaml = getYaml();

        final String output = yaml.dump(applicationTenantConfigurationPersistence);
        logger.debug("output yml \n{}", output);

        final File applicationYmlFile = applicationYmlFile(tenantKey);
        logger.debug("applicationYmlFile {}", applicationYmlFile.getPath());
        try {
            FileUtils.write(applicationYmlFile, output, "UTF-8");
        } catch (final IOException e) {
            throw new TenantConfigurationPersistenceException("Unable write application tenant configuration file", e);
        }
    }

    @VisibleForTesting
    void writeLocalization(final String localization, final String tenantKey) {
        final File localizationJsonFile = localizationJsonFile(tenantKey);

        try {
            final ObjectMapper mapper = new ObjectMapper();
            if (localization != null) {
                final Object json = mapper.readValue(localization, Object.class);
                final String output = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(json);
                FileUtils.write(localizationJsonFile, output, "UTF-8");
            }
        } catch (final IOException e) {
            throw new TenantConfigurationPersistenceException("Unable write tenant localization file", e);
        }
    }

    private void makeTenantDirectory(final String tenantKey) {
        final File tenantDirectory = tenantDirectory(tenantKey);
        logger.debug("tenantDirectory {}", tenantDirectory.getPath());
        try {
            FileUtils.forceMkdir(tenantDirectory);
        } catch (final IOException e) {
            throw new TenantConfigurationPersistenceException("Unable to create tenant directory", e);
        }
    }

    private File localRepository() {
        try {
            final URL localRepositoryUrl = new URL(tenantConfigurationPersistenceProperties.getLocalRepositoryUri());
            return FileUtils.toFile(localRepositoryUrl);
        } catch (final MalformedURLException e) {
            throw new TenantConfigurationPersistenceException("Configuration error for local directory", e);
        }
    }

    private Yaml getYaml() {
        final DumperOptions options = new DumperOptions();
        options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
        options.setIndent(2);
        options.setCanonical(false);

        final SkipEmptyRepresenter representer = new SkipEmptyRepresenter();
        representer.addClassTag(ApplicationTenantConfigurationPersistence.class, Tag.MAP);
        representer.addClassTag(ReportingSystemPropertiesImpl.class, Tag.MAP);
        representer.addClassTag(AggregateReportingPropertiesTenant.class, Tag.MAP);
        representer.addClassTag(DataSourceElementsTenant.class, Tag.MAP);
        representer.addClassTag(DataSourceUrlParts.class, Tag.MAP);
        representer.addClassTag(ArchivePropertiesTenant.class, Tag.MAP);
        representer.addClassTag(TenantProperties.class, Tag.MAP);
        representer.addClassTag(Tenant.class, Tag.MAP);
        return new Yaml(representer, options);
    }

    private UsernamePasswordCredentialsProvider credentialsProvider() {
        return new UsernamePasswordCredentialsProvider(tenantConfigurationPersistenceProperties.getGitUsername(),
                tenantConfigurationPersistenceProperties.getGitPassword());
    }

    private File tenantDirectory(final String tenantKey) {
        final String pathname = localRepository().getPath() + File.separator + "tenant-" + tenantKey;
        return new File(pathname);
    }

    private File applicationYmlFile(final String tenantKey) {
        return new File(tenantDirectory(tenantKey).getPath() + File.separator + ConfigFileName);
    }

    private File localizationJsonFile(final String tenantKey) {
        return new File(tenantDirectory(tenantKey).getPath() + File.separator + LocalizationName);
    }

    private static String applicationYmlRelativePath(final String tenantKey) {
        return "tenant-" + tenantKey + File.separator + ConfigFileName;
    }

    private static String localizationJsonRelativePath(final String tenantKey) {
        return "tenant-" + tenantKey + File.separator + LocalizationName;
    }

    /**
     * Remove all the nodes that are null or objects / collections that are empty to match the spring configuration style.
     */
    private class SkipEmptyRepresenter extends Representer {
        //from https://bitbucket.org/asomov/snakeyaml/src/tip/src/test/java/org/yaml/snakeyaml/issues/issue60/SkipBeanTest.java

        @Override
        protected NodeTuple representJavaBeanProperty(final Object javaBean,
                                                      final Property property,
                                                      final Object propertyValue,
                                                      final Tag customTag) {
            final NodeTuple tuple = super.representJavaBeanProperty(javaBean, property, propertyValue,
                    customTag);
            final Node valueNode = tuple.getValueNode();
            if (Tag.NULL.equals(valueNode.getTag())) {
                return null;// skip 'null' values
            }
            if (valueNode instanceof CollectionNode) {
                if (Tag.SEQ.equals(valueNode.getTag())) {
                    final SequenceNode seq = (SequenceNode) valueNode;
                    if (seq.getValue().isEmpty()) {
                        return null;// skip empty lists
                    }
                }
                if (Tag.MAP.equals(valueNode.getTag())) {
                    final MappingNode seq = (MappingNode) valueNode;
                    if (seq.getValue().isEmpty()) {
                        return null;// skip empty maps
                    }
                }
            }
            return tuple;
        }
    }

}
