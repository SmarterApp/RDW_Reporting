package org.opentestsystem.rdw.admin.repository.impl;

import com.google.common.collect.ImmutableList;
import org.opentestsystem.rdw.admin.model.Embargo;
import org.opentestsystem.rdw.admin.model.TestResultsReportType;
import org.opentestsystem.rdw.admin.model.TestResultsStatus;
import org.opentestsystem.rdw.admin.model.TestResultsAvailability;
import org.opentestsystem.rdw.admin.repository.EmbargoRepository;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.dao.DataRetrievalFailureException;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.UNMATCHABLE_IDS;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.getNullable;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.nullOrEmptyToDefault;
import static org.opentestsystem.rdw.reporting.common.model.OrganizationType.State;

@Repository
public class JdbcEmbargoRepository implements EmbargoRepository {
    private final NamedParameterJdbcTemplate template;

    @Value("${sql.embargo.findAllBySchoolYear}")
    private String findAllBySchoolYearQuery;

    @Value("${sql.embargo.findOneBySchoolYearAndState}")
    private String findOneBySchoolYearAndState;

    @Value("${sql.embargo.findOneBySchoolYearAndDistrict}")
    private String findOneBySchoolYearAndDistrict;

    @Value("${sql.embargo.findTestResultsAvailability}")
    private String findTestResultsAvailability;

    @Value("${sql.embargo.createState}")
    private String createState;

    @Value("${sql.embargo.createDistrict}")
    private String createDistrict;

    @Value("${sql.embargo.updateState}")
    private String updateState;

    @Value("${sql.embargo.updateDistrict}")
    private String updateDistrict;

    public static final List<Integer> UNMATCHABLE_STATUSES = ImmutableList.of(-1);

    @Autowired
    public JdbcEmbargoRepository(@Qualifier("warehouseJdbcTemplate") final NamedParameterJdbcTemplate template) {
        this.template = template;
    }

    @Override
    public Collection<Embargo> findAllBySchoolYear(final int schoolYear, final Collection<Long> districtIds) {
        // the query returns multiple rows per organization, each having different subject_id and count
        // create builders while iterating result set, indexing them off of organization id
        final Map<Long, Embargo.Builder> builderMap = new HashMap<>();
        template.query(findAllBySchoolYearQuery,
                new MapSqlParameterSource()
                        .addValue("district_ids", nullOrEmptyToDefault(districtIds, UNMATCHABLE_IDS))
                        .addValue("school_year", schoolYear), (rs, rowNum) -> {
                    final Long id = getNullable(rs, rs.getLong("org_id"));
                    final Embargo.Builder builder = builderMap.computeIfAbsent(id, innerId -> {
                        try {
                            final Embargo.Builder innerBuilder = Embargo.builder()
                                    .organizationType(OrganizationType.valueOf(rs.getString("org_type")))
                                    .organizationId(innerId)
                                    .organizationName(rs.getString("org_name"))
                                    .individualEnabled(getNullable(rs, rs.getBoolean("individual")))
                                    .aggregateEnabled(getNullable(rs, rs.getBoolean("aggregate")))
                                    .schoolYear(rs.getInt("school_year"));

                            return innerBuilder;
                        } catch (SQLException e) {
                            throw new DataRetrievalFailureException(e.getMessage());
                        }
                    });

                    final String subjectCode = rs.getString("subject_code");
                    if (subjectCode != null) {
                        builder.examCount(rs.getString("subject_code"), rs.getLong("count"));
                    }

                    return builder;
                }
        );
        return builderMap.values().stream().map(Embargo.Builder::build).collect(Collectors.toList());
    }

    @Override
    public Embargo findOneBySchoolYearAndState(final int schoolYear) {
        return template.query(findOneBySchoolYearAndState,
                new MapSqlParameterSource()
                        .addValue("school_year", schoolYear),
                EmbargoExtractor);
    }

    @Override
    public Embargo findOneBySchoolYearAndDistrictId(final int schoolYear, final long districtId) {
        return template.query(findOneBySchoolYearAndDistrict,
                new MapSqlParameterSource()
                        .addValue("district_id", districtId)
                        .addValue("school_year", schoolYear),
                EmbargoExtractor);
    }

    @Override
    public List<TestResultsAvailability> findTestResultsAvailability(
        Collection<Integer> includedStatuses,
        Collection<Integer> filteredStatuses,
        Collection<Long> districtIds) {

        return template.query(
            findTestResultsAvailability,
            new MapSqlParameterSource()
                .addValue("included_statuses", nullOrEmptyToDefault(includedStatuses, UNMATCHABLE_STATUSES))
                .addValue("filtered_statuses", nullOrEmptyToDefault(filteredStatuses, UNMATCHABLE_STATUSES))
                .addValue("district_ids", nullOrEmptyToDefault(districtIds, UNMATCHABLE_IDS)),
            (row, index) -> mapToTestResults(row)
        );
    }

    @Override
    public void create(final Embargo embargo, final String username) {
        try {
            if (1 != template.update((embargo.getOrganizationType() == State) ? createState : createDistrict,
                    toSource(embargo, username))) {
                throw new IllegalArgumentException("Error creating embargo");
            }
        } catch (final DataIntegrityViolationException e) {
            throw new IllegalArgumentException("Exception creating embargo", e);
        }
    }

    @Override
    public void update(final Embargo embargo, final String username) {
        final int count = template.update((embargo.getOrganizationType() == State) ? updateState : updateDistrict,
                toSource(embargo, username));
        if (count != 1) {
            throw new IllegalArgumentException("Failed to update embargo");
        }
    }

    private MapSqlParameterSource toSource(final Embargo embargo, final String username) {
        return new MapSqlParameterSource()
                .addValue("district_id", embargo.getOrganizationId())
                .addValue("school_year", embargo.getSchoolYear())
                .addValue("individual", embargo.isIndividualEnabled())
                .addValue("aggregate", embargo.isAggregateEnabled())
                .addValue("updated_by", username);
    }

    private static final ResultSetExtractor<Embargo> EmbargoExtractor = rs -> rs.next() ? Embargo.builder()
            .organizationType(OrganizationType.valueOf(rs.getString("org_type")))
            .organizationId(getNullable(rs, rs.getLong("org_id")))
            .organizationName(rs.getString("org_name"))
            .individualEnabled(getNullable(rs, rs.getBoolean("individual")))
            .aggregateEnabled(getNullable(rs, rs.getBoolean("aggregate")))
            .schoolYear(rs.getInt("school_year"))
            .readOnly(false)
            .build() : null;

    private TestResultsAvailability mapToTestResults(ResultSet row) throws SQLException {
        return TestResultsAvailability.builder()
            .districtId(row.getLong("district_id"))
            .districtName(row.getString("district_name"))
            .schoolYear(row.getInt("school_year"))
            .subjectId(row.getLong("subject_id"))
            .subjectCode(row.getString("subject_code"))
            .status(TestResultsStatus.byStatusCode(getNullable(row, row.getInt("status"))))
            .reportType(TestResultsReportType.caseInsensitiveValue(row.getString("report_type")))
            .examCount(row.getInt("count"))
            .build();
    }
}
