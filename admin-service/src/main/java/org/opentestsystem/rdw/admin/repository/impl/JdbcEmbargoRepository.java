package org.opentestsystem.rdw.admin.repository.impl;

import com.google.common.collect.ImmutableList;
import org.opentestsystem.rdw.admin.model.EmbargoAuditRecord;
import org.opentestsystem.rdw.admin.model.EmbargoQuery;
import org.opentestsystem.rdw.admin.model.EmbargoUpdate;
import org.opentestsystem.rdw.admin.model.Embargo;
import org.opentestsystem.rdw.admin.model.EmbargoReportType;
import org.opentestsystem.rdw.admin.repository.EmbargoAuditRepository;
import org.opentestsystem.rdw.admin.repository.EmbargoRepository;
import org.opentestsystem.rdw.reporting.common.model.EmbargoStatus;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Arrays;
import java.util.Date;
import java.util.List;

import static org.opentestsystem.rdw.admin.model.EmbargoReportType.Aggregate;
import static org.opentestsystem.rdw.admin.model.EmbargoReportType.Individual;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.UNMATCHABLE_IDS;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.nullOrEmptyToDefault;
import static org.opentestsystem.rdw.reporting.common.model.EmbargoStatus.Loading;
import static org.opentestsystem.rdw.reporting.common.util.CollectionUtils.safeIsEmpty;

@Repository
public class JdbcEmbargoRepository implements EmbargoRepository, EmbargoAuditRepository {
    // ORDER BY clause for embargo results must be added dynamically.
    private final static String OrderByPlaceholder = "{ORDER_BY_PLACEHOLDER}";

    // Primary sort field for embargo results must be added dynamically.
    private final static String PrimarySortPlaceholder = "{PRIMARY_SORT_PLACEHOLDER}";

    // This should be a subset of the fields selected in findEmbargoes SQL
    private final static List<String> SortableFields = Arrays.asList(
        "school_year", "district_name", "district_id", "subject_code", "subject_id", "report_type", "status");

    private final NamedParameterJdbcTemplate template;

    @Value("${sql.embargo.findEmbargoes}")
    private String findEmbargoes;

    @Value("${sql.embargo.findEmbargoesDefaultOrdering}")
    private String findEmbargoesDefaultOrdering;

    @Value("${sql.embargo.findEmbargoAuditRecords}")
    private String findEmbargoAuditRecords;

    @Value("${sql.embargo.createEmbargo}")
    private String createEmbargo;

    @Value("${sql.embargo.updateEmbargoIndividualStatus}")
    private String updateEmbargoIndividualStatus;

    @Value("${sql.embargo.updateEmbargoAggregateStatus}")
    private String updateEmbargoAggregateStatus;


    public static final List<Integer> UNMATCHABLE_STATUSES = ImmutableList.of(-1);

    @Autowired
    public JdbcEmbargoRepository(@Qualifier("warehouseJdbcTemplate") final NamedParameterJdbcTemplate template) {
        this.template = template;
    }

    @Override
    public List<Embargo> findEmbargoes(final EmbargoQuery query) {
        final String orderBySql = getOrderBy(query.getSortField(), query.isDescending());
        final String enhancedSql = addOrdering(findEmbargoes, orderBySql);

        return template.query(
            enhancedSql,
            getSqlParameterSource(query),
            (row, index) -> mapToTestResults(row)
        );
    }

    @Override
    public int countByQuery(final EmbargoQuery query) {
        // Remove any page limits to ensure we get the proper count.
        final EmbargoQuery noLimitsQuery = query.copy().rowOffset(0).pageSize(Integer.MAX_VALUE).build();

        // Convert existing SQL to count rows.
        final String sql = String.format("select count(*) from (%s) as results",
            addOrdering(findEmbargoes, " "));

        return template.queryForObject(
            sql,
            getSqlParameterSource(noLimitsQuery),
            Integer.class
        );
    }

    private MapSqlParameterSource getSqlParameterSource(final EmbargoQuery query) {
        return new MapSqlParameterSource()
            .addValue("statuses", nullOrEmptyToDefault(query.getStatusValues(), UNMATCHABLE_STATUSES))
            .addValue("filter_by_year", query.getSchoolYear() != null)
            .addValue("year", query.getSchoolYear())
            .addValue("filter_by_district", !safeIsEmpty(query.getDistrictIds()))
            .addValue("district_ids", nullOrEmptyToDefault(query.getDistrictIds(), UNMATCHABLE_IDS))
            .addValue("filter_by_subject", query.getSubjectId() != null)
            .addValue("subject_id", query.getSubjectId())
            .addValue("filter_by_report_type", query.getReportType() != null)
            .addValue("report_type", query.getReportTypeValue())
            .addValue("page_size", query.getPageSize())
            .addValue("offset", query.getRowOffset());
    }

    private String getOrderBy(final String sortField, final boolean descending) {
        final String sql = this.findEmbargoesDefaultOrdering;

        String primarySort = "NULL";

        // If primary sort field has been set on the client use it, add it to the sort.
        if (sortField != null && SortableFields.contains(sortField)) {
            // Special case for status sort because two statuses are stored in the same db record
            final String sortByParam = sortField.equalsIgnoreCase("status") ?
                "IF(report_type='Individual', c_individual, c_aggregate)" :
                sortField;

            primarySort = String.format("%s %s", sortByParam, descending ? "DESC" : "ASC");
        }

        return sql.replace(PrimarySortPlaceholder, primarySort);
    }

    // Prepared statements don't have support for parametrized "ORDER BY" clauses,
    // so we have to make just this part of the query dynamically built.
    // Note: the query is also doing pagination, so it's not possible to sort outside the query.
    private String addOrdering(final String sql,  final String orderBySql) {
        return sql.replace(OrderByPlaceholder, orderBySql);
    }

    @Override
    public List<EmbargoAuditRecord> findEmbargoAuditRecords(final Date startDate) {
        return template.query(
            findEmbargoAuditRecords,
            new MapSqlParameterSource()
                .addValue("start_date", startDate),
            (row, index) -> mapToEmbargoAuditRecord(row)
        );
    }

    @Override
    @Transactional(transactionManager = "warehouseTxManager")
    public int update(final EmbargoUpdate embargo, final String username) {
        int updated = 0;

        final boolean filterByReportType = embargo.getReportType() != null;
        // New records may need to be created if transitioning from Loading
        if (embargo.getStatus() == Loading) {
            int count = template.update(createEmbargo, toCreateSource(embargo, username));

            // If not limited to a single report type, count the records affected as double
            updated += (filterByReportType ? count : 2 * count);
        }

        // Update existing records with new status
        if (!filterByReportType || embargo.getReportType() == Individual) {
            updated += template.update(updateEmbargoIndividualStatus, toUpdateSource(embargo, username));
        }
        if (!filterByReportType || embargo.getReportType() == Aggregate) {
            updated += template.update(updateEmbargoAggregateStatus, toUpdateSource(embargo, username));
        }

        return updated;
    }

    private SqlParameterSource toUpdateSource(final EmbargoUpdate embargo,
                                              final String username) {
        return toSource(embargo, username)
            .addValue("current_status", embargo.getStatus().getStatusCode())
            .addValue("new_status", embargo.getNewStatus().getStatusCode());
    }

    private SqlParameterSource toCreateSource(final EmbargoUpdate embargo, final String username) {
        final EmbargoStatus newIndividual = embargo.getReportType() == Aggregate ? Loading : embargo.getNewStatus();
        final EmbargoStatus newAggregate = embargo.getReportType() == Individual ? Loading : embargo.getNewStatus();

        return toSource(embargo, username)
                .addValue("individual", newIndividual.getStatusCode())
                .addValue("aggregate", newAggregate.getStatusCode());
    }

    private MapSqlParameterSource toSource(final EmbargoUpdate embargo, final String username) {
        return new MapSqlParameterSource()
            .addValue("school_year", embargo.getSchoolYear())
            .addValue("subject_id", embargo.getSubjectId())
            .addValue("filter_by_district", !safeIsEmpty(embargo.getDistrictIds()))
            .addValue("district_ids", nullOrEmptyToDefault(embargo.getDistrictIds(), UNMATCHABLE_IDS))
            .addValue("updated_by", username);
    }

    private Embargo mapToTestResults(final ResultSet row) throws SQLException {
        return Embargo.builder()
            .districtId(row.getLong("district_id"))
            .districtName(row.getString("district_name"))
            .schoolYear(row.getInt("school_year"))
            .subjectId(row.getLong("subject_id"))
            .subjectCode(row.getString("subject_code"))
            .individualStatus(EmbargoStatus.valueOf(row.getInt("c_individual")))
            .aggregateStatus(EmbargoStatus.valueOf(row.getInt("c_aggregate")))
            .reportType(EmbargoReportType.caseInsensitiveValueOf(row.getString("report_type")))
            .examCount(row.getInt("exam_count"))
            .build();
    }

    private EmbargoAuditRecord mapToEmbargoAuditRecord(final ResultSet row) throws SQLException {
        return EmbargoAuditRecord.builder()
            .schoolYear(row.getInt("school_year"))
            .district(row.getString("district"))
            .subject(row.getString("subject"))
            .individualStatus(EmbargoStatus.valueOf(row.getInt("individual")))
            .previousIndividualStatus(EmbargoStatus.valueOf(row.getInt("previous_individual")))
            .aggregateStatus(EmbargoStatus.valueOf(row.getInt("aggregate")))
            .previousAggregateStatus(EmbargoStatus.valueOf(row.getInt("previous_aggregate")))
            .user(row.getString("user"))
            .updated(row.getTimestamp("updated"))
            .build();
    }
}
