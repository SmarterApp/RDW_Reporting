package org.opentestsystem.rdw.admin.service.impl;

import org.opentestsystem.rdw.admin.model.CompilationError;
import org.opentestsystem.rdw.admin.model.Pipeline;
import org.opentestsystem.rdw.admin.model.PipelineScript;
import org.opentestsystem.rdw.admin.model.PipelineTest;
import org.opentestsystem.rdw.admin.model.PipelineTestResult;
import org.opentestsystem.rdw.admin.model.PipelineTestRun;
import org.opentestsystem.rdw.admin.model.PublishedPipeline;
import org.opentestsystem.rdw.admin.model.SchemaError;
import org.opentestsystem.rdw.admin.model.ScriptError;
import org.opentestsystem.rdw.admin.repository.PipelineRepository;
import org.opentestsystem.rdw.admin.repository.PipelineScriptRepository;
import org.opentestsystem.rdw.admin.repository.PipelineTestRepository;
import org.opentestsystem.rdw.admin.repository.PublishedPipelineRepository;
import org.opentestsystem.rdw.admin.service.PipelineService;
import org.springframework.stereotype.Service;
import org.xmlunit.builder.DiffBuilder;
import org.xmlunit.builder.Input;
import org.xmlunit.diff.Diff;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import static com.google.common.collect.ImmutableList.of;
import static java.util.stream.Collectors.toList;

/**
 * Default implementation of the pipeline service.
 */
@Service
class DefaultPipelineService implements PipelineService {

    private final PipelineRepository repository;
    private final PipelineScriptRepository scriptRepository;
    private final PipelineTestRepository testRepository;
    private final PublishedPipelineRepository publishedPipelineRepository;

    DefaultPipelineService(
            final PipelineRepository repository,
            final PipelineScriptRepository scriptRepository,
            final PipelineTestRepository testRepository,
            final PublishedPipelineRepository publishedPipelineRepository) {
        this.repository = repository;
        this.scriptRepository = scriptRepository;
        this.testRepository = testRepository;
        this.publishedPipelineRepository = publishedPipelineRepository;
    }

    @Override
    public List<Pipeline> getPipelines() {
        return repository.findAll();
    }

    @Override
    public Pipeline getPipeline(final int id) {
        return repository.findById(id);
    }

    @Override
    public List<PublishedPipeline> getPublishedPipelines(final String pipelineCode) {
        return getPublishedPipelines(pipelineCode, null);
    }

    @Override
    public List<PublishedPipeline> getPublishedPipelines(final String pipelineCode, final Integer version) {
        return publishedPipelineRepository.findAllByCodeAndVersion(pipelineCode, version);
    }

    @Override
    public List<PipelineScript> getScripts(final int pipelineId) {
        return scriptRepository.findAllByPipeline(pipelineId);
    }

    @Override
    public List<PipelineTest> getTests(final int pipelineId) {
        return testRepository.findAllByPipeline(pipelineId);
    }

    @Override
    public List<CompilationError> compile(final String scriptBody) {
        // TODO
        return scriptBody.contains("error")
                ? of(
                CompilationError.builder()
                        .row(1)
                        .column(1)
                        .message("Failed to compile this line")
                        .build()
        )
                : of();
    }

    @Override
    public List<PipelineTestRun> test(final int pipelineId) {
        return test(pipelineId, null);
    }

    @Override
    public List<PipelineTestRun> test(final int pipelineId, final Collection<Integer> testIds) {
        final Pipeline pipeline = repository.findById(pipelineId);
        final List<PipelineScript> scripts = scriptRepository.findAllByPipeline(pipelineId);
        final List<PipelineTest> tests = testRepository.findAllByPipeline(pipelineId);
        return tests.stream()
                .filter(test ->
                        testIds == null || testIds.contains(test.getId())
                )
                .map(test -> run(test, scripts, pipeline))
                .collect(toList());
    }

    @Override
    public int publish(final int pipelineId) {
        // TODO
        return 1;
    }

    @Override
    public void activate(final int pipelineId, final int version) {
        // TODO
    }

    private PipelineTestRun run(final PipelineTest test, final List<PipelineScript> scripts, final Pipeline pipeline) {
        final PipelineTestRun.Builder run = PipelineTestRun.builder()
                .test(test);

        //someService.run(test.getInput(), scripts);
        final List<ScriptError> scriptErrors = new ArrayList<>();
        final String actualOutput = "";

        if (!scriptErrors.isEmpty()) {
            return run.result(PipelineTestResult.failedWithScriptErrors(scriptErrors))
                    .build();
        }

        // depends on pipeline input type
        // TODO create abstraction to put the strategizing behind

        // XML specific diff logic - TODO add tests
        final Diff diff = DiffBuilder
                .compare(
                        Input.fromString(test.getOutput()).build()
                )
                .withTest(
                        Input.fromString(actualOutput).build()
                )
                .ignoreComments()
                .normalizeWhitespace()
                .build();

        if (diff.hasDifferences()) {
            return run.result(PipelineTestResult.failedWithOutput(actualOutput))
                    .build();
        }

        // someService.validateSchema(actualOutput, pipelineCode)
        final List<SchemaError> schemaErrors = new ArrayList<>();

        if (!schemaErrors.isEmpty()) {
            return run.result(PipelineTestResult.failedWithSchemaErrors(schemaErrors))
                    .build();
        }

        return run.result(PipelineTestResult.passed())
                .build();
    }


}
