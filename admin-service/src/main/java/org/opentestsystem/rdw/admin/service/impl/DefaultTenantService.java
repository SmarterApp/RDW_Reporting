package org.opentestsystem.rdw.admin.service.impl;

import org.opentestsystem.rdw.admin.model.AllApplicationTenantConfiguration;
import org.opentestsystem.rdw.admin.model.ApplicationTenantConfiguration;
import org.opentestsystem.rdw.admin.model.TenantConfiguration;
import org.opentestsystem.rdw.admin.model.TenantConfigurationStubs;
import org.opentestsystem.rdw.admin.repository.impl.InMemoryTenantRepository;
import org.opentestsystem.rdw.admin.service.TenantService;
import org.opentestsystem.rdw.archive.ArchivePropertiesRoot;
import org.opentestsystem.rdw.archive.ArchivePropertiesTenant;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.multitenant.TenantProperties;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsProperties;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsTenant;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingPropertiesRoot;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingPropertiesTenant;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemPropertiesImpl;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemSettings;
import org.opentestsystem.rdw.reporting.common.multitenant.ReportingTenantIdResolver;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.Set;


/**
 * Service to manage tenant configurations.
 * Reading in Default data from services
 * //todo Modify to actually update application properties yml files
 */
@Service
public class DefaultTenantService implements TenantService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultTenantService.class);

    private TenantProperties tenantProperties;
    private InMemoryTenantRepository inMemoryTenantRepository;
    private DefaultActuatorClientRdwService defaultTenantPropertiesService;
    private ReportingTenantIdResolver reportingTenantIdResolver;

    private Map<String,TenantConfiguration> tenantConfigurationMap = new HashMap<>();

    @Autowired
    DefaultTenantService(TenantProperties tenantProperties, InMemoryTenantRepository inMemoryTenantRepository,
                         DefaultActuatorClientRdwService defaultTenantPropertiesService, ReportingTenantIdResolver reportingTenantIdResolver) {
        this.tenantProperties = tenantProperties;
        this.inMemoryTenantRepository = inMemoryTenantRepository;
        this.defaultTenantPropertiesService = defaultTenantPropertiesService;
        this.reportingTenantIdResolver = reportingTenantIdResolver;
    }

    @Override
    public AllApplicationTenantConfiguration getAll() {
        //  retrieve the current default information from services & tenant info
        AllApplicationTenantConfiguration allApplicationTenantConfiguration = getAllApplicationTenantConfiguration();

        // is not datasources are returned then use mocks
        if (!allApplicationTenantConfiguration.getApplicationTenantConfiguration().getDataSources().isEmpty() ) {
            logger.info("Retrieved Default applicationTenantConfiguration from services and possible tenant information");
            // add tenantConfiguration to memory if nothing is there - keep until git Write is done
            if(inMemoryTenantRepository.getAll().size() == 0) {
                tenantConfigurationMap.forEach((key, t) -> inMemoryTenantRepository.add(t));
            }

        } else {
            // if nothing found, use mock Data for the time being
            logger.debug("USING MOCK DATA for Default applicationTenantConfiguration ");
            allApplicationTenantConfiguration.setApplicationTenantConfiguration(TenantConfigurationStubs.getMockDefaultApplicationTenantConfiguration());
            if(inMemoryTenantRepository.getAll().size() == 0) {
                logger.debug("No Actuator endpoint found Tenants, so adding 2 CA & NV");
                // add tenantConfiguration to memory if nothing is there - keep until git Write is done
                inMemoryTenantRepository.add(TenantConfigurationStubs.createMockTenantCA());
                inMemoryTenantRepository.add(TenantConfigurationStubs.createMockTenantNV());
            }
        }
        // In Memory Map should have been updated - send that back
        // Add the currently configured tenants
        allApplicationTenantConfiguration.setTenants(inMemoryTenantRepository.getAll());
        return allApplicationTenantConfiguration;
    }

    /**
     * Get the currently configured tenantConfiguration data from actuator endpoints
     * todo look at refactoring and caching and WHERE to pick up the localization for each tenantConfiguration
     */
    private AllApplicationTenantConfiguration getAllApplicationTenantConfiguration() {
        AllApplicationTenantConfiguration allApplicationTenantConfiguration = new AllApplicationTenantConfiguration();

        // need a tenantConfiguration for each tenant
        Map<String, Tenant> tenants = tenantProperties.getTenants();
        tenants.forEach((key, t) -> {
            TenantConfiguration tenantConfiguration = new TenantConfiguration();
            Tenant tenant = new Tenant();
            tenant.setKey(t.getKey());
            tenant.setId(t.getId());
            tenant.setDescription(t.getDescription());
            tenant.setName(t.getName());
            tenantConfiguration.setTenant(tenant);

            ApplicationTenantConfiguration applicationTenantConfiguration = new ApplicationTenantConfiguration();
            Map<String,DataSourceElementsTenant> tenantDataSources = new HashMap<>();
            applicationTenantConfiguration.setDataSources(tenantDataSources);
            tenantConfiguration.setApplicationTenantConfiguration(applicationTenantConfiguration);
            tenantConfigurationMap.put(key,tenantConfiguration);
        });
        logger.info("Retrieve current /configProps from the services");

        // make the service call once to all of them and retrieve the data from results
        List<ResponseEntity<String>> responseList = defaultTenantPropertiesService.getAllResponseEntities();
        ApplicationTenantConfiguration applicationTenantConfiguration = new ApplicationTenantConfiguration();

        // get reporting data
        Optional<ReportingSystemSettings> reportingSystemSettings = defaultTenantPropertiesService.getReportingSystemSettings(responseList);
        if (reportingSystemSettings.isPresent()) {
            // get Default ReportingSystemSettings Data
            Optional<ReportingSystemPropertiesImpl> reportingSystemProperties = defaultTenantPropertiesService.getReportingSystemSettingsImpl(reportingSystemSettings);
            if (reportingSystemProperties.isPresent()) {
                logger.info("Add Default ReportingSystemSettings");
                applicationTenantConfiguration.setReporting(reportingSystemProperties.get());
            }
            // Add each tenantConfiguration's reportingSystemSettings overrides
            Map<String, ReportingSystemPropertiesImpl> reportingTenants = reportingSystemSettings.get().getTenants();
            reportingTenants.forEach((k,r) -> {
                if(tenantConfigurationMap.containsKey(k)) {
                    logger.info("Add tenant {}'s ReportingSystemSettings overrides", k);
                    tenantConfigurationMap.get(k).getApplicationTenantConfiguration().setReporting(r);
                } // todo tbd on handling if service's reporting tenants is not in the overall tenant list
            });
        }

        // get datasets
        // Get datasources
        Map<String,DataSourceElementsTenant> defaultDataSources = new HashMap<>();

        Optional<DataSourceElementsProperties> dataSourceReadOnlyElementsProperties = defaultTenantPropertiesService.getDataSourceElementsProperties(responseList);
        if (dataSourceReadOnlyElementsProperties.isPresent()) {
            // get Default dataSourceReadOnly DataSources
            Optional<DataSourceElementsTenant> dataSourceReadOnly = defaultTenantPropertiesService.getDataSourceElementsTenant(dataSourceReadOnlyElementsProperties);
            if (dataSourceReadOnly.isPresent()) {
                logger.info("Add Default Reporting ReadOnly DataSource");
                defaultDataSources.put("reporting_ro", dataSourceReadOnly.get());
            }
            // Add each tenantConfiguration's read only dataSet overrides
            Map<String, DataSourceElementsTenant> readOnlyTenants = dataSourceReadOnlyElementsProperties.get().getTenants();
            readOnlyTenants.forEach((k,d) -> {
                if(tenantConfigurationMap.containsKey(k) ) {
                    logger.info("Add tenant {}'s Reporting ReadOnly DataSource overrides", k);
                    tenantConfigurationMap.get(k).getApplicationTenantConfiguration().getDataSources().put("reporting_ro", d);
                }
                // todo tbd on handling if service's readonly dataSet tenants is not in the overall tenant list
            });
        }

        Optional<DataSourceElementsProperties> writableDataSetProperties = defaultTenantPropertiesService.getWritableDataSource(responseList);
        if (writableDataSetProperties.isPresent()) {
            // get Default writableDataSetProperties DataSources
            Optional<DataSourceElementsTenant> dataSourceWritable = defaultTenantPropertiesService.getWritableDataSourceElementsTenant(writableDataSetProperties);
            if (dataSourceWritable.isPresent()) {
                logger.info("Add Default Reporting Writable DataSource");
                defaultDataSources.put("reporting_rw", dataSourceWritable.get());
            }
            // Add each tenantConfiguration's dataSourceWritable overrides
            Map<String, DataSourceElementsTenant> writableTenants = writableDataSetProperties.get().getTenants();
            writableTenants.forEach((k,d) -> {
                if(tenantConfigurationMap.containsKey(k)) {
                    logger.info("Add tenant {}'s Reporting ReadOnly DataSource overrides", k);
                    tenantConfigurationMap.get(k).getApplicationTenantConfiguration().getDataSources().put("reporting_rw", d);
                } // todo tbd on handling if service's writable dataSets is not in the overall tenant list
            });
        }

        Optional<DataSourceElementsProperties> warehouseDataSetProperties = defaultTenantPropertiesService.getWarehouseDataSource(responseList);
        if (writableDataSetProperties.isPresent()) {
            // get Default warehouseDataSetProperties DataSources
            Optional<DataSourceElementsTenant> dataSourceWarehouse = defaultTenantPropertiesService.getWarehouseDataSourceElementsTenant(warehouseDataSetProperties);
            if (dataSourceWarehouse.isPresent()) {
                logger.info("Add Default Reporting Warehouse DataSource");
                defaultDataSources.put("warehouse_rw", dataSourceWarehouse.get());
            }
            // Add each tenantConfiguration's dataSourceWarehouse overrides
            Map<String, DataSourceElementsTenant> warehouseTenants = warehouseDataSetProperties.get().getTenants();
            warehouseTenants.forEach((k,d) -> {
                if(tenantConfigurationMap.containsKey(k)) {
                    logger.info("Add tenant {}'s Reporting Warehouse DataSource overrides", k);
                    tenantConfigurationMap.get(k).getApplicationTenantConfiguration().getDataSources().put("warehouse_rw", d);
                } // todo tbd on handling if service's warehouse dataSets is not in the overall tenant list
            });
        }

        Optional<DataSourceElementsProperties> olapDataSetProperties = defaultTenantPropertiesService.getOlapDataSource(responseList);
        if (writableDataSetProperties.isPresent()) {
            // get Default warehouseDataSetProperties DataSources
            Optional<DataSourceElementsTenant> dataSourceOlap = defaultTenantPropertiesService.getOlapDataSourceElementsTenant(olapDataSetProperties);
            if (dataSourceOlap.isPresent()) {
                logger.info("Add Default Reporting OLAP DataSource");
                defaultDataSources.put("olap_ro", dataSourceOlap.get());
            }
            // Add each tenantConfiguration's dataSourceWarehouse overrides
            Map<String, DataSourceElementsTenant> olapTenants = olapDataSetProperties.get().getTenants();
            olapTenants.forEach((k,d) -> {
                if(tenantConfigurationMap.containsKey(k)) {
                    logger.info("Add tenant {}'s Reporting OLAP DataSource overrides", k);
                    tenantConfigurationMap.get(k).getApplicationTenantConfiguration().getDataSources().put("olap_ro", d);
                } // todo tbd on handling if service's olap dataSets is not in the overall tenant list
            });
        }

        Optional<ArchivePropertiesRoot> archiveProperties = defaultTenantPropertiesService.getArchivePropertiesRoot(responseList);
        if (archiveProperties.isPresent()) {
            // get Default archiveProperties
            Optional<ArchivePropertiesTenant> archivePropertiesTenant = defaultTenantPropertiesService.getArchivePropertiesTenant(archiveProperties);
            if (archivePropertiesTenant.isPresent()) {
                logger.info("Add Default Reporting Archive Properties");
                applicationTenantConfiguration.setArchiveProperties(archivePropertiesTenant.get());
            }
            // Add each archiveProperties overrides
            Map<String, ArchivePropertiesTenant> archiveTenants = archiveProperties.get().getTenants();
            archiveTenants.forEach((k,a) -> {
                if(tenantConfigurationMap.containsKey(k)) {
                    logger.info("Add tenant {}'s Reporting ArchiveProperties overrides", k);
                    tenantConfigurationMap.get(k).getApplicationTenantConfiguration().setArchiveProperties(a);
                } // todo tbd on handling if service's archiveProperties is not in the overall tenant list
            });
        }
        Optional<AggregateReportingPropertiesRoot> aggregateProperties = defaultTenantPropertiesService.getAggregateReportingPropertiesRoot(responseList);
        if (aggregateProperties.isPresent()) {
            // get Default aggregateProperties
            Optional<AggregateReportingPropertiesTenant> aggregatePropertiesTenant = defaultTenantPropertiesService.getAggregateProperties(aggregateProperties);
            if (aggregatePropertiesTenant.isPresent()) {
                logger.info("Add Default AggregateReportingProperties");
                applicationTenantConfiguration.setAggregateReportingPropertiesTenant(aggregatePropertiesTenant.get());
            }
            // Add each AggregateReportingPropertiesTenant overrides
            Map<String, AggregateReportingPropertiesTenant> aggregateTenants = aggregateProperties.get().getTenants();
            aggregateTenants.forEach((k,a) -> {
                if(tenantConfigurationMap.containsKey(k)) {
                    logger.info("Add tenant {}'s Reporting AggregateReportingProperties overrides", k);
                    tenantConfigurationMap.get(k).getApplicationTenantConfiguration().setAggregateReportingPropertiesTenant(a);
                } // todo tbd on handling if service's setAggregateReportingPropertiesTenant is not in the overall tenant list
            });
        }

        applicationTenantConfiguration.setDataSources(defaultDataSources);
        allApplicationTenantConfiguration.setApplicationTenantConfiguration(applicationTenantConfiguration);
        Set<TenantConfiguration> tenantConfigurationSet = new HashSet<>(tenantConfigurationMap.values());;
        allApplicationTenantConfiguration.setTenants(tenantConfigurationSet);
        return allApplicationTenantConfiguration;
    }

    @Override
    public TenantConfiguration createTenant(TenantConfiguration tenantConfiguration) {
        logger.debug("Creating tenant with Id {}", tenantConfiguration.getTenant().getKey());
        validateNewTenant(tenantConfiguration);
        return inMemoryTenantRepository.add(tenantConfiguration);
    }

    @Override
    public void deleteTenant(final String tenantKey) {
        // todo - TBD use a soft or (inactive) remove for tenant
        logger.debug("Removing tenant {}", tenantKey);
        inMemoryTenantRepository.delete(tenantKey);
    }

    @Override
    public TenantConfiguration updateTenant(TenantConfiguration tenantConfiguration) {
        logger.debug("Updating tenant with Id {}", tenantConfiguration.getTenant().getKey());

        //should only overwrite the tenantOverride properties in each service in the tenantConfiguration
        validateTenantExists(tenantConfiguration);
        // Todo Update appropriate yml files
        return inMemoryTenantRepository.update(tenantConfiguration);
    }

    /**
     * @return the current TenantKey - and if null the mock tenant for now.
     */
    private String getCurrentTenantKey() {
        // todo replace else with something else
        return reportingTenantIdResolver.getTenantId().orElse(TenantConfigurationStubs.getTenantNV().getKey());
    }
    /**
     * Validates the tenant does not exist
     * @param tenantConfiguration the tenant to validate does not exist
     */
    private void validateNewTenant(final TenantConfiguration tenantConfiguration) {

        // see if tenant key is in app settings or in memory map
        // TODO uncomment out once the tenant properties are beging actively updated
        //if(isTenantFound(tenantConfiguration.getTenant().getKey()) ||
        if( inMemoryTenantRepository.tenantExists(tenantConfiguration.getTenant().getKey())) {
            String errorMsg = "Tenant: " + tenantConfiguration.getTenant().getName() +
                    " key: " + tenantConfiguration.getTenant().getKey() + " exists already. Please update existing tenant, or add another tenant key.";
            logger.error(errorMsg);
            throw new IllegalArgumentException(errorMsg);
        }
    }

    /**
     * Validates the tenant is in the current memory map and in the tenantProperties
     * must exist in both - tbd what to do if not
     * @param tenantConfiguration tenant to valid exists
     */
    private void validateTenantExists(TenantConfiguration tenantConfiguration){

        // make sure tenant key is in app settings and in tenant storage
        // TODO uncomment out once the tenant properties are beging actively updated
        //if(!isTenantFound(tenantConfiguration.getTenant().getKey()) ||
        if( !inMemoryTenantRepository.tenantExists(tenantConfiguration.getTenant().getKey())) {
            String errorMsg = "Tenant: " + tenantConfiguration.getTenant().getName() +
                   " key: " + tenantConfiguration.getTenant().getKey() + " not found.";
            logger.error(errorMsg);
            throw new NoSuchElementException(errorMsg);
       }
    }

    /**
     * @param key the key of the tenant to find
     * @return true if the key exists in the tenantProperty tenant list.
     */
    private boolean isTenantFound(final String key) {
        if (tenantProperties != null) {
            //  TODO undo once tenantProperties in place
            return tenantProperties.getTenants().containsKey(key);
        }
        return false;
    }

}
