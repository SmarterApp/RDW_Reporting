package org.opentestsystem.rdw.admin.service.impl;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.opentestsystem.rdw.admin.model.TenantConfiguration;
import org.opentestsystem.rdw.admin.multitenant.DataSet;
import org.opentestsystem.rdw.admin.multitenant.SandboxDataSets;
import org.opentestsystem.rdw.admin.multitenant.TenantType;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatusService;
import org.opentestsystem.rdw.admin.service.TenantConfigurationViewService;
import org.opentestsystem.rdw.admin.service.TenantService;
import org.opentestsystem.rdw.admin.service.TenantValidationService;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.multitenant.TenantProperties;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Service to manage tenant configurations.
 * //todo update application properties yml files
 */
@Service
public class DefaultTenantService implements TenantService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultTenantService.class);

    private TenantProperties tenantProperties;
    private TenantConfigurationViewService tenantConfigurationViewService;
    private TenantAdministrationStatusService tenantAdministrationStatusService;
    private SandboxDataSets sandboxDatasets;
    private TenantValidationService tenantValidationService;

    @Autowired
    DefaultTenantService(TenantProperties tenantProperties,
                         TenantConfigurationViewService tenantConfigurationViewService,
                         TenantAdministrationStatusService tenantAdministrationStatusService,
                         SandboxDataSets sandboxDatasets,
                         TenantValidationService tenantValidationService) {
        this.tenantProperties = tenantProperties;
        this.tenantConfigurationViewService = tenantConfigurationViewService;
        this.tenantAdministrationStatusService = tenantAdministrationStatusService;
        this.sandboxDatasets = sandboxDatasets;
        this.tenantValidationService = tenantValidationService;
    }

    @Override
    public Set<TenantConfiguration> getAll(TenantType tenantType) {
        return ImmutableSet
                .copyOf(getTenantConfigurations(tenantType).values());
    }

    @Override
    public TenantConfiguration createTenant(TenantConfiguration tenantConfiguration) {
        logger.debug("Creating a new tenant with key {}", tenantConfiguration.getTenant().getKey());
        tenantValidationService.tenantCreationValidation(tenantConfiguration);
        // TODO call service to start the tenantCreations
        // do not return tenantCfg to UI
        //return tenantConfigurationRepository.add(tenantConfiguration);
        //TODO: Implement
        logger.error("Not yet implemented");
        return null;
    }

    @Override
    public void deleteTenant(final String tenantKey) {
        logger.debug("Removing tenant {}", tenantKey);
        //TODO: validate only for sandboxes
        //TODO: Implement
        logger.error("not yet implemented");
    }

    @Override
    public TenantConfiguration updateTenant(TenantConfiguration tenantConfiguration) {
        logger.debug("Updating tenant {}", tenantConfiguration.getTenant().getKey());
        tenantValidationService.sandboxUpdateValidation(tenantConfiguration);
        logger.error("not yet implemented");
        //TODO: Implement
        return null;
    }

    @Override
    public List<DataSet> getSandboxDataSets() {
        return sandboxDatasets == null ? ImmutableList.of() : ImmutableList.copyOf(sandboxDatasets.getSandboxDatasets());
    }

    @Override
    public TenantConfiguration getTenantDefaults() {
        tenantConfigurationViewService.servicesPropertiesRefresh();
        //return tenantConfigurationViewService.getDefaultApplicationTenantConfiguration();
        return null;
    }

    @Override
    public TenantConfiguration getParentTenantDefaults(String key) {
        //TODO: Implement
        return null;
    }

    /**
     * If active tenantKey is found in the tenantAdministrationStatusService then this needs to remove that endtry
     *
     * @return a map of TenantConfigurations created from the tenantProperties & tenantAdministrationStatusService
     */
    @VisibleForTesting
    Map<String, TenantConfiguration> getTenantConfigurations(final TenantType tenantType) {
        Stream<Map.Entry<String, TenantConfiguration>> combined =
                Stream.concat(fetchActiveTenantConfigurations(tenantType).entrySet().stream(),
                        fetchInProcessTenantConfigurations(tenantType).entrySet().stream());

        return combined.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    //TODO: extract out to "TenantConfigurationReader":
    @VisibleForTesting
    Map<String, TenantConfiguration> fetchActiveTenantConfigurations(final TenantType tenantType) {
        Map<String, Tenant> tenantMap = filterTenantsByType(tenantType);

        Map<String, TenantConfiguration> activeTenantConfigurations = tenantMap
                .entrySet()
                .stream()
                .map(entry -> {
                    String key = entry.getKey();
                    Tenant tenant = entry.getValue();
                    TenantConfiguration tenantConfiguration = tenantConfigurationViewService.getTenantConfiguration(key);
                    tenantConfiguration.setTenant(tenant);
                    //TODO: merge this functionality up
                    TenantConfiguration applicationTenantConfiguration = tenantConfigurationViewService.getTenantConfiguration(key);
                    tenantConfiguration.setAggregateReportingProperties(applicationTenantConfiguration.getAggregateReportingProperties());
                    tenantConfiguration.setReporting(applicationTenantConfiguration.getReporting());
                    //TODO: NEED Localization API Call HERE
                    //tenantConfiguration.setLocalization();
                    if (tenant.isSandbox()) {
                        tenantConfiguration.setParentTenantKey(parentTenantKey(tenant.getKey()));
                        //TODO: leaving tenantConfiguration.sandboxDatasets empty, don't think we need it verify in UI
                    } else {
                        tenantConfiguration.setDataSources(applicationTenantConfiguration.getDataSources());
                        tenantConfiguration.setArchiveProperties(applicationTenantConfiguration.getArchiveProperties());
                    }
                    return ImmutablePair.of(key, tenantConfiguration);
                })
                .collect(Collectors.toMap(Pair::getLeft, Pair::getRight));

        return activeTenantConfigurations;
    }

    //TODO: extract out to "TenantConfigurationReader":
    @VisibleForTesting
    Map<String, TenantConfiguration> fetchInProcessTenantConfigurations(final TenantType tenantType) {
        final Map<String, Tenant> currentSandboxTenants = filterTenantsByType(tenantType);

        //snapshot of tenant status service state
        final ImmutableMap<String, Pair<TenantAdministrationStatus, TenantConfiguration>> currentAllTenantStatus =
                tenantAdministrationStatusService
                        .allTenantStatusAsMap();

        //gather tenant tenant status currently in the status service
        final Map<String, TenantAdministrationStatus> currentSandboxTenantStatus = currentAllTenantStatus
                .entrySet()
                .stream()
                .filter(entry -> entry.getValue().getRight().getTenant().isSandbox() == (tenantType == TenantType.SANDBOX))
                .collect(Collectors.toMap(Map.Entry::getKey,
                        e -> e.getValue().getLeft()));

        //set of keys that have a status and also exist in the current set of tenants
        final Set<String> statusStaleKeysWithExistingTenant = currentSandboxTenantStatus
                .keySet()
                .stream()
                .filter(currentSandboxTenants::containsKey)
                .collect(Collectors.toSet());

        //side effect: clean up the status for tenant tenants that are stale
        statusStaleKeysWithExistingTenant.forEach(k -> tenantAdministrationStatusService.remove(k));

        //tenant status with stale tenants removed
        final Map<String, TenantAdministrationStatus> activeCurrentSandboxTenantStatus = currentSandboxTenantStatus
                .entrySet()
                .stream()
                .filter(entry -> !statusStaleKeysWithExistingTenant.contains(entry.getKey()))
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));

        //construct result
        final Map<String, TenantConfiguration> inProcessTenantConfigurations = activeCurrentSandboxTenantStatus.entrySet()
                .stream()
                .map(entry -> {
                    String key = entry.getKey();
                    TenantAdministrationStatus status = entry.getValue();
                    TenantConfiguration tenantConfiguration = currentAllTenantStatus.get(key).getRight();
                    tenantConfiguration.setAdministrationStatus(status);
                    return ImmutablePair.of(key, tenantConfiguration);
                })
                .collect(Collectors.toMap(Pair::getLeft, Pair::getRight));

        return inProcessTenantConfigurations;
    }

    @VisibleForTesting
    Map<String, Tenant> filterTenantsByType(TenantType tenantType) {
        return tenantProperties
                .getTenants()
                .entrySet()
                .stream()
                .filter(entry -> entry.getValue().isSandbox() == (tenantType == TenantType.SANDBOX))
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    @VisibleForTesting
    String parentTenantKey(final String tenantKey) {
        final String sandboxPattern = "_S";
        if (tenantKey.contains(sandboxPattern)) {
            return tenantKey.substring(0, tenantKey.indexOf(sandboxPattern));
        } else {
            return null;
        }
    }
}
