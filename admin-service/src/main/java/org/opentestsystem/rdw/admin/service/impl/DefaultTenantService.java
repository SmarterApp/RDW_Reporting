package org.opentestsystem.rdw.admin.service.impl;

import com.google.common.collect.ImmutableSet;
import org.apache.commons.lang3.tuple.Pair;
import org.opentestsystem.rdw.admin.model.AllApplicationTenantConfiguration;
import org.opentestsystem.rdw.admin.model.ApplicationTenantConfiguration;
import org.opentestsystem.rdw.admin.model.TenantConfiguration;
import org.opentestsystem.rdw.admin.model.TenantConfigurationStubs;
import org.opentestsystem.rdw.admin.multitenant.DataSet;
import org.opentestsystem.rdw.admin.multitenant.SandboxDataSets;
import org.opentestsystem.rdw.admin.multitenant.TenantAdministrationStatus;
import org.opentestsystem.rdw.admin.multitenant.TenantAdministrationStatusService;
import org.opentestsystem.rdw.admin.repository.TenantConfigurationRepository;
import org.opentestsystem.rdw.admin.service.TenantConfigPropsService;
import org.opentestsystem.rdw.admin.service.TenantService;
import org.opentestsystem.rdw.admin.service.TenantValidationService;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.multitenant.TenantProperties;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsTenant;
import org.opentestsystem.rdw.reporting.common.multitenant.ReportingTenantIdResolver;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Service to manage tenant configurations.
 * //todo update application properties yml files
 */
@Service
public class DefaultTenantService implements TenantService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultTenantService.class);

    private TenantProperties tenantProperties;
    private TenantConfigurationRepository tenantConfigurationRepository;
    private ReportingTenantIdResolver reportingTenantIdResolver;
    private TenantConfigPropsService tenantConfigPropsService;
    private TenantAdministrationStatusService tenantAdministrationStatusService;
    private SandboxDataSets sandboxDatasets;
    private final TenantValidationService tenantValidationService;

    @Autowired
    DefaultTenantService(TenantProperties tenantProperties,
                         TenantConfigurationRepository tenantConfigurationRepository,
                         ReportingTenantIdResolver reportingTenantIdResolver,
                         TenantConfigPropsService tenantConfigPropsService,
                         TenantAdministrationStatusService tenantAdministrationStatusService,
                         SandboxDataSets sandboxDatasets,
                         TenantValidationService tenantValidationService) {
        this.tenantProperties = tenantProperties;
        this.tenantConfigurationRepository = tenantConfigurationRepository;
        this.reportingTenantIdResolver = reportingTenantIdResolver;
        this.tenantConfigPropsService = tenantConfigPropsService;
        this.tenantAdministrationStatusService = tenantAdministrationStatusService;
        this.sandboxDatasets = sandboxDatasets;
        this.tenantValidationService = tenantValidationService;
    }

    @Override
    public AllApplicationTenantConfiguration getAll(TenantType tenantType) {
        Map<String, TenantConfiguration> tenantConfigurationMap = getTenantConfigurationFromTenantProperties();
        logger.info("TenantCfg GetAll, CurrentTenant key is {} and current TenantCfgMap has a count of {}",
                getCurrentTenantKey(), tenantConfigurationMap.size());

        AllApplicationTenantConfiguration allApplicationTenantConfiguration = getAllApplicationTenantConfiguration(tenantConfigurationMap);
        updateInMemoryTenantConfigurations(tenantConfigurationMap);

        allApplicationTenantConfiguration.setTenants(tenantConfigurationRepository.getAll());
        return allApplicationTenantConfiguration;
    }

    /**
     * @param tenantConfigurationMap currently configured tenants
     * @return currently configured  default properties and the tenantConfiguration data from actuator endpoints
     */
    private AllApplicationTenantConfiguration getAllApplicationTenantConfiguration(Map<String, TenantConfiguration> tenantConfigurationMap) {
        AllApplicationTenantConfiguration allApplicationTenantConfiguration = new AllApplicationTenantConfiguration();
        tenantConfigPropsService.servicesPropertiesRefresh();
        ApplicationTenantConfiguration defaultApplicationTenantConfiguration = tenantConfigPropsService.getDefaultApplicationTenantConfiguration();

        tenantConfigurationMap.forEach((k, t) -> {
            logger.info("Add TenantConfiguration {}'s overrides", k);
            t.setApplicationTenantConfiguration(tenantConfigPropsService.getTenantAppConfiguration(k));
            // where localization goes
        });

        allApplicationTenantConfiguration.setApplicationTenantConfiguration(defaultApplicationTenantConfiguration);
        allApplicationTenantConfiguration.setTenants(ImmutableSet.copyOf(tenantConfigurationMap.values()));
        return allApplicationTenantConfiguration;
    }

    /**
     * Used to populate the inMemoryMap
     *
     * @param tenantConfigurationMap the tenantMap to add
     */
    private void updateInMemoryTenantConfigurations(final Map<String, TenantConfiguration> tenantConfigurationMap) {
        // add tenantConfiguration to memory if nothing is there - keep until git Write is done
        if (tenantConfigurationRepository.getAll().isEmpty()) {
            tenantConfigurationMap.forEach((key, t) -> tenantConfigurationRepository.add(t));
        } // if not empty expecting existing ImMemory is in sync with any user changes and yml file updates.
    }

    @Override
    public TenantConfiguration createTenant(TenantConfiguration tenantConfiguration) {
        logger.debug("Creating a new tenant with key {}", tenantConfiguration.getTenant().getKey());
        tenantValidationService.tenantCreationValidation(tenantConfiguration);
        // TODO call service to start the tenantCreations
        // do not return tenantCfg to UI
        return tenantConfigurationRepository.add(tenantConfiguration);
    }

    @Override
    public void deleteTenant(final String tenantKey) {
        // todo - TBD use a soft or (inactive) remove for tenant, for now removing from inmemoryMap
        logger.debug("Removing tenant {}", tenantKey);
        tenantConfigurationRepository.delete(tenantKey);
    }

    @Override
    public TenantConfiguration updateTenant(TenantConfiguration tenantConfiguration) {
        logger.debug("Updating tenant {}", tenantConfiguration.getTenant().getKey());
        tenantValidationService.tenantUpdateValidation(tenantConfiguration);
        // Todo Update appropriate yml files
        return tenantConfigurationRepository.update(tenantConfiguration);
    }

    @Override
    public List<DataSet> getSandboxDataSets() {
        return sandboxDatasets.getSandboxDatasets();
    }


    /**
     * @return the current Tenant Key - and if null the mock tenant for now.
     */
    private String getCurrentTenantKey() {
        // todo replace 'else' with something else
        return reportingTenantIdResolver.getTenantId().orElse(TenantConfigurationStubs.getTenantCA().getKey());
    }

    /**
     * If active tenantKey is found in the tenantAdministrationStatusService then this needs to remove that endtry
     *
     * @return a map of TenantConfigurations created from the tenantProperties & tenantAdministrationStatusService
     */
    private Map<String, TenantConfiguration> getTenantConfigurationFromTenantProperties() {
        Map<String, TenantConfiguration> tenantConfigurationMap = new HashMap<>();
        // need the list of tenants being created
        Map<String, TenantAdministrationStatus> createTenantMap = tenantAdministrationStatusService.allTenantStatusAsMap()
                .entrySet()
                .stream()
                .collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue().getLeft()));

        // need a tenantConfiguration for each tenant
        Map<String, Tenant> tenants = tenantProperties.getTenants();
        tenants.forEach((key, t) -> {

            // only want tenants`
            if (!t.isSandbox()) {
                TenantConfiguration tenantConfiguration = new TenantConfiguration();

                Tenant tenant = new Tenant();
                tenant.setKey(t.getKey());
                tenant.setId(t.getId());
                tenant.setDescription(t.getDescription());
                tenant.setName(t.getName());
                tenant.setCreated(t.getCreated());
                tenantConfiguration.setTenant(tenant);

                // see the any of the currents exist in the createTenantMap
                if (createTenantMap.containsKey(tenant.getKey())) {
                    // if it exists need to remove that tenant from the statusService
                    tenantAdministrationStatusService.remove(tenant.getKey());
                    createTenantMap.remove(tenant.getKey());
                }

                // each tenant has it's own applicationTenantConfiguration
                ApplicationTenantConfiguration applicationTenantConfiguration = getNewApplicationTenantConfiguration();
                tenantConfiguration.setApplicationTenantConfiguration(applicationTenantConfiguration);
                // add to return list
                tenantConfigurationMap.put(key, tenantConfiguration);
            }
        });

        // now we can add any tenants found in the statusMap into the returned tenantConfigurationMap
        createTenantMap.forEach((k, v) -> {
            Optional<Pair<TenantAdministrationStatus, TenantConfiguration>> tenantStatusMap = tenantAdministrationStatusService.findStatus(k);
            if (tenantStatusMap.isPresent()) {
                TenantConfiguration wipTenant = tenantStatusMap.get().getRight();
                if (!wipTenant.getTenant().isSandbox()) {
                    logger.debug("Tenant's create from the status service is {} and if its a sandbox = {}",
                            wipTenant.getTenant().getCreated(), wipTenant.getTenant().isSandbox());
                    tenantConfigurationMap.put(k, wipTenant);
                } // skip sandboxes in create status
            }
        });
        return tenantConfigurationMap;
    }

    /**
     * @return a new ApplicationTenantConfiguration containing an empty map for DataSources
     */
    private ApplicationTenantConfiguration getNewApplicationTenantConfiguration() {
        // each tenant has it's own applicationTenantConfiguration create the initial empty map of dataSources
        ApplicationTenantConfiguration applicationTenantConfiguration = new ApplicationTenantConfiguration();
        Map<String, DataSourceElementsTenant> tenantDataSources = new HashMap<>();
        applicationTenantConfiguration.setDataSources(tenantDataSources);
        return applicationTenantConfiguration;
    }

}
