package org.opentestsystem.rdw.admin.multitenant.service.impl;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import org.apache.commons.lang3.RandomStringUtils;
import org.opentestsystem.rdw.admin.model.TenantMetric;
import org.opentestsystem.rdw.admin.multitenant.DataSet;
import org.opentestsystem.rdw.admin.multitenant.SandboxDataSets;
import org.opentestsystem.rdw.admin.multitenant.TenantType;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationRequestHandler;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatusService;
import org.opentestsystem.rdw.admin.multitenant.model.TenantConfiguration;
import org.opentestsystem.rdw.admin.multitenant.service.TenantConfigurationViewService;
import org.opentestsystem.rdw.admin.multitenant.service.TenantService;
import org.opentestsystem.rdw.admin.multitenant.service.TenantValidationService;
import org.opentestsystem.rdw.admin.repository.MetricsRepository;
import org.opentestsystem.rdw.archive.ArchivePropertiesTenant;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.multitenant.TenantContextHolder;
import org.opentestsystem.rdw.multitenant.TenantProperties;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsTenant;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceUrlParts;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingPropertiesTenant;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemPropertiesImpl;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.regex.Matcher;

import static org.opentestsystem.rdw.admin.multitenant.service.impl.TenantKeys.SandboxKeyPattern;

/**
 * Service to manage tenant configurations.
 * //todo update application properties yml files
 */
@Service
public class DefaultTenantService implements TenantService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultTenantService.class);

    private final SandboxDataSets sandboxDatasets;
    private final TenantConfigurationViewService tenantConfigurationViewService;
    private final TenantValidationService tenantValidationService;
    private final TenantAdministrationRequestHandler tenantAdministrationRequestHandler;
    private final TenantAdministrationStatusService tenantAdministrationStatusService;
    private final MetricsRepository metricsRepository;
    private final TenantProperties tenantProperties;

    @Autowired
    DefaultTenantService(
            final SandboxDataSets sandboxDatasets,
            final TenantConfigurationViewService tenantConfigurationViewService,
            final TenantValidationService tenantValidationService,
            final TenantAdministrationRequestHandler tenantAdministrationRequestHandler,
            final TenantAdministrationStatusService tenantAdministrationStatusService,
            final MetricsRepository metricsRepository, TenantProperties tenantProperties) {
        this.tenantConfigurationViewService = tenantConfigurationViewService;
        this.sandboxDatasets = sandboxDatasets;
        this.tenantValidationService = tenantValidationService;
        this.tenantAdministrationRequestHandler = tenantAdministrationRequestHandler;
        this.tenantAdministrationStatusService = tenantAdministrationStatusService;
        this.metricsRepository = metricsRepository;
        this.tenantProperties = tenantProperties;
    }

    @Override
    public Set<TenantConfiguration> getAll(final TenantType tenantType) {
        return ImmutableSet.copyOf(tenantConfigurationViewService
                .allTenantConfigurations(tenantType).values());
    }

    @Override
    public boolean exists(final String key) {
        return tenantConfigurationViewService.exists(key);
    }

    @Override
    public boolean existsId(final String id) {
        return tenantConfigurationViewService.existsId(id);
    }

    @Override
    public Optional<TenantConfiguration> findActiveTenantConfigurationByKey(final String key) {
        return tenantConfigurationViewService.findActiveTenantConfiguration(key);
    }

    @Override
    public void createTenant(final String username, final TenantConfiguration tenantConfiguration) {
        final String tenantKey = tenantConfiguration.getTenant().getKey();
        if (tenantConfiguration.getTenant().isSandbox()) {
            logger.debug("Creating sandbox for tenant ({})", tenantKey);
            tenantValidationService.sandboxCreationValidation(tenantConfiguration);
            final TenantConfiguration sandbox = sandboxConfigurationForCreate(username, tenantConfiguration);
            // sandboxes have keys generated
            logger.debug("Creating sandbox ({})", sandbox.getTenant().getKey());
            tenantAdministrationRequestHandler.createSandbox(sandbox);
        } else {
            // tenant's are given user defined key/id
            logger.debug("Creating tenant ({})", tenantKey);
            tenantValidationService.tenantCreationValidation(tenantConfiguration);
            final TenantConfiguration tenant = tenantConfigurationForCreate(username, tenantConfiguration);
            tenantAdministrationRequestHandler.createTenant(tenant);
        }
    }

    @Override
    public void updateTenant(final String username, final TenantConfiguration tenantConfiguration) {
        logger.debug("Updating tenant ({})", tenantConfiguration.getTenant().getKey());
        if (tenantConfiguration.getTenant().isSandbox()) {
            tenantValidationService.sandboxUpdateValidation(tenantConfiguration);
            tenantAdministrationRequestHandler.updateSandbox(
                    tenantSandboxConfigurationForUpdate(username, tenantConfiguration)
            );
        } else {
            tenantValidationService.tenantUpdateValidation(tenantConfiguration);
            tenantAdministrationRequestHandler.updateTenant(
                    tenantSandboxConfigurationForUpdate(username, tenantConfiguration)
            );
        }
    }

    @Override
    public void deleteTenant(final String tenantKey) {
        final TenantConfiguration tenantConfiguration = tenantConfigurationViewService
                .findActiveTenantConfiguration(tenantKey)
                .orElseThrow(() -> new IllegalArgumentException(String.format(
                        "Tenant key \"%s\" not found",
                        tenantKey
                )));

        if (tenantConfiguration.getTenant().isSandbox()) {
            tenantAdministrationRequestHandler.deleteSandbox(tenantConfiguration);
        } else {
            tenantAdministrationRequestHandler.deleteTenant(tenantConfiguration);
        }
    }

    @Override
    public List<DataSet> getSandboxDataSets() {
        return Optional.ofNullable(sandboxDatasets)
                .flatMap(sandboxDataSets -> Optional.ofNullable(sandboxDataSets.getSandboxDatasets()))
                .map(ImmutableList::copyOf)
                .orElse(ImmutableList.of());
    }

    @Override
    public TenantConfiguration getTenantDefaults() {
        return tenantConfigurationViewService.defaultTenantConfiguration();
    }

    @Override
    public void updateTenantStatus(final String tenantKey, final TenantAdministrationStatus status) {
        tenantAdministrationStatusService.updateStatus(tenantKey, status);
    }

    @Override
    public void deleteTenantStatus(final String tenantKey) {
        tenantAdministrationStatusService.remove(tenantKey);
    }

    @Override
    public List<TenantMetric> findAllMetrics(String tenantKey) {
        List<TenantMetric> result = new ArrayList<>();
        if (tenantProperties.getTenants().containsKey(tenantKey)) {
            Tenant tenant = tenantProperties.getTenants().get(tenantKey);
            try {
                TenantContextHolder.setTenantId(tenant.getId());
                result = metricsRepository.findAllMetrics();
            } finally {
                TenantContextHolder.clear();
            }
        }
        return result;
    }

    @VisibleForTesting
    TenantConfiguration sandboxConfigurationForCreate(final String username, final TenantConfiguration requestTenantConfiguration) {

        final Tenant requestTenant = requestTenantConfiguration.getTenant();
        final String requestDataset = requestTenant.getSandboxDataset();

        final ReportingSystemPropertiesImpl requestReporting = requestTenantConfiguration.getReporting();
        final AggregateReportingPropertiesTenant requestAggregate = requestTenantConfiguration.getAggregateReportingProperties();
        final String parentTenantKey = requestTenantConfiguration.getParentTenantKey();

        final String sandboxKey = nextSandboxKey(requestTenantConfiguration.getParentTenantKey());
        final String sandboxDbPassword = createRandomPassword();
        final Map<String, DataSourceElementsTenant> datasources = generateDataSourceElementsMap(sandboxKey, sandboxDbPassword);
        final ArchivePropertiesTenant archivePropertiesTenant = new ArchivePropertiesTenant();
        archivePropertiesTenant.setPathPrefix(sandboxKey.toLowerCase());
        if (isLocalizationSupplied(requestTenantConfiguration.getLocalization())) {
            requestReporting.setTranslationLocation(generateTranslationLocation(sandboxKey));
        }

        final String localization = requestTenantConfiguration.getLocalization();

        final String created = DateTimeFormatter.ISO_INSTANT.format(Instant.now());

        final Tenant tenant = Tenant.builder()
                .key(sandboxKey)
                .id(sandboxKey)
                .sandbox(true)
                .name(requestTenant.getName())
                .description(requestTenant.getDescription())
                .sandboxDataset(requestDataset)
                .created(created)
                .updated(created)
                .createdBy(username)
                .updatedBy(username)
                .build();

        return TenantConfiguration.builder()
                .tenant(tenant)
                .reporting(requestReporting)
                .aggregateReportingProperties(requestAggregate)
                .dataSources(datasources)
                .parentTenantKey(parentTenantKey)
                .archiveProperties(archivePropertiesTenant)
                .localizaton(localization)
                .build();
    }

    @VisibleForTesting
    TenantConfiguration tenantConfigurationForCreate(final String username, final TenantConfiguration configuration) {

        // Not using immutable here
        if (isLocalizationSupplied(configuration.getLocalization())) {
            configuration.getReporting().setTranslationLocation(
                    generateTranslationLocation(configuration.getTenant().getKey())
            );
        }

        final String created = DateTimeFormatter.ISO_INSTANT.format(Instant.now());

        return configuration.copy()
                .tenant(
                        configuration.getTenant().copy()
                                .created(created)
                                .updated(created)
                                .createdBy(username)
                                .updatedBy(username)
                                .build()
                )
                .build();
    }

    @VisibleForTesting
    TenantConfiguration tenantSandboxConfigurationForUpdate(final String username, final TenantConfiguration requestTenantConfiguration) {
        final String tenantKey = requestTenantConfiguration.getTenant().getKey();
        //should not throw if this is called after validation
        final TenantConfiguration existingTenantConfiguration = tenantConfigurationViewService
                .findActiveTenantConfiguration(tenantKey)
                .orElseThrow(IllegalStateException::new);

        //Only updatable fields for tenant are name and description
        final Tenant existingTenant = existingTenantConfiguration.getTenant();

        final String updated = DateTimeFormatter.ISO_INSTANT.format(Instant.now());

        final Tenant updateTenant = existingTenant.copy()
                .name(requestTenantConfiguration.getTenant().getName())
                .description(requestTenantConfiguration.getTenant().getDescription())
                .updated(updated)
                .updatedBy(username)
                .build();

        ReportingSystemPropertiesImpl reporting = requestTenantConfiguration.getReporting();
        if (isLocalizationSupplied(requestTenantConfiguration.getLocalization())) {
            //reporting can be null if no other reporting setting submitted
            if (reporting == null) {
                reporting = new ReportingSystemPropertiesImpl();
            }
            final String translationLocation = generateTranslationLocation(tenantKey);
            reporting.setTranslationLocation(translationLocation);
        }

        //only part of tenant, reporting, aggregate, and localization can be updated
        return TenantConfiguration
                .builder()
                .copy(existingTenantConfiguration)
                .tenant(updateTenant)
                .reporting(reporting)
                .aggregateReportingProperties(requestTenantConfiguration.getAggregateReportingProperties())
                .localizaton(requestTenantConfiguration.getLocalization())
                .validation(requestTenantConfiguration.getValidation())
                .artClient(requestTenantConfiguration.getArtClient())
                .importServiceClient(requestTenantConfiguration.getImportServiceClient())
                .sendReconciliationReport(requestTenantConfiguration.getSendReconciliationReport())
                .build();
    }

    private boolean isLocalizationSupplied(final String localization) {
        return localization != null && !localization.isEmpty() && !localization.equals("{}");
    }

    private String generateTranslationLocation(final String tenantKey) {
        return "binary-${spring.cloud.config.uri}/*/*/master/tenant-" + tenantKey + "/";
    }

    @VisibleForTesting
    String nextSandboxKey(final String parentTenantKey) {
        final int maxConfigured = tenantConfigurationViewService
                .allTenantConfigurations(TenantType.SANDBOX)
                .keySet()
                .stream()
                // only sandboxes of this tenant
                .filter(key -> key.contains(parentTenantKey + "_S"))
                // sandboxes only
                .filter(key -> SandboxKeyPattern.matcher(key).matches())
                // get the sandbox number
                .map(key -> {
                    final Matcher matcher = SandboxKeyPattern.matcher(key);
                    matcher.find();
                    return matcher.group(2);
                })
                .map(Integer::parseInt)
                .max(Integer::compare)
                .orElse(0);

        return parentTenantKey + "_S" + String.format("%03d", maxConfigured + 1);
    }

    @VisibleForTesting
    Map<String, DataSourceElementsTenant> generateDataSourceElementsMap(String sandboxKey, String databasePassword) {
        String dbUsername = sandboxKey.replaceAll("_", "").toLowerCase();
        String dbPostfix = "_" + sandboxKey.toLowerCase();

        //TODO: Externalize datasource keys
        return new ImmutableMap.Builder<String, DataSourceElementsTenant>()
                .put("olap_ro", createDataSourceElements(dbUsername, databasePassword, "reporting" + dbPostfix, null))
                .put("olap_rw", createDataSourceElements(dbUsername, databasePassword, "reporting" + dbPostfix, null))
                .put("reporting_ro", createDataSourceElements(dbUsername, databasePassword, null, "reporting" + dbPostfix))
                .put("reporting_rw", createDataSourceElements(dbUsername, databasePassword, null, "reporting" + dbPostfix))
                .put("warehouse_ro", createDataSourceElements(dbUsername, databasePassword, null, "warehouse" + dbPostfix))
                .put("warehouse_rw", createDataSourceElements(dbUsername, databasePassword, null, "warehouse" + dbPostfix))
                .put("migrate_rw", createDataSourceElements(dbUsername, databasePassword, null, "migrate_olap" + dbPostfix))
                .build();
    }

    private DataSourceElementsTenant createDataSourceElements(String username,
                                                              String password,
                                                              String schemaSearchPath,
                                                              String databaseName) {
        DataSourceElementsTenant dataSourceElementsTenant = new DataSourceElementsTenant();
        dataSourceElementsTenant.setUsername(username);
        dataSourceElementsTenant.setPassword(password);
        dataSourceElementsTenant.setSchemaSearchPath(schemaSearchPath);
        DataSourceUrlParts dataSourceUrlParts = new DataSourceUrlParts();
        dataSourceUrlParts.setDatabase(databaseName);
        dataSourceElementsTenant.setUrlParts(dataSourceUrlParts);
        return dataSourceElementsTenant;
    }

    private String createRandomPassword() {
        //Match the Redshift requirements
        final String letters = RandomStringUtils.random(1, true, false).toUpperCase() +
                RandomStringUtils.random(5, true, false).toLowerCase();
        final String numbers = RandomStringUtils.random(2, false, true);
        return letters + numbers;
    }

}

