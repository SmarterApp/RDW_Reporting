package org.opentestsystem.rdw.admin.multitenant.service.impl;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import org.apache.commons.lang3.RandomStringUtils;
import org.opentestsystem.rdw.admin.multitenant.DataSet;
import org.opentestsystem.rdw.admin.multitenant.SandboxDataSets;
import org.opentestsystem.rdw.admin.multitenant.TenantType;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationRequestHandler;
import org.opentestsystem.rdw.admin.multitenant.model.TenantConfiguration;
import org.opentestsystem.rdw.admin.multitenant.service.TenantConfigurationViewService;
import org.opentestsystem.rdw.admin.multitenant.service.TenantService;
import org.opentestsystem.rdw.admin.multitenant.service.TenantValidationService;
import org.opentestsystem.rdw.archive.ArchivePropertiesTenant;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsTenant;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceUrlParts;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingPropertiesTenant;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemPropertiesImpl;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;

/**
 * Service to manage tenant configurations.
 * //todo update application properties yml files
 */
@Service
public class DefaultTenantService implements TenantService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultTenantService.class);

    private final TenantConfigurationViewService tenantConfigurationViewService;
    private final SandboxDataSets sandboxDatasets;
    private final TenantValidationService tenantValidationService;
    private final TenantAdministrationRequestHandler tenantAdministrationRequestHandler;

    @Autowired
    DefaultTenantService(final TenantConfigurationViewService tenantConfigurationViewService,
                         final SandboxDataSets sandboxDatasets,
                         final TenantValidationService tenantValidationService,
                         final TenantAdministrationRequestHandler tenantAdministrationRequestHandler) {
        this.tenantConfigurationViewService = tenantConfigurationViewService;
        this.sandboxDatasets = sandboxDatasets;
        this.tenantValidationService = tenantValidationService;
        this.tenantAdministrationRequestHandler = tenantAdministrationRequestHandler;
    }

    @Override
    public Set<TenantConfiguration> getAll(TenantType tenantType) {
        return ImmutableSet.copyOf(tenantConfigurationViewService
                .allTenantConfigurations(tenantType).values());
    }

    @Override
    public TenantConfiguration tenantConfiguration(final String key) {
        return tenantConfigurationViewService.tenantConfiguration(key);
    }

    @Override
    public void createTenant(TenantConfiguration tenantConfiguration) {
        logger.debug("Creating a new tenant with key {}", tenantConfiguration.getTenant().getKey());
        if (tenantConfiguration.getTenant().isSandbox()) {
            TenantConfiguration sandbox = generateSandboxTenantConfigrationForCreate(tenantConfiguration);
            tenantAdministrationRequestHandler.createSandbox(sandbox);
        } else {
            tenantValidationService.tenantCreationValidation(tenantConfiguration);
            tenantAdministrationRequestHandler.createTenant(tenantConfiguration);
        }
    }

    @Override
    public void deleteTenant(final String tenantKey) {
        logger.debug("Removing tenant {}", tenantKey);
        //TODO: validate only for sandboxes
        //TODO: Implement
        logger.error("deleteTenant not yet implemented");
    }

    @Override
    public TenantConfiguration updateTenant(TenantConfiguration tenantConfiguration) {
        logger.debug("Updating tenant {}", tenantConfiguration.getTenant().getKey());
        tenantValidationService.sandboxUpdateValidation(tenantConfiguration);
        logger.error("updateTenant not yet implemented");
        //TODO: Implement
        return null;
    }

    @Override
    public List<DataSet> getSandboxDataSets() {
        return Optional.ofNullable(sandboxDatasets)
                .flatMap(sandboxDataSets -> Optional.ofNullable(sandboxDataSets.getSandboxDatasets()))
                .map(ImmutableList::copyOf)
                .orElse(ImmutableList.of());
    }

    @Override
    public TenantConfiguration getTenantDefaults() {
        return tenantConfigurationViewService.defaultTenantConfiguration();
    }

    @Override
    public TenantConfiguration getParentTenantDefaults(String key) {
        //TODO: Implement
        return null;
    }

    @VisibleForTesting
    public TenantConfiguration generateSandboxTenantConfigrationForCreate(final TenantConfiguration requestTenantConfiguration) {
        tenantValidationService.sandboxCreationValidation(requestTenantConfiguration);

        final Tenant requestTenant = requestTenantConfiguration.getTenant();
        final String requestDataset = requestTenant.getSandboxDataset();
        final ReportingSystemPropertiesImpl requestReporting = requestTenantConfiguration.getReporting();
        final AggregateReportingPropertiesTenant requestAggregate = requestTenantConfiguration.getAggregateReportingProperties();
        final String parentTenantKey = requestTenantConfiguration.getParentTenantKey();

        final String sandboxKey = generateKey(requestTenantConfiguration.getParentTenantKey());
        final String sandboxDbPassword = createRandomPassword();
        final Map<String, DataSourceElementsTenant> datasources = generateDataSourceElementsMap(sandboxKey, sandboxDbPassword);
        final ArchivePropertiesTenant archivePropertiesTenant = new ArchivePropertiesTenant();
        archivePropertiesTenant.setPathPrefix(sandboxKey.toLowerCase());

        final Tenant tenant = Tenant.builder()
                .key(sandboxKey)
                .id(sandboxKey)
                .created(Instant.now())
                .sandbox(true)
                .description(sandboxKey) //TODO Something Better
                .sandboxDataset(requestDataset)
                .build();

        return TenantConfiguration.builder()
                .tenant(tenant)
                .reporting(requestReporting)
                .aggregateReportingProperties(requestAggregate)
                .dataSources(datasources)
                .parentTenantKey(parentTenantKey)
                .archiveProperties(archivePropertiesTenant)
                .build();
    }

    @VisibleForTesting
    String generateKey(final String parentTenantKey) {
        final int maxConfigured = tenantConfigurationViewService
                .allTenantConfigurations(TenantType.SANDBOX)
                .keySet()
                .stream()
                .filter(key -> key.length() > 2)
                .filter(key -> key.contains(parentTenantKey + "_S"))
                .map(key -> key.substring(key.length() - 3))
                .map(Integer::parseInt)
                .max(Integer::compare)
                .orElse(0);

        return parentTenantKey + "_" + "S" + String.format("%03d", maxConfigured + 1);
    }

    @VisibleForTesting
    Map<String, DataSourceElementsTenant> generateDataSourceElementsMap(String sandboxKey, String databasePassword) {
        String dbUsername = sandboxKey.replaceAll("_", "").toLowerCase();
        String dbPostfix = "_" + sandboxKey.toLowerCase();

        //TODO: Externalize datasource keys
        return new ImmutableMap.Builder<String, DataSourceElementsTenant>()
                .put("olap_ro", createDataSourceElements(dbUsername, databasePassword, "reporting" + dbPostfix, null))
                .put("olap_rw", createDataSourceElements(dbUsername, databasePassword, "reporting" + dbPostfix, null))
                .put("reporting_ro", createDataSourceElements(dbUsername, databasePassword, null, "reporting" + dbPostfix))
                .put("reporting_rw", createDataSourceElements(dbUsername, databasePassword, null, "reporting" + dbPostfix))
                .put("warehouse_ro", createDataSourceElements(dbUsername, databasePassword, null, "warehouse" + dbPostfix))
                .put("warehouse_rw", createDataSourceElements(dbUsername, databasePassword, null, "warehouse" + dbPostfix))
                .put("migrate_rw", createDataSourceElements(dbUsername, databasePassword, null, "migrate_olap" + dbPostfix))
                .build();
    }

    private DataSourceElementsTenant createDataSourceElements(String username,
                                                              String password,
                                                              String schemaSearchPath,
                                                              String databaseName) {
        DataSourceElementsTenant dataSourceElementsTenant = new DataSourceElementsTenant();
        dataSourceElementsTenant.setUsername(username);
        dataSourceElementsTenant.setPassword(password);
        dataSourceElementsTenant.setSchemaSearchPath(schemaSearchPath);
        DataSourceUrlParts dataSourceUrlParts = new DataSourceUrlParts();
        dataSourceUrlParts.setDatabase(databaseName);
        dataSourceElementsTenant.setUrlParts(dataSourceUrlParts);
        return dataSourceElementsTenant;
    }

    private String createRandomPassword() {
        //Match the Redshift requirements
        final String letters = RandomStringUtils.random(1, true, false).toUpperCase() +
                RandomStringUtils.random(5, true, false).toLowerCase();
        final String numbers = RandomStringUtils.random(2, false, true);
        return letters + numbers;
    }

}

