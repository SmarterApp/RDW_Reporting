package org.opentestsystem.rdw.admin.multitenant.service.impl;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import org.apache.commons.lang3.RandomStringUtils;
import org.opentestsystem.rdw.admin.multitenant.DataSet;
import org.opentestsystem.rdw.admin.multitenant.SandboxDataSets;
import org.opentestsystem.rdw.admin.multitenant.TenantType;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationRequestHandler;
import org.opentestsystem.rdw.admin.multitenant.model.TenantConfiguration;
import org.opentestsystem.rdw.admin.multitenant.service.TenantConfigurationViewService;
import org.opentestsystem.rdw.admin.multitenant.service.TenantService;
import org.opentestsystem.rdw.admin.multitenant.service.TenantValidationService;
import org.opentestsystem.rdw.archive.ArchivePropertiesTenant;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsTenant;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceUrlParts;
import org.opentestsystem.rdw.multitenant.validation.ExamProcessorValidationPropertiesTenant;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingPropertiesTenant;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemPropertiesImpl;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;

/**
 * Service to manage tenant configurations.
 * //todo update application properties yml files
 */
@Service
public class DefaultTenantService implements TenantService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultTenantService.class);

    private final TenantConfigurationViewService tenantConfigurationViewService;
    private final SandboxDataSets sandboxDatasets;
    private final TenantValidationService tenantValidationService;
    private final TenantAdministrationRequestHandler tenantAdministrationRequestHandler;

    @Autowired
    DefaultTenantService(final TenantConfigurationViewService tenantConfigurationViewService,
                         final SandboxDataSets sandboxDatasets,
                         final TenantValidationService tenantValidationService,
                         final TenantAdministrationRequestHandler tenantAdministrationRequestHandler) {
        this.tenantConfigurationViewService = tenantConfigurationViewService;
        this.sandboxDatasets = sandboxDatasets;
        this.tenantValidationService = tenantValidationService;
        this.tenantAdministrationRequestHandler = tenantAdministrationRequestHandler;
    }

    @Override
    public Set<TenantConfiguration> getAll(final TenantType tenantType) {
        return ImmutableSet.copyOf(tenantConfigurationViewService
                .allTenantConfigurations(tenantType).values());
    }

    @Override
    public boolean exists(final String key) {
        return tenantConfigurationViewService.exists(key);
    }

    @Override
    public Optional<TenantConfiguration> findActiveTenantConfigurationByKey(final String key) {
        return tenantConfigurationViewService.findActiveTenantConfiguration(key);
    }

    @Override
    public void createTenant(final TenantConfiguration tenantConfiguration) {
        if (tenantConfiguration.getTenant().isSandbox()) {
            logger.debug("Creating a new sandbox with key {}", tenantConfiguration.getTenant().getKey());
            TenantConfiguration sandbox = generateSandboxTenantConfigurationForCreate(tenantConfiguration);
            // sandboxes have keys generated
            logger.debug("Creating a new sandbox with key {}", sandbox.getTenant().getKey());
            tenantAdministrationRequestHandler.createSandbox(sandbox);
        } else {
            // tenant's are given user defined key/id
            logger.debug("Creating a new tenant with key {}", tenantConfiguration.getTenant().getKey());
            tenantValidationService.tenantCreationValidation(tenantConfiguration);
            // update the translationLocalization with specific
            if (isLocalizationSupplied(tenantConfiguration.getLocalization())) {
                tenantConfiguration.getReporting().setTranslationLocation(tenantConfiguration.getTenant().getKey());
            }
            tenantAdministrationRequestHandler.createTenant(tenantConfiguration);
        }
    }

    @Override
    public void deleteTenant(final String tenantKey) {
        Optional<TenantConfiguration> tenantConfigurationOptional =
                tenantConfigurationViewService.findActiveTenantConfiguration(tenantKey);
        TenantConfiguration tenantConfiguration = tenantConfigurationOptional.orElseThrow(() -> new IllegalArgumentException("Tenant key not found"));
        if (tenantConfiguration.getTenant().isSandbox()) {
            tenantAdministrationRequestHandler.deleteSandbox(tenantConfiguration);
        } else {
            throw new IllegalArgumentException("Only sandboxes can be deleted");
        }
    }

    @Override
    public void updateTenant(final TenantConfiguration tenantConfiguration) {
        logger.debug("Updating tenant {}", tenantConfiguration.getTenant().getKey());
        final boolean isSandbox = tenantConfiguration.getTenant().isSandbox();
        if (isSandbox) {
            tenantValidationService.sandboxUpdateValidation(tenantConfiguration);
            TenantConfiguration updateTenantConfiguration = generateUpdateTenantConfiguration(tenantConfiguration);
            tenantAdministrationRequestHandler.updateSandbox(updateTenantConfiguration);
        } else {
            tenantValidationService.tenantUpdateValidation(tenantConfiguration);
            TenantConfiguration updateTenantConfiguration = generateUpdateTenantConfiguration(tenantConfiguration);
            tenantAdministrationRequestHandler.updateTenant(updateTenantConfiguration);
        }
    }

    private TenantConfiguration generateUpdateTenantConfiguration(TenantConfiguration requestTenantConfiguration) {
        //should not throw if this is called after validation
        TenantConfiguration existingTenantConfiguration = tenantConfigurationViewService
                .findActiveTenantConfiguration(requestTenantConfiguration.getTenant().getKey())
                .orElseThrow(IllegalStateException::new);

        //Only updatable fields for tenant are name and description
        Tenant existingTenant = existingTenantConfiguration.getTenant();
        Tenant updateTenant = Tenant
                .builder()
                .id(existingTenant.getId())
                .key(existingTenant.getKey())
                .sandbox(existingTenant.isSandbox())
                .created(existingTenant.getCreated())
                .sandboxDataset(existingTenant.getSandboxDataset())
                .name(requestTenantConfiguration.getTenant().getName())
                .description(requestTenantConfiguration.getTenant().getDescription())
                .build();

        ReportingSystemPropertiesImpl reporting = requestTenantConfiguration.getReporting();
        if (isLocalizationSupplied(requestTenantConfiguration.getLocalization())) {
            //reporting can be null if no other reporting setting submitted
            if (reporting == null) {
                reporting = new ReportingSystemPropertiesImpl();
            }
            reporting.setTranslationLocation(generateTenantLocalization(requestTenantConfiguration.getTenant().getKey()));
        }

        //TODO: handle exam-processor validation

        //only part of tenant, reporting, aggregate, and localization can be updated
        TenantConfiguration updateTenantConfiguration = TenantConfiguration
                .builder()
                .copy(existingTenantConfiguration)
                .tenant(updateTenant)
                .reporting(reporting)
                .aggregateReportingProperties(requestTenantConfiguration.getAggregateReportingProperties())
                .localizaton(requestTenantConfiguration.getLocalization())
                .build();

        return updateTenantConfiguration;
    }

    @Override
    public List<DataSet> getSandboxDataSets() {
        return Optional.ofNullable(sandboxDatasets)
                .flatMap(sandboxDataSets -> Optional.ofNullable(sandboxDataSets.getSandboxDatasets()))
                .map(ImmutableList::copyOf)
                .orElse(ImmutableList.of());
    }

    @Override
    public TenantConfiguration getTenantDefaults() {
        return tenantConfigurationViewService.defaultTenantConfiguration();
    }

    @VisibleForTesting
    TenantConfiguration generateSandboxTenantConfigurationForCreate(final TenantConfiguration requestTenantConfiguration) {
        tenantValidationService.sandboxCreationValidation(requestTenantConfiguration);

        final Tenant requestTenant = requestTenantConfiguration.getTenant();
        final String requestDataset = requestTenant.getSandboxDataset();

        final ReportingSystemPropertiesImpl requestReporting = requestTenantConfiguration.getReporting();
        final AggregateReportingPropertiesTenant requestAggregate = requestTenantConfiguration.getAggregateReportingProperties();
        final String parentTenantKey = requestTenantConfiguration.getParentTenantKey();

        final String sandboxKey = generateKey(requestTenantConfiguration.getParentTenantKey());
        final String sandboxDbPassword = createRandomPassword();
        final Map<String, DataSourceElementsTenant> datasources = generateDataSourceElementsMap(sandboxKey, sandboxDbPassword);
        final ArchivePropertiesTenant archivePropertiesTenant = new ArchivePropertiesTenant();
        archivePropertiesTenant.setPathPrefix(sandboxKey.toLowerCase());
        if (isLocalizationSupplied(requestTenantConfiguration.getLocalization())) {
            requestReporting.setTranslationLocation(generateTenantLocalization(sandboxKey));
        }

        final String localization = requestTenantConfiguration.getLocalization();

        final ExamProcessorValidationPropertiesTenant validation = requestTenantConfiguration.getValidation();

        final Tenant tenant = Tenant.builder()
                .key(sandboxKey)
                .id(sandboxKey)
                .created(Instant.now())
                .sandbox(true)
                .name(requestTenant.getName())
                .description(requestTenant.getDescription())
                .sandboxDataset(requestDataset)
                .build();

        return TenantConfiguration.builder()
                .tenant(tenant)
                .reporting(requestReporting)
                .aggregateReportingProperties(requestAggregate)
                .dataSources(datasources)
                .parentTenantKey(parentTenantKey)
                .archiveProperties(archivePropertiesTenant)
                .validation(validation)
                .localizaton(localization)
                .build();
    }

    private boolean isLocalizationSupplied(final String localization) {
        return localization != null && !localization.isEmpty() && !localization.equals("{}");
    }

    private String generateTenantLocalization(final String tenantKey) {
        return "binary-${spring.cloud.config.uri}/*/*/master/tenant-" + tenantKey + "/";
    }

    @VisibleForTesting
    String generateKey(final String parentTenantKey) {
        final int maxConfigured = tenantConfigurationViewService
                .allTenantConfigurations(TenantType.SANDBOX)
                .keySet()
                .stream()
                .filter(key -> key.length() > 2)
                .filter(key -> key.contains(parentTenantKey + "_S"))
                .map(key -> key.substring(key.length() - 3))
                .map(Integer::parseInt)
                .max(Integer::compare)
                .orElse(0);

        return parentTenantKey + "_" + "S" + String.format("%03d", maxConfigured + 1);
    }

    @VisibleForTesting
    Map<String, DataSourceElementsTenant> generateDataSourceElementsMap(String sandboxKey, String databasePassword) {
        String dbUsername = sandboxKey.replaceAll("_", "").toLowerCase();
        String dbPostfix = "_" + sandboxKey.toLowerCase();

        //TODO: Externalize datasource keys
        return new ImmutableMap.Builder<String, DataSourceElementsTenant>()
                .put("olap_ro", createDataSourceElements(dbUsername, databasePassword, "reporting" + dbPostfix, null))
                .put("olap_rw", createDataSourceElements(dbUsername, databasePassword, "reporting" + dbPostfix, null))
                .put("reporting_ro", createDataSourceElements(dbUsername, databasePassword, null, "reporting" + dbPostfix))
                .put("reporting_rw", createDataSourceElements(dbUsername, databasePassword, null, "reporting" + dbPostfix))
                .put("warehouse_ro", createDataSourceElements(dbUsername, databasePassword, null, "warehouse" + dbPostfix))
                .put("warehouse_rw", createDataSourceElements(dbUsername, databasePassword, null, "warehouse" + dbPostfix))
                .put("migrate_rw", createDataSourceElements(dbUsername, databasePassword, null, "migrate_olap" + dbPostfix))
                .build();
    }

    private DataSourceElementsTenant createDataSourceElements(String username,
                                                              String password,
                                                              String schemaSearchPath,
                                                              String databaseName) {
        DataSourceElementsTenant dataSourceElementsTenant = new DataSourceElementsTenant();
        dataSourceElementsTenant.setUsername(username);
        dataSourceElementsTenant.setPassword(password);
        dataSourceElementsTenant.setSchemaSearchPath(schemaSearchPath);
        DataSourceUrlParts dataSourceUrlParts = new DataSourceUrlParts();
        dataSourceUrlParts.setDatabase(databaseName);
        dataSourceElementsTenant.setUrlParts(dataSourceUrlParts);
        return dataSourceElementsTenant;
    }

    private String createRandomPassword() {
        //Match the Redshift requirements
        final String letters = RandomStringUtils.random(1, true, false).toUpperCase() +
                RandomStringUtils.random(5, true, false).toLowerCase();
        final String numbers = RandomStringUtils.random(2, false, true);
        return letters + numbers;
    }

}

