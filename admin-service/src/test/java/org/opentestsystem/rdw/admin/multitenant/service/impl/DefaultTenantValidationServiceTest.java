package org.opentestsystem.rdw.admin.multitenant.service.impl;

import com.google.common.collect.ImmutableMap;
import org.junit.Before;
import org.junit.Test;

import java.util.HashMap;
import java.util.Map;
import org.opentestsystem.rdw.admin.multitenant.TenantType;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatus;
import org.opentestsystem.rdw.admin.multitenant.administration.TenantAdministrationStatusContext;
import org.opentestsystem.rdw.admin.multitenant.model.TenantConfiguration;
import org.opentestsystem.rdw.admin.multitenant.service.TenantConfigurationViewService;
import org.opentestsystem.rdw.admin.multitenant.service.TenantValidationService;
import org.opentestsystem.rdw.admin.service.impl.RDWDataSourceNames;
import org.opentestsystem.rdw.archive.ArchivePropertiesTenant;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceElementsTenant;
import org.opentestsystem.rdw.multitenant.datasource.DataSourceUrlParts;

import static org.mockito.Mockito.atLeastOnce;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class DefaultTenantValidationServiceTest {

    // class under test
    private DefaultTenantValidationService tenantValidationService;

    private TenantConfigurationViewService tenantConfigurationViewService;
    private TenantConfiguration hawaiiTenant;
    private TenantConfiguration washingtonTenant;
    private TenantConfiguration hiS001;
    private TenantConfiguration hiS002;


    private Map<String, TenantConfiguration> tenantConfigurations;
    private Map<String, TenantConfiguration> sandboxConfigurations;

    @Before
    public void setup() {
        tenantConfigurationViewService = mock(TenantConfigurationViewService.class);
        tenantValidationService = new DefaultTenantValidationService(tenantConfigurationViewService);

        hawaiiTenant = generateTenantConfiguration("HI", false);
        washingtonTenant = generateTenantConfiguration("WA", false);
        tenantConfigurations = ImmutableMap.of("HI", hawaiiTenant, "WA", washingtonTenant);
        when(tenantConfigurationViewService.allTenantConfigurations(TenantType.TENANT)).thenReturn(tenantConfigurations);

        hiS001 = generateTenantConfiguration("HI_S001", true);
        hiS002 = generateTenantConfiguration("HI_S002", true);
        sandboxConfigurations = ImmutableMap.of("HI_S001", hiS001, "HI_S002", hiS002);
        when(tenantConfigurationViewService.allTenantConfigurations(TenantType.SANDBOX)).thenReturn(sandboxConfigurations);
    }

    @Test
    public void itShouldValidateSandboxCreation() {
        // create a sandbox not in current map
        TenantConfiguration hiS003 = generateTenantConfiguration("HI_S003", true);
        tenantValidationService.sandboxCreationValidation(hiS003);
        verify(tenantConfigurationViewService, atLeastOnce()).allTenantConfigurations(TenantType.SANDBOX);
    }

    @Test
    public void itShouldValidateSandboxUpdate() {
        tenantValidationService.sandboxUpdateValidation(hiS001);
        verify(tenantConfigurationViewService).allTenantConfigurations(TenantType.SANDBOX);
    }

    @Test(expected = Exception.class)
    public void itShouldFailValidateSandboxCreation() {
        tenantValidationService.sandboxCreationValidation(hiS002);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldVerifySandboxRequiredFieldsTenant() {
        tenantValidationService.verifySandboxRequiredFields(TenantConfiguration.builder().build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldVerifySandboxRequiredFieldsIsSandbox() {
        tenantValidationService.verifySandboxRequiredFields(TenantConfiguration.builder()
                .tenant(Tenant.builder()
                        .sandbox(false)
                        .sandboxDataset("TEST")
                        .build())
                .build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldVerifySandboxRequiredSandboxDataset() {
        tenantValidationService.verifySandboxRequiredFields(TenantConfiguration.builder()
                .tenant(Tenant.builder()
                        .sandbox(true)
                        .sandboxDataset("TEST")
                        .build())
                .build());
    }

    @Test(expected = Exception.class)
    public void itShouldFailDatabaseNameExist() {
        // want a new tenant since database tests follow if key exist tests
        TenantConfiguration NY = generateTenantConfiguration("NY", false);
        // setdatabase name to the same database in the same dataSource of another tenant
        NY.getDataSources().get(RDWDataSourceNames.REPORTING_RO.getName()).getUrlParts()
                .setDatabase(hawaiiTenant.getDataSources().get(RDWDataSourceNames.REPORTING_RO.getName()).getUrlParts().getDatabase());
        tenantValidationService.tenantCreationValidation(NY);
        verify(tenantConfigurationViewService).allTenantConfigurations(TenantType.TENANT);
    }

    @Test(expected = Exception.class)
    public void itShouldFailDatabaseNameisNull() {
        // want a new tenant since database tests follow if key exist tests
        TenantConfiguration NY = generateTenantConfiguration("NY", false);
        // setdatabase name to the same database in the same dataSource of another tenant
        NY.getDataSources().get(RDWDataSourceNames.REPORTING_RW.getName()).getUrlParts().setDatabase(null);
        tenantValidationService.tenantCreationValidation(NY);
        verify(tenantConfigurationViewService).allTenantConfigurations(TenantType.TENANT);
    }

    @Test(expected = Exception.class)
    public void itShouldFailDatabaseNameisEmpty() {
        // want a new tenant since database tests follow if key exist tests
        TenantConfiguration NY = generateTenantConfiguration("NY", false);
        // setdatabase name to the same database in the same dataSource of another tenant
        NY.getDataSources().get(RDWDataSourceNames.WAREHOUSE_RW.getName()).getUrlParts().setDatabase("");
        tenantValidationService.tenantCreationValidation(NY);
        verify(tenantConfigurationViewService).allTenantConfigurations(TenantType.TENANT);
    }

    @Test(expected = Exception.class)
    public void itShouldFailOlapInvalidUserName() {
        // want a new tenant since olap tests follow if key exist tests
        TenantConfiguration NY = generateTenantConfiguration("NY", false);
        NY.getDataSources().get(RDWDataSourceNames.OLAP_RO.getName()).setUsername("LongerThanTheMaxAllowed");
        tenantValidationService.tenantCreationValidation(NY);
        verify(tenantConfigurationViewService).allTenantConfigurations(TenantType.TENANT);
    }

    @Test(expected = Exception.class)
    public void itShouldFailOlapUserNameIsNull() {
        // want a new tenant since olap tests follow if key exist tests
        TenantConfiguration NY = generateTenantConfiguration("NY", false);
        NY.getDataSources().get(RDWDataSourceNames.OLAP_RO.getName()).setUsername(null);
        tenantValidationService.tenantCreationValidation(NY);
        verify(tenantConfigurationViewService).allTenantConfigurations(TenantType.TENANT);
    }

    @Test(expected = Exception.class)
    public void itShouldFailOlapUserNameIsEmpty() {
        // want a new tenant since olap tests follow if key exist tests
        TenantConfiguration NY = generateTenantConfiguration("NY", false);
        NY.getDataSources().get(RDWDataSourceNames.OLAP_RO.getName()).setUsername("");
        tenantValidationService.tenantCreationValidation(NY);
        verify(tenantConfigurationViewService).allTenantConfigurations(TenantType.TENANT);
    }

    @Test(expected = Exception.class)
    public void itShouldFailOlapInvalidSchemaSearchPath() {
        // want a new tenant since olap tests follow if key exist tests
        TenantConfiguration NY = generateTenantConfiguration("NY", false);
        NY.getDataSources().get(RDWDataSourceNames.OLAP_RO.getName()).setSchemaSearchPath("NOT-VALID");
        tenantValidationService.tenantCreationValidation(NY);
        verify(tenantConfigurationViewService).allTenantConfigurations(TenantType.TENANT);
    }

    @Test(expected = Exception.class)
    public void itShouldFailOlapSchemaSearchPathIsNull() {
        // want a new tenant since olap tests follow if key exist tests
        TenantConfiguration NY = generateTenantConfiguration("NY", false);
        NY.getDataSources().get(RDWDataSourceNames.OLAP_RO.getName()).setSchemaSearchPath(null);
        tenantValidationService.tenantCreationValidation(NY);
        verify(tenantConfigurationViewService).allTenantConfigurations(TenantType.TENANT);
    }

    @Test(expected = Exception.class)
    public void itShouldFailOlapSchemaSearchPathIsEmpty() {
        // want a new tenant since olap tests follow if key exist tests
        TenantConfiguration NY = generateTenantConfiguration("NY", false);
        NY.getDataSources().get(RDWDataSourceNames.OLAP_RO.getName()).setSchemaSearchPath("");
        tenantValidationService.tenantCreationValidation(NY);
        verify(tenantConfigurationViewService).allTenantConfigurations(TenantType.TENANT);
    }

    @Test(expected = Exception.class)
    public void itShouldFailAchiveInvalidPrefix() {
        // want a new tenant since archive tests follow if key exist tests
        TenantConfiguration NY = generateTenantConfiguration("NY", false);
        // test if prefix path is set to an existing prefix path
        NY.getArchiveProperties().setPathPrefix(hawaiiTenant.getArchiveProperties().getPathPrefix());
        tenantValidationService.tenantCreationValidation(NY);
        verify(tenantConfigurationViewService).allTenantConfigurations(TenantType.TENANT);
    }

    @Test(expected = Exception.class)
    public void itShouldFailAchivePrefixIsNull() {
        // want a new tenant since archive tests follow if key exist tests
        TenantConfiguration NY = generateTenantConfiguration("NY", false);
        // test if prefix path is set to an existing prefix path
        NY.getArchiveProperties().setPathPrefix(null);
        tenantValidationService.tenantCreationValidation(NY);
        verify(tenantConfigurationViewService).allTenantConfigurations(TenantType.TENANT);
    }
    @Test(expected = Exception.class)
    public void itShouldFailAchivePrefixIsEmpty() {
        // want a new tenant since archive tests follow if key exist tests
        TenantConfiguration NY = generateTenantConfiguration("NY", false);
        // test if prefix path is set to an existing prefix path
        NY.getArchiveProperties().setPathPrefix("");
        tenantValidationService.tenantCreationValidation(NY);
        verify(tenantConfigurationViewService).allTenantConfigurations(TenantType.TENANT);
    }

    @Test(expected = Exception.class)
    public void itShouldFailTenantExists() {
        tenantValidationService.tenantCreationValidation(hawaiiTenant);
    }

    @Test
    public void itShouldValidateTenantCreation() {
        TenantConfiguration NY = generateTenantConfiguration("NY", false);
        tenantValidationService.tenantCreationValidation(NY);
        verify(tenantConfigurationViewService).allTenantConfigurations(TenantType.TENANT);
    }

    @Test(expected = Exception.class)
    public void itShouldFailTenantUpdate() {
        TenantConfiguration NY = generateTenantConfiguration("NY", false);
        tenantValidationService.tenantUpdateValidation(NY);
    }

    @Test
    public void itShouldValidateTenantUpdate() {
        tenantValidationService.tenantUpdateValidation(washingtonTenant);
        verify(tenantConfigurationViewService).allTenantConfigurations(TenantType.TENANT);
    }

    /**
     * @param key of the dataSources to create
     * @return map of DataSourceElementsTenant with testable data for cvalidation
     */
    private Map<String, DataSourceElementsTenant> generateTenantDataSources(final String key) {
        Map<String, DataSourceElementsTenant> dataSources = new HashMap<>();
        dataSources.put(RDWDataSourceNames.REPORTING_RO.getName(), getDataSource(RDWDataSourceNames.REPORTING_RO.getName(), key));
        dataSources.put(RDWDataSourceNames.REPORTING_RW.getName(), getDataSource(RDWDataSourceNames.REPORTING_RW.getName(), key));
        dataSources.put(RDWDataSourceNames.WAREHOUSE_RW.getName(), getDataSource(RDWDataSourceNames.WAREHOUSE_RW.getName(), key));
        dataSources.put(RDWDataSourceNames.OLAP_RO.getName(), getDataSource(RDWDataSourceNames.OLAP_RO.getName(), key));
        return dataSources;
    }

    /**
     * @param key        of the tenant and to be used in creating the db name
     * @param dataSource used to build the db name
     * @return DataSourceUrlParts with a database named
     */
    private DataSourceUrlParts geturlParts(final String key, final String dataSource) {
        DataSourceUrlParts urlParts = new DataSourceUrlParts();
        urlParts.setDatabase(key + "_" + dataSource + "db");
        return urlParts;
    }

    /**
     * @param dataSourceName to setup for validation
     * @param key            of the tenant to use in the db and username naming
     * @return DataSourceElementsTenant with testable data for validation
     */
    private DataSourceElementsTenant getDataSource(final String dataSourceName, final String key) {
        DataSourceElementsTenant dataSource = new DataSourceElementsTenant();
        dataSource.setUrlParts(geturlParts(key, dataSourceName));
        dataSource.setUsername(key + "_username");
        // each olap datasource should get the same SchemaSearchPath
        if(dataSourceName.equals(RDWDataSourceNames.OLAP_RO.getName())) {
            dataSource.setSchemaSearchPath("redShiftPath");
        }
        return dataSource;
    }

    private ArchivePropertiesTenant getArchive(final String key) {
        ArchivePropertiesTenant archivePropertiesTenant = new ArchivePropertiesTenant();
        archivePropertiesTenant.setPathPrefix(key + "_path");
        return archivePropertiesTenant;
    }

    /**
     * @param key       key of the new tenant or sandbox
     * @param isSandbox indicate if tenant or sandbox
     * @return TenantConfiguration with testable data for validation
     */
    private TenantConfiguration generateTenantConfiguration(String key, boolean isSandbox) {
        return TenantConfiguration.builder()
                .tenant(Tenant.builder()
                        .id(key)
                        .key(key)
                        .name(key + "-name")
                        .sandbox(isSandbox)
                        .build())
                .administrationStatus(
                        TenantAdministrationStatusContext.builder()
                                .message("Started creating " + key)
                                .tenantAdministrationStatus(TenantAdministrationStatus.STARTED)
                                .build())
                .dataSources(generateTenantDataSources(key))
                .archiveProperties(getArchive(key))
                .build();
    }
}