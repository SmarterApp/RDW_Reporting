package org.opentestsystem.rdw.admin.service.impl;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.opentestsystem.rdw.admin.model.Embargo;
import org.opentestsystem.rdw.admin.repository.EmbargoRepository;
import org.opentestsystem.rdw.admin.repository.ImportRepository;
import org.opentestsystem.rdw.common.model.ImportContent;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemPropertiesImpl;
import org.opentestsystem.rdw.reporting.common.model.District;
import org.opentestsystem.rdw.reporting.common.model.OrganizationQuery;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.opentestsystem.rdw.reporting.common.repository.OrganizationRepository;
import org.opentestsystem.rdw.reporting.common.security.User;
import org.opentestsystem.rdw.security.Permission;
import org.opentestsystem.rdw.security.PermissionScope;

import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyCollection;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.admin.security.AdminPermission.EmbargoWrite;
import static org.opentestsystem.rdw.admin.security.AdminPermission.TestDataLoadingWrite;
import static org.opentestsystem.rdw.admin.security.AdminPermission.TestDataReviewingWrite;

@RunWith(MockitoJUnitRunner.class)
public class DefaultEmbargoServiceTest {

    @Mock
    private EmbargoRepository repository;
    @Mock
    private OrganizationRepository organizationRepository;
    @Mock
    private ImportRepository importRepository;
    @Mock
    public User user;
    private static final int schoolYear = 2018;

    private DefaultEmbargoService service;

    @Before
    public void setup() {
        final ReportingSystemPropertiesImpl systemSettings = new ReportingSystemPropertiesImpl();
        systemSettings.getState().setCode("CA");
        systemSettings.getState().setName("California");
        systemSettings.setSchoolYear(schoolYear);

        Map<String, Permission> permissions = ImmutableMap.of(
            EmbargoWrite,
            new Permission(EmbargoWrite, PermissionScope.builder().statewide(true).addDistrictId(123L).build()),
            TestDataReviewingWrite,
            new Permission(TestDataReviewingWrite,
                PermissionScope.builder().statewide(true).addDistrictId(123L).build())
        );

        when(user.getPermissionsById()).thenReturn(permissions);

        service = new DefaultEmbargoService(repository, organizationRepository, importRepository, systemSettings);
    }

    @Test
    public void saveShouldDoNothingIfNoEmbargoFlagsSet() {
        service.save(user, Embargo.builder()
                .organizationType(OrganizationType.State)
                .build());
        verifyZeroInteractions(repository, organizationRepository, importRepository);
    }

    @Test(expected = NoSuchElementException.class)
    public void saveShouldCheckAnyEmbargoWriteAccess() {
        when(user.getPermissionsById()).thenReturn(ImmutableMap.of());
        service.save(user, Embargo.builder()
                .organizationType(OrganizationType.State)
                .aggregateEnabled(true)
                .build());
    }

    @Test(expected = NoSuchElementException.class)
    public void saveShouldCheckStateAccess() {
        when(user.getPermissionsById()).thenReturn(ImmutableMap.of("EMBARGO_WRITE", new Permission("EMBARGO_WRITE", PermissionScope.EMPTY)));
        service.save(user, Embargo.builder()
                .organizationType(OrganizationType.State)
                .aggregateEnabled(true)
                .build());
    }

    @Test(expected = NoSuchElementException.class)
    public void saveShouldCheckDistrictAccess() {
        when(organizationRepository.findAll(any(PermissionScope.class), any(OrganizationQuery.class)))
                .thenReturn(ImmutableList.of());
        service.save(user, Embargo.builder()
                .organizationType(OrganizationType.District)
                .organizationId(123L)
                .individualEnabled(true)
                .build());
    }

    @Test(expected = IllegalArgumentException.class)
    public void saveShouldCheckOrganizationType() {
        service.save(user, Embargo.builder()
                .organizationType(OrganizationType.DistrictGroup)
                .organizationId(100L)
                .aggregateEnabled(true)
                .build());
    }

    @Test
    public void saveShouldNoOpIfNoChange() {
        final Embargo embargo = Embargo.builder()
                .organizationType(OrganizationType.State)
                .aggregateEnabled(true)
                .individualEnabled(false)
                .build();

        when(repository.findOneBySchoolYearAndState(anyInt())).thenReturn(embargo);
        service.save(user, embargo);
        verify(repository).findOneBySchoolYearAndState(anyInt());
        verifyNoMoreInteractions(repository, importRepository);
    }

    @Test
    public void saveShouldCreateStateEmbargo() {
        final Embargo embargo = Embargo.builder()
                .organizationType(OrganizationType.State)
                .aggregateEnabled(false)
                .build();

        final long importId = 42;
        when(importRepository.create(eq(ImportContent.EMBARGO), anyString(), anyString(), anyString())).thenReturn(importId);

        service.save(user, embargo);

        final ArgumentCaptor<Embargo> embargoCaptor = ArgumentCaptor.forClass(Embargo.class);
        final String username = user.getUsername();
        verify(repository).create(embargoCaptor.capture(), eq(username));
        final Embargo created = embargoCaptor.getValue();
        assertThat(created.getOrganizationType()).isEqualTo(OrganizationType.State);
        assertThat(created.isAggregateEnabled()).isFalse();
        assertThat(created.getSchoolYear()).isEqualTo(schoolYear);
        verify(importRepository).setProcessed(importId);
    }

    @Test
    public void saveShouldUpdateDistrictEmbargo() {
        final Embargo embargo = Embargo.builder()
                .organizationType(OrganizationType.District)
                .organizationId(123L)
                .individualEnabled(true)
                .build();

        final Embargo existing = Embargo.builder()
                .organizationType(OrganizationType.District)
                .organizationId(123L)
                .individualEnabled(false)
                .aggregateEnabled(true)
                .build();

        when(organizationRepository.findAll(any(), any())).thenReturn(ImmutableList.of(District.builder().id(123L).build()));
        when(repository.findOneBySchoolYearAndDistrictId(schoolYear, existing.getOrganizationId())).thenReturn(existing);

        final long importId = 47;
        when(importRepository.create(eq(ImportContent.EMBARGO), anyString(), anyString(), anyString())).thenReturn(importId);

        service.save(user, embargo);

        final ArgumentCaptor<Embargo> embargoCaptor = ArgumentCaptor.forClass(Embargo.class);
        final String username = user.getUsername();
        verify(repository).update(embargoCaptor.capture(), eq(username));
        final Embargo updated = embargoCaptor.getValue();
        assertThat(updated.getOrganizationType()).isEqualTo(OrganizationType.District);
        assertThat(updated.getOrganizationId()).isEqualTo(embargo.getOrganizationId());
        assertThat(updated.isIndividualEnabled()).isTrue();     // what was passed in
        assertThat(updated.isAggregateEnabled()).isTrue();      // copied from existing
        verify(importRepository).setProcessed(importId);
    }

    @Test
    public void saveShouldSetImportStatusOnException() {
        final Embargo embargo = Embargo.builder()
                .organizationType(OrganizationType.State)
                .aggregateEnabled(false)
                .build();

        final long importId = 42;
        when(importRepository.create(eq(ImportContent.EMBARGO), anyString(), anyString(), anyString())).thenReturn(importId);
        doThrow(RuntimeException.class).when(repository).create(any(), any());

        service.save(user, embargo);

        // verify status was set to something error-y
        final ArgumentCaptor<ImportStatus> statusCaptor = ArgumentCaptor.forClass(ImportStatus.class);
        verify(importRepository).setStatus(eq(importId), statusCaptor.capture(), anyString());
        assertThat(statusCaptor.getValue().getValue()).isLessThan(0);
    }

    @Test
    public void findAllShouldUseRepository() {
        when(repository.findAllBySchoolYear(eq(2018), anyCollection())).thenReturn(ImmutableList.of(
                Embargo.builder()
                        .organizationType(OrganizationType.State)
                        .individualEnabled(false)
                        .aggregateEnabled(true)
                        .build(),
                Embargo.builder()
                        .organizationType(OrganizationType.District)
                        .organizationId(123L)
                        .organizationName("LAUSD")
                        .individualEnabled(false)
                        .aggregateEnabled(false)
                        .build()

        ));
        when(organizationRepository.findAll(any(), any())).thenReturn(ImmutableList.of(District.builder().id(123L).build()));

        final List<Embargo> embargos = (List<Embargo>) service.findAll(user);
        assertThat(embargos).hasSize(2);
        assertThat(embargos.get(0).getOrganizationType()).isEqualTo(OrganizationType.State);
        assertThat(embargos.get(0).getOrganizationName()).isEqualTo("California");
        assertThat(embargos.get(0).isReadOnly()).isFalse();
    }

    @Test
    public void findTestResultsShouldUseRepository() {
        service.findTestResults(user);
        verify(repository).findTestResultsAvailability(anyCollection(), anyCollection(), anyCollection());
    }

    @Test(expected = NoSuchElementException.class)
    public void findTestResultsShouldCheckEmbargoWrite() {
        Map<String, Permission> permissions = ImmutableMap.of();
        when(user.getPermissionsById()).thenReturn(permissions);

        service.findTestResults(user);
    }

    @Test
    public void findAllShouldSetStateReadOnlyTrue() {
        when(repository.findAllBySchoolYear(eq(2018), anyCollection())).thenReturn(ImmutableList.of(
                Embargo.builder()
                        .organizationType(OrganizationType.State)
                        .individualEnabled(false)
                        .aggregateEnabled(true)
                        .build(),
                Embargo.builder()
                        .organizationType(OrganizationType.District)
                        .organizationId(123L)
                        .organizationName("LAUSD")
                        .individualEnabled(false)
                        .aggregateEnabled(false)
                        .build()

        ));
        when(organizationRepository.findAll(any(), any())).thenReturn(ImmutableList.of(District.builder().id(123L).build()));
        when(user.getPermissionsById()).thenReturn(ImmutableMap.of("EMBARGO_WRITE",
                new Permission("EMBARGO_WRITE", PermissionScope.builder().statewide(false).addDistrictId(123L).build())));

        final List<Embargo> embargos = (List<Embargo>) service.findAll(user);
        assertThat(embargos.get(0).isReadOnly()).isTrue();
    }

    @Test
    public void findAuditRecordsShouldUseRepository() {
        Map<String, Permission> permissions = ImmutableMap.of(
            TestDataLoadingWrite,
            new Permission(TestDataLoadingWrite, PermissionScope.builder().statewide(true).build()),
            TestDataReviewingWrite,
            new Permission(TestDataReviewingWrite,
                PermissionScope.builder().statewide(true).addDistrictId(123L).build())
        );

        when(user.getPermissionsById()).thenReturn(permissions);

        service.findAuditRecords(user, new Date());
        verify(repository).findEmbargoAuditRecords(any(Date.class));
    }

    @Test(expected = NoSuchElementException.class)
    public void findAuditRecordsShouldCheckDataLoadingWrite() {
        service.findAuditRecords(user, new Date());
    }
}
