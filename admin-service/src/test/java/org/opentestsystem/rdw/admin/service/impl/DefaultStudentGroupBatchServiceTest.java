package org.opentestsystem.rdw.admin.service.impl;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.opentestsystem.rdw.admin.model.StudentGroupBatch;
import org.opentestsystem.rdw.admin.repository.ImportRepository;
import org.opentestsystem.rdw.admin.service.GroupsSource;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.group.CsvValidationService;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.opentestsystem.rdw.security.Permission;
import org.opentestsystem.rdw.security.PermissionScope;
import org.springframework.mock.web.MockMultipartFile;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.web.multipart.MultipartFile;

import java.io.InputStream;
import java.util.List;

import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.group.CsvValidationResult.failure;
import static org.opentestsystem.rdw.group.CsvValidationResult.success;

@RunWith(MockitoJUnitRunner.class)
public class DefaultStudentGroupBatchServiceTest {
    @Mock
    private ImportRepository repository;
    @Mock
    private ArchiveService archiveService;
    @Mock
    private GroupsSource source;
    @Mock
    private CsvValidationService validationService;

    private DefaultStudentGroupBatchService service;

    private final Permission groupWrite = new Permission("GROUP_WRITE", PermissionScope.STATEWIDE);
    private final User user = User.builder()
            .id("user")
            .username("test")
            .password("password")
            .authorities(ImmutableSet.of(new SimpleGrantedAuthority("ROLE_USER")))
            .permissionsById(ImmutableMap.of("GROUP_WRITE", groupWrite))
            .build();

    @Before
    public void createService() {
        service = new DefaultStudentGroupBatchService(repository, archiveService, validationService, source);
    }

    @Test
    public void itShouldUseRepositoryToFindAllStudentGroupBatches() {
        final List<StudentGroupBatch> studentGroupBatches = newArrayList();
        when(repository.findGroupByCreator("test")).thenReturn(studentGroupBatches);

        assertThat(service.findAllStudentGroupBatches(user)).isEqualTo(studentGroupBatches);
    }

    @Test
    public void happyPath() {
        final String filename = "test.csv";
        final String contentType = "text/csv";
        final byte[] body = "group_name,school_natural_id,school_year,subject_code,student_ssid,group_user_login".getBytes();
        final MultipartFile file = new MockMultipartFile(filename, filename, contentType, body);

        final long id = 42L;
        final StudentGroupBatch batch = StudentGroupBatch.builder().id(id).filename(filename).build();

        when(validationService.validate(any(), any(), any())).thenAnswer(invocation -> {
            // we need to read the entire stream so digest is calculated properly
            final InputStream is = invocation.getArgument(0);
            assertThat(is.read(new byte[1000])).isLessThan(1000);
            return newArrayList(success(0, "yay!"));
        });
        when(validationService.toSuccessMessage(any())).thenReturn("yay!");
        when(repository.findGroupByDigest(any())).thenReturn(null);
        when(repository.createGroupImport(eq(contentType), any(), eq(filename), eq(user.getUsername()))).thenReturn(id);
        when(repository.findGroupById(id)).thenReturn(batch);

        assertThat(service.upload(user, file)).isEqualTo(batch);
        verify(repository).setStatus(id, ImportStatus.ACCEPTED, "yay!");
        verify(source).send(any(), eq(contentType), eq(id));
    }

    @Test
    public void itShouldHandleValidationFailures() {
        final String filename = "test.csv";
        final String contentType = "text/csv";
        final byte[] body = "group_name,school_natural_id,school_year,subject_code,student_ssid,group_user_login".getBytes();
        final MultipartFile file = new MockMultipartFile(filename, filename, contentType, body);

        final long id = 42L;
        final StudentGroupBatch batch = StudentGroupBatch.builder().id(id).filename(filename).build();

        when(validationService.validate(any(), any(), any())).thenAnswer(invocation -> {
            // we need to read the entire stream so digest is calculated properly
            final InputStream is = invocation.getArgument(0);
            assertThat(is.read(new byte[1000])).isLessThan(1000);
            return newArrayList(failure(0, "boo"));
        });
        when(validationService.toFailureMessage(any())).thenReturn("boo");
        when(repository.findGroupByDigest(any())).thenReturn(null);
        when(repository.createGroupImport(eq(contentType), any(), eq(filename), eq(user.getUsername()))).thenReturn(id);
        when(repository.findGroupById(id)).thenReturn(batch);

        assertThat(service.upload(user, file)).isEqualTo(batch);
        verify(repository).setStatus(id, ImportStatus.BAD_DATA, "boo");
        verifyZeroInteractions(source);
    }

    @Test
    public void itShouldHandleExistingContent() {
        final String filename = "test.csv";
        final String contentType = "text/csv";
        final byte[] body = "group_name,school_natural_id,school_year,subject_code,student_ssid,group_user_login".getBytes();
        final MultipartFile file = new MockMultipartFile(filename, filename, contentType, body);

        final long id = 42L;
        final StudentGroupBatch batch = StudentGroupBatch.builder().id(id).filename(filename).build();

        when(validationService.validate(any(), any(), any())).thenAnswer(invocation -> {
            // we need to read the entire stream so digest is calculated properly
            final InputStream is = invocation.getArgument(0);
            assertThat(is.read(new byte[1000])).isLessThan(1000);
            return newArrayList(success(0, "yay!"));
        });
        when(validationService.toSuccessMessage(any())).thenReturn("yay!");
        when(repository.findGroupByDigest(any())).thenReturn(batch);
        when(repository.findGroupById(id)).thenReturn(batch);

        assertThat(service.upload(user, file)).isEqualTo(batch);
        verify(repository).setStatus(id, ImportStatus.ACCEPTED, "yay!");
        verify(source).send(any(), eq(contentType), eq(id));
        verify(repository, never()).create(any(), any(), any(), any());
        verifyZeroInteractions(archiveService);
    }
}