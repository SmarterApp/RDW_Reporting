package org.opentestsystem.rdw.admin.service.impl;

import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import org.apache.commons.codec.binary.Hex;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.csv.CSVRecord;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.opentestsystem.rdw.admin.model.CsvValidationResult;
import org.opentestsystem.rdw.admin.model.StudentGroupBatch;
import org.opentestsystem.rdw.admin.repository.StudentGroupBatchRepository;
import org.opentestsystem.rdw.admin.service.CsvValidationService;
import org.opentestsystem.rdw.admin.service.GroupsSource;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.opentestsystem.rdw.security.Permission;
import org.opentestsystem.rdw.security.PermissionScope;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.web.multipart.MultipartFile;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;
import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.anyList;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.anyString;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.common.model.ImportStatus.ACCEPTED;
import static org.opentestsystem.rdw.common.model.ImportStatus.BAD_DATA;

@RunWith(MockitoJUnitRunner.class)
public class DefaultStudentGroupBatchServiceTest {
    private static final Joiner CommaJoiner = Joiner.on(",");
    private static final Joiner LineJoiner = Joiner.on("\n");

    private static final List<String> ValidHeaders = ImmutableList.of("header_a", "header_b");

    private static final List<String> ValidValues = ImmutableList.copyOf(ValidHeaders.stream()
            .map(header -> header + "_val_汉字")
            .collect(Collectors.toList()));

    @Mock
    private StudentGroupBatchRepository repository;

    @Mock
    private ArchiveService archiveService;

    @Mock
    private GroupsSource source;

    @Mock
    private CsvValidationService validationService;

    @Captor
    private ArgumentCaptor<List<String>> headerCaptor;

    private DefaultStudentGroupBatchService service;
    private MultipartFile file;
    private List<List<String>> values;

    private final Permission groupWrite = new Permission("GROUP_WRITE", PermissionScope.STATEWIDE);
    private final User user = User.builder()
            .id("user")
            .username("test")
            .password("password")
            .authorities(ImmutableSet.of(new SimpleGrantedAuthority("ROLE_USER")))
            .permissionsById(ImmutableMap.of("GROUP_WRITE", groupWrite))
            .build();

    @Before
    public void before() {
        when(validationService.toFailureMessage(anyList())).thenReturn("message");
        when(validationService.validateHeaders(anyList())).thenAnswer(invocation -> {
            final List<String> headers = invocation.getArgument(0);
            return ValidHeaders.equals(headers) ? emptyList() :
                    singletonList(CsvValidationResult.builder().row(0).message("Invalid Headers").build());
        });

        values = newArrayList();
        when(validationService.validateRecords(any(Iterator.class), any(PermissionScope.class)))
                .thenAnswer(invocation -> {
                    final Iterator<CSVRecord> recordIterator = invocation.getArgument(0);
                    while (recordIterator.hasNext()) {
                        final CSVRecord record = recordIterator.next();
                        values.add(newArrayList(record.iterator()));
                    }
                    return Collections.emptyList();
                });

        service = new DefaultStudentGroupBatchService(repository, archiveService, validationService, source);

        file = mock(MultipartFile.class);
        when(file.getOriginalFilename()).thenReturn("file name");
        when(file.getSize()).thenReturn(150L);
        when(file.getContentType()).thenReturn("csv");
        when(repository.create(any(StudentGroupBatch.class))).thenAnswer(invocation -> invocation.getArguments()[0]);
    }

    @Test
    public void itShouldUseRepositoryToFindAllStudentGroupBatches() throws IOException {
        final Iterable studentGroupBatches = mock(Iterable.class);
        when(repository.findByCreator("test")).thenReturn(studentGroupBatches);

        assertThat(service.findAllStudentGroupBatches(user)).isEqualTo(studentGroupBatches);
    }

    @Test
    public void itShouldUploadAndValidate() throws IOException {
        final String payload = payload(ValidHeaders, ValidValues);
        when(file.getInputStream()).thenReturn(new ByteArrayInputStream(payload.getBytes()));

        final StudentGroupBatch batch = StudentGroupBatch.builder()
                .creator(user.getUsername())
                .status(ACCEPTED)
                .digest(DigestUtils.md5Hex(payload.getBytes()).toUpperCase())
                .build();
        assertThat(service.upload(user, file)).isEqualTo(batch);
        assertThat(values).hasSize(1);
        assertThat(values.get(0)).containsExactlyElementsOf(ValidValues);
    }

    @Test
    public void itShouldNotUploadIfColumnHeadersAreMissing() throws IOException {
        final String payload = CommaJoiner.join(ValidValues);
        when(file.getInputStream()).thenReturn(new ByteArrayInputStream(payload.getBytes()));

        final StudentGroupBatch batch = StudentGroupBatch.builder()
                .creator(user.getUsername())
                .status(BAD_DATA)
                .digest(Hex.encodeHexString(DigestUtils.md5(payload)).toUpperCase())
                .message("message")
                .build();
        assertThat(service.upload(user, file)).isEqualTo(batch);
    }

    @Test
    public void itShouldNotUploadEmptyFile() throws IOException {
        when(file.getInputStream()).thenReturn(new ByteArrayInputStream("".getBytes()));
        final StudentGroupBatch batch = StudentGroupBatch.builder()
                .creator(user.getUsername())
                .status(BAD_DATA)
                .digest(Hex.encodeHexString(DigestUtils.md5("")).toUpperCase())
                .message("message")
                .build();
        assertThat(service.upload(user, file)).isEqualTo(batch);
    }

    @Test
    public void itShouldNotUploadIfFailedToReadTheFile() throws IOException {
        when(file.getInputStream()).thenThrow(new RuntimeException("failed"));

        final StudentGroupBatch batch = StudentGroupBatch.builder()
                .creator(user.getUsername())
                .status(BAD_DATA)
                .digest(Hex.encodeHexString(DigestUtils.md5("")).toUpperCase())
                .message("Exception processing upload: failed")
                .build();
        assertThat(service.upload(user, file)).isEqualTo(batch);
    }

    @Test
    public void itShouldHandleBOMBytes() throws Exception {
        final String payloadWithBOM = '\uFEFF' + payload(ValidHeaders, ValidValues);
        when(file.getInputStream()).thenReturn(new ByteArrayInputStream(payloadWithBOM.getBytes()));

        service.upload(user, file);

        verify(validationService).validateHeaders(headerCaptor.capture());
        final List<String> headers = headerCaptor.getValue();
        assertThat(headers).containsExactlyElementsOf(ValidHeaders);
    }

    @Test
    public void itShouldSetNewlineToCR() throws IOException {
        final Properties properties = captureArchiveProperties("/test.cr.csv", ACCEPTED);
        assertThat(properties.getProperty("delimiter")).isEqualTo(",");
        assertThat(properties.getProperty("newline")).isEqualTo("\\r");
    }

    @Test
    public void itShouldSetNewlineToLF() throws IOException {
        final Properties properties = captureArchiveProperties("/test.lf.csv", ACCEPTED);
        assertThat(properties.getProperty("delimiter")).isEqualTo(",");
        assertThat(properties.getProperty("newline")).isEqualTo("\\n");
    }

    @Test
    public void itShouldSetNewlineToCRLF() throws IOException {
        final Properties properties = captureArchiveProperties("/test.crlf.csv", ACCEPTED);
        assertThat(properties.getProperty("delimiter")).isEqualTo(",");
        assertThat(properties.getProperty("newline")).isEqualTo("\\r\\n");
    }

    @Test
    public void delimiterDetectionIsNotImplemented() throws IOException {
        // for now, a tab-delimited file will be treated as a csv with bad data
        final Properties properties = captureArchiveProperties("/test.crlf.tsv", BAD_DATA);
        assertThat(properties.getProperty("delimiter")).isEqualTo(",");
        assertThat(properties.getProperty("newline")).isEqualTo("\\r\\n");
    }

    private Properties captureArchiveProperties(final String resource, final ImportStatus expectedStatus) throws IOException {
        when(file.getInputStream()).thenReturn(this.getClass().getResourceAsStream(resource));
        assertThat(service.upload(user, file).getStatus()).isEqualTo(expectedStatus);
        final ArgumentCaptor<Properties> propertiesCaptor = ArgumentCaptor.forClass(Properties.class);
        verify(archiveService).writeResource(anyString(), any(InputStream.class), propertiesCaptor.capture());
        return propertiesCaptor.getValue();
    }

    private String payload(final List<String> headers, final List<String> values) {
        return LineJoiner.join(CommaJoiner.join(headers), CommaJoiner.join(values));
    }
}