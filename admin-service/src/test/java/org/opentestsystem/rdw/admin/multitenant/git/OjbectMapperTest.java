package org.opentestsystem.rdw.admin.multitenant.git;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;
import com.fasterxml.jackson.dataformat.yaml.YAMLGenerator;
import org.junit.Before;
import org.junit.Test;
import org.springframework.beans.factory.config.YamlPropertiesFactoryBean;
import org.springframework.boot.bind.PropertiesConfigurationFactory;
import org.springframework.core.env.MutablePropertySources;
import org.springframework.core.env.PropertiesPropertySource;
import org.springframework.core.io.InputStreamResource;
import org.springframework.core.io.Resource;
import org.springframework.validation.BindException;

import java.io.ByteArrayInputStream;
import java.nio.charset.StandardCharsets;
import java.util.Properties;
import org.opentestsystem.rdw.admin.multitenant.model.ApplicationTenantConfigurationPersistence;
import org.opentestsystem.rdw.admin.multitenant.model.TenantConfiguration;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemPropertiesImpl;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * This tests the writing of properties using the same object mapper as
 * GitTenantConfigurationPersistenceService. It's easier to do this than to do a full-on IT.
 *
 * @see GitTenantConfigurationPersistenceService
 */
public class OjbectMapperTest {

    private ObjectMapper ymlMapper;

    @Before
    public void createMapper() {
        // create the mapper the same way DefaultConfigServerClient does
        ymlMapper = new ObjectMapper(new YAMLFactory().disable(YAMLGenerator.Feature.WRITE_DOC_START_MARKER));
//        ymlMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        ymlMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);
        ymlMapper.findAndRegisterModules();
    }

    @Test
    public void bigTest() throws JsonProcessingException, BindException {
        final ApplicationTenantConfigurationPersistence config =
                new ApplicationTenantConfigurationPersistence(tenantConfiguration());
        final String output = ymlMapper.writeValueAsString(config);
        System.out.println(output);

        final ApplicationTenantConfigurationPersistence out =
                buildFromYaml(new ApplicationTenantConfigurationPersistence(), output);
        assertThat(out).isNotNull();
        assertThat(out.getReporting().get("tenants")).isNotEmpty();
    }

    @Test
    public void itShouldWriteReportingProperties() throws JsonProcessingException, BindException {
        final ReportingSystemPropertiesImpl config = new ReportingSystemPropertiesImpl();
        config.setIrisVendorId("IRIS");
        final String output = ymlMapper.writeValueAsString(config);
        System.out.println(output);

        final ReportingSystemPropertiesImpl reporting = buildFromYaml(new ReportingSystemPropertiesImpl(), output);
        assertThat(reporting.getIrisVendorId()).isEqualTo("IRIS");
    }

    private TenantConfiguration tenantConfiguration() {
        final ReportingSystemPropertiesImpl reporting = new ReportingSystemPropertiesImpl();
        reporting.setIrisVendorId("IRIS");

        // TODO - add other things

        return TenantConfiguration.builder()
                .tenant(Tenant.builder().id("XX").key("XX").name("Test").build())
                .reporting(reporting)
                .build();
    }


    // this emulates how Spring populates an object from properties
    private <T> T buildFromYaml(final T object, final String yaml) throws BindException {
        final MutablePropertySources propertySources = new MutablePropertySources();
        propertySources.addLast(new PropertiesPropertySource("properties", loadYamlIntoProperties(yaml)));

        final PropertiesConfigurationFactory<T> configurationFactory = new PropertiesConfigurationFactory<>(object);
        configurationFactory.setPropertySources(propertySources);
        configurationFactory.bindPropertiesToTarget();

        return object;
    }

    private Properties loadYamlIntoProperties(final String yaml) {
        final Resource resource = new InputStreamResource(new ByteArrayInputStream(yaml.getBytes(StandardCharsets.UTF_8)));
        final YamlPropertiesFactoryBean factory = new YamlPropertiesFactoryBean();
        factory.setResources(resource);
        factory.afterPropertiesSet();
        return factory.getObject();
    }
}
