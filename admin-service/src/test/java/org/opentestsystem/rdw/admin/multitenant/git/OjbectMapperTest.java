package org.opentestsystem.rdw.admin.multitenant.git;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.collect.ImmutableSet;
import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.rdw.admin.multitenant.model.ApplicationTenantConfigurationPersistence;
import org.opentestsystem.rdw.admin.multitenant.model.TenantConfiguration;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.multitenant.task.ArtClientPropertiesTenant;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingPropertiesTenant;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemPropertiesImpl;
import org.springframework.beans.factory.config.YamlPropertiesFactoryBean;
import org.springframework.boot.bind.PropertiesConfigurationFactory;
import org.springframework.core.env.MutablePropertySources;
import org.springframework.core.env.PropertiesPropertySource;
import org.springframework.core.io.InputStreamResource;
import org.springframework.core.io.Resource;
import org.springframework.security.oauth2.client.token.grant.password.ResourceOwnerPasswordResourceDetails;
import org.springframework.validation.BindException;

import java.io.ByteArrayInputStream;
import java.nio.charset.StandardCharsets;
import java.util.Properties;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * This tests the writing of properties using the same object mapper as
 * GitTenantConfigurationPersistenceService. It's easier to do this than to do a full-on IT.
 *
 * @see GitTenantConfigurationPersistenceService
 */
public class OjbectMapperTest {

    private ObjectMapper ymlMapper;

    @Before
    public void createMapper() {
        ymlMapper = GitTenantConfigurationPersistenceService.createObjectMapper();
    }

    @Test
    public void bigTest() throws JsonProcessingException, BindException {
        final ApplicationTenantConfigurationPersistence config =
                new ApplicationTenantConfigurationPersistence(tenantConfiguration());
        final String output = ymlMapper.writeValueAsString(config);
        System.out.println(output);

        assertThat(output).contains("testOauthUser");
        assertThat(output).contains("testOauthUserPass");
        assertThat(output).doesNotContain("grantType");
        assertThat(output).doesNotContain("clientAuthenticationScheme");

        final ApplicationTenantConfigurationPersistence out =
                buildFromYaml(new ApplicationTenantConfigurationPersistence(), output);
        assertThat(out).isNotNull();
        assertThat(out.getReporting().get("tenants")).isNotEmpty();
        assertThat(out.getTaskUpdateOrganizationsArtClient().get("tenants")).isNotEmpty();
    }

    @Test
    public void itShouldWriteReportingProperties() throws JsonProcessingException, BindException {
        final ReportingSystemPropertiesImpl config = new ReportingSystemPropertiesImpl();
        config.setIrisVendorId("IRIS");
        final String output = ymlMapper.writeValueAsString(config);
        System.out.println(output);

        final ReportingSystemPropertiesImpl reporting = buildFromYaml(new ReportingSystemPropertiesImpl(), output);
        assertThat(reporting.getIrisVendorId()).isEqualTo("IRIS");
    }

    @Test
    public void itShouldReadAssessmentTypes() throws BindException {
        // This was a reported bug in QA.
        // NOTE: the solution (switching from immutable Set to mutable List) means that we lose
        //       the deduplication behavior of the set. Fortunately, we use Jackson YAML to write
        //       the configuration so it generally won't be a problem.
        final String yaml =
                "aggregateReporting:\n" +
                        "  tenants:\n" +
                        "    TS_S002:\n" +
                        "      assessmentTypes:\n" +
                        "        - \"sum\"\n" +
                        "        - \"iab\"\n" +
                        "        - \"sum\"";

        final ApplicationTenantConfigurationPersistence out =
                buildFromYaml(new ApplicationTenantConfigurationPersistence(), yaml);
        assertThat(out.getAggregateReporting().get("tenants").get("TS_S002").getAssessmentTypes())
                .containsExactlyInAnyOrder("sum", "iab", "sum");
    }

    private TenantConfiguration tenantConfiguration() {
        final ReportingSystemPropertiesImpl reporting = new ReportingSystemPropertiesImpl();
        reporting.setIrisVendorId("IRIS");

        final AggregateReportingPropertiesTenant aggregate = new AggregateReportingPropertiesTenant();
        aggregate.setAssessmentTypes(ImmutableSet.of("sum", "iab"));

        // TODO - add more data to test stuff
        ArtClientPropertiesTenant artClientPropertiesTenant = new ArtClientPropertiesTenant();
        ResourceOwnerPasswordResourceDetails oauth2 = new ResourceOwnerPasswordResourceDetails();
        oauth2.setUsername("testOauthUser");
        oauth2.setPassword("testOauthUserPass");
        artClientPropertiesTenant.setOauth2(oauth2);

        return TenantConfiguration.builder()
                .tenant(Tenant.builder().id("XX").key("XX").name("Test").build())
                .reporting(reporting)
                .aggregateReportingProperties(aggregate)
                .artClient(artClientPropertiesTenant)
                .build();
    }


    // this emulates how Spring populates an object from properties
    private <T> T buildFromYaml(final T object, final String yaml) throws BindException {
        final MutablePropertySources propertySources = new MutablePropertySources();
        propertySources.addLast(new PropertiesPropertySource("properties", loadYamlIntoProperties(yaml)));

        final PropertiesConfigurationFactory<T> configurationFactory = new PropertiesConfigurationFactory<>(object);
        configurationFactory.setPropertySources(propertySources);
        configurationFactory.bindPropertiesToTarget();

        return object;
    }

    private Properties loadYamlIntoProperties(final String yaml) {
        final Resource resource = new InputStreamResource(new ByteArrayInputStream(yaml.getBytes(StandardCharsets.UTF_8)));
        final YamlPropertiesFactoryBean factory = new YamlPropertiesFactoryBean();
        factory.setResources(resource);
        factory.afterPropertiesSet();
        return factory.getObject();
    }
}
