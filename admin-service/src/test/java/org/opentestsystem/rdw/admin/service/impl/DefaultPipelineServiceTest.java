package org.opentestsystem.rdw.admin.service.impl;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.opentestsystem.rdw.admin.model.Pipeline;
import org.opentestsystem.rdw.admin.model.PipelineScript;
import org.opentestsystem.rdw.admin.model.PipelineTest;
import org.opentestsystem.rdw.admin.model.PipelineTestResult;
import org.opentestsystem.rdw.admin.model.PipelineTestRun;
import org.opentestsystem.rdw.admin.repository.PipelineRepository;
import org.opentestsystem.rdw.admin.repository.PipelineScriptRepository;
import org.opentestsystem.rdw.admin.repository.PipelineTestRepository;
import org.opentestsystem.rdw.admin.service.PipelineOutputComparisonService;
import org.opentestsystem.rdw.script.PipelineFactory;
import org.opentestsystem.rdw.script.PipelineScriptDefinition;
import org.opentestsystem.rdw.script.PipelineScriptType;
import org.opentestsystem.rdw.script.ScriptError;
import org.opentestsystem.rdw.script.ScriptSource;
import org.opentestsystem.rdw.script.publishing.PublishedPipelineRepository;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.Optional;

import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class DefaultPipelineServiceTest {

    @Mock
    private PipelineRepository pipelineRepository;

    @Mock
    private PipelineScriptRepository pipelineScriptRepository;

    @Mock
    private PipelineTestRepository pipelineTestRepository;

    @Mock
    private PublishedPipelineRepository publishedPipelineRepository;

    @Mock
    private PipelineFactory pipelineFactory;

    @Mock
    private PipelineOutputComparisonService pipelineOutputComparisionService;

    @Mock
    private ScriptSource scriptSource;

    @Mock
    private org.opentestsystem.rdw.script.Pipeline developmentPipeline;

    @Autowired
    private DefaultPipelineService service;

    @Before
    public void before() {
        service = new DefaultPipelineService(
                pipelineRepository,
                pipelineScriptRepository,
                pipelineTestRepository,
                publishedPipelineRepository,
                pipelineFactory,
                pipelineOutputComparisionService,
                scriptSource
        );
    }

    @Test
    public void compileShouldCatchWhenThereIsNoBaseScript() {
        final Pipeline pipeline = pipeline().build();
        when(pipelineRepository.findById(pipeline.getId())).thenReturn(pipeline);
        when(scriptSource.getScript(PipelineScriptType.Base, pipeline.getCode()))
                .thenReturn(Optional.empty());

        assertThat(service.compile(pipeline.getId(), "anything"))
                .usingRecursiveFieldByFieldElementComparator()
                .containsExactly(
                        new ScriptError("Compilation failed. Please see logs for details")
                );
    }

    @Test
    public void compileShouldCatchWhenThereIsAClassCastException() {
        final Pipeline pipeline = pipeline().build();
        when(pipelineRepository.findById(pipeline.getId())).thenReturn(pipeline);
        when(scriptSource.getScript(PipelineScriptType.Base, pipeline.getCode()))
                .thenReturn(Optional.of(
                        PipelineScriptDefinition.builder()
                                .type(PipelineScriptType.Base)
                                .body("base")
                                .build()
                ));

        assertThat(service.compile(pipeline.getId(), "public class HelloWorld {}"))
                .usingRecursiveFieldByFieldElementComparator()
                .containsExactly(
                        new ScriptError("Compilation failed. Please see logs for details")
                );
    }

    @Test
    public void compileShouldCatchWhenThereIsAGroovyScriptCompilationIssue() {
        final Pipeline pipeline = pipeline().build();
        when(pipelineRepository.findById(pipeline.getId())).thenReturn(pipeline);
        when(scriptSource.getScript(PipelineScriptType.Base, pipeline.getCode()))
                .thenReturn(Optional.of(
                        PipelineScriptDefinition.builder()
                                .type(PipelineScriptType.Base)
                                .body("base")
                                .build()
                ));

        assertThat(service.compile(pipeline.getId(), "return 'xxx")).hasSize(1);
    }

    @Test
    public void testShouldHandlePipelineRuntimeExceptions() {

        final Pipeline pipeline = pipeline().build();

        final PipelineScript script = PipelineScript.builder()
                .body("body")
                .build();

        final PipelineTest test = PipelineTest.builder()
                .input("in")
                .build();

        final String exceptionMessage = "BOOM!";

        when(pipelineRepository.findById(pipeline.getId())).thenReturn(pipeline);
        when(pipelineScriptRepository.findAllByPipeline(pipeline.getId()))
                .thenReturn(newArrayList(
                        script
                ));
        when(pipelineTestRepository.findAllByPipeline(pipeline.getId()))
                .thenReturn(newArrayList(
                        test
                ));

        when(pipelineFactory.getDevelopmentPipeline(pipeline.getCode(), pipeline.getActiveVersion(), script.getBody()))
                .thenReturn(developmentPipeline);

        when(developmentPipeline.run(test.getInput()))
                .thenThrow(new RuntimeException(exceptionMessage));

        assertThat(service.test(pipeline.getId()))
                .usingRecursiveFieldByFieldElementComparator()
                .containsExactly(
                        PipelineTestRun.builder()
                                .test(test)
                                .result(PipelineTestResult.failedWithScriptError(
                                        new ScriptError(exceptionMessage)
                                ))
                                .build()
                );
    }

    private static Pipeline.Builder pipeline() {
        return Pipeline.builder()
                .id(1)
                .code("code")
                .inputType("xml");
    }

}
