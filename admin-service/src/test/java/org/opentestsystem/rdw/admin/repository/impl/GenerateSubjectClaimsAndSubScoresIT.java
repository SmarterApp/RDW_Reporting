package org.opentestsystem.rdw.admin.repository.impl;

import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import com.fasterxml.jackson.datatype.guava.GuavaModule;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.Multimap;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.opentestsystem.rdw.admin.repository.RepositoryIT;
import org.opentestsystem.rdw.reporting.common.subject.model.AssessmentType;
import org.opentestsystem.rdw.reporting.common.subject.model.Category;
import org.opentestsystem.rdw.reporting.common.subject.model.ItemClaim;
import org.opentestsystem.rdw.reporting.common.subject.model.PerformanceLevel;
import org.opentestsystem.rdw.reporting.common.subject.model.ReportClaim;
import org.opentestsystem.rdw.reporting.common.subject.model.ReportGrade;
import org.opentestsystem.rdw.reporting.common.subject.model.ReportPerformanceLevel;
import org.opentestsystem.rdw.reporting.common.subject.model.Standard;
import org.opentestsystem.rdw.reporting.common.subject.model.SubScore;
import org.opentestsystem.rdw.reporting.common.subject.model.SubScoring;
import org.opentestsystem.rdw.reporting.common.subject.model.Subject;
import org.opentestsystem.rdw.reporting.common.subject.model.Target;
import org.opentestsystem.rdw.reporting.common.subject.model.TertiaryScore;
import org.opentestsystem.rdw.reporting.common.subject.model.jackson.SubjectModule;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.core.io.support.PropertiesLoaderUtils;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.util.StringUtils.isEmpty;

@RunWith(SpringRunner.class)
@RepositoryIT
@Transactional(transactionManager = "warehouseTxManager")
public class GenerateSubjectClaimsAndSubScoresIT {

    private static final Map<Integer, Map<String, String>> IconMap = ImmutableMap.<Integer, Map<String, String>>builder()
            .put(1, ImmutableMap.<String, String>builder()
                    .put("1", "fa-book")
                    .put("SOCK_2", "fa-edit")
                    .put("3", "fa-question")
                    .build())
            .put(2, ImmutableMap.<String, String>builder()
                    .put("SOCK_R", "fa-book")
                    .put("2-W", "fa-edit")
                    .put("SOCK_LS", "fa-lightbulb-o")
                    .put("4-CR", "fa-question")
                    .build())
            .build();

    private static final List<String> ELASubScoreOrder = newArrayList("SOCK_R", "SOCK_LS", "2-W", "4-CR");
    private static final List<String> MathSubScoreOrder = newArrayList("1", "SOCK_2", "3");

    private static final Multimap<String, String> ELASubScoreClaimMap = ImmutableMultimap.<String, String>builder()
            .put("SOCK_R", "1-IT")
            .put("SOCK_R", "1-LT")
            .put("2-W", "2-W")
            .put("SOCK_LS", "3-L")
            .put("SOCK_LS", "3-S")
            .put("4-CR", "4-CR")
            .build();

    private static final Multimap<String, String> MathSubScoreClaimMap = ImmutableMultimap.<String, String>builder()
            .put("1", "1")
            .put("SOCK_2", "2")
            .put("SOCK_2", "4")
            .put("3", "3")
            .build();

    @Autowired
    @Qualifier("warehouseJdbcTemplate")
    NamedParameterJdbcTemplate template;

    private XmlMapper objectMapper;
    private Properties messagesProperties;
    private List<String> gradeCodes;

    @Before
    public void setup() throws Exception {
        objectMapper = new XmlMapper();
        objectMapper.enable(SerializationFeature.INDENT_OUTPUT);
        objectMapper.registerModules(new SubjectModule(), new GuavaModule());

        messagesProperties = PropertiesLoaderUtils.loadAllProperties("messages.properties");

        gradeCodes = loadGradeCodes();
    }

    @Test
    public void createMathSubject() throws Exception {
        final int subjectId = 1;

        final Subject.Builder subjectBuilder = Subject.builder()
                .name("Math")
                .code("Math")
                .commonCoreStandardDescription("This column reflects the Common Core State Standard(s) associated with a test item. Test items may be associated with more than one standard.  Items that assess mathematical practices (problem solving, modeling and data analysis, and communicating reasoning) are also aligned to standards that describe the mathematical content with which students engage. For example, an item may ask students to communicate their reasoning when solving a problem about geometry or fractions. For more information, see the <a href=\\\"https://portal.smarterbalanced.org/library/en/mathematics-content-specifications.pdf\\\" target=\\\"_blank\\\">Mathematics Content Specifications</a>.");

        //Load claims and targets
        final List<Category> categories = newArrayList();
        categories.add(Category.builder()
                .code("1")
                .name("Concepts & Procedures")
                .displayOrder(1)
                .icon("fa-book")
                .categories(fetchTargets(subjectId, "1"))
                .build());
        categories.add(Category.builder()
                .code("SOCK_2")
                .name("Problem Solving & Modeling / Data Analysis")
                .displayOrder(2)
                .icon("fa-edit")
                .categories(ImmutableList.of(
                        Category.builder()
                                .code("2")
                                .name("Problem Solving")
                                .categories(fetchTargets(subjectId, "2"))
                                .build(),
                        Category.builder()
                                .code("4")
                                .name("Modeling and Data Analysis")
                                .categories(fetchTargets(subjectId, "4"))
                                .build()))
                .build());
        categories.add(Category.builder()
                .code("3")
                .name("Communicating Reasoning")
                .displayOrder(3)
                .icon("fa-question")
                .categories(fetchTargets(subjectId, "3"))
                .build());
        subjectBuilder.categories(categories);

        //Load assessment types and sub-scores
        final Map<Integer, AssessmentType.Builder> assessmentTypes = fetchAssessmentTypes();
        final Map<Integer, Map<String, SubScore.Builder>> subScores = fetchSubScores(subjectId);

        for (final Map.Entry<Integer, AssessmentType.Builder> assessmentType : assessmentTypes.entrySet()) {
            final Map<String, SubScore.Builder> subScoreBuilders = subScores.get(assessmentType.getKey());
            if (subScoreBuilders == null) continue;

            final SubScoring subScoring = SubScoring.builder()
                    .subScorePerformanceLevels(ImmutableList.of(
                            performanceLevel(1, "Below Standard"),
                            performanceLevel(2, "Near Standard"),
                            performanceLevel(3, "Above Standard")))
                    .build();

            assessmentType.getValue().subScoring(subScoring);
        }
        subjectBuilder.assessmentTypes(assessmentTypes.values().stream()
                .map(AssessmentType.Builder::build)
                .collect(Collectors.toList()));

        //Load report messages
        final Collection<String> claimCodes = subScores.get(1).keySet();
        subjectBuilder.reportGrades(getReportGrades("MATH", claimCodes));

        //Load standards
        subjectBuilder.standards(getStandards(subjectId));

        //Build and export subject xml
        final Subject subject = subjectBuilder.build();
        final String subjectXML = objectMapper.writeValueAsString(subject);
        assertThat(subjectXML).isNotEmpty();
    }

    @Test
    public void createELASubject() throws Exception {
        final int subjectId = 2;

        final Subject.Builder subjectBuilder = Subject.builder()
                .name("ELA")
                .code("ELA")
                .commonCoreStandardDescription("This column reflects the Common Core State Standard(s) associated with a test item. Test items may be associated with more than one standard.  For example, a question that asks students to evaluate research sources may assess both reading and research skills.  For more information, see the <a href=\\\"https://portal.smarterbalanced.org/library/en/english-language-artsliteracy-content-specifications.pdf\\\" target=\\\"_blank\\\">English Language Arts Content Specifications</a>.");

        //Load claims and targets
        final List<Category> categories = newArrayList();
        categories.add(Category.builder()
                .code("SOCK_R")
                .name("Reading")
                .displayOrder(1)
                .icon("fa-book")
                .categories(ImmutableList.of(
                        Category.builder()
                                .code("1-LT")
                                .name("Literary Text")
                                .categories(fetchTargets(subjectId, "1-LT"))
                                .build(),
                        Category.builder()
                                .code("1-IT")
                                .name("Informational Text")
                                .categories(fetchTargets(subjectId, "1-IT"))
                                .build()))
                .build());
        categories.add(Category.builder()
                .code("SOCK_LS")
                .name("Listening")
                .displayOrder(2)
                .icon("fa-lightbulb-o")
                .categories(ImmutableList.of(
                        Category.builder()
                                .code("3-S")
                                .name("Listening")
                                .categories(fetchTargets(subjectId, "3-S"))
                                .build(),
                        Category.builder()
                                .code("3-L")
                                .name("Listening")
                                .categories(fetchTargets(subjectId, "3-L"))
                                .build()))
                .build());
        categories.add(Category.builder()
                .code("2-W")
                .name("Writing")
                .displayOrder(3)
                .icon("fa-edit")
                .categories(fetchTargets(subjectId, "2-W"))
                .build());
        categories.add(Category.builder()
                .code("4-CR")
                .name("Research & Inquiry")
                .displayOrder(4)
                .icon("fa-question")
                .categories(fetchTargets(subjectId, "4-CR"))
                .build());
        subjectBuilder.categories(categories);

        //Load assessment types and sub-scores
        final Map<Integer, AssessmentType.Builder> assessmentTypes = fetchAssessmentTypes();
        final Map<Integer, Map<String, SubScore.Builder>> subScores = fetchSubScores(subjectId);

        for (final Map.Entry<Integer, AssessmentType.Builder> assessmentType : assessmentTypes.entrySet()) {
            final Map<String, SubScore.Builder> subScoreBuilders = subScores.get(assessmentType.getKey());
            if (subScoreBuilders == null) continue;

            final SubScoring subScoring = SubScoring.builder()
                    .subScorePerformanceLevels(ImmutableList.of(
                            performanceLevel(1, "Below Standard"),
                            performanceLevel(2, "Near Standard"),
                            performanceLevel(3, "Above Standard")))
                    .build();

            assessmentType.getValue().subScoring(subScoring);
        }
        subjectBuilder.assessmentTypes(assessmentTypes.values().stream()
                .map(AssessmentType.Builder::build)
                .collect(Collectors.toList()));

        //Load report messages
        final Collection<String> claimCodes = subScores.get(1).keySet();
        subjectBuilder.reportGrades(getReportGrades("ELA", claimCodes));

        //Load standards
        subjectBuilder.standards(getStandards(subjectId));

        //Build and export subject xml
        final Subject subject = subjectBuilder.build();
        final String subjectXML = objectMapper.writeValueAsString(subject);
        assertThat(subjectXML).isNotEmpty();
    }

    private List<Standard> getStandards(final int subjectId) {
        return template.query(
                "SELECT * from common_core_standard WHERE subject_id = :subjectId ORDER BY natural_id",
                new MapSqlParameterSource()
                        .addValue("subjectId", subjectId),
                (row, rowNum) -> Standard.builder()
                            .code(row.getString("natural_id"))
                            .description(row.getString("description"))
                            .build());
    }

    private List<ReportGrade> getReportGrades(final String subjectKey, final Collection<String> claimCodes) {
        final List<ReportGrade> reportGrades = newArrayList();
        for (final String gradeCode : gradeCodes) {
            final String overall = messagesProperties.getProperty(String.format("report.overall-achievement.grade.%s.subject.%s", gradeCode, subjectKey));
            if (isEmpty(overall)) continue;

            final ReportGrade.Builder gradeBuilder = ReportGrade.builder()
                    .overallAchievementMessage(overall)
                    .claimAchievementMessage(messagesProperties.getProperty(String.format("report.student-achievement-by-claim.grade.%s.subject.%s", gradeCode, subjectKey)))
                    .code(gradeCode);

            //Append overall performance level messages
            final List<ReportPerformanceLevel> performanceLevels = newArrayList();
            for (int level = 1;; level++) {
                final String levelMessage = messagesProperties.getProperty(String.format("report.overall-achievement.grade.%s.subject.%s.level.%d", gradeCode, subjectKey, level));
                if (isEmpty(levelMessage)) break;

                performanceLevels.add(ReportPerformanceLevel.builder().level(level).description(levelMessage).build());
            }
            gradeBuilder.reportPerformanceLevels(performanceLevels);

            //Append claim performance level messages
            final List<ReportClaim> claims = newArrayList();
            for (final String claimCode : claimCodes) {
                final List<ReportPerformanceLevel> claimPerformanceLevels = newArrayList();
                for (int level = 1;; level++) {
                    final String levelMessage = messagesProperties.getProperty(String.format("report.claim.%s.grade.%s.level.%d", claimCode, gradeCode, level));
                    if (isEmpty(levelMessage)) break;

                    claimPerformanceLevels.add(ReportPerformanceLevel.builder().level(level).description(levelMessage).build());
                }
                claims.add(ReportClaim.builder()
                        .code(claimCode)
                        .performanceLevels(claimPerformanceLevels)
                        .build());
            }
            gradeBuilder.reportClaims(claims);

            reportGrades.add(gradeBuilder.build());
        }

        return reportGrades;
    }

    private void appendTertiaryScores(final SubScore.Builder subScore, final int subjectId, final Collection<String> claimCodes) {
        final List<TertiaryScore> tertiaryScores = newArrayList();
        template.query(
                "SELECT target.* from target " +
                        "JOIN claim ON claim.id = target.claim_id " +
                        "where claim.subject_id = :subjectId " +
                        "AND claim.code IN (:claimCodes)" +
                        "ORDER BY target.code",
                new MapSqlParameterSource()
                        .addValue("subjectId", subjectId)
                        .addValue("claimCodes", claimCodes),
                (row) -> {
                    final TertiaryScore tertiaryScore = TertiaryScore.builder()
                            .code(row.getString("natural_id"))
                            .name(row.getString("code"))
                            .description(row.getString("description"))
                            .build();
                    tertiaryScores.add(tertiaryScore);
                });
        subScore.tertiaryScores(tertiaryScores);
    }

    private Map<Integer, ItemClaim> fetchClaims(final int subjectId) {
        final Map<Integer, ItemClaim.Builder> claims = newHashMap();
        template.query(
                "SELECT * from claim where subject_id = :subjectId",
                new MapSqlParameterSource()
                        .addValue("subjectId", subjectId),
                (row) -> {
                    final Integer id = row.getInt("id");
                    final ItemClaim.Builder builder = ItemClaim.builder()
                            .code(row.getString("code"))
                            .name(row.getString("name"))
                            .description(row.getString("description"));
                    claims.put(id, builder);
                });

        for (final Map.Entry<Integer, ItemClaim.Builder> claim : claims.entrySet()) {
            final List<Target> targets = newArrayList();
            template.query(
                    "SELECT natural_id, code, description from target " +
                            "where claim_id = :claimId " +
                            "ORDER BY code",
                    new MapSqlParameterSource()
                            .addValue("claimId", claim.getKey()),
                    (row) -> {
                        final Target target = Target.builder()
                                .code(row.getString("natural_id"))
                                .name(row.getString("code"))
                                .description(row.getString("description"))
                                .build();
                        targets.add(target);
                    });
            claim.getValue().targets(targets);
        }

        return claims.entrySet().stream()
                .collect(Collectors.toMap(
                        Map.Entry::getKey,
                        entry -> entry.getValue().build()
                ));
    }

    private List<Category> fetchTargets(final int subjectId, final String claimCode) {
        return template.query(
                "SELECT t.natural_id, t.code, t.description FROM target t " +
                        "JOIN claim c ON c.id = t.claim_id " +
                        "WHERE c.code = :claimCode " +
                        "AND c.subject_id = :subjectId " +
                        "ORDER BY t.code",
                new MapSqlParameterSource()
                        .addValue("subjectId", subjectId)
                        .addValue("claimCode", claimCode),
                (row, rowNum) -> Category.builder()
                            .code(row.getString("natural_id"))
                            .name(row.getString("code"))
                            .description(row.getString("description"))
                            .build());
    }

    private Map<Integer, AssessmentType.Builder> fetchAssessmentTypes() {
        final Map<Integer, AssessmentType.Builder> assessmentTypes = newHashMap();

        assessmentTypes.put(2, AssessmentType.builder()
                .code("iab")
                .performanceLevels(ImmutableList.of(
                        performanceLevel(1, "Below Standard"),
                        performanceLevel(2, "Near Standard"),
                        performanceLevel(3, "Above Standard")))
        );
        assessmentTypes.put(1, AssessmentType.builder()
                .code("ica")
                .performanceLevels(ImmutableList.of(
                        performanceLevel(1, "Did Not Meet Standard"),
                        performanceLevel(2, "Nearly Met Standard"),
                        performanceLevel(3, "Met Standard", true),
                        performanceLevel(4, "Exceeded Standard")))
        );

        assessmentTypes.put(3, AssessmentType.builder()
                .code("sum")
                .performanceLevels(ImmutableList.of(
                        performanceLevel(1, "Did Not Meet Standard"),
                        performanceLevel(2, "Nearly Met Standard"),
                        performanceLevel(3, "Met Standard", true),
                        performanceLevel(4, "Exceeded Standard")))
        );

        return assessmentTypes;
    }

    private Map<Integer, Map<String, SubScore.Builder>> fetchSubScores(final int subjectId) {
        final Map<Integer, Map<String, SubScore.Builder>> subScores = newHashMap();
        template.query(
                "SELECT * from subject_claim_score where subject_id = :subjectId",
                new MapSqlParameterSource()
                        .addValue("subjectId", subjectId),
                (row) -> {
                    final Integer asmtType = row.getInt("asmt_type_id");
                    final Map<String, SubScore.Builder> builderMap = subScores.computeIfAbsent(asmtType, key -> newHashMap());
                    final SubScore.Builder builder = SubScore.builder()
                            .code(row.getString("code"))
                            .name(row.getString("name"))
                            .icon(getIcon(subjectId, row.getString("code")));
                    builderMap.put(row.getString("code"), builder);
                });
        return subScores;
    }

    private List<String> loadGradeCodes() {
        return template.queryForList(
                "SELECT code from grade order by id",
                new MapSqlParameterSource(),
                String.class);
    }

    private PerformanceLevel performanceLevel(final int level, final String name) {
        return performanceLevel(level, name, false);
    }

    private PerformanceLevel performanceLevel(final int level, final String name, final boolean rollup) {
        return PerformanceLevel.builder()
                .level(level)
                .name(name)
                .rollup(rollup)
                .build();
    }

    private String getIcon(final int subjectId, final String subScoreCode) {
        return IconMap.get(subjectId).get(subScoreCode);
    }

}
