package org.opentestsystem.rdw.admin.repository.impl;

import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import com.fasterxml.jackson.datatype.guava.GuavaModule;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.Multimap;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.opentestsystem.rdw.admin.repository.RepositoryIT;
import org.opentestsystem.rdw.reporting.common.i18n.JsonResourceTranslationProvider;
import org.opentestsystem.rdw.reporting.common.subject.model.AssessmentType;
import org.opentestsystem.rdw.reporting.common.subject.model.DepthOfKnowledge;
import org.opentestsystem.rdw.reporting.common.subject.model.ItemClaim;
import org.opentestsystem.rdw.reporting.common.subject.model.ItemDifficulty;
import org.opentestsystem.rdw.reporting.common.subject.model.PerformanceLevel;
import org.opentestsystem.rdw.reporting.common.subject.model.PerformanceLevels;
import org.opentestsystem.rdw.reporting.common.subject.model.ReportAssessmentType;
import org.opentestsystem.rdw.reporting.common.subject.model.ReportCategory;
import org.opentestsystem.rdw.reporting.common.subject.model.ReportGrade;
import org.opentestsystem.rdw.reporting.common.subject.model.ReportPerformanceLevel;
import org.opentestsystem.rdw.reporting.common.subject.model.Standard;
import org.opentestsystem.rdw.reporting.common.subject.model.SubScoring;
import org.opentestsystem.rdw.reporting.common.subject.model.Subject;
import org.opentestsystem.rdw.reporting.common.subject.model.SubjectMessage;
import org.opentestsystem.rdw.reporting.common.subject.model.Target;
import org.opentestsystem.rdw.reporting.common.subject.model.jackson.SubjectModule;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.core.io.DefaultResourceLoader;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collection;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.util.StringUtils.isEmpty;

@RunWith(SpringRunner.class)
@RepositoryIT
@Transactional(transactionManager = "warehouseTxManager")
public class GenerateSubjectClaimsAndSubScoresIT {

    private static final Map<Integer, Map<String, String>> IconMap = ImmutableMap.<Integer, Map<String, String>>builder()
            .put(1, ImmutableMap.<String, String>builder()
                    .put("1", "fa-book")
                    .put("SOCK_2", "fa-edit")
                    .put("3", "fa-question")
                    .build())
            .put(2, ImmutableMap.<String, String>builder()
                    .put("SOCK_R", "fa-book")
                    .put("2-W", "fa-edit")
                    .put("SOCK_LS", "fa-lightbulb-o")
                    .put("4-CR", "fa-question")
                    .build())
            .build();

    private static final List<String> ELASubScoreOrder = newArrayList("SOCK_R", "SOCK_LS", "2-W", "4-CR");
    private static final List<String> MathSubScoreOrder = newArrayList("1", "SOCK_2", "3");

    private static final Multimap<String, String> ELASubScoreClaimMap = ImmutableMultimap.<String, String>builder()
            .put("SOCK_R", "1-IT")
            .put("SOCK_R", "1-LT")
            .put("2-W", "2-W")
            .put("SOCK_LS", "3-L")
            .put("SOCK_LS", "3-S")
            .put("4-CR", "4-CR")
            .build();

    private static final Multimap<String, String> MathSubScoreClaimMap = ImmutableMultimap.<String, String>builder()
            .put("1", "1")
            .put("SOCK_2", "2")
            .put("SOCK_2", "4")
            .put("3", "3")
            .build();

    @Autowired
    @Qualifier("warehouseJdbcTemplate")
    NamedParameterJdbcTemplate template;

    private XmlMapper objectMapper;
    private Map<String, String> messages;
    private List<String> gradeCodes;

    @Before
    public void setup() throws Exception {
        objectMapper = new XmlMapper();
        objectMapper.enable(SerializationFeature.INDENT_OUTPUT);
        objectMapper.registerModules(new SubjectModule(), new GuavaModule());

        final JsonResourceTranslationProvider messageProvider = new JsonResourceTranslationProvider("classpath:/i18n/", new DefaultResourceLoader());
        messages = messageProvider.getTranslationsByCode(Locale.US);

        gradeCodes = loadGradeCodes();
    }

    @Test
    public void createMathSubject() throws Exception {
        final int subjectId = 1;

        final Subject.Builder subjectBuilder = Subject.builder()
                .name("Math")
                .code("Math")
                .subjectMessages(ImmutableList.of(
                        SubjectMessage.builder()
                                .key("standard-description")
                                .value("This column reflects the Common Core State Standard(s) associated with a test item. Test items may be associated with more than one standard.  Items that assess mathematical practices (problem solving, modeling and data analysis, and communicating reasoning) are also aligned to standards that describe the mathematical content with which students engage. For example, an item may ask students to communicate their reasoning when solving a problem about geometry or fractions. For more information, see the <a href=\\\"https://portal.smarterbalanced.org/library/en/mathematics-content-specifications.pdf\\\" target=\\\"_blank\\\">Mathematics Content Specifications</a>.")
                                .build()));

        //Load claims and targets
        final List<ItemClaim> claims = newArrayList(fetchClaims(subjectId).values());
        subjectBuilder.claims(claims);

        //Add Depths of Knowledge
        subjectBuilder.depthsOfKnowledge(getDepthsOfKnowledge(subjectId));

        //Add Item Difficulty cutpoints
        subjectBuilder.itemDifficulties(getItemDifficulties(subjectId, 1));

        //Load assessment types and sub-scores
        final Map<Integer, AssessmentType.Builder> assessmentTypes = fetchAssessmentTypes();

        for (final Map.Entry<Integer, AssessmentType.Builder> assessmentType : assessmentTypes.entrySet()) {

            //No sub-scores on IABs
            if (assessmentType.getKey() == 2) continue;

            final SubScoring subScoring = SubScoring.builder()
                    .subScorePerformanceLevels(ImmutableList.of(
                            performanceLevel(1, "Below Standard", "aqua"),
                            performanceLevel(2, "Near Standard", "textured-blue"),
                            performanceLevel(3, "Above Standard", "blue-dark")))
                    .build();

            assessmentType.getValue().subScoring(subScoring);
        }
        subjectBuilder.assessmentTypes(assessmentTypes.values().stream()
                .map(AssessmentType.Builder::build)
                .collect(Collectors.toList()));

        //Load report messages
        final Collection<String> claimCodes = claims.stream()
                .filter(ItemClaim::isScorable)
                .map(ItemClaim::getCode)
                .collect(Collectors.toList());
        subjectBuilder.reportGrades(getReportGrades("MATH", claimCodes));

        //Load standards
        subjectBuilder.standards(getStandards(subjectId));

        //Build and export subject xml
        final Subject subject = subjectBuilder.build();
        final String subjectXML = objectMapper.writeValueAsString(subject);
        assertThat(subjectXML).isNotEmpty();
    }

    @Test
    public void createELASubject() throws Exception {
        final int subjectId = 2;

        final Subject.Builder subjectBuilder = Subject.builder()
                .name("ELA")
                .code("ELA")
                .subjectMessages(ImmutableList.of(
                        SubjectMessage.builder()
                                .key("standard-description")
                                .value("This column reflects the Common Core State Standard(s) associated with a test item. Test items may be associated with more than one standard.  For example, a question that asks students to evaluate research sources may assess both reading and research skills.  For more information, see the <a href=\\\"https://portal.smarterbalanced.org/library/en/english-language-artsliteracy-content-specifications.pdf\\\" target=\\\"_blank\\\">English Language Arts Content Specifications</a>.")
                                .build()));

        //Load claims and targets
        final List<ItemClaim> claims = newArrayList(fetchClaims(subjectId).values());
        subjectBuilder.claims(claims);

        //Add Depths of Knowledge
        subjectBuilder.depthsOfKnowledge(getDepthsOfKnowledge(subjectId));

        //Add Item Difficulty cutpoints
        subjectBuilder.itemDifficulties(getItemDifficulties(subjectId, 1));

        //Load assessment types and sub-scores
        final Map<Integer, AssessmentType.Builder> assessmentTypes = fetchAssessmentTypes();

        for (final Map.Entry<Integer, AssessmentType.Builder> assessmentType : assessmentTypes.entrySet()) {

            //No sub-scores on IABs
            if (assessmentType.getKey() == 2) continue;

            final SubScoring subScoring = SubScoring.builder()
                    .subScorePerformanceLevels(ImmutableList.of(
                            performanceLevel(1, "Below Standard", "aqua"),
                            performanceLevel(2, "Near Standard", "textured-blue"),
                            performanceLevel(3, "Above Standard", "blue-dark")))
                    .build();

            assessmentType.getValue().subScoring(subScoring);
        }
        subjectBuilder.assessmentTypes(assessmentTypes.values().stream()
                .map(AssessmentType.Builder::build)
                .collect(Collectors.toList()));

        //Load report messages
        final Collection<String> claimCodes = claims.stream()
                .filter(ItemClaim::isScorable)
                .map(ItemClaim::getCode)
                .collect(Collectors.toList());
        subjectBuilder.reportGrades(getReportGrades("ELA", claimCodes));

        //Load standards
        subjectBuilder.standards(getStandards(subjectId));

        //Build and export subject xml
        final Subject subject = subjectBuilder.build();
        final String subjectXML = objectMapper.writeValueAsString(subject);
        assertThat(subjectXML).isNotEmpty();
    }

    private List<ItemDifficulty> getItemDifficulties(final int subjectId, final int assessmentTypeId) {
        return template.query(
                "SELECT d.*, g.code from item_difficulty_cuts d " +
                        "JOIN grade g ON g.id = d.grade_id " +
                        "WHERE d.subject_id = :subjectId " +
                        "AND d.asmt_type_id = :asmtType " +
                        "ORDER BY d.grade_id",
                new MapSqlParameterSource()
                        .addValue("subjectId", subjectId)
                        .addValue("asmtType", assessmentTypeId),
                (row, rowNum) -> ItemDifficulty.builder()
                        .gradeCode(row.getString("code"))
                        .moderateLowEnd(row.getDouble("moderate_low_end"))
                        .difficultLowEnd(row.getDouble("difficult_low_end"))
                        .build());
    }

    private List<DepthOfKnowledge> getDepthsOfKnowledge(final int subjectId) {
        return template.query(
                "SELECT * from depth_of_knowledge " +
                        "WHERE subject_id = :subjectId ORDER BY level",
                new MapSqlParameterSource()
                        .addValue("subjectId", subjectId),
                (row, rowNum) -> DepthOfKnowledge.builder()
                        .level(row.getInt("level"))
                        .name(row.getString("description"))
                        .reference(row.getString("reference"))
                        .build());
    }

    private List<Standard> getStandards(final int subjectId) {
        return template.query(
                "SELECT * from common_core_standard WHERE subject_id = :subjectId ORDER BY natural_id",
                new MapSqlParameterSource()
                        .addValue("subjectId", subjectId),
                (row, rowNum) -> Standard.builder()
                            .code(row.getString("natural_id"))
                            .description(row.getString("description"))
                            .build());
    }

    private List<ReportGrade> getReportGrades(final String subjectKey, final Collection<String> claimCodes) {
        final List<ReportGrade> reportGrades = newArrayList();
        for (final String gradeCode : gradeCodes) {
            final String overall = messages.get(String.format("report.overall-achievement.grade.%s.subject.%s.title", gradeCode, subjectKey));
            if (isEmpty(overall)) continue;

            final ReportAssessmentType.Builder asmtTypeBuilder = ReportAssessmentType.builder()
                    .overallAchievementMessage(overall)
                    .claimAchievementMessage(messages.get(String.format("report.student-achievement-by-claim.grade.%s.subject.%s", gradeCode, subjectKey)));

            //Append overall performance level messages
            final List<ReportPerformanceLevel> performanceLevels = newArrayList();
            for (int level = 1;; level++) {
                final String levelMessage = messages.get(String.format("report.overall-achievement.grade.%s.subject.%s.level.%d", gradeCode, subjectKey, level));
                if (isEmpty(levelMessage)) break;

                performanceLevels.add(ReportPerformanceLevel.builder().level(level).description(levelMessage).build());
            }
            asmtTypeBuilder.reportPerformanceLevels(performanceLevels);

            //Append claim performance level messages
            final List<ReportCategory> claims = newArrayList();
            for (final String claimCode : claimCodes) {
                final List<ReportPerformanceLevel> claimPerformanceLevels = newArrayList();
                for (int level = 1;; level++) {
                    final String levelMessage = messages.get(String.format("report.claim.%s.grade.%s.level.%d", claimCode, gradeCode, level));
                    if (isEmpty(levelMessage)) break;

                    claimPerformanceLevels.add(ReportPerformanceLevel.builder().level(level).description(levelMessage).build());
                }
                claims.add(ReportCategory.builder()
                        .code(claimCode)
                        .performanceLevels(claimPerformanceLevels)
                        .build());
            }
            asmtTypeBuilder.reportClaims(claims);

            reportGrades.add(ReportGrade.builder()
                    .code(gradeCode)
                    .reportAssessmentTypes(ImmutableList.of(
                            asmtTypeBuilder.code("ica").build(),
                            asmtTypeBuilder.code("sum").build()))
                    .build());
        }

        return reportGrades;
    }

    private Map<Integer, ItemClaim> fetchClaims(final int subjectId) {
        final Map<String, ItemClaim> scorableClaimsByCode = fetchScorableClaims(subjectId);
        final Map<Integer, ItemClaim.Builder> claimsById = newHashMap();
        template.query(
                "SELECT * from claim where subject_id = :subjectId",
                new MapSqlParameterSource()
                        .addValue("subjectId", subjectId),
                (row) -> {
                    final Integer id = row.getInt("id");
                    final String code = row.getString("code");
                    final ItemClaim.Builder builder = ItemClaim.builder()
                            .code(code)
                            .name(row.getString("name"))
                            .scorable(false)
                            .organizational(true)
                            .description(row.getString("description"));

                    final ItemClaim scorableClaim = scorableClaimsByCode.remove(code);
                    if (scorableClaim != null) {
                        builder.icon(scorableClaim.getIcon())
                                .displayOrder(scorableClaim.getDisplayOrder())
                                .scorable(true);
                    }

                    claimsById.put(id, builder);
                });

        int i = -1;
        for (final ItemClaim scorableClaim : scorableClaimsByCode.values()) {
            claimsById.putIfAbsent(i--, scorableClaim.copy());
        }

        for (final Map.Entry<Integer, ItemClaim.Builder> claim : claimsById.entrySet()) {
            if (claim.getKey() < 0) continue;

            final List<Target> targets = newArrayList();
            template.query(
                    "SELECT natural_id, code, description from target " +
                            "where claim_id = :claimId " +
                            "ORDER BY code",
                    new MapSqlParameterSource()
                            .addValue("claimId", claim.getKey()),
                    (row) -> {
                        final Target target = Target.builder()
                                .code(row.getString("natural_id"))
                                .name(row.getString("code"))
                                .description(row.getString("description"))
                                .build();
                        targets.add(target);
                    });
            claim.getValue().targets(targets);
        }

        return claimsById.entrySet().stream()
                .collect(Collectors.toMap(
                        Map.Entry::getKey,
                        entry -> entry.getValue().build()
                ));
    }

    private Map<Integer, AssessmentType.Builder> fetchAssessmentTypes() {
        final Map<Integer, AssessmentType.Builder> assessmentTypes = newHashMap();

        assessmentTypes.put(2, AssessmentType.builder()
                .code("iab")
                .performanceLevels(PerformanceLevels.builder()
                        .performanceLevels(ImmutableList.of(
                                performanceLevel(1, "Below Standard", "aqua"),
                                performanceLevel(2, "Near Standard", "textured-blue"),
                                performanceLevel(3, "Above Standard", "blue-dark")))
                        .build())
        );
        assessmentTypes.put(1, AssessmentType.builder()
                .code("ica")
                .performanceLevels(PerformanceLevels.builder()
                        .standardCutoff(3)
                        .performanceLevels(ImmutableList.of(
                                performanceLevel(1, "Did Not Meet Standard", "maroon"),
                                performanceLevel(2, "Nearly Met Standard", "gray-darkest"),
                                performanceLevel(3, "Met Standard", "green-dark"),
                                performanceLevel(4, "Exceeded Standard", "blue-dark")))
                        .build())
        );

        assessmentTypes.put(3, AssessmentType.builder()
                .code("sum")
                .performanceLevels(PerformanceLevels.builder()
                        .standardCutoff(3)
                        .performanceLevels(ImmutableList.of(
                                performanceLevel(1, "Did Not Meet Standard", "maroon"),
                                performanceLevel(2, "Nearly Met Standard", "gray-darkest"),
                                performanceLevel(3, "Met Standard", "green-dark"),
                                performanceLevel(4, "Exceeded Standard", "blue-dark")))
                        .build())
        );

        return assessmentTypes;
    }

    private Map<String, ItemClaim> fetchScorableClaims(final int subjectId) {
        final Map<String, ItemClaim> scorableClaims = newHashMap();
        template.query(
                "SELECT * from subject_claim_score where subject_id = :subjectId AND asmt_type_id = 1",
                new MapSqlParameterSource()
                        .addValue("subjectId", subjectId),
                (row) -> {
                    final ItemClaim.Builder builder = ItemClaim.builder()
                            .code(row.getString("code"))
                            .name(row.getString("name"))
                            .scorable(true)
                            .organizational(false)
                            .displayOrder(subjectId == 1
                                    ? MathSubScoreOrder.indexOf(row.getString("code")) + 1
                                    : ELASubScoreOrder.indexOf(row.getString("code")) + 1
                            )
                            .icon(getIcon(subjectId, row.getString("code")));
                    scorableClaims.put(row.getString("code"), builder.build());
                });
        return scorableClaims;
    }

    private List<String> loadGradeCodes() {
        return template.queryForList(
                "SELECT code from grade order by id",
                new MapSqlParameterSource(),
                String.class);
    }

    private PerformanceLevel performanceLevel(final int level, final String name, final String color) {
        return PerformanceLevel.builder()
                .level(level)
                .name(name)
                .color(color)
                .build();
    }

    private String getIcon(final int subjectId, final String subScoreCode) {
        return IconMap.get(subjectId).get(subScoreCode);
    }

}
