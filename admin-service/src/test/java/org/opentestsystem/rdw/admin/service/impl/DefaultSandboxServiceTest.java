package org.opentestsystem.rdw.admin.service.impl;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.junit.Before;
import org.junit.Test;

import org.opentestsystem.rdw.admin.model.ApplicationSandboxConfigurations;
import org.opentestsystem.rdw.admin.model.SandboxConfiguration;
import org.opentestsystem.rdw.admin.model.SandboxConfigurationStubs;
import org.opentestsystem.rdw.admin.model.TenantConfiguration;
import org.opentestsystem.rdw.admin.model.TenantConfigurationStubs;
import org.opentestsystem.rdw.admin.multitenant.SandboxDataSets;
import org.opentestsystem.rdw.admin.multitenant.TenantAdministrationStatus;
import org.opentestsystem.rdw.admin.multitenant.TenantAdministrationStatusService;
import org.opentestsystem.rdw.admin.repository.impl.InMemorySandboxConfigurationRepository;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.multitenant.TenantProperties;
import org.opentestsystem.rdw.reporting.common.configuration.AggregateReportingPropertiesTenant;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemProperties;
import org.opentestsystem.rdw.reporting.common.multitenant.ReportingTenantIdResolver;

import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.Set;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class DefaultSandboxServiceTest {
    private DefaultSandboxService service;

    private InMemorySandboxConfigurationRepository inMemorySandboxConfigurationRepository;
    private ReportingTenantIdResolver reportingTenantIdResolver;
    private DefaultTenantConfigPropsService defaultTenantConfigPropsService;
    private TenantProperties tenantProperties;
    private SandboxDataSets sandboxDataSets;
    private TenantAdministrationStatusService tenantAdministrationStatusService;

    @Before
    public void setup() {
        inMemorySandboxConfigurationRepository = mock(InMemorySandboxConfigurationRepository.class);
        reportingTenantIdResolver = mock(ReportingTenantIdResolver.class);
        defaultTenantConfigPropsService = mock(DefaultTenantConfigPropsService.class);
        tenantProperties = mock(TenantProperties.class);
        sandboxDataSets = mock(SandboxDataSets.class);
        tenantAdministrationStatusService = mock(TenantAdministrationStatusService.class);

        when(sandboxDataSets.getSandboxDatasets()).thenReturn(new ArrayList<>(SandboxConfigurationStubs.getDataSets()));
        when(reportingTenantIdResolver.getTenantId()).thenReturn(
                Optional.of(SandboxConfigurationStubs.getSandboxCAInfo().getKey()));
        service = new DefaultSandboxService(inMemorySandboxConfigurationRepository, reportingTenantIdResolver,
                defaultTenantConfigPropsService, tenantProperties, sandboxDataSets, tenantAdministrationStatusService);
    }

    @Test
    public void itShouldRetrieveAllSandboxes() {
        SandboxConfiguration sandboxConfigurationCa = SandboxConfigurationStubs.getCaInterimSandboxConfiguration();
        SandboxConfiguration sandboxConfigurationMi = SandboxConfigurationStubs.getMiInterimSandboxConfiguration();
        Set<SandboxConfiguration> sandboxConfigurations = ImmutableSet.of(sandboxConfigurationCa, sandboxConfigurationMi);
        when(inMemorySandboxConfigurationRepository.getAll()).thenReturn(sandboxConfigurations);

        when(defaultTenantConfigPropsService.getDefaultApplicationSandboxConfiguration())
                .thenReturn(SandboxConfigurationStubs.getApplicationSandboxConfigurationDefault().getApplicationSandboxConfiguration());
        when(tenantProperties.findTenantById(any())).thenReturn(Optional.of(TenantConfigurationStubs.getTenantCA()));
        when(tenantAdministrationStatusService.getTenants()).thenReturn(new HashMap<>());

        ApplicationSandboxConfigurations applicationSandboxConfigurations = service.getAll();

        verify(inMemorySandboxConfigurationRepository, times(2)).getAll();
        verify(defaultTenantConfigPropsService).getDefaultApplicationSandboxConfiguration();
        verify(tenantProperties).findTenantById(any());
        verify(sandboxDataSets).getSandboxDatasets();
        verify(tenantAdministrationStatusService).getTenants();

        assertThat(applicationSandboxConfigurations).isNotNull();
        assertThat(applicationSandboxConfigurations.getSandboxConfigurationPackage()).isNotNull();
        assertThat(applicationSandboxConfigurations.getSandboxes()).isNotEmpty();
        assertThat(applicationSandboxConfigurations.getSandboxes().size()).isEqualTo(2);
        assertThat(applicationSandboxConfigurations.getSandboxConfigurationPackage().getDataSets().size()).isEqualTo(SandboxConfigurationStubs.getDataSets().size());

        Optional<SandboxConfiguration> sandboxCa = getSandboxConfigurationFromKey(applicationSandboxConfigurations, sandboxConfigurationCa.getSandbox().getKey());
        assertThat(sandboxCa).isPresent();
        if (sandboxCa.isPresent()) {
            verifySandboxes(sandboxCa.get(), sandboxConfigurationCa);
        }

        Optional<SandboxConfiguration> sandboxMi = getSandboxConfigurationFromKey(applicationSandboxConfigurations, sandboxConfigurationMi.getSandbox().getKey());
        assertThat(sandboxMi).isPresent();
        if (sandboxMi.isPresent()) {
            verifySandboxes(sandboxMi.get(), sandboxConfigurationMi);
        }
    }

    @Test
    public void itShouldIncludeSandboxesInCreateStatus() {
        when(defaultTenantConfigPropsService.getDefaultApplicationSandboxConfiguration())
                .thenReturn(SandboxConfigurationStubs.getApplicationSandboxConfigurationDefault().getApplicationSandboxConfiguration());

        SandboxConfiguration sandboxConfigurationCa = SandboxConfigurationStubs.getCaInterimSandboxConfiguration();
        sandboxConfigurationCa.getSandbox().setCreated(Instant.now());
        SandboxConfiguration sandboxConfigurationMi = SandboxConfigurationStubs.getMiInterimSandboxConfiguration();
        sandboxConfigurationMi.getSandbox().setCreated(null);
        when(tenantProperties.findTenantById(sandboxConfigurationCa.getSandbox().getKey())).thenReturn(Optional.of(TenantConfigurationStubs.getTenantCA()));
        when(inMemorySandboxConfigurationRepository.getAll()).thenReturn(ImmutableSet.of(sandboxConfigurationCa, sandboxConfigurationMi));

        TenantConfiguration mockTenantCa = service.sandboxConfigurationToTenantConfiguration.apply(sandboxConfigurationCa);
        TenantConfiguration mockTenantMi = service.sandboxConfigurationToTenantConfiguration.apply(sandboxConfigurationMi);
        Map<String, Tenant> tenants = new HashMap<>();
        tenants.put(mockTenantCa.getTenant().getKey(), mockTenantCa.getTenant());
        tenants.put(mockTenantMi.getTenant().getKey(), mockTenantMi.getTenant());
        when(tenantProperties.getTenants()).thenReturn(ImmutableMap.copyOf(tenants));

        Map<String, TenantAdministrationStatus> statusTenantMap = new HashMap<>();
        statusTenantMap.put(sandboxConfigurationMi.getSandbox().getKey(), TenantAdministrationStatus.CREATING_DATABASES);
        when(tenantAdministrationStatusService.getTenants()).thenReturn(statusTenantMap);
        when(tenantAdministrationStatusService.findStatus(sandboxConfigurationMi.getSandbox().getKey())).thenReturn(Optional.of(ImmutablePair.of(TenantAdministrationStatus.CREATING_DATABASES, mockTenantMi)));

        ApplicationSandboxConfigurations applicationSandboxConfigurations = service.getAll();

        verify(inMemorySandboxConfigurationRepository, times(2)).getAll();
        verify(defaultTenantConfigPropsService).getDefaultApplicationSandboxConfiguration();
        verify(tenantProperties).findTenantById(any());
        verify(sandboxDataSets).getSandboxDatasets();
        verify(tenantAdministrationStatusService).getTenants();
        // make sure remove is called
        verify(tenantAdministrationStatusService).remove(sandboxConfigurationMi.getSandbox().getKey());
        // make sure with nothing in status map - .findStatus() should not be called
        verify(tenantAdministrationStatusService, times(0)).findStatus(mockTenantMi.getTenant().getKey());

        assertThat(applicationSandboxConfigurations).isNotNull();
        assertThat(applicationSandboxConfigurations.getSandboxConfigurationPackage()).isNotNull();
        assertThat(applicationSandboxConfigurations.getSandboxes()).isNotEmpty();
        assertThat(applicationSandboxConfigurations.getSandboxes().size()).isEqualTo(2);
        assertThat(applicationSandboxConfigurations.getSandboxConfigurationPackage().getDataSets().size()).isEqualTo(SandboxConfigurationStubs.getDataSets().size());

        Optional<SandboxConfiguration> sandboxCa = getSandboxConfigurationFromKey(applicationSandboxConfigurations, sandboxConfigurationCa.getSandbox().getKey());
        assertThat(sandboxCa).isPresent();
        if (sandboxCa.isPresent()) {
            assertThat(sandboxCa.get().getSandbox().getKey()).isEqualTo(sandboxConfigurationCa.getSandbox().getKey());
            assertThat(sandboxCa.get().getSandbox().getCreated()).isNotNull();
        }

        Optional<SandboxConfiguration> sandboxMi = getSandboxConfigurationFromKey(applicationSandboxConfigurations, sandboxConfigurationMi.getSandbox().getKey());
        assertThat(sandboxMi).isPresent();
        if (sandboxMi.isPresent()) {
            assertThat(sandboxMi.get().getSandbox().getKey()).isEqualTo(sandboxConfigurationMi.getSandbox().getKey());
            assertThat(sandboxMi.get().getSandbox().getCreated()).isNull();
        }
    }

    private Set<SandboxConfiguration> get2Sandboxes() {
        return ImmutableSet.of(SandboxConfigurationStubs.getCaInterimSandboxConfiguration(),
                SandboxConfigurationStubs.getMiInterimSandboxConfiguration());
    }

    @Test
    public void itShouldRemoveSandboxesSuccessfullyCreated() {
        SandboxConfiguration sandboxConfigurationCa = SandboxConfigurationStubs.getCaInterimSandboxConfiguration();
        sandboxConfigurationCa.getSandbox().setCreated(Instant.now());
        SandboxConfiguration sandboxConfigurationMi = SandboxConfigurationStubs.getMiInterimSandboxConfiguration();
        sandboxConfigurationMi.getSandbox().setCreated(Instant.now());

        Set<SandboxConfiguration> sandboxConfigurations = ImmutableSet.of(sandboxConfigurationCa, sandboxConfigurationMi);
        when(inMemorySandboxConfigurationRepository.getAll()).thenReturn(sandboxConfigurations);

        when(defaultTenantConfigPropsService.getDefaultApplicationSandboxConfiguration())
                .thenReturn(SandboxConfigurationStubs.getApplicationSandboxConfigurationDefault().getApplicationSandboxConfiguration());
        when(tenantProperties.findTenantById(sandboxConfigurationCa.getSandbox().getKey())).thenReturn(Optional.of(TenantConfigurationStubs.getTenantCA()));

        TenantConfiguration mockTenantCa = service.sandboxConfigurationToTenantConfiguration.apply(sandboxConfigurationCa);
        TenantConfiguration mockTenantMi = service.sandboxConfigurationToTenantConfiguration.apply(sandboxConfigurationMi);
        Map<String, Tenant> tenants = new HashMap<>();
        tenants.put(mockTenantCa.getTenant().getKey(), mockTenantCa.getTenant());
        tenants.put(mockTenantMi.getTenant().getKey(), mockTenantMi.getTenant());
        when(tenantProperties.getTenants()).thenReturn(ImmutableMap.copyOf(tenants));

        Map<String, TenantAdministrationStatus> statusTenantMap = new HashMap<>();
        statusTenantMap.put(sandboxConfigurationMi.getSandbox().getKey(), TenantAdministrationStatus.CREATING_DATABASES);
        when(tenantAdministrationStatusService.getTenants()).thenReturn(statusTenantMap);
        when(tenantAdministrationStatusService.findStatus(sandboxConfigurationMi.getSandbox().getKey())).thenReturn(Optional.of(ImmutablePair.of(TenantAdministrationStatus.CREATING_DATABASES, mockTenantMi)));

        ApplicationSandboxConfigurations applicationSandboxConfigurations = service.getAll();

        verify(inMemorySandboxConfigurationRepository, times(2)).getAll();
        verify(defaultTenantConfigPropsService).getDefaultApplicationSandboxConfiguration();
        verify(tenantProperties).findTenantById(any());
        verify(sandboxDataSets).getSandboxDatasets();
        verify(tenantAdministrationStatusService).getTenants();
        verify(tenantAdministrationStatusService, times(0)).findStatus(mockTenantMi.getTenant().getKey());

        assertThat(applicationSandboxConfigurations).isNotNull();
        assertThat(applicationSandboxConfigurations.getSandboxConfigurationPackage()).isNotNull();
        assertThat(applicationSandboxConfigurations.getSandboxes()).isNotEmpty();
        assertThat(applicationSandboxConfigurations.getSandboxes().size()).isEqualTo(2);
        assertThat(applicationSandboxConfigurations.getSandboxConfigurationPackage().getDataSets().size()).isEqualTo(SandboxConfigurationStubs.getDataSets().size());

        Optional<SandboxConfiguration> sandboxCa = getSandboxConfigurationFromKey(applicationSandboxConfigurations, sandboxConfigurationCa.getSandbox().getKey());
        assertThat(sandboxCa).isPresent();
        if (sandboxCa.isPresent()) {
            assertThat(sandboxCa.get().getSandbox().getKey()).isEqualTo(sandboxConfigurationCa.getSandbox().getKey());
            assertThat(sandboxCa.get().getSandbox().getCreated()).isNotNull();
        }

        Optional<SandboxConfiguration> sandboxMi = getSandboxConfigurationFromKey(applicationSandboxConfigurations, sandboxConfigurationMi.getSandbox().getKey());
        assertThat(sandboxMi).isPresent();
        if (sandboxMi.isPresent()) {
            assertThat(sandboxMi.get().getSandbox().getKey()).isEqualTo(sandboxConfigurationMi.getSandbox().getKey());
            assertThat(sandboxMi.get().getSandbox().getCreated()).isNotNull();
        }
    }

    @Test
    public void itShouldCreateSandbox() {
        SandboxConfiguration sandboxConfigurationCa = SandboxConfigurationStubs.getCaInterimSandboxConfiguration();
        when(inMemorySandboxConfigurationRepository.create(sandboxConfigurationCa)).thenReturn(sandboxConfigurationCa);
        SandboxConfiguration sandboxConfiguration = service.create(sandboxConfigurationCa);

        verify(inMemorySandboxConfigurationRepository).create(sandboxConfigurationCa);
        assertThat(sandboxConfiguration).isNotNull();
        assertThat(sandboxConfiguration.getSandbox()).isNotNull();
        verifySandboxes(sandboxConfiguration, sandboxConfigurationCa);
    }

    @Test
    public void itShouldUpdateSandbox() {
        String expectedDescription = "Sandbox's New description for Testing";
        SandboxConfiguration sandboxConfigurationCa = SandboxConfigurationStubs.getCaInterimSandboxConfiguration();
        SandboxConfiguration updatedSandboxConfiguration = SandboxConfigurationStubs.getCaInterimSandboxConfiguration();
        updatedSandboxConfiguration.getSandbox().setDescription(expectedDescription);
        when(inMemorySandboxConfigurationRepository.update(sandboxConfigurationCa)).thenReturn(updatedSandboxConfiguration);
        when(inMemorySandboxConfigurationRepository.exists(sandboxConfigurationCa.getSandbox().getKey())).thenReturn(true);

        SandboxConfiguration sandboxCfg = service.update(sandboxConfigurationCa);

        verify(inMemorySandboxConfigurationRepository).update(sandboxConfigurationCa);
        verifySandboxes(sandboxCfg, updatedSandboxConfiguration);
    }

    @Test
    public void itShouldDeleteSandbox() {
        String key = SandboxConfigurationStubs.getCaInterimSandboxConfiguration().getSandbox().getKey();
        service.delete(key);
        verify(inMemorySandboxConfigurationRepository).delete(key);
    }

    @Test
    public void itShouldResetSandbox() {
        String key = SandboxConfigurationStubs.getCaInterimSandboxConfiguration().getSandbox().getKey();
        service.resetDataSet(key);
        verify(inMemorySandboxConfigurationRepository).reset(key);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldNotCreateSandbox() {
        SandboxConfiguration sandboxConfigurationCa = SandboxConfigurationStubs.getCaInterimSandboxConfiguration();
        when(inMemorySandboxConfigurationRepository.create(sandboxConfigurationCa)).thenReturn(sandboxConfigurationCa);
        when(inMemorySandboxConfigurationRepository.exists(any())).thenReturn(true);
        service.create(sandboxConfigurationCa);
    }

    @Test(expected = NoSuchElementException.class)
    public void itShouldNotUpdateSandbox() {
        SandboxConfiguration sandboxConfigurationCa = SandboxConfigurationStubs.getCaInterimSandboxConfiguration();
        when(inMemorySandboxConfigurationRepository.create(sandboxConfigurationCa)).thenReturn(sandboxConfigurationCa);
        when(inMemorySandboxConfigurationRepository.exists(sandboxConfigurationCa.getSandbox().getKey())).thenReturn(false);
        service.update(sandboxConfigurationCa);
    }

    private void verifySandboxes(final SandboxConfiguration sandboxConfiguration, final SandboxConfiguration expectedSandboxConfiguration) {
        assertThat(sandboxConfiguration.getSandbox().getKey()).isEqualTo(expectedSandboxConfiguration.getSandbox().getKey());
        assertThat(sandboxConfiguration.getSandbox().getId()).isEqualTo(expectedSandboxConfiguration.getSandbox().getId());
        assertThat(sandboxConfiguration.getSandbox().getSandboxDataset()).isEqualTo(expectedSandboxConfiguration.getSandbox().getSandboxDataset());
        assertThat(sandboxConfiguration.getSandbox().getDescription()).isEqualTo(expectedSandboxConfiguration.getSandbox().getDescription());
        assertThat(sandboxConfiguration.getSandbox().getName()).isEqualTo(expectedSandboxConfiguration.getSandbox().getName());

        verifyReporting(sandboxConfiguration.getApplicationSandboxConfiguration().getReporting(), expectedSandboxConfiguration.getApplicationSandboxConfiguration().getReporting());
        verifyLocalization(sandboxConfiguration.getLocalization(), expectedSandboxConfiguration.getLocalization());

        verifyAggregatorProperties(sandboxConfiguration.getApplicationSandboxConfiguration().getAggregateReportingPropertiesTenant(),
                expectedSandboxConfiguration.getApplicationSandboxConfiguration().getAggregateReportingPropertiesTenant());
    }

    /**
     * the aggregator property lists can be null
     *
     * @param aggregateProperties         retrieved properties
     * @param expectedAggregateProperties expected properties
     */
    private void verifyAggregatorProperties(AggregateReportingPropertiesTenant aggregateProperties, AggregateReportingPropertiesTenant expectedAggregateProperties) {
        assertThat(aggregateProperties.getAssessmentTypes().size()).isEqualTo(expectedAggregateProperties.getAssessmentTypes().size());
        assertThat(aggregateProperties.getStateAggregateAssessmentTypes().size()).isEqualTo(expectedAggregateProperties.getStateAggregateAssessmentTypes().size());
        assertThat(aggregateProperties.getStatewideUserAssessmentTypes().size()).isEqualTo(expectedAggregateProperties.getStatewideUserAssessmentTypes().size());
    }

    private void verifyLocalization(final String localization, final String expectedLocalization) {
        assertThat(localization).isEqualTo(expectedLocalization);
    }

    private void verifyReporting(final ReportingSystemProperties reportingSystemSettings, final ReportingSystemProperties expectedReportingSystemSettings) {
        assertThat(reportingSystemSettings.getAccessDeniedUrl()).isEqualTo(expectedReportingSystemSettings.getAccessDeniedUrl());
        assertThat(reportingSystemSettings.getAnalyticsTrackingId()).isEqualTo(expectedReportingSystemSettings.getAnalyticsTrackingId());
        assertThat(reportingSystemSettings.getInterpretiveGuideUrl()).isEqualTo(expectedReportingSystemSettings.getInterpretiveGuideUrl());
        assertThat(reportingSystemSettings.getIrisVendorId()).isEqualTo(expectedReportingSystemSettings.getIrisVendorId());
        assertThat(reportingSystemSettings.getLandingPageUrl()).isEqualTo(expectedReportingSystemSettings.getLandingPageUrl());
        assertThat(reportingSystemSettings.getMinItemDataYear()).isEqualTo(expectedReportingSystemSettings.getMinItemDataYear());
        assertThat(reportingSystemSettings.getSchoolYear()).isEqualTo(expectedReportingSystemSettings.getSchoolYear());
        assertThat(reportingSystemSettings.getUserGuideUrl()).isEqualTo(expectedReportingSystemSettings.getUserGuideUrl());
        assertThat(reportingSystemSettings.getTargetReport()).isEqualTo(expectedReportingSystemSettings.getTargetReport());
        assertThat(reportingSystemSettings.getTranslationLocation()).isEqualTo(expectedReportingSystemSettings.getTranslationLocation());
        assertThat(reportingSystemSettings.isPercentileDisplayEnabled()).isEqualTo(expectedReportingSystemSettings.isPercentileDisplayEnabled());
        assertThat(reportingSystemSettings.isTransferAccessEnabled()).isEqualTo(expectedReportingSystemSettings.isTransferAccessEnabled());
        assertThat(reportingSystemSettings.getState()).isNotNull();
        assertThat(reportingSystemSettings.getState().getCode()).isEqualTo(expectedReportingSystemSettings.getState().getCode());
        assertThat(reportingSystemSettings.getState().getName()).isEqualTo(expectedReportingSystemSettings.getState().getName());

        assertThat(reportingSystemSettings.getReportLanguages().size()).isEqualTo(expectedReportingSystemSettings.getReportLanguages().size());
        assertThat(reportingSystemSettings.getUiLanguages().size()).isEqualTo(expectedReportingSystemSettings.getUiLanguages().size());
        assertThat(reportingSystemSettings.getEffectiveReportLanguages().size()).isEqualTo(expectedReportingSystemSettings.getEffectiveReportLanguages().size());

    }

    /**
     * Lookup the given key in the ApplicationSandboxConfigurations sandbox list
     *
     * @param applicationSandboxConfigurations contains the list of sandboxes to look through
     * @param key                              The key of the sandbox to find
     * @return SandboxConfiguration if key is found
     */
    private Optional<SandboxConfiguration> getSandboxConfigurationFromKey(final ApplicationSandboxConfigurations applicationSandboxConfigurations, String key) {
        return applicationSandboxConfigurations.getSandboxes().stream()
                .filter(sandbox ->
                        sandbox.getSandbox().getKey().equals(key)
                ).findFirst();
    }

}
