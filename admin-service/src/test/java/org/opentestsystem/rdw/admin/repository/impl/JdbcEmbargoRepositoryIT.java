package org.opentestsystem.rdw.admin.repository.impl;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.opentestsystem.rdw.admin.model.EmbargoAuditRecord;
import org.opentestsystem.rdw.admin.model.EmbargoQuery;
import org.opentestsystem.rdw.admin.model.EmbargoUpdate;
import org.opentestsystem.rdw.admin.model.Embargo;
import org.opentestsystem.rdw.admin.repository.EmbargoAuditRepository;
import org.opentestsystem.rdw.admin.repository.EmbargoRepository;
import org.opentestsystem.rdw.admin.repository.RepositoryIT;
import org.opentestsystem.rdw.reporting.common.model.EmbargoStatus;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.jdbc.Sql;
import org.springframework.test.context.jdbc.SqlConfig;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.transaction.annotation.Transactional;

import java.util.Arrays;
import java.util.Comparator;
import java.util.Date;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.opentestsystem.rdw.admin.model.EmbargoReportType.Aggregate;
import static org.opentestsystem.rdw.admin.model.EmbargoReportType.Individual;
import static org.opentestsystem.rdw.reporting.common.model.EmbargoStatus.Loading;
import static org.opentestsystem.rdw.reporting.common.model.EmbargoStatus.Released;
import static org.opentestsystem.rdw.reporting.common.model.EmbargoStatus.Reviewing;

@RunWith(SpringRunner.class)
@RepositoryIT
@ContextConfiguration(classes = {
        JdbcEmbargoRepository.class,
        JdbcImportRepository.class
})
@Sql(config = @SqlConfig(dataSource = "warehouseDatasource", transactionManager = "warehouseTxManager"),
     scripts = {"classpath:embargo-test-data.sql"}
)
@Transactional(transactionManager = "warehouseTxManager")
public class JdbcEmbargoRepositoryIT {

    private static final int TotalRecordsInTestData = 60;

    // Default sort for TestResultsAvailability query
    private static final Comparator<Embargo> DefaultSort =
       Comparator.comparingInt(Embargo::getSchoolYear).reversed()
           .thenComparing(Embargo::getDistrictName)
           .thenComparing(Embargo::getSubjectCode)
           .thenComparing(Embargo::getReportType);

    @Autowired
    EmbargoRepository repository;

    @Autowired
    EmbargoAuditRepository auditRepository;

    @Autowired
    @Qualifier("warehouseJdbcTemplate")
    NamedParameterJdbcTemplate template;

    @Test
    public void itShouldFindAvailableTestResults() {
        final EmbargoQuery query = EmbargoQuery.builder()
            .statuses(Arrays.asList(EmbargoStatus.values()))
            .pageSize(1000)
            .rowOffset(0)
            .build();

        final List<Embargo> testResults = repository.findEmbargoes(query);
        assertThat(testResults).hasSize(TotalRecordsInTestData);
        assertThat(testResults).isSortedAccordingTo(DefaultSort);
//        assertThat(testResults.stream().allMatch(r -> r.getExamCount().equals(5))).isTrue();

        assertThat(repository.countByQuery(query)).isEqualTo(TotalRecordsInTestData);
    }

    @Test
    public void isShouldLimitTestResultsByPageSize() {
        final EmbargoQuery query = EmbargoQuery.builder()
            .statuses(Arrays.asList(EmbargoStatus.values()))
            .pageSize(10)
            .rowOffset(0)
            .build();

        final List<Embargo> testResults = repository.findEmbargoes(query);
        assertThat(testResults).hasSize(10);

        // Total count should be the name regardless of page size or offset
        assertThat(repository.countByQuery(query)).isEqualTo(TotalRecordsInTestData);
    }

    @Test
    public void isShouldFindTestResultsWithOffset() {
        final EmbargoQuery query = EmbargoQuery.builder()
            .statuses(Arrays.asList(EmbargoStatus.values()))
            .pageSize(2)
            .rowOffset(0)
            .build();

        final List<Embargo> testResults = repository.findEmbargoes(query);

        // Total count should be the name regardless of page size or offset
        assertThat(repository.countByQuery(query)).isEqualTo(TotalRecordsInTestData);

        final EmbargoQuery query2 = query.copy().rowOffset(1).build();
        final List<Embargo> testResults2 = repository.findEmbargoes(query2);

        assertThat(isMatch(testResults.get(1), testResults2.get(0))).isTrue();
    }

    @Test
    public void itShouldFilterTestResultsByYear()  {
        final EmbargoQuery query = EmbargoQuery.builder()
            .statuses(Arrays.asList(EmbargoStatus.values()))
            .schoolYear(2017)
            .pageSize(1000)
            .rowOffset(0)
            .build();

        final List<Embargo> testResults = repository.findEmbargoes(query);
        assertThat(testResults).hasSize(TotalRecordsInTestData/5); // Because filtering in one year out of the five
        assertThat(testResults.stream().allMatch(r -> r.getSchoolYear().equals(2017)));

        assertThat(repository.countByQuery(query)).isEqualTo(TotalRecordsInTestData/5);
    }

    @Test
    public void itShouldFilterTestResultsByDistrictIds()  {
        final EmbargoQuery query = EmbargoQuery.builder()
            .statuses(Arrays.asList(EmbargoStatus.values()))
            .districtIds(Arrays.asList(-10L, -20L))
            .pageSize(1000)
            .rowOffset(0)
            .build();

        final List<Embargo> testResults = repository.findEmbargoes(query);
        assertThat(testResults).hasSize(40);
        assertThat(testResults.stream().allMatch(r -> r.getDistrictId().equals(10L) || r.getDistrictId().equals(20L)));
    }

    @Test
    public void itShouldFilterTestResultsBySubjectId()  {
        final EmbargoQuery query = EmbargoQuery.builder()
            .statuses(Arrays.asList(EmbargoStatus.values()))
            .subjectId(1)
            .pageSize(1000)
            .rowOffset(0)
            .build();

        final List<Embargo> testResults = repository.findEmbargoes(query);
        assertThat(testResults).hasSize(30);
        assertThat(testResults.stream().allMatch(r -> r.getSubjectId().equals(1L)));
    }

    @Test
    public void itShouldFilterTestResultsByReportType()  {
        final EmbargoQuery query = EmbargoQuery.builder()
            .statuses(Arrays.asList(EmbargoStatus.values()))
            .reportType(Aggregate)
            .pageSize(1000)
            .rowOffset(0)
            .build();

        final List<Embargo> testResults = repository.findEmbargoes(query);
        assertThat(testResults).hasSize(30);
        assertThat(testResults.stream().allMatch(r -> r.getReportType() == Aggregate));
    }

    @Test
    public void itShouldFilterTestResultsByStatus()  {
        final EmbargoQuery query = EmbargoQuery.builder()
            .statuses(Arrays.asList(Released))
            .pageSize(1000)
            .rowOffset(0)
            .build();

        final List<Embargo> testResults = repository.findEmbargoes(query);
        assertThat(testResults).hasSize(7);
        assertThat(testResults.stream().allMatch(r -> r.getStatus() != EmbargoStatus.Loading));
    }

    @Test
    public void itShouldSupportTestResultsClientSort()  {
        final EmbargoQuery query = EmbargoQuery.builder()
            .statuses(Arrays.asList(EmbargoStatus.values()))
            .sortField("subject_code")
            .pageSize(1000)
            .rowOffset(0)
            .build();

        final List<Embargo> testResults = repository.findEmbargoes(query);
        assertThat(testResults).hasSize(60);
        assertThat(testResults).isSortedAccordingTo(Comparator.comparing(Embargo::getSubjectCode));
    }

    @Test
    public void itShouldSupportTestResultsClientSortDescending()  {
        final EmbargoQuery query = EmbargoQuery.builder()
            .statuses(Arrays.asList(EmbargoStatus.values()))
            .sortField("district_name")
            .descending(true)
            .pageSize(1000)
            .rowOffset(0)
            .build();

        final List<Embargo> testResults = repository.findEmbargoes(query);
        assertThat(testResults).hasSize(60);
        assertThat(testResults).isSortedAccordingTo(Comparator.comparing(Embargo::getDistrictName).reversed());
    }

    @Test
    public void itShouldUpdateEmbargoStatusFromReviewingToReleased() {
        // Current test data has 7 released records and 5 reviewing
        final int startingReleasedCount = 7;
        final int startingReviewingCount = 5;

        final EmbargoQuery query = EmbargoQuery.builder()
            .statuses(Arrays.asList(Released))
            .build();
        final EmbargoQuery query2 = EmbargoQuery.builder()
            .statuses(Arrays.asList(Reviewing))
            .build();
        assertThat(repository.countByQuery(query2)).isEqualTo(startingReviewingCount);
        assertThat(repository.countByQuery(query)).isEqualTo(startingReleasedCount);

        final EmbargoUpdate update = EmbargoUpdate.builder()
            .status(Reviewing)
            .newStatus(Released)
            .build();

        repository.update(update, "test");

        assertThat(repository.countByQuery(query)).isEqualTo(startingReleasedCount + startingReviewingCount);
    }

    @Test
    public void itShouldUpdateEmbargoStatusFromLoadingToReviewing() {
        // Current test data has 4 reviewing records and 53 loading
        final int startingReviewingCount = 5;
        final int startingLoadingCount = 48;

        final EmbargoQuery query = EmbargoQuery.builder()
            .statuses(Arrays.asList(Reviewing))
            .build();

        assertThat(repository.countByQuery(query)).isEqualTo(startingReviewingCount);

        final EmbargoUpdate update = EmbargoUpdate.builder()
            .status(Loading)
            .newStatus(Reviewing)
            .build();

        repository.update(update, "test");

        assertThat(repository.countByQuery(query)).isEqualTo(startingLoadingCount + startingReviewingCount);
    }

    @Test
    public void itShouldTargetUpdateStatusBasedOnQuery() {
        // This is a complex test, but it shows that an update request can be constructed
        // to only affect a single embargo entry

        // For all records in reviewing status
        final EmbargoQuery countQuery = EmbargoQuery.builder()
            .statuses(Arrays.asList(Reviewing))
            .build();

        // Should only retrieve embargo with values (-10, 2018, 1, 1, 1) : see embargo-test-data.sql
        final EmbargoQuery query = EmbargoQuery.builder()
            .statuses(Arrays.asList(EmbargoStatus.values()))
            .districtIds(Arrays.asList(-10L))
            .schoolYear(2018)
            .subjectId(1)
            .sortField("report_type")
            .rowOffset(0)
            .pageSize(1000)
            .build();

        final int startingReviewingCount = repository.countByQuery(countQuery);
        final List<Embargo> before = repository.findEmbargoes(query);
        assertThat(before).hasSize(2);
        assertThat(before.get(0).getReportType()).isEqualTo(Aggregate);
        assertThat(before.get(0).getStatus()).isEqualTo(Released);
        assertThat(before.get(1).getReportType()).isEqualTo(Individual);
        assertThat(before.get(1).getStatus()).isEqualTo(Released);

        // Target only the individual embargo status for one specific year, district, subject combination
        final EmbargoUpdate update = EmbargoUpdate.builder()
            .districtIds(Arrays.asList(-10L))
            .schoolYear(2018)
            .subjectId(1)
            .reportType(Individual)
            .status(Released)
            .newStatus(Reviewing)
            .build();

        repository.update(update, "test");

        final List<Embargo> after = repository.findEmbargoes(query);
        assertThat(after).hasSize(2);
        assertThat(after.get(0).getReportType()).isEqualTo(Aggregate);
        assertThat(after.get(0).getStatus()).isEqualTo(Released);
        assertThat(after.get(1).getReportType()).isEqualTo(Individual);
        assertThat(after.get(1).getStatus()).isEqualTo(Reviewing);
        assertThat(repository.countByQuery(countQuery)).isEqualTo(startingReviewingCount + 1);
    }

    private boolean isMatch(Embargo a, Embargo b) {
        return a.getSchoolYear().equals(b.getSchoolYear()) &&
            a.getDistrictId().equals(b.getDistrictId()) &&
            a.getSubjectId().equals(b.getSubjectId()) &&
            a.getReportType() == b.getReportType() &&
            a.getStatus() == b.getStatus();
    }

    @Test
    public void itShouldFindEmbargoAuditRecords() {
        final Date startDate = new Date(0L);
        final List<EmbargoAuditRecord> auditRecords = auditRepository.findEmbargoAuditRecords(startDate);

        assertThat(auditRecords).hasSize(8);
    }

    @Test
    public void itShouldAuditDistrictEmbargoDelete() {
        final int countStateEmbargo = countRowsInTableWhere("district_embargo", "1=1");

        template.getJdbcOperations().execute("DELETE FROM district_embargo");

        assertThat(countRowsInTableWhere("audit_district_embargo", "action = 'delete'")).isEqualTo(countStateEmbargo);
    }

    private int countRowsInTableWhere(String tableName, String whereClause) {
        return template.getJdbcOperations().queryForObject("SELECT COUNT(0) FROM " + tableName + " WHERE " + whereClause, Integer.class);
    }
}
