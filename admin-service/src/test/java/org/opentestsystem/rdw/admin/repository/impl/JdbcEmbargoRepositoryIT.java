package org.opentestsystem.rdw.admin.repository.impl;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.jdbc.Sql;
import org.springframework.test.context.jdbc.SqlConfig;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collection;
import java.util.List;
import org.opentestsystem.rdw.admin.model.Embargo;
import org.opentestsystem.rdw.admin.repository.RepositoryIT;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;

import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;

@RunWith(SpringRunner.class)
@RepositoryIT
@ContextConfiguration(classes = {
        JdbcEmbargoRepository.class,
        JdbcImportRepository.class
})
@Sql(config = @SqlConfig(dataSource = "warehouseDatasource", transactionManager = "warehouseTxManager"),
     scripts = {"classpath:embargo-test-data.sql"}
)
@Transactional(transactionManager = "warehouseTxManager")
public class JdbcEmbargoRepositoryIT {

    @Autowired
    JdbcEmbargoRepository repository;

    @Autowired
    @Qualifier("warehouseJdbcTemplate")
    NamedParameterJdbcTemplate template;

    @Test
    public void itShouldFindAllBySchoolYear() {
        // there are three districts (-10, -20, -30) and the state
        assertThat(repository.findAllBySchoolYear(2018, newArrayList(-10L, -20L, -30L))).hasSize(4);
        assertThat(repository.findAllBySchoolYear(2018, newArrayList(-10L))).hasSize(2);
        assertThat(repository.findAllBySchoolYear(2018, newArrayList(-10L, 123L))).hasSize(2);
        assertThat(repository.findAllBySchoolYear(2018, newArrayList())).hasSize(1);
    }

    @Test
    public void itShouldDefaultIndividualToTrueAndAggregateToFalseForState() {
        final Collection<Embargo> embargos = repository.findAllBySchoolYear(1999, newArrayList());
        assertThat(embargos).hasSize(1);
        final Embargo stateEmbargo = embargos.stream().findFirst().orElse(null);
        assertThat(stateEmbargo).isNotNull();
        assertThat(stateEmbargo.isAggregateEnabled()).isTrue();
        assertThat(stateEmbargo.isIndividualEnabled()).isFalse();
    }

    @Test
    public void itShouldDefaultDistrictIndividualToTrueAndAggregateToFalseIfStateAndDistrictAreUndefined() {
        final Collection<Embargo> embargos = repository.findAllBySchoolYear(1999, newArrayList(-10L));
        assertThat(embargos).hasSize(2);
        final Embargo districtEmbargo = embargos.stream()
                .filter(embargo -> embargo.getOrganizationType() == OrganizationType.District)
                .findFirst()
                .orElse(null);
        assertThat(districtEmbargo).isNotNull();
        assertThat(districtEmbargo.isAggregateEnabled()).isTrue();
        assertThat(districtEmbargo.isIndividualEnabled()).isFalse();
    }

    @Test
    public void itShouldDefaultDistrictIndividualToStateAndAggregateToStateIfStateIsDefinedAndDistrictIsUndefined() {
        final Collection<Embargo> embargos = repository.findAllBySchoolYear(2019, newArrayList(-10L));
        assertThat(embargos).hasSize(2);
        final Embargo districtEmbargo = embargos.stream()
                .filter(embargo -> embargo.getOrganizationType() == OrganizationType.District)
                .findFirst()
                .orElse(null);
        assertThat(districtEmbargo).isNotNull();
        assertThat(districtEmbargo.isAggregateEnabled()).isTrue();
        assertThat(districtEmbargo.isIndividualEnabled()).isTrue();
    }

    @Test
    public void itShouldReleaseADistrictIfStateIsReleased() {
        final Collection<Embargo> embargos = repository.findAllBySchoolYear(2020, newArrayList(-10L));
        assertThat(embargos).hasSize(2);
        final Embargo districtEmbargo = embargos.stream()
                .filter(embargo -> embargo.getOrganizationType() == OrganizationType.District)
                .findFirst()
                .orElse(null);
        assertThat(districtEmbargo).isNotNull();
        assertThat(districtEmbargo.isAggregateEnabled()).isFalse();
        assertThat(districtEmbargo.isIndividualEnabled()).isFalse();
    }

    @Test
    public void findAllShouldIncludeExamCounts() {
        final Collection<Embargo> embargos = repository.findAllBySchoolYear(2018, newArrayList(-10L));
        assertThat(embargos).isInstanceOf(List.class);

        final Embargo state = ((List<Embargo>) embargos).get(0);
        assertThat(state.getExamCounts()).hasSize(2);
        assertThat(state.getExamCounts().get("Math")).isEqualTo(2);
        assertThat(state.getExamCounts().get("ELA")).isEqualTo(1);

        final Embargo district = ((List<Embargo>) embargos).get(1);
        assertThat(district.getExamCounts()).hasSize(2);
        assertThat(district.getExamCounts().get("Math")).isEqualTo(2);
        assertThat(district.getExamCounts().get("ELA")).isEqualTo(0);
    }

    @Test
    public void findAllShouldIncludeExamCountsEvenIfNoExams() {
        final Collection<Embargo> embargos = repository.findAllBySchoolYear(2019, newArrayList(-10L));

        final Embargo state = ((List<Embargo>) embargos).get(0);
        assertThat(state.getExamCounts()).hasSize(2);
        assertThat(state.getExamCounts().get("Math")).isEqualTo(0);
        assertThat(state.getExamCounts().get("ELA")).isEqualTo(0);

        final Embargo district = ((List<Embargo>) embargos).get(1);
        assertThat(district.getExamCounts()).hasSize(2);
        assertThat(district.getExamCounts().get("Math")).isEqualTo(0);
        assertThat(state.getExamCounts().get("ELA")).isEqualTo(0);
    }

    @Test
    public void itShouldFindOneBySchoolYearAndState() {
        final Embargo embargo = repository.findOneBySchoolYearAndState(2018);
        assertThat(embargo.getOrganizationType()).isEqualTo(OrganizationType.State);
        assertThat(embargo.getOrganizationId()).isNull();
        assertThat(embargo.getOrganizationName()).isNull();
        assertThat(embargo.isAggregateEnabled()).isTrue();
        assertThat(embargo.isIndividualEnabled()).isFalse();
    }

    @Test
    public void findOneBySchoolYearAndStateShouldReturnNullIfNoSettingsForSchoolYear() {
        assertThat(repository.findOneBySchoolYearAndState(2015)).isNull();
    }

    @Test
    public void itShouldFindOneBySchoolYearAndDistrictId() {
        final Embargo embargo = repository.findOneBySchoolYearAndDistrictId(2018, -10);
        assertThat(embargo.getOrganizationType()).isEqualTo(OrganizationType.District);
        assertThat(embargo.getOrganizationId()).isEqualTo(-10);
        assertThat(embargo.getOrganizationName()).isEqualTo("district1");
        assertThat(embargo.isAggregateEnabled()).isTrue();
        assertThat(embargo.isIndividualEnabled()).isTrue();
    }

    @Test
    public void findOneBySchoolYearAndDistrictIdShouldReturnNullIfDistrictNotFound() {
        assertThat(repository.findOneBySchoolYearAndDistrictId(2018, 123L)).isNull();
    }

    @Test
    public void findOneBySchoolYearAndDistrictIdShouldReturnNullIfDistrictSettingsNotFound() {
        assertThat(repository.findOneBySchoolYearAndDistrictId(2018, -30)).isNull();
    }

    @Test
    public void itShouldCreateAStateEmbargo() {
        final Embargo embargo = Embargo.builder()
                .organizationType(OrganizationType.State)
                .aggregateEnabled(false)
                .schoolYear(2017)
                .build();

        assertThat(repository.findOneBySchoolYearAndState(2017)).isNull();
        assertThat(countRowsInTableWhere("audit_state_embargo", "school_year = 2017 and aggregate = 0")).isZero();

        repository.create(embargo, "test");

        assertThat(repository.findOneBySchoolYearAndState(2017).isAggregateEnabled()).isFalse();
        assertThat(countRowsInTableWhere("audit_state_embargo", "action = 'insert' and school_year = 2017 and aggregate = 0")).isEqualTo(1);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailToCreateADuplicateStateEmbargo() {
        final Embargo embargo = Embargo.builder()
                .organizationType(OrganizationType.State)
                .aggregateEnabled(false)
                .schoolYear(2018)
                .build();
        repository.create(embargo, "test");
    }

    @Test
    public void itShouldCreateADistrictEmbargo() {
        final Embargo embargo = Embargo.builder()
                .organizationType(OrganizationType.District)
                .organizationId(-30L)
                .schoolYear(2018)
                .individualEnabled(false)
                .build();


        assertThat(repository.findOneBySchoolYearAndDistrictId(2018, -30)).isNull();
        assertThat(countRowsInTableWhere("audit_district_embargo", "district_id = -30 and school_year = 2018 and individual = 0")).isZero();

        repository.create(embargo, "test");

        assertThat(repository.findOneBySchoolYearAndDistrictId(2018, -30).isAggregateEnabled()).isNull();
        assertThat(repository.findOneBySchoolYearAndDistrictId(2018, -30).isIndividualEnabled()).isFalse();

        assertThat(countRowsInTableWhere("audit_district_embargo", "action = 'insert' and district_id = -30 and school_year = 2018 and individual = 0")).isEqualTo(1);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailToCreateADuplicateDistrictEmbargo() {
        final Embargo embargo = Embargo.builder()
                .organizationType(OrganizationType.District)
                .organizationId(-10L)
                .schoolYear(2018)
                .individualEnabled(false)
                .build();

        repository.create(embargo, "test");
    }

    @Test
    public void itShouldUpdateAStateEmbargo() {
        final Embargo embargo = Embargo.builder()
                .organizationType(OrganizationType.State)
                .aggregateEnabled(false)
                .schoolYear(2018)
                .build();

        assertThat(repository.findOneBySchoolYearAndState(2018).isAggregateEnabled()).isTrue();
        assertThat(countRowsInTableWhere("audit_state_embargo", "school_year = 2018 and aggregate = 0")).isZero();
        assertThat(countRowsInTableWhere("audit_state_embargo", "school_year = 2018 and aggregate = 1")).isEqualTo(1);

        repository.update(embargo, "test");
        assertThat(repository.findOneBySchoolYearAndState(2018).isAggregateEnabled()).isFalse();

        assertThat(countRowsInTableWhere("audit_state_embargo", "action = 'update' and school_year = 2018 and aggregate = 0")).isEqualTo(1);
        assertThat(countRowsInTableWhere("audit_state_embargo", "school_year = 2018 and aggregate = 1")).isEqualTo(1);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailToUpdateAMissingStateEmbargo() {
        final Embargo embargo = Embargo.builder()
                .organizationType(OrganizationType.State)
                .aggregateEnabled(false)
                .schoolYear(2017)
                .build();

        repository.update(embargo, "test");
    }

    @Test
    public void itShouldUpdateADistrictEmbargo() {
        final Embargo embargo = Embargo.builder()
                .organizationType(OrganizationType.District)
                .organizationId(-20L)
                .aggregateEnabled(false)
                .schoolYear(2018)
                .build();

        assertThat(repository.findOneBySchoolYearAndDistrictId(2018, -20).isAggregateEnabled()).isNull();
        assertThat(countRowsInTableWhere("audit_district_embargo", "district_id = -20 and school_year = 2018 and aggregate is null")).isEqualTo(1);
        assertThat(countRowsInTableWhere("audit_district_embargo", "district_id = -20 and school_year = 2018 and aggregate = 0")).isZero();

        repository.update(embargo, "test");

        assertThat(repository.findOneBySchoolYearAndDistrictId(2018, -20).isAggregateEnabled()).isFalse();
        assertThat(countRowsInTableWhere("audit_district_embargo", "district_id = -20 and school_year = 2018 and aggregate is null")).isEqualTo(1);
        assertThat(countRowsInTableWhere("audit_district_embargo", "action = 'update' and district_id = -20 and school_year = 2018 and aggregate = 0")).isEqualTo(1);
    }

    @Test
    public void itShouldAuditStateEmbargoDelete() {
        final int countStateEmbargo = countRowsInTableWhere("state_embargo", "1=1");

        template.getJdbcOperations().execute("DELETE FROM state_embargo");

        assertThat(countRowsInTableWhere("audit_state_embargo", "action = 'delete'")).isEqualTo(countStateEmbargo);
    }

    @Test
    public void itShouldAuditDistrictEmbargoDelete() {
        final int countStateEmbargo = countRowsInTableWhere("district_embargo", "1=1");

        template.getJdbcOperations().execute("DELETE FROM district_embargo");

        assertThat(countRowsInTableWhere("audit_district_embargo", "action = 'delete'")).isEqualTo(countStateEmbargo);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailToUpdateAMissingDistrictEmbargo() {
        final Embargo embargo = Embargo.builder()
                .organizationType(OrganizationType.District)
                .organizationId(-30L)
                .aggregateEnabled(false)
                .schoolYear(2018)
                .build();

        repository.update(embargo, "test");
    }

    private int countRowsInTableWhere(String tableName, String whereClause) {
        return template.getJdbcOperations().queryForObject("SELECT COUNT(0) FROM " + tableName + " WHERE " + whereClause, Integer.class);
    }
}
