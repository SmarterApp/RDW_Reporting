package org.opentestsystem.rdw.admin.repository.impl;

import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.opentestsystem.rdw.admin.model.Embargo;
import org.opentestsystem.rdw.admin.model.EmbargoAuditRecord;
import org.opentestsystem.rdw.admin.model.EmbargoQuery;
import org.opentestsystem.rdw.admin.model.TestResultAvailability;
import org.opentestsystem.rdw.admin.model.TestResultsReportType;
import org.opentestsystem.rdw.admin.model.TestResultsStatus;
import org.opentestsystem.rdw.admin.repository.RepositoryIT;
import org.opentestsystem.rdw.reporting.common.model.OrganizationType;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.jdbc.Sql;
import org.springframework.test.context.jdbc.SqlConfig;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.transaction.annotation.Transactional;

import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Date;
import java.util.List;

import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;

@RunWith(SpringRunner.class)
@RepositoryIT
@ContextConfiguration(classes = {
        JdbcEmbargoRepository.class,
        JdbcImportRepository.class
})
@Sql(config = @SqlConfig(dataSource = "warehouseDatasource", transactionManager = "warehouseTxManager"),
     scripts = {"classpath:embargo-test-data.sql"}
)
@Transactional(transactionManager = "warehouseTxManager")
public class JdbcEmbargoRepositoryIT {

    private static final int TotalRecordsInTestData = 60;

    // Default sort for TestResultsAvailability query
    private static final Comparator<TestResultAvailability> DefaultSort =
       Comparator.comparingInt(TestResultAvailability::getSchoolYear).reversed()
           .thenComparing(TestResultAvailability::getDistrictName)
           .thenComparing(TestResultAvailability::getSubjectCode)
           .thenComparing(TestResultAvailability::getReportType);

    @Autowired
    JdbcEmbargoRepository repository;

    @Autowired
    @Qualifier("warehouseJdbcTemplate")
    NamedParameterJdbcTemplate template;

    @Test
    public void itShouldFindAllBySchoolYear() {
        // there are three districts (-10, -20, -30) and the state
        assertThat(repository.findAllBySchoolYear(2018, newArrayList(-10L, -20L, -30L))).hasSize(4);
        assertThat(repository.findAllBySchoolYear(2018, newArrayList(-10L))).hasSize(2);
        assertThat(repository.findAllBySchoolYear(2018, newArrayList(-10L, 123L))).hasSize(2);
        assertThat(repository.findAllBySchoolYear(2018, newArrayList())).hasSize(1);
    }

    @Test
    public void itShouldDefaultIndividualToTrueAndAggregateToFalseForState() {
        final Collection<Embargo> embargos = repository.findAllBySchoolYear(1999, newArrayList());
        assertThat(embargos).hasSize(1);
        final Embargo stateEmbargo = embargos.stream().findFirst().orElse(null);
        assertThat(stateEmbargo).isNotNull();
        assertThat(stateEmbargo.isAggregateEnabled()).isTrue();
        assertThat(stateEmbargo.isIndividualEnabled()).isFalse();
    }

    @Test
    public void itShouldDefaultDistrictIndividualToTrueAndAggregateToFalseIfStateAndDistrictAreUndefined() {
        final Collection<Embargo> embargos = repository.findAllBySchoolYear(1999, newArrayList(-10L));
        assertThat(embargos).hasSize(2);
        final Embargo districtEmbargo = embargos.stream()
                .filter(embargo -> embargo.getOrganizationType() == OrganizationType.District)
                .findFirst()
                .orElse(null);
        assertThat(districtEmbargo).isNotNull();
        assertThat(districtEmbargo.isAggregateEnabled()).isTrue();
        assertThat(districtEmbargo.isIndividualEnabled()).isFalse();
    }

    @Test
    public void itShouldDefaultDistrictIndividualToStateAndAggregateToStateIfStateIsDefinedAndDistrictIsUndefined() {
        final Collection<Embargo> embargos = repository.findAllBySchoolYear(2019, newArrayList(-10L));
        assertThat(embargos).hasSize(2);
        final Embargo districtEmbargo = embargos.stream()
                .filter(embargo -> embargo.getOrganizationType() == OrganizationType.District)
                .findFirst()
                .orElse(null);
        assertThat(districtEmbargo).isNotNull();
        assertThat(districtEmbargo.isAggregateEnabled()).isTrue();
        assertThat(districtEmbargo.isIndividualEnabled()).isTrue();
    }

    @Test
    public void itShouldReleaseADistrictIfStateIsReleased() {
        final Collection<Embargo> embargos = repository.findAllBySchoolYear(2020, newArrayList(-10L));
        assertThat(embargos).hasSize(2);
        final Embargo districtEmbargo = embargos.stream()
                .filter(embargo -> embargo.getOrganizationType() == OrganizationType.District)
                .findFirst()
                .orElse(null);
        assertThat(districtEmbargo).isNotNull();
        assertThat(districtEmbargo.isAggregateEnabled()).isFalse();
        assertThat(districtEmbargo.isIndividualEnabled()).isFalse();
    }

    @Test
    public void findAllShouldIncludeExamCounts() {
        final Collection<Embargo> embargos = repository.findAllBySchoolYear(2018, newArrayList(-10L));
        assertThat(embargos).isInstanceOf(List.class);

        final Embargo state = ((List<Embargo>) embargos).get(0);
        assertThat(state.getExamCounts()).hasSize(2);
        assertThat(state.getExamCounts().get("Math")).isEqualTo(2);
        assertThat(state.getExamCounts().get("ELA")).isEqualTo(1);

        final Embargo district = ((List<Embargo>) embargos).get(1);
        assertThat(district.getExamCounts()).hasSize(2);
        assertThat(district.getExamCounts().get("Math")).isEqualTo(2);
        assertThat(district.getExamCounts().get("ELA")).isEqualTo(0);
    }

    @Test
    public void findAllShouldIncludeExamCountsEvenIfNoExams() {
        final Collection<Embargo> embargos = repository.findAllBySchoolYear(2019, newArrayList(-10L));

        final Embargo state = ((List<Embargo>) embargos).get(0);
        assertThat(state.getExamCounts()).hasSize(2);
        assertThat(state.getExamCounts().get("Math")).isEqualTo(0);
        assertThat(state.getExamCounts().get("ELA")).isEqualTo(0);

        final Embargo district = ((List<Embargo>) embargos).get(1);
        assertThat(district.getExamCounts()).hasSize(2);
        assertThat(district.getExamCounts().get("Math")).isEqualTo(0);
        assertThat(state.getExamCounts().get("ELA")).isEqualTo(0);
    }

    @Test
    public void itShouldFindOneBySchoolYearAndState() {
        final Embargo embargo = repository.findOneBySchoolYearAndState(2018);
        assertThat(embargo.getOrganizationType()).isEqualTo(OrganizationType.State);
        assertThat(embargo.getOrganizationId()).isNull();
        assertThat(embargo.getOrganizationName()).isNull();
        assertThat(embargo.isAggregateEnabled()).isTrue();
        assertThat(embargo.isIndividualEnabled()).isFalse();
    }

    @Test
    public void findOneBySchoolYearAndStateShouldReturnNullIfNoSettingsForSchoolYear() {
        assertThat(repository.findOneBySchoolYearAndState(2015)).isNull();
    }

    @Test
    public void itShouldFindOneBySchoolYearAndDistrictId() {
        final Embargo embargo = repository.findOneBySchoolYearAndDistrictId(2018, -10);
        assertThat(embargo.getOrganizationType()).isEqualTo(OrganizationType.District);
        assertThat(embargo.getOrganizationId()).isEqualTo(-10);
        assertThat(embargo.getOrganizationName()).isEqualTo("district1");
        assertThat(embargo.isAggregateEnabled()).isTrue();
        assertThat(embargo.isIndividualEnabled()).isTrue();
    }

    @Test
    public void itShouldFindAvailableTestResults() {
        final EmbargoQuery query = EmbargoQuery.builder()
            .statuses(Arrays.asList(TestResultsStatus.values()))
            .pageSize(1000)
            .rowOffset(0)
            .build();

        final List<TestResultAvailability> testResults = repository.findTestResultsAvailability(query);
        assertThat(testResults).hasSize(TotalRecordsInTestData);
        assertThat(testResults).isSortedAccordingTo(DefaultSort);
        assertThat(testResults.stream().allMatch(r -> r.getExamCount().equals(5))).isTrue();

        assertThat(repository.countByQuery(query)).isEqualTo(TotalRecordsInTestData);
    }

    @Test
    public void isShouldLimitTestResultsByPageSize() {
        final EmbargoQuery query = EmbargoQuery.builder()
            .statuses(Arrays.asList(TestResultsStatus.values()))
            .pageSize(10)
            .rowOffset(0)
            .build();

        final List<TestResultAvailability> testResults = repository.findTestResultsAvailability(query);
        assertThat(testResults).hasSize(10);

        // Total count should be the name regardless of page size or offset
        assertThat(repository.countByQuery(query)).isEqualTo(TotalRecordsInTestData);
    }

    @Test
    public void isShouldFindTestResultsWithOffset() {
        final EmbargoQuery query = EmbargoQuery.builder()
            .statuses(Arrays.asList(TestResultsStatus.values()))
            .pageSize(2)
            .rowOffset(0)
            .build();

        final List<TestResultAvailability> testResults = repository.findTestResultsAvailability(query);

        // Total count should be the name regardless of page size or offset
        assertThat(repository.countByQuery(query)).isEqualTo(TotalRecordsInTestData);

        final EmbargoQuery query2 = query.copy().rowOffset(1).build();
        final List<TestResultAvailability> testResults2 = repository.findTestResultsAvailability(query2);

        assertThat(isMatch(testResults.get(1), testResults2.get(0))).isTrue();
    }

    @Test
    public void itShouldFilterTestResultsByYear()  {
        final EmbargoQuery query = EmbargoQuery.builder()
            .statuses(Arrays.asList(TestResultsStatus.values()))
            .schoolYear(2017)
            .pageSize(1000)
            .rowOffset(0)
            .build();

        final List<TestResultAvailability> testResults = repository.findTestResultsAvailability(query);
        assertThat(testResults).hasSize(TotalRecordsInTestData/5); // Because filtering in one year out of the five
        assertThat(testResults.stream().allMatch(r -> r.getSchoolYear().equals(2017)));

        assertThat(repository.countByQuery(query)).isEqualTo(TotalRecordsInTestData/5);
    }

    @Test
    public void itShouldFilterTestResultsByDistrictIds()  {
        final EmbargoQuery query = EmbargoQuery.builder()
            .statuses(Arrays.asList(TestResultsStatus.values()))
            .districtIds(Arrays.asList(-10L, -20L))
            .pageSize(1000)
            .rowOffset(0)
            .build();

        final List<TestResultAvailability> testResults = repository.findTestResultsAvailability(query);
        assertThat(testResults).hasSize(40);
        assertThat(testResults.stream().allMatch(r -> r.getDistrictId().equals(10L) || r.getDistrictId().equals(20L)));
    }

    @Test
    public void itShouldFilterTestResultsBySubjectId()  {
        final EmbargoQuery query = EmbargoQuery.builder()
            .statuses(Arrays.asList(TestResultsStatus.values()))
            .subjectId(1)
            .pageSize(1000)
            .rowOffset(0)
            .build();

        final List<TestResultAvailability> testResults = repository.findTestResultsAvailability(query);
        assertThat(testResults).hasSize(30);
        assertThat(testResults.stream().allMatch(r -> r.getSubjectId().equals(1L)));
    }

    @Test
    public void itShouldFilterTestResultsByReportType()  {
        final EmbargoQuery query = EmbargoQuery.builder()
            .statuses(Arrays.asList(TestResultsStatus.values()))
            .reportType(TestResultsReportType.Aggregate)
            .pageSize(1000)
            .rowOffset(0)
            .build();

        final List<TestResultAvailability> testResults = repository.findTestResultsAvailability(query);
        assertThat(testResults).hasSize(30);
        assertThat(testResults.stream().allMatch(r -> r.getReportType() == TestResultsReportType.Aggregate));
    }

    @Test
    public void itShouldFilterTestResultsByStatus()  {
        final EmbargoQuery query = EmbargoQuery.builder()
            .statuses(Arrays.asList(TestResultsStatus.Reviewing, TestResultsStatus.Released))
            .pageSize(1000)
            .rowOffset(0)
            .build();

        final List<TestResultAvailability> testResults = repository.findTestResultsAvailability(query);
        assertThat(testResults).hasSize(7);
        assertThat(testResults.stream().allMatch(r -> r.getStatus() != TestResultsStatus.Loading));
    }

    @Test
    public void itShouldSupportTestResultsClientSort()  {
        final EmbargoQuery query = EmbargoQuery.builder()
            .statuses(Arrays.asList(TestResultsStatus.values()))
            .sortField("subject_code")
            .pageSize(1000)
            .rowOffset(0)
            .build();

        final List<TestResultAvailability> testResults = repository.findTestResultsAvailability(query);
        assertThat(testResults).hasSize(60);
        assertThat(testResults).isSortedAccordingTo(Comparator.comparing(TestResultAvailability::getSubjectCode));
    }

    @Test
    public void itShouldSupportTestResultsClientSortDescending()  {
        final EmbargoQuery query = EmbargoQuery.builder()
            .statuses(Arrays.asList(TestResultsStatus.values()))
            .sortField("district_name")
            .descending(true)
            .pageSize(1000)
            .rowOffset(0)
            .build();

        final List<TestResultAvailability> testResults = repository.findTestResultsAvailability(query);
        assertThat(testResults).hasSize(60);
        assertThat(testResults).isSortedAccordingTo(Comparator.comparing(TestResultAvailability::getDistrictName).reversed());
    }

    private boolean isMatch(TestResultAvailability a, TestResultAvailability b) {
        return a.getSchoolYear().equals(b.getSchoolYear()) &&
            a.getDistrictId().equals(b.getDistrictId()) &&
            a.getSubjectId().equals(b.getSubjectId()) &&
            a.getReportType() == b.getReportType() &&
            a.getStatus() == b.getStatus();
    }

    @Test
    public void itShouldFindEmbargoAuditRecords() {
        final Date startDate = new Date(0L);
        final List<EmbargoAuditRecord> auditRecords = repository.findEmbargoAuditRecords(startDate);

        assertThat(auditRecords).hasSize(4);
    }

    @Test
    public void findOneBySchoolYearAndDistrictIdShouldReturnNullIfDistrictNotFound() {
        assertThat(repository.findOneBySchoolYearAndDistrictId(2018, 123L)).isNull();
    }

    @Test
    public void findOneBySchoolYearAndDistrictIdShouldReturnNullIfDistrictSettingsNotFound() {
        assertThat(repository.findOneBySchoolYearAndDistrictId(2018, -30)).isNull();
    }

    @Test
    public void itShouldCreateAStateEmbargo() {
        final Embargo embargo = Embargo.builder()
                .organizationType(OrganizationType.State)
                .aggregateEnabled(false)
                .schoolYear(2017)
                .build();

        assertThat(repository.findOneBySchoolYearAndState(2017)).isNull();
        assertThat(countRowsInTableWhere("audit_state_embargo", "school_year = 2017 and aggregate = 0")).isZero();

        repository.create(embargo, "test");

        assertThat(repository.findOneBySchoolYearAndState(2017).isAggregateEnabled()).isFalse();
        assertThat(countRowsInTableWhere("audit_state_embargo", "action = 'insert' and school_year = 2017 and aggregate = 0")).isEqualTo(1);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailToCreateADuplicateStateEmbargo() {
        final Embargo embargo = Embargo.builder()
                .organizationType(OrganizationType.State)
                .aggregateEnabled(false)
                .schoolYear(2018)
                .build();
        repository.create(embargo, "test");
    }

    @Test
    @Ignore("Ignore for now until we stabilize changes to database")
    public void itShouldCreateADistrictEmbargo() {
        final Embargo embargo = Embargo.builder()
                .organizationType(OrganizationType.District)
                .organizationId(-30L)
                .schoolYear(2018)
                .individualEnabled(false)
                .build();


        assertThat(repository.findOneBySchoolYearAndDistrictId(2018, -30)).isNull();
        assertThat(countRowsInTableWhere("audit_district_embargo", "district_id = -30 and school_year = 2018 and individual = 0")).isZero();

        repository.create(embargo, "test");

        assertThat(repository.findOneBySchoolYearAndDistrictId(2018, -30).isAggregateEnabled()).isNull();
        assertThat(repository.findOneBySchoolYearAndDistrictId(2018, -30).isIndividualEnabled()).isFalse();

        assertThat(countRowsInTableWhere("audit_district_embargo", "action = 'insert' and district_id = -30 and school_year = 2018 and individual = 0")).isEqualTo(1);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailToCreateADuplicateDistrictEmbargo() {
        final Embargo embargo = Embargo.builder()
                .organizationType(OrganizationType.District)
                .organizationId(-10L)
                .schoolYear(2018)
                .individualEnabled(false)
                .build();

        repository.create(embargo, "test");
    }

    @Test
    public void itShouldUpdateAStateEmbargo() {
        final Embargo embargo = Embargo.builder()
                .organizationType(OrganizationType.State)
                .aggregateEnabled(false)
                .schoolYear(2018)
                .build();

        assertThat(repository.findOneBySchoolYearAndState(2018).isAggregateEnabled()).isTrue();
        assertThat(countRowsInTableWhere("audit_state_embargo", "school_year = 2018 and aggregate = 0")).isZero();
        assertThat(countRowsInTableWhere("audit_state_embargo", "school_year = 2018 and aggregate = 1")).isEqualTo(1);

        repository.update(embargo, "test");
        assertThat(repository.findOneBySchoolYearAndState(2018).isAggregateEnabled()).isFalse();

        assertThat(countRowsInTableWhere("audit_state_embargo", "action = 'update' and school_year = 2018 and aggregate = 0")).isEqualTo(1);
        assertThat(countRowsInTableWhere("audit_state_embargo", "school_year = 2018 and aggregate = 1")).isEqualTo(1);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailToUpdateAMissingStateEmbargo() {
        final Embargo embargo = Embargo.builder()
                .organizationType(OrganizationType.State)
                .aggregateEnabled(false)
                .schoolYear(2017)
                .build();

        repository.update(embargo, "test");
    }

    @Test
    public void itShouldUpdateADistrictEmbargo() {
        final Embargo embargo = Embargo.builder()
                .organizationType(OrganizationType.District)
                .organizationId(-20L)
                .aggregateEnabled(false)
                .schoolYear(2018)
                .build();

        assertThat(repository.findOneBySchoolYearAndDistrictId(2018, -20).isAggregateEnabled()).isNull();
        assertThat(countRowsInTableWhere("audit_district_embargo", "district_id = -20 and school_year = 2018 and aggregate is null")).isEqualTo(1);
        assertThat(countRowsInTableWhere("audit_district_embargo", "district_id = -20 and school_year = 2018 and aggregate = 0")).isZero();

        repository.update(embargo, "test");

        assertThat(repository.findOneBySchoolYearAndDistrictId(2018, -20).isAggregateEnabled()).isFalse();
        assertThat(countRowsInTableWhere("audit_district_embargo", "district_id = -20 and school_year = 2018 and aggregate is null")).isEqualTo(1);
        assertThat(countRowsInTableWhere("audit_district_embargo", "action = 'update' and district_id = -20 and school_year = 2018 and aggregate = 0")).isEqualTo(1);
    }

    @Test
    public void itShouldAuditStateEmbargoDelete() {
        final int countStateEmbargo = countRowsInTableWhere("state_embargo", "1=1");

        template.getJdbcOperations().execute("DELETE FROM state_embargo");

        assertThat(countRowsInTableWhere("audit_state_embargo", "action = 'delete'")).isEqualTo(countStateEmbargo);
    }

    @Test
    public void itShouldAuditDistrictEmbargoDelete() {
        final int countStateEmbargo = countRowsInTableWhere("district_embargo", "1=1");

        template.getJdbcOperations().execute("DELETE FROM district_embargo");

        assertThat(countRowsInTableWhere("audit_district_embargo", "action = 'delete'")).isEqualTo(countStateEmbargo);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailToUpdateAMissingDistrictEmbargo() {
        final Embargo embargo = Embargo.builder()
                .organizationType(OrganizationType.District)
                .organizationId(-30L)
                .aggregateEnabled(false)
                .schoolYear(2018)
                .build();

        repository.update(embargo, "test");
    }

    private int countRowsInTableWhere(String tableName, String whereClause) {
        return template.getJdbcOperations().queryForObject("SELECT COUNT(0) FROM " + tableName + " WHERE " + whereClause, Integer.class);
    }
}
