package org.opentestsystem.rdw.reporting.processor.stream;


import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.opentestsystem.rdw.reporting.common.model.AggregateQuery;
import org.opentestsystem.rdw.reporting.common.model.AggregateRequestMessage;
import org.opentestsystem.rdw.reporting.common.stream.MessageSecurityService;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.opentestsystem.rdw.reporting.processor.model.UserReport;
import org.opentestsystem.rdw.reporting.processor.model.ReportRequestMessage;
import org.opentestsystem.rdw.reporting.processor.service.ReportContentService;
import org.opentestsystem.rdw.reporting.processor.service.ReportService;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.support.MessageBuilder;

import java.net.URI;
import java.util.HashMap;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.springframework.http.MediaType.APPLICATION_JSON;

@RunWith(MockitoJUnitRunner.class)
public class AggregateReportRequestSubmitterTest {

    private static final URI ReportUri = URI.create("/REPORTS/123");
    private static final long ReportId = 123;

    @Mock
    private ReportService reportService;

    @Mock
    private MessageSecurityService messageSecurityService;

    @Mock
    private AggregateReportRequestProcessor processor;

    @Mock
    private MessageChannel channel;

    @Mock
    private ReportContentService contentService;

    @Mock
    private User user;

    @Mock
    private UserReport report;

    @Mock
    private AggregateQuery query;

    @Captor
    private ArgumentCaptor<Message<AggregateRequestMessage>> requestCaptor;

    private Message<ReportRequestMessage> message;
    private AggregateReportRequestSubmitter submitter;

    @Before
    public void setup() {
        when(messageSecurityService.getUser(any(Message.class))).thenReturn(user);
        when(messageSecurityService.withUser(any(), any(User.class)))
                .thenAnswer(invocation -> invocation.getArgument(0));

        final ReportRequestMessage payload = ReportRequestMessage.builder()
                .reportId(ReportId)
                .build();
        message = MessageBuilder.createMessage(payload, new MessageHeaders(new HashMap<>()));

        when(report.getQuery()).thenReturn(query);
        when(report.getId()).thenReturn(ReportId);

        when(contentService.createUri(eq(report), eq(APPLICATION_JSON))).thenReturn(ReportUri);

        when(reportService.findOneById(eq(ReportId))).thenReturn(Optional.of(report));

        when(processor.aggregateRequest()).thenReturn(channel);

        submitter = new AggregateReportRequestSubmitter(reportService, messageSecurityService, processor, contentService);
    }

    @Test
    public void itShouldTransformAndSubmitAnAggregateReportRequest() {
        submitter.submitAggregateReportRequest(message);

        verify(messageSecurityService).withUser(any(), eq(user));
        verify(channel).send(requestCaptor.capture());
        final AggregateRequestMessage requestMessage = requestCaptor.getValue().getPayload();
        assertThat(requestMessage.getId()).isEqualTo(ReportId);
        assertThat(requestMessage.getAggregateQuery()).isEqualTo(query);
        assertThat(requestMessage.getResponseLocation()).isEqualTo(ReportUri);
    }

}