package org.opentestsystem.rdw.reporting.processor.service;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.opentestsystem.rdw.reporting.common.model.Report;
import org.opentestsystem.rdw.reporting.common.repository.DataSourceConfiguration;
import org.opentestsystem.rdw.reporting.processor.repository.JdbcReportRepository;
import org.opentestsystem.rdw.utils.YamlPropertiesConfigurator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringRunner;

import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

import static org.assertj.core.api.Assertions.assertThat;
import static org.opentestsystem.rdw.reporting.processor.MockBuilder.report;

@ContextConfiguration(classes = TestConfiguration.class)
@SpringBootTest(classes = {
        DataSourceAutoConfiguration.class,
        DataSourceConfiguration.class,
        YamlPropertiesConfigurator.class,
        DefaultReportService.class,
        JdbcReportRepository.class,
        JacksonAutoConfiguration.class
})
@ActiveProfiles("test")
@RunWith(SpringRunner.class)
public class DefaultReportServiceIT {
    private final static int chunkCount = 10;

    @Autowired
    public ReportService service;

    @Autowired
    public NamedParameterJdbcTemplate template;

    private ExecutorService executorService;

    private Long reportId;

    @Before
    public void setup() {
        executorService = Executors.newFixedThreadPool(chunkCount);
    }

    @After
    public void tearDown() {
        executorService.shutdownNow();
        if (reportId != null) {
            template.update(
                    "DELETE FROM user_report WHERE id = :report_id;",
                    new MapSqlParameterSource().addValue("report_id", reportId));
        }
    }

    @Test
    public void itShouldOnlyReturnChunksCompletedOnce() throws Exception {
        final Report report = service.create(Report.builder()
                .copy(report())
                .totalChunkCount(chunkCount)
                .build());
        reportId = report.getId();

        final Semaphore startSemaphore = new Semaphore(0);
        final Semaphore endSemaphore = new Semaphore(0);
        final CopyOnWriteArrayList<Boolean> isLastChunkResults = new CopyOnWriteArrayList<>();
        final CopyOnWriteArrayList<Integer> completeCount = new CopyOnWriteArrayList<>();

        for (int i = 0; i < chunkCount; i++) {
            final int chunkIdx = i;
            executorService.execute(() -> {
                try {
                    startSemaphore.tryAcquire(30, TimeUnit.SECONDS);
                    final Report updated = service.completeChunk(report);
                    isLastChunkResults.add(updated.getTotalChunkCount() == updated.getCompleteChunkCount());
                    completeCount.add(updated.getCompleteChunkCount());
                    endSemaphore.release(1);
                } catch (final InterruptedException e) {
                    throw new RuntimeException("Failed to acquire chunk permit", e);
                }
            });
        }
        startSemaphore.release(chunkCount);
        endSemaphore.tryAcquire(chunkCount, 30, TimeUnit.SECONDS);

        assertThat(isLastChunkResults.stream().filter((x) -> x)).hasSize(1);
        for (int i = 1; i <= chunkCount; i++) {
            assertThat(completeCount).contains(i);
        }
    }
}