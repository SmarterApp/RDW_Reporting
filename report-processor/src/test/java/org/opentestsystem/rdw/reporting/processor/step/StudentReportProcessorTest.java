package org.opentestsystem.rdw.reporting.processor.step;

import com.google.common.collect.ImmutableMap;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.common.model.Subject;
import org.opentestsystem.rdw.reporting.common.model.Report;
import org.opentestsystem.rdw.reporting.common.model.Student;
import org.opentestsystem.rdw.reporting.common.report.AbstractBatchExamReportRequest;
import org.opentestsystem.rdw.reporting.common.report.AbstractExamReport;
import org.opentestsystem.rdw.reporting.common.report.AbstractExamReportRequest;
import org.opentestsystem.rdw.reporting.common.report.ExamQueryParams;
import org.opentestsystem.rdw.reporting.common.report.PrintOptions;
import org.opentestsystem.rdw.reporting.common.report.ReportViewSupport;
import org.opentestsystem.rdw.reporting.common.report.iab.IabReport;
import org.opentestsystem.rdw.reporting.common.report.iab.IabReportRepository;
import org.opentestsystem.rdw.reporting.common.report.ica.IcaReport;
import org.opentestsystem.rdw.reporting.common.report.ica.IcaReportRepository;
import org.opentestsystem.rdw.reporting.common.report.processor.HtmlToPdfProcessor;
import org.opentestsystem.rdw.reporting.common.report.processor.TemplateProcessor;
import org.opentestsystem.rdw.reporting.common.security.PermissionScope;
import org.opentestsystem.rdw.reporting.processor.model.ProcessStudentChunkMessage;
import org.opentestsystem.rdw.reporting.processor.model.StudentCompositeReport;
import org.opentestsystem.rdw.reporting.processor.requesthandler.ExamQueryParamsParser;
import org.opentestsystem.rdw.reporting.processor.service.ReportGenerationTemporaryStorage;
import org.opentestsystem.rdw.reporting.processor.service.ReportService;
import org.opentestsystem.rdw.reporting.processor.stream.GenerateStudentsReportProcessor;
import org.opentestsystem.rdw.reporting.processor.stream.StudentReportProcessor;
import org.springframework.retry.RecoveryCallback;
import org.springframework.retry.RetryCallback;
import org.springframework.retry.RetryContext;
import org.springframework.retry.RetryState;
import org.springframework.retry.support.RetryTemplate;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.Set;

import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyCollectionOf;
import static org.mockito.Matchers.anyMapOf;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.reporting.processor.MockBuilder.student;

@RunWith(MockitoJUnitRunner.class)
public class StudentReportProcessorTest {
    private static final long ReportId = 123L;

    @Mock
    private IabReportRepository iabReportRepository;

    @Mock
    private IcaReportRepository icaReportRepository;

    @Mock
    private ReportService reportService;

    @Mock
    private ReportGenerationTemporaryStorage temporaryStorage;

    @Mock
    private ReportViewSupport support;

    @Mock
    private TemplateProcessor templateProcessor;

    @Mock
    private HtmlToPdfProcessor htmlToPdfProcessor;

    @Mock
    private RetryTemplate retryTemplate;

    @Mock
    private GenerateStudentsReportProcessor processor;

    @Captor
    private ArgumentCaptor<ExamQueryParams> examFilterCaptor;

    @Captor
    private ArgumentCaptor<Collection<Long>> studentIdCaptor;

    @Captor
    private ArgumentCaptor<Map<String, Object>> templateProcessorModelCaptor;

    private ProcessStudentChunkMessage message;
    private Set<ExamQueryParamsParser> queryParamsParsers;
    private StudentReportProcessor writer;

    @Before
    public void setup() throws Exception {
        final AbstractExamReportRequest reportRequest = mock(AbstractBatchExamReportRequest.class);
        when(reportRequest.getLanguage()).thenReturn(Locale.US);
        final PrintOptions printOptions = mock(PrintOptions.class);
        when(reportRequest.getOptions()).thenReturn(printOptions);

        final Report report = Report.builder()
                .id(ReportId)
                .totalChunkCount(10)
                .reportRequest(reportRequest)
                .build();
        when(reportService.findOneById(ReportId)).thenReturn(Optional.of(report));
        when(reportService.completeChunk(any(Report.class))).thenAnswer(invocation ->
                invocation.getArgumentAt(0, Report.class));

        message = ProcessStudentChunkMessage.builder()
                .reportId(ReportId)
                .students(newArrayList(
                        student(1L).copy().lastName("LastA").build(),
                        student(2L).copy().lastName("LastB").build()))
                .build();

        queryParamsParsers = new LinkedHashSet<>();
        final ExamQueryParamsParser accepting = accepting();
        final ExamQueryParams params = ExamQueryParams.builder().build();
        when(accepting.parseQueryParams(eq(reportRequest)))
                .thenReturn(params);
        queryParamsParsers.add(accepting);

        when(iabReportRepository.findAllForStudentsByExamFilter(any(PermissionScope.class), anyCollectionOf(Long.class), any(ExamQueryParams.class)))
                .thenReturn(new HashMap<>());

        when(icaReportRepository.findAllForStudentsByExamFilter(any(PermissionScope.class), anyCollectionOf(Long.class), any(ExamQueryParams.class)))
                .thenReturn(new HashMap<>());

        final byte[] htmlContent = "htmlContent".getBytes();
        when(templateProcessor.process(eq("batch-reports"), anyMapOf(String.class, Object.class), eq(Locale.US)))
                .thenReturn(htmlContent);

        doAnswer(invocation ->
                invocation.getArgumentAt(0, RetryCallback.class).doWithRetry(mock(RetryContext.class))
        ).when(retryTemplate).execute(any(RetryCallback.class), any(RecoveryCallback.class), any(RetryState.class));

        final byte[] pdfConetnt = "pdfContent".getBytes();
        when(htmlToPdfProcessor.process(eq(htmlContent), eq(printOptions)))
                .thenAnswer(invocation -> new ByteArrayInputStream(pdfConetnt));

        writer = new StudentReportProcessor(
                queryParamsParsers,
                iabReportRepository,
                icaReportRepository,
                reportService,
                temporaryStorage,
                support,
                templateProcessor,
                htmlToPdfProcessor,
                retryTemplate,
                processor);
    }

    @Test(expected = IllegalStateException.class)
    public void itShouldThrowIfUnableToFindAParser() {
        queryParamsParsers.clear();
        writer.generateStudentChunkReport(message);
    }

    @Test(expected = IllegalStateException.class)
    public void itShouldThrowIfUnableToFindAnAcceptingParser() {
        queryParamsParsers.clear();
        queryParamsParsers.add(rejecting());
        queryParamsParsers.add(rejecting());
        writer.generateStudentChunkReport(message);
    }

    @Test
    public void itShouldSelectTheFirstAcceptingParser() throws Exception {
        queryParamsParsers.clear();
        final ExamQueryParamsParser accepting = accepting();
        final ExamQueryParams params = ExamQueryParams.builder().build();
        when(accepting.parseQueryParams(any(AbstractBatchExamReportRequest.class)))
                .thenReturn(params);

        queryParamsParsers.add(rejecting());
        queryParamsParsers.add(rejecting());
        queryParamsParsers.add(accepting);
        queryParamsParsers.add(accepting());
        writer.generateStudentChunkReport(message);

        verify(iabReportRepository).findAllForStudentsByExamFilter(
                any(PermissionScope.class),
                studentIdCaptor.capture(),
                examFilterCaptor.capture());

        assertThat(studentIdCaptor.getValue()).containsOnly(1L, 2L);
        assertThat(examFilterCaptor.getValue()).isEqualTo(params);
    }

    @Test
    public void itShouldFetchIabReports() throws Exception {
        final Map<Long, Map<Subject, IabReport>> reportsByStudent = new HashMap<>();
        reportsByStudent.put(1L, reportsBySubject(IabReport.class));

        final ExamQueryParamsParser parser = mock(ExamQueryParamsParser.class);
        when(parser.accept(any(AbstractExamReportRequest.class))).thenReturn(true);
        final ExamQueryParams params = ExamQueryParams.builder()
                .assessmentType(AssessmentType.IAB)
                .build();
        when(parser.parseQueryParams(any(AbstractExamReportRequest.class))).thenReturn(params);
        queryParamsParsers.clear();
        queryParamsParsers.add(parser);

        when(iabReportRepository.findAllForStudentsByExamFilter(
                any(PermissionScope.class),
                anyCollectionOf(Long.class),
                eq(params)))
                .thenReturn(reportsByStudent);

        writer.generateStudentChunkReport(message);

        verify(templateProcessor).process(anyString(), templateProcessorModelCaptor.capture(), any(Locale.class));
        final List<StudentCompositeReport> reports = (List<StudentCompositeReport>)templateProcessorModelCaptor.getValue().get("studentCompositeReports");

        assertThat(reports).hasSize(2);
        assertThat(reports.get(0).getIabEla()).isNotNull();
        assertThat(reports.get(0).getIabMath()).isNotNull();
        assertThat(reports.get(0).getStudent().getId()).isEqualTo(1L);

        verifyZeroInteractions(icaReportRepository);
    }

    @Test
    public void itShouldFetchIcaReports() throws Exception {
        final Map<Long, Map<Subject, IcaReport>> reportsByStudent = new HashMap<>();
        reportsByStudent.put(1L, reportsBySubject(IcaReport.class));

        final ExamQueryParamsParser parser = mock(ExamQueryParamsParser.class);
        when(parser.accept(any(AbstractExamReportRequest.class))).thenReturn(true);
        final ExamQueryParams params = ExamQueryParams.builder()
                .assessmentType(AssessmentType.ICA)
                .build();
        when(parser.parseQueryParams(any(AbstractExamReportRequest.class))).thenReturn(params);
        queryParamsParsers.clear();
        queryParamsParsers.add(parser);

        when(icaReportRepository.findAllForStudentsByExamFilter(
                any(PermissionScope.class),
                anyCollectionOf(Long.class),
                any(ExamQueryParams.class)))
                .thenReturn(reportsByStudent);

        writer.generateStudentChunkReport(message);

        verify(templateProcessor).process(anyString(), templateProcessorModelCaptor.capture(), any(Locale.class));
        final List<StudentCompositeReport> reports = (List<StudentCompositeReport>)templateProcessorModelCaptor.getValue().get("studentCompositeReports");

        assertThat(reports).hasSize(2);
        assertThat(reports.get(0).getIcaEla()).isNotNull();
        assertThat(reports.get(0).getIcaMath()).isNotNull();
        assertThat(reports.get(0).getStudent().getId()).isEqualTo(1);

        verifyZeroInteractions(iabReportRepository);
    }

    @Test
    public void itShouldFetchIcaAndIABReports() throws Exception {
        final Map<Long, Map<Subject, IcaReport>> icaReportsByStudent = new HashMap<>();
        icaReportsByStudent.put(1L, reportsBySubject(IcaReport.class));
        final Map<Long, Map<Subject, IabReport>> iabReportsbyStudent = new HashMap<>();
        iabReportsbyStudent.put(1L, reportsBySubject(IabReport.class));

        final ExamQueryParamsParser parser = mock(ExamQueryParamsParser.class);
        when(parser.accept(any(AbstractExamReportRequest.class))).thenReturn(true);
        final ExamQueryParams params = ExamQueryParams.builder()
                .build();
        when(parser.parseQueryParams(any(AbstractExamReportRequest.class))).thenReturn(params);
        queryParamsParsers.clear();
        queryParamsParsers.add(parser);

        when(iabReportRepository.findAllForStudentsByExamFilter(
                any(PermissionScope.class),
                anyCollectionOf(Long.class),
                any(ExamQueryParams.class)))
                .thenReturn(iabReportsbyStudent);

        when(icaReportRepository.findAllForStudentsByExamFilter(
                any(PermissionScope.class),
                anyCollectionOf(Long.class),
                any(ExamQueryParams.class)))
                .thenReturn(icaReportsByStudent);

        writer.generateStudentChunkReport(message);

        verify(templateProcessor).process(anyString(), templateProcessorModelCaptor.capture(), any(Locale.class));
        final List<StudentCompositeReport> reports = (List<StudentCompositeReport>)templateProcessorModelCaptor.getValue().get("studentCompositeReports");

        assertThat(reports).hasSize(2);
        assertThat(reports.get(0).getIabEla()).isNotNull();
        assertThat(reports.get(0).getIabMath()).isNotNull();
        assertThat(reports.get(0).getIcaEla()).isNotNull();
        assertThat(reports.get(0).getIcaMath()).isNotNull();
        assertThat(reports.get(0).getStudent().getId()).isEqualTo(1);
    }

    @Test
    public void itShouldWritePdfContentsToTemporaryStorage() throws Exception {
        writer.generateStudentChunkReport(message);

        verify(temporaryStorage).writeChunk(eq(message.getReportId()), eq(0), any(InputStream.class));
    }

    private ExamQueryParamsParser accepting() {
        final ExamQueryParamsParser parser = mock(ExamQueryParamsParser.class);
        when(parser.accept(any(AbstractBatchExamReportRequest.class))).thenReturn(true);
        return parser;
    }

    private ExamQueryParamsParser rejecting() {
        return mock(ExamQueryParamsParser.class);
    }

    private <T extends AbstractExamReport>  Map<Subject, T> reportsBySubject(final Class<T> reportClazz) {
        final Student student = Student.builder()
                .id(123L)
                .firstName("first")
                .lastName("last")
                .ssid("ssid")
                .build();

        final T mathReport = mock(reportClazz);
        when(mathReport.getStudent()).thenReturn(student);

        final T elaReport = mock(reportClazz);
        when(elaReport.getStudent()).thenReturn(student);

        return ImmutableMap.<Subject, T>builder()
                .put(Subject.MATH, mathReport)
                .put(Subject.ELA, elaReport)
                .build();
    }
}
