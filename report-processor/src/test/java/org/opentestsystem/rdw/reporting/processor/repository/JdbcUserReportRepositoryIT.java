package org.opentestsystem.rdw.reporting.processor.repository;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringRunner;

import java.util.List;
import java.util.NoSuchElementException;
import org.opentestsystem.rdw.reporting.common.model.SchoolGradePrintableReportQuery;
import org.opentestsystem.rdw.reporting.common.test.ITDataSourceConfiguration;
import org.opentestsystem.rdw.reporting.common.test.RepositoryIT;
import org.opentestsystem.rdw.reporting.common.test.TenantConfiguration;
import org.opentestsystem.rdw.reporting.processor.configuration.JacksonConfiguration;
import org.opentestsystem.rdw.reporting.processor.model.UserReport;

import static com.google.common.collect.ImmutableList.of;
import static java.lang.Integer.parseInt;
import static org.assertj.core.api.Assertions.assertThat;
import static org.opentestsystem.rdw.reporting.processor.MockBuilder.report;
import static org.opentestsystem.rdw.reporting.processor.stream.FetchStudents.CompletedChunk;
import static org.opentestsystem.rdw.reporting.processor.stream.FetchStudents.TotalChunk;

@RunWith(SpringRunner.class)
@RepositoryIT
@ContextConfiguration(classes = {
        ITDataSourceConfiguration.class,
        JdbcUserReportRepository.class,
        JacksonAutoConfiguration.class,
        JacksonConfiguration.class,
        ReportQueryMapper.class,
        TenantConfiguration.class
})
public class JdbcUserReportRepositoryIT {

    @Autowired
    private UserReportRepository repository;

    @Autowired
    private NamedParameterJdbcTemplate template;

    @Test
    public void itShouldInsertAReport() {
        final UserReport report = report();
        assertThat(report.getId()).isNull();

        final UserReport inserted = repository.create(report);
        assertThat(inserted.getId()).isGreaterThan(0);
        assertThat(inserted.getUser()).isEqualTo(report.getUser());
        assertThat(inserted.getLabel()).isEqualTo(report.getLabel());
        assertThat(inserted.getCreated()).isEqualTo(report.getCreated());
        assertThat(inserted.getReportResourceUri()).isEqualTo(report.getReportResourceUri());
        assertThat(inserted.getStatus()).isEqualTo(report.getStatus());
        assertThat(((SchoolGradePrintableReportQuery) inserted.getQuery()).getSchoolYear())
                .isEqualTo(((SchoolGradePrintableReportQuery) report.getQuery()).getSchoolYear());

        final String reportType = template.queryForObject(
                "SELECT report_type FROM user_report WHERE id = :id",
                new MapSqlParameterSource("id", inserted.getId()),
                String.class);
        assertThat(reportType).isEqualTo(report.getQuery().getType().name());
    }

    @Test
    public void itShouldUpdateAReport() {
        final UserReport original = repository.create(report());
        final UserReport modified = UserReport.builder()
                .copy(original)
                .label("Some New Label")
                .build();

        final UserReport updated = repository.update(modified);
        assertThat(updated.getLabel()).isEqualTo(modified.getLabel());

        final UserReport fetched = repository.findById(original.getId());
        assertThat(fetched.getLabel()).isEqualTo(modified.getLabel());
    }

    @Test
    public void itShouldFindOneById() {
        final UserReport original = repository.create(report());

        final UserReport fetched = repository.findById(original.getId());
        assertThat(fetched.getId()).isEqualTo(original.getId());
        assertThat(fetched.getCreated()).isEqualTo(original.getCreated());
        assertThat(fetched.getLabel()).isEqualTo(original.getLabel());
        assertThat(fetched.getUser()).isEqualTo(original.getUser());
        assertThat(fetched.getStatus()).isEqualTo(original.getStatus());
        assertThat(fetched.getReportResourceUri()).isEqualTo(original.getReportResourceUri());
        assertThat(((SchoolGradePrintableReportQuery) fetched.getQuery()).getSchoolYear())
                .isEqualTo(((SchoolGradePrintableReportQuery) original.getQuery()).getSchoolYear());
    }

    @Test
    public void itShouldHandleAMissingReportById() {
        assertThat(repository.findById(123L)).isNull();
    }

    @Test
    public void itShouldFindAllReportsForAUser() {
        final UserReport reportA = repository.create(report());
        final UserReport reportB = repository.create(report());
        repository.create(UserReport.builder()
                .copy(report())
                .user("another user")
                .build());

        final List<UserReport> userReports = repository.findByUserAndIds(reportA.getUser(), of());

        assertThat(userReports.stream().map(UserReport::getId))
                .hasSize(2)
                .containsOnly(reportA.getId(), reportB.getId());
    }

    @Test
    public void itShouldFindAllReportsForAUserFilteredByIds() {
        final UserReport reportA = repository.create(report());
        final UserReport reportB = repository.create(report());
        repository.create(report());
        repository.create(UserReport.builder()
                .copy(report())
                .user("another user")
                .build());

        final List<UserReport> userReports = repository
                .findByUserAndIds(reportA.getUser(), of(reportA.getId(), reportB.getId()));

        assertThat(userReports.stream().map(UserReport::getId))
                .hasSize(2)
                .containsOnly(reportA.getId(), reportB.getId());
    }

    @Test
    public void itShouldHandleNoReportsForAUser() {
        assertThat(repository.findByUserAndIds("user", of())).isEmpty();
    }

    @Test
    public void itShouldMarkChunksCompleted() {
        UserReport report = UserReport.builder()
                .copy(report())
                .metadata(TotalChunk, "10")
                .metadata(CompletedChunk, "0")
                .build();

        report = repository.create(report);
        report = repository.update(report);

        report = repository.completeChunk(report);
        int completedChunkCount = parseInt(report.getMetadata().get(CompletedChunk));
        assertThat(completedChunkCount).isEqualTo(1);

        report = repository.findById(report.getId());
        completedChunkCount = parseInt(report.getMetadata().get(CompletedChunk));
        assertThat(completedChunkCount).isEqualTo(1);

        report = repository.completeChunk(report);
        completedChunkCount = parseInt(report.getMetadata().get(CompletedChunk));
        assertThat(completedChunkCount).isEqualTo(2);

        report = repository.findById(report.getId());
        completedChunkCount = parseInt(report.getMetadata().get(CompletedChunk));
        assertThat(completedChunkCount).isEqualTo(2);
    }

    @Test
    public void itShouldUpsertMetadataOnReportUpdate() {
        final UserReport original = repository.create(report());
        UserReport updateSrc = original.copy()
                .metadata("some_metadata", "some_value")
                .build();
        repository.update(updateSrc);
        UserReport updateResult = repository.findById(original.getId());
        assertThat(updateResult.getMetadata().size()).isEqualTo(1);
        assertThat(updateResult.getMetadata().get("some_metadata")).isEqualTo("some_value");

        updateSrc = updateResult.copy()
                .metadata("some_metadata", "new_value")
                .metadata("new_metadata", "another_value")
                .build();
        repository.update(updateSrc);
        updateResult = repository.findById(original.getId());
        assertThat(updateResult.getMetadata().size()).isEqualTo(2);
        assertThat(updateResult.getMetadata().get("some_metadata")).isEqualTo("new_value");
        assertThat(updateResult.getMetadata().get("new_metadata")).isEqualTo("another_value");
    }

    @Test
    public void itShouldDelete() {
        final UserReport original = repository.create(report());
        original.getMetadata().put("some_metadata", "some_value");
        repository.update(original);

        int metadataCount = template.queryForObject("SELECT count(*) FROM user_report_metadata",
                new MapSqlParameterSource(),
                Integer.class);
        assertThat(metadataCount).isEqualTo(1);

        repository.deleteByUserAndId(original.getUser(), original.getId());

        metadataCount = template.queryForObject("SELECT count(*) FROM user_report_metadata",
                new MapSqlParameterSource(),
                Integer.class);
        assertThat(metadataCount).isEqualTo(0);
    }

    @Test(expected = NoSuchElementException.class)
    public void itShouldThrowExceptionWhenDeletingAbsentRecord() {
        final UserReport original = repository.create(report());
        repository.deleteByUserAndId(original.getUser(), -1);
    }

    @Test(expected = NoSuchElementException.class)
    public void itShouldThrowExceptionWhenDeletingPresentRecordWithIncorrectUser() {
        final UserReport original = repository.create(report());
        repository.deleteByUserAndId("wrong user", original.getId());
    }

}
