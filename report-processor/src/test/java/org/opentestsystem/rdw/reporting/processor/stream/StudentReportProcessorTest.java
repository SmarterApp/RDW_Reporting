package org.opentestsystem.rdw.reporting.processor.stream;

import com.google.common.collect.ImmutableMap;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.common.model.Subject;
import org.opentestsystem.rdw.reporting.common.stream.MessageSecurityService;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.opentestsystem.rdw.reporting.processor.model.AbstractBatchExamReportRequest;
import org.opentestsystem.rdw.reporting.processor.model.AbstractExamReport;
import org.opentestsystem.rdw.reporting.processor.model.AbstractExamReportRequest;
import org.opentestsystem.rdw.reporting.processor.model.ExamQueryParams;
import org.opentestsystem.rdw.reporting.processor.model.IabReport;
import org.opentestsystem.rdw.reporting.processor.model.IcaSummativeReport;
import org.opentestsystem.rdw.reporting.processor.model.PrintOptions;
import org.opentestsystem.rdw.reporting.processor.model.ProcessStudentChunkMessage;
import org.opentestsystem.rdw.reporting.processor.model.Report;
import org.opentestsystem.rdw.reporting.processor.model.StudentCompositeReport;
import org.opentestsystem.rdw.reporting.processor.repository.IabReportRepository;
import org.opentestsystem.rdw.reporting.processor.repository.IcaSummativeReportRepository;
import org.opentestsystem.rdw.reporting.processor.requesthandler.ExamQueryParamsParser;
import org.opentestsystem.rdw.reporting.processor.service.HtmlToPdfProcessor;
import org.opentestsystem.rdw.reporting.processor.service.ReportGenerationTemporaryStorage;
import org.opentestsystem.rdw.reporting.processor.service.ReportService;
import org.opentestsystem.rdw.reporting.processor.service.ReportViewSupport;
import org.opentestsystem.rdw.reporting.processor.service.TemplateProcessor;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.retry.RetryCallback;
import org.springframework.retry.RetryContext;
import org.springframework.retry.support.RetryTemplate;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.Set;

import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyCollection;
import static org.mockito.ArgumentMatchers.anyMap;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.reporting.processor.MockBuilder.student;
import static org.opentestsystem.rdw.reporting.processor.stream.FetchStudents.TotalChunk;

@RunWith(MockitoJUnitRunner.class)
public class StudentReportProcessorTest {
    private static final long ReportId = 123L;

    @Mock
    private IabReportRepository iabReportRepository;

    @Mock
    private IcaSummativeReportRepository icaReportRepository;

    @Mock
    private ReportService reportService;

    @Mock
    private ReportGenerationTemporaryStorage temporaryStorage;

    @Mock
    private ReportViewSupport support;

    @Mock
    private TemplateProcessor templateProcessor;

    @Mock
    private HtmlToPdfProcessor htmlToPdfProcessor;

    @Mock
    private RetryTemplate retryTemplate;

    @Mock
    private PdfReportProcessor processor;

    @Mock
    private MessageSecurityService messageSecurityService;

    @Mock
    private User user;

    @Captor
    private ArgumentCaptor<ExamQueryParams> examFilterCaptor;

    @Captor
    private ArgumentCaptor<Collection<Long>> studentIdCaptor;

    @Captor
    private ArgumentCaptor<Map<String, Object>> templateProcessorModelCaptor;

    private ProcessStudentChunkMessage payload;
    private Message<ProcessStudentChunkMessage> message;
    private Set<ExamQueryParamsParser> queryParamsParsers;
    private StudentReportProcessor writer;

    @Before
    public void setup() throws Exception {
        final AbstractExamReportRequest reportRequest = mock(AbstractBatchExamReportRequest.class);
        when(reportRequest.getLanguage()).thenReturn(Locale.US);
        final PrintOptions printOptions = mock(PrintOptions.class);
        when(reportRequest.getOptions()).thenReturn(printOptions);

        final Report report = Report.builder()
                .id(ReportId)
                .metadata(TotalChunk, "10")
                .reportRequest(reportRequest)
                .build();
        when(reportService.findOneById(ReportId)).thenReturn(Optional.of(report));
        when(reportService.completeChunk(any(Report.class))).thenAnswer(invocation ->
                invocation.getArgument(0));

        payload = ProcessStudentChunkMessage.builder()
                .reportId(ReportId)
                .students(newArrayList(
                        student(1L).copy().lastName("LastA").build(),
                        student(2L).copy().lastName("LastB").build()))
                .build();
        message = MessageBuilder.createMessage(payload, new MessageHeaders(new HashMap<>()));

        queryParamsParsers = new LinkedHashSet<>();
        final ExamQueryParamsParser accepting = accepting();
        final ExamQueryParams params = ExamQueryParams.builder().build();
        when(accepting.parseQueryParams(eq(reportRequest)))
                .thenReturn(params);
        queryParamsParsers.add(accepting);

        when(iabReportRepository.findAllForStudentsByExamFilter(any(User.class), anyCollection(), any(ExamQueryParams.class)))
                .thenReturn(new HashMap<>());

        when(icaReportRepository.findAllForStudentsByExamFilter(any(User.class), anyCollection(), any(ExamQueryParams.class)))
                .thenReturn(new HashMap<>());

        final byte[] htmlContent = "htmlContent".getBytes();
        when(templateProcessor.process(eq("batch-reports"), anyMap(), eq(Locale.US)))
                .thenReturn(htmlContent);

        doAnswer(invocation -> {
            final RetryCallback callback = invocation.getArgument(0);
            return callback.doWithRetry(mock(RetryContext.class));
        }).when(retryTemplate).execute(any(), any(), any());

        final byte[] pdfConetnt = "pdfContent".getBytes();
        when(htmlToPdfProcessor.process(eq(htmlContent), eq(printOptions)))
                .thenAnswer(invocation -> new ByteArrayInputStream(pdfConetnt));

        when(messageSecurityService.getUser(any(Message.class))).thenReturn(user);

        writer = new StudentReportProcessor(
                queryParamsParsers,
                iabReportRepository,
                icaReportRepository,
                reportService,
                temporaryStorage,
                support,
                templateProcessor,
                htmlToPdfProcessor,
                retryTemplate,
                processor,
                messageSecurityService);
    }

    @Test(expected = IllegalStateException.class)
    public void itShouldThrowIfUnableToFindAParser() {
        queryParamsParsers.clear();
        writer.generateStudentChunkReport(message);
    }

    @Test(expected = IllegalStateException.class)
    public void itShouldThrowIfUnableToFindAnAcceptingParser() {
        queryParamsParsers.clear();
        queryParamsParsers.add(rejecting());
        queryParamsParsers.add(rejecting());
        writer.generateStudentChunkReport(message);
    }

    @Test
    public void itShouldSelectTheFirstAcceptingParser() throws Exception {
        queryParamsParsers.clear();
        final ExamQueryParamsParser accepting = accepting();
        final ExamQueryParams params = ExamQueryParams.builder().build();
        when(accepting.parseQueryParams(any(AbstractBatchExamReportRequest.class)))
                .thenReturn(params);

        queryParamsParsers.add(rejecting());
        queryParamsParsers.add(rejecting());
        queryParamsParsers.add(accepting);
        queryParamsParsers.add(accepting());
        writer.generateStudentChunkReport(message);

        verify(iabReportRepository).findAllForStudentsByExamFilter(
                any(User.class),
                studentIdCaptor.capture(),
                examFilterCaptor.capture());

        assertThat(studentIdCaptor.getValue()).containsOnly(1L, 2L);
        assertThat(examFilterCaptor.getValue()).isEqualTo(params);
    }

    @Test
    public void itShouldFetchIabReports() throws Exception {
        final Map<Long, Map<Subject, IabReport>> reportsByStudent = new HashMap<>();
        reportsByStudent.put(1L, reportsBySubject(IabReport.class));

        final ExamQueryParamsParser parser = mock(ExamQueryParamsParser.class);
        when(parser.accept(any(AbstractExamReportRequest.class))).thenReturn(true);
        final ExamQueryParams params = ExamQueryParams.builder()
                .assessmentTypeCode("iab")
                .build();
        when(parser.parseQueryParams(any(AbstractExamReportRequest.class))).thenReturn(params);
        queryParamsParsers.clear();
        queryParamsParsers.add(parser);

        when(iabReportRepository.findAllForStudentsByExamFilter(
                any(User.class),
                anyCollection(),
                eq(params)))
                .thenReturn(reportsByStudent);

        writer.generateStudentChunkReport(message);

        verify(templateProcessor).process(anyString(), templateProcessorModelCaptor.capture(), any(Locale.class));
        final List<StudentCompositeReport> reports = (List<StudentCompositeReport>) templateProcessorModelCaptor.getValue().get("studentCompositeReports");

        assertThat(reports).hasSize(2);
        assertThat(reports.get(0).getIabEla()).isNotNull();
        assertThat(reports.get(0).getIabMath()).isNotNull();
        assertThat(reports.get(0).getStudent().getId()).isEqualTo(1L);

        verifyZeroInteractions(icaReportRepository);
    }

    @Test
    public void itShouldFetchIcaReports() throws Exception {
        final Map<Long, Map<Subject, IcaSummativeReport>> reportsByStudent = new HashMap<>();
        reportsByStudent.put(1L, reportsBySubject(IcaSummativeReport.class));

        final ExamQueryParamsParser parser = mock(ExamQueryParamsParser.class);
        when(parser.accept(any(AbstractExamReportRequest.class))).thenReturn(true);
        final ExamQueryParams params = ExamQueryParams.builder()
                .assessmentTypeCode("ica")
                .build();
        when(parser.parseQueryParams(any(AbstractExamReportRequest.class))).thenReturn(params);
        queryParamsParsers.clear();
        queryParamsParsers.add(parser);

        when(icaReportRepository.findAllForStudentsByExamFilter(
                any(User.class),
                anyCollection(),
                any(ExamQueryParams.class)))
                .thenReturn(reportsByStudent);

        writer.generateStudentChunkReport(message);

        verify(templateProcessor).process(anyString(), templateProcessorModelCaptor.capture(), any(Locale.class));
        final List<StudentCompositeReport> reports = (List<StudentCompositeReport>) templateProcessorModelCaptor.getValue().get("studentCompositeReports");

        assertThat(reports).hasSize(2);
        assertThat(reports.get(0).getIcaEla()).isNotNull();
        assertThat(reports.get(0).getIcaMath()).isNotNull();
        assertThat(reports.get(0).getStudent().getId()).isEqualTo(1);

        verifyZeroInteractions(iabReportRepository);
    }

    @Test
    public void itShouldFetchIcaAndIABReports() throws Exception {
        final Map<Long, Map<Subject, IcaSummativeReport>> icaReportsByStudent = new HashMap<>();
        icaReportsByStudent.put(1L, reportsBySubject(IcaSummativeReport.class));
        final Map<Long, Map<Subject, IabReport>> iabReportsbyStudent = new HashMap<>();
        iabReportsbyStudent.put(1L, reportsBySubject(IabReport.class));

        final ExamQueryParamsParser parser = mock(ExamQueryParamsParser.class);
        when(parser.accept(any(AbstractExamReportRequest.class))).thenReturn(true);
        final ExamQueryParams params = ExamQueryParams.builder()
                .build();
        when(parser.parseQueryParams(any(AbstractExamReportRequest.class))).thenReturn(params);
        queryParamsParsers.clear();
        queryParamsParsers.add(parser);

        when(iabReportRepository.findAllForStudentsByExamFilter(
                any(User.class),
                anyCollection(),
                any(ExamQueryParams.class)))
                .thenReturn(iabReportsbyStudent);

        when(icaReportRepository.findAllForStudentsByExamFilter(
                any(User.class),
                anyCollection(),
                any(ExamQueryParams.class)))
                .thenReturn(icaReportsByStudent);

        writer.generateStudentChunkReport(message);

        verify(templateProcessor).process(anyString(), templateProcessorModelCaptor.capture(), any(Locale.class));
        final List<StudentCompositeReport> reports = (List<StudentCompositeReport>) templateProcessorModelCaptor.getValue().get("studentCompositeReports");

        assertThat(reports).hasSize(2);
        assertThat(reports.get(0).getIabEla()).isNotNull();
        assertThat(reports.get(0).getIabMath()).isNotNull();
        assertThat(reports.get(0).getIcaEla()).isNotNull();
        assertThat(reports.get(0).getIcaMath()).isNotNull();
        assertThat(reports.get(0).getStudent().getId()).isEqualTo(1);
    }

    @Test
    public void itShouldWritePdfContentsToTemporaryStorage() throws Exception {
        writer.generateStudentChunkReport(message);

        verify(temporaryStorage).writeChunk(eq(payload.getReportId()), eq(0), any(InputStream.class));
    }

    private ExamQueryParamsParser accepting() {
        final ExamQueryParamsParser parser = mock(ExamQueryParamsParser.class);
        when(parser.accept(any(AbstractBatchExamReportRequest.class))).thenReturn(true);
        return parser;
    }

    private ExamQueryParamsParser rejecting() {
        return mock(ExamQueryParamsParser.class);
    }

    private <T extends AbstractExamReport> Map<Subject, T> reportsBySubject(final Class<T> reportClazz) {
        final T mathReport = mock(reportClazz);
        final T elaReport = mock(reportClazz);
        return ImmutableMap.<Subject, T>builder()
                .put(Subject.MATH, mathReport)
                .put(Subject.ELA, elaReport)
                .build();
    }
}
