package org.opentestsystem.rdw.reporting.processor.stream;

import com.google.common.collect.ImmutableList;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.retry.RetryCallback;
import org.springframework.retry.RetryContext;
import org.springframework.retry.support.RetryTemplate;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import org.opentestsystem.rdw.reporting.common.model.AbstractPrintableReportQuery;
import org.opentestsystem.rdw.reporting.common.model.SubjectDefinition;
import org.opentestsystem.rdw.reporting.common.security.User;
import org.opentestsystem.rdw.reporting.common.service.SubjectDefinitionService;
import org.opentestsystem.rdw.reporting.common.stream.MessageSecurityService;
import org.opentestsystem.rdw.reporting.processor.model.AbstractExamReport;
import org.opentestsystem.rdw.reporting.processor.model.ExamQueryParams;
import org.opentestsystem.rdw.reporting.processor.model.IabReport;
import org.opentestsystem.rdw.reporting.processor.model.IcaSummativeReport;
import org.opentestsystem.rdw.reporting.processor.model.ProcessStudentChunkMessage;
import org.opentestsystem.rdw.reporting.processor.model.StudentCompositeReport;
import org.opentestsystem.rdw.reporting.processor.model.UserReport;
import org.opentestsystem.rdw.reporting.processor.repository.IabReportRepository;
import org.opentestsystem.rdw.reporting.processor.repository.IcaSummativeReportRepository;
import org.opentestsystem.rdw.reporting.processor.repository.SubjectRepository;
import org.opentestsystem.rdw.reporting.processor.requesthandler.ExamQueryParamsParser;
import org.opentestsystem.rdw.reporting.processor.service.HtmlToPdfProcessor;
import org.opentestsystem.rdw.reporting.processor.service.ReportGenerationTemporaryStorage;
import org.opentestsystem.rdw.reporting.processor.service.ReportViewSupport;
import org.opentestsystem.rdw.reporting.processor.service.TemplateProcessor;
import org.opentestsystem.rdw.reporting.processor.service.UserReportService;

import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyCollection;
import static org.mockito.ArgumentMatchers.anyMap;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.reporting.processor.MockBuilder.student;
import static org.opentestsystem.rdw.reporting.processor.stream.FetchStudents.TotalChunk;

@RunWith(MockitoJUnitRunner.class)
public class StudentReportProcessorTest {
    private static final long ReportId = 123L;
    private static final List<String> AssessmentTypes = ImmutableList.of("ica", "iab", "sum");

    @Mock
    private IabReportRepository iabReportRepository;

    @Mock
    private IcaSummativeReportRepository icaReportRepository;

    @Mock
    private UserReportService userReportService;

    @Mock
    private ReportGenerationTemporaryStorage temporaryStorage;

    @Mock
    private ReportViewSupport support;

    @Mock
    private TemplateProcessor templateProcessor;

    @Mock
    private HtmlToPdfProcessor htmlToPdfProcessor;

    @Mock
    private RetryTemplate retryTemplate;

    @Mock
    private PdfReportProcessor processor;

    @Mock
    private MessageSecurityService messageSecurityService;

    @Mock
    private User user;

    @Mock
    private SubjectRepository subjectRepository;

    @Mock
    private SubjectDefinitionService subjectDefinitionService;

    @Captor
    private ArgumentCaptor<ExamQueryParams> examFilterCaptor;

    @Captor
    private ArgumentCaptor<Collection<Long>> studentIdCaptor;

    @Captor
    private ArgumentCaptor<Map<String, Object>> templateProcessorModelCaptor;

    private ProcessStudentChunkMessage payload;
    private Message<ProcessStudentChunkMessage> message;
    private Set<ExamQueryParamsParser> queryParamsParsers;
    private StudentReportProcessor writer;

    @Before
    public void setup() throws Exception {
        final AbstractPrintableReportQuery query = mock(AbstractPrintableReportQuery.class);
        when(query.getLanguage()).thenReturn(Locale.US);

        final UserReport report = UserReport.builder()
                .id(ReportId)
                .metadata(TotalChunk, "10")
                .query(query)
                .build();
        when(userReportService.findOneById(ReportId)).thenReturn(Optional.of(report));
        when(userReportService.completeChunk(any(UserReport.class))).thenAnswer(invocation ->
                invocation.getArgument(0));

        payload = ProcessStudentChunkMessage.builder()
                .reportId(ReportId)
                .students(newArrayList(
                        student(1L).copy().lastName("LastA").build(),
                        student(2L).copy().lastName("LastB").build()))
                .build();
        message = MessageBuilder.createMessage(payload, new MessageHeaders(new HashMap<>()));

        queryParamsParsers = new LinkedHashSet<>();
        final ExamQueryParamsParser accepting = accepting();
        final ExamQueryParams params = ExamQueryParams.builder().build();
        when(accepting.parseQueryParams(eq(query)))
                .thenReturn(params);
        queryParamsParsers.add(accepting);

        final SubjectDefinition subjectDefinition = mock(SubjectDefinition.class);

        when(subjectDefinitionService.findAll()).thenReturn(Collections.singletonList(subjectDefinition));

        final IabReport iabReport = IabReport.builder()
                .subject("Math")
                .assessmentType("iab")
                .subjectDefinition(subjectDefinition).build();

        when(iabReportRepository.findAllForStudentsByExamFilter(any(User.class), anyCollection(), any(ExamQueryParams.class)))
                .thenReturn(Collections.singletonMap(1L, Collections.singleton(iabReport)));

        when(icaReportRepository.findAllForStudentsByExamFilter(any(User.class), anyCollection(), any(ExamQueryParams.class)))
                .thenReturn(new HashMap<>());

        final byte[] htmlContent = "htmlContent".getBytes();
        when(templateProcessor.process(eq("batch-reports"), anyMap(), eq(Locale.US)))
                .thenReturn(htmlContent);

        doAnswer(invocation -> {
            final RetryCallback callback = invocation.getArgument(0);
            return callback.doWithRetry(mock(RetryContext.class));
        }).when(retryTemplate).execute(any(), any(), any());

        final byte[] pdfContent = "pdfContent".getBytes();
        when(htmlToPdfProcessor.process(eq(htmlContent)))
                .thenAnswer(invocation -> new ByteArrayInputStream(pdfContent));

        when(messageSecurityService.getUser(any(Message.class))).thenReturn(user);

        when(subjectRepository.findAll()).thenReturn(ImmutableList.of("Math", "ELA"));

        when(subjectDefinitionService.findAll()).thenReturn(subjectDefinitions("Math", "ELA"));

        writer = new StudentReportProcessor(
                queryParamsParsers,
                iabReportRepository,
                icaReportRepository,
                userReportService,
                temporaryStorage,
                support,
                templateProcessor,
                htmlToPdfProcessor,
                retryTemplate,
                processor,
                messageSecurityService,
                subjectRepository,
                subjectDefinitionService);
    }

    @Test(expected = IllegalStateException.class)
    public void itShouldThrowIfUnableToFindAParser() {
        queryParamsParsers.clear();
        writer.generateStudentChunkReport(message);
    }

    @Test(expected = IllegalStateException.class)
    public void itShouldThrowIfUnableToFindAnAcceptingParser() {
        queryParamsParsers.clear();
        queryParamsParsers.add(rejecting());
        queryParamsParsers.add(rejecting());
        writer.generateStudentChunkReport(message);
    }

    @Test
    public void itShouldSelectTheFirstAcceptingParser() {
        queryParamsParsers.clear();
        final ExamQueryParamsParser accepting = accepting();
        final ExamQueryParams params = ExamQueryParams.builder().build();
        when(accepting.parseQueryParams(any(AbstractPrintableReportQuery.class)))
                .thenReturn(params);

        queryParamsParsers.add(rejecting());
        queryParamsParsers.add(rejecting());
        queryParamsParsers.add(accepting);
        queryParamsParsers.add(accepting());
        writer.generateStudentChunkReport(message);

        verify(iabReportRepository).findAllForStudentsByExamFilter(
                any(User.class),
                studentIdCaptor.capture(),
                examFilterCaptor.capture());

        assertThat(studentIdCaptor.getValue()).containsOnly(1L, 2L);
        assertThat(examFilterCaptor.getValue()).isEqualTo(params);
    }

    @Test
    public void itShouldFetchIabReports() {
        final Map<Long, Collection<IabReport>> reportsByStudent = new HashMap<>();
        reportsByStudent.put(1L, reportsForSubjects(IabReport.builder(), "iab"));

        final ExamQueryParamsParser parser = mock(ExamQueryParamsParser.class);
        when(parser.accept(any(AbstractPrintableReportQuery.class))).thenReturn(true);
        final ExamQueryParams params = ExamQueryParams.builder()
                .assessmentTypeCode("iab")
                .build();
        when(parser.parseQueryParams(any(AbstractPrintableReportQuery.class))).thenReturn(params);
        queryParamsParsers.clear();
        queryParamsParsers.add(parser);

        when(iabReportRepository.findAllForStudentsByExamFilter(
                any(User.class),
                anyCollection(),
                eq(params)))
                .thenReturn(reportsByStudent);

        writer.generateStudentChunkReport(message);

        verify(templateProcessor).process(anyString(), templateProcessorModelCaptor.capture(), any(Locale.class));
        final List<StudentCompositeReport> reports = (List<StudentCompositeReport>) templateProcessorModelCaptor.getValue().get("studentCompositeReports");

        assertThat(reports).hasSize(2);
        assertThat(reports.get(0).getReports().stream().map(AbstractExamReport::getSubject)).containsExactly("Math", "ELA");
        assertThat(reports.get(0).getStudent().getId()).isEqualTo(1L);

        verifyZeroInteractions(icaReportRepository);
    }

    @Test
    public void itShouldFetchIcaReports() {
        final Map<Long, Collection<IcaSummativeReport>> reportsByStudent = new HashMap<>();
        reportsByStudent.put(1L, reportsForSubjects(IcaSummativeReport.builder(), "ica"));

        final ExamQueryParamsParser parser = mock(ExamQueryParamsParser.class);
        when(parser.accept(any(AbstractPrintableReportQuery.class))).thenReturn(true);
        final ExamQueryParams params = ExamQueryParams.builder()
                .assessmentTypeCode("ica")
                .build();
        when(parser.parseQueryParams(any(AbstractPrintableReportQuery.class))).thenReturn(params);
        queryParamsParsers.clear();
        queryParamsParsers.add(parser);

        when(icaReportRepository.findAllForStudentsByExamFilter(
                any(User.class),
                anyCollection(),
                any(ExamQueryParams.class)))
                .thenReturn(reportsByStudent);

        writer.generateStudentChunkReport(message);

        verify(templateProcessor).process(anyString(), templateProcessorModelCaptor.capture(), any(Locale.class));
        final List<StudentCompositeReport> reports = (List<StudentCompositeReport>) templateProcessorModelCaptor.getValue().get("studentCompositeReports");

        assertThat(reports).hasSize(2);
        assertThat(reports.get(0).getReports().stream().map(AbstractExamReport::getSubject)).containsExactly("Math", "ELA");
        assertThat(reports.get(0).getStudent().getId()).isEqualTo(1);

        verifyZeroInteractions(iabReportRepository);
    }

    @Test
    public void itShouldFetchIcaAndIabAndSummativeReports() {
        final Map<Long, Collection<IcaSummativeReport>> sumReportsByStudent = new HashMap<>();
        sumReportsByStudent.put(1L, reportsForSubjects(IcaSummativeReport.builder(), "sum"));

        final Map<Long, Collection<IcaSummativeReport>> icaReportsByStudent = new HashMap<>();
        icaReportsByStudent.put(1L, reportsForSubjects(IcaSummativeReport.builder(), "ica"));

        final Map<Long, Collection<IabReport>> iabReportsbyStudent = new HashMap<>();
        iabReportsbyStudent.put(1L, reportsForSubjects(IabReport.builder(), "iab"));

        final ExamQueryParamsParser parser = mock(ExamQueryParamsParser.class);
        when(parser.accept(any(AbstractPrintableReportQuery.class))).thenReturn(true);
        final ExamQueryParams params = ExamQueryParams.builder()
                .build();
        when(parser.parseQueryParams(any(AbstractPrintableReportQuery.class))).thenReturn(params);
        queryParamsParsers.clear();
        queryParamsParsers.add(parser);

        when(iabReportRepository.findAllForStudentsByExamFilter(
                any(User.class),
                anyCollection(),
                any(ExamQueryParams.class)))
                .thenReturn(iabReportsbyStudent);

        when(icaReportRepository.findAllForStudentsByExamFilter(
                any(User.class),
                anyCollection(),
                any(ExamQueryParams.class)))
                .thenAnswer(invocation -> {
                    final ExamQueryParams requestParams = invocation.getArgument(2);
                    if ("ica".equals(requestParams.getAssessmentTypeCode())) {
                        return icaReportsByStudent;
                    } else if ("sum".equals(requestParams.getAssessmentTypeCode())) {
                        return sumReportsByStudent;
                    } else {
                        throw new IllegalStateException("Unknown assessment type");
                    }
                });

        writer.generateStudentChunkReport(message);

        verify(templateProcessor).process(anyString(), templateProcessorModelCaptor.capture(), any(Locale.class));
        final List<StudentCompositeReport> reports = (List<StudentCompositeReport>) templateProcessorModelCaptor.getValue().get("studentCompositeReports");

        assertThat(reports).hasSize(2);
        assertThat(reports.get(0).getReports().stream().map(AbstractExamReport::getSubject))
                .containsExactly("Math", "ELA", "Math", "ELA", "Math", "ELA");
        assertThat(reports.get(0).getReports().stream().map(AbstractExamReport::getAssessmentType))
                .containsExactly("iab", "iab", "ica", "ica", "sum", "sum");
        assertThat(reports.get(0).getStudent().getId()).isEqualTo(1);
    }

    @Test
    public void itShouldWritePdfContentsToTemporaryStorage() {
        writer.generateStudentChunkReport(message);

        verify(temporaryStorage).writeChunk(eq(payload.getReportId()), eq(0), any(InputStream.class));
    }

    @Test
    public void itShouldHandleNullAssessmentTypeWhenGeneratingStudentChunk() {
        writer.generateStudentChunkReport(message);

        verify(icaReportRepository, times(2)).findAllForStudentsByExamFilter(
                any(User.class),
                anyCollection(),
                examFilterCaptor.capture()
        );
        assertThat(examFilterCaptor.getValue().getAssessmentTypeCode()).isNotEmpty();
    }

    private ExamQueryParamsParser accepting() {
        final ExamQueryParamsParser parser = mock(ExamQueryParamsParser.class);
        when(parser.accept(any(AbstractPrintableReportQuery.class))).thenReturn(true);
        return parser;
    }

    private ExamQueryParamsParser rejecting() {
        return mock(ExamQueryParamsParser.class);
    }

    private <R extends AbstractExamReport, T extends AbstractExamReport.Builder<R, T>> List<R> reportsForSubjects(final T builder, final String assessmentType) {
        final R mathReport = builder
                .assessmentType(assessmentType)
                .subject("Math")
                .build();

        final R elaReport = builder
                .assessmentType(assessmentType)
                .subject("ELA")
                .build();
        return ImmutableList.of(mathReport, elaReport);
    }

    private Collection<SubjectDefinition> subjectDefinitions(final String... subjectCodes) {
        return Arrays.stream(subjectCodes)
                .flatMap(subject -> AssessmentTypes.stream()
                        .map(asmtType -> subjectDefinition(subject, asmtType)))
                .collect(Collectors.toList());
    }

    private SubjectDefinition subjectDefinition(final String subject, final String asmtType) {
        return SubjectDefinition.builder()
                .subjectCode(subject)
                .asmtTypeCode(asmtType)
                .build();
    }
}
