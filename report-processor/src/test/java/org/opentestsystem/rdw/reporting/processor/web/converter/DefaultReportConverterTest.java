package org.opentestsystem.rdw.reporting.processor.web.converter;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.opentestsystem.rdw.reporting.processor.web.ReportContentResource;
import org.springframework.core.io.Resource;
import org.springframework.http.MediaType;
import org.springframework.mock.http.MockHttpOutputMessage;

import java.util.Set;

import static com.google.common.collect.Sets.newHashSet;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static org.springframework.http.MediaType.APPLICATION_JSON;


@RunWith(MockitoJUnitRunner.class)
public class DefaultReportConverterTest {

    @Mock
    private ReportContentResource resource;

    private ReportHandler defaultHandler;
    private MockHttpOutputMessage outputMessage;
    private Set<ReportHandler> registeredHandlers;
    private DefaultReportConverter converter;

    @Before
    public void setup() {
        defaultHandler = handler(true);
        outputMessage = new MockHttpOutputMessage();

        registeredHandlers = newHashSet();

        converter = new DefaultReportConverter(defaultHandler, registeredHandlers);
    }

    @Test
    public void itShouldWriteReportContentResources() {
        assertThat(converter.canWrite(ReportContentResource.class, null)).isTrue();
    }

    @Test
    public void itShouldNotReadReportContentResources() {
        assertThat(converter.canRead(ReportContentResource.class, null)).isFalse();
    }

    @Test
    public void itShouldNotWriteNonReportContentResources() {
        assertThat(converter.canWrite(Resource.class, null)).isFalse();
    }

    @Test
    public void itShouldFirstDelegateToAnAcceptingRegisteredHandler() throws Exception {
        final ReportHandler rejectingHandler = handler(false);
        final ReportHandler acceptingHandler = handler(true);
        registeredHandlers.add(rejectingHandler);
        registeredHandlers.add(acceptingHandler);

        converter.write(resource, APPLICATION_JSON, outputMessage);

        verify(acceptingHandler).accept(eq(resource), eq(APPLICATION_JSON));
        verify(acceptingHandler).writeResource(eq(resource), eq(outputMessage));
        verifyZeroInteractions(defaultHandler);
    }

    @Test
    public void itShouldFallBackToTheDefaultHandler() throws Exception {
        final ReportHandler rejectingHandler = handler(false);
        registeredHandlers.add(rejectingHandler);

        converter.write(resource, APPLICATION_JSON, outputMessage);

        verify(defaultHandler).writeResource(eq(resource), eq(outputMessage));
    }

    private ReportHandler handler(final boolean accepting) {
        final ReportHandler handler = mock(ReportHandler.class);
        when(handler.accept(any(ReportContentResource.class), any(MediaType.class)))
                .thenReturn(accepting);
        return handler;
    }
}