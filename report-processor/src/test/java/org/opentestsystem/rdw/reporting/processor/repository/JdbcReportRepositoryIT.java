package org.opentestsystem.rdw.reporting.processor.repository;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.opentestsystem.rdw.reporting.common.model.SchoolGradePrintableReportQuery;
import org.opentestsystem.rdw.reporting.common.test.ITDataSourceConfiguration;
import org.opentestsystem.rdw.reporting.common.test.RepositoryIT;
import org.opentestsystem.rdw.reporting.processor.model.UserReport;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringRunner;

import java.net.URI;
import java.time.Instant;
import java.util.Collections;
import java.util.List;

import static com.google.common.collect.ImmutableList.of;
import static com.google.common.collect.Sets.newHashSet;
import static java.lang.Integer.parseInt;
import static org.assertj.core.api.Assertions.assertThat;
import static org.opentestsystem.rdw.reporting.common.model.ReportStatus.PENDING;
import static org.opentestsystem.rdw.reporting.processor.MockBuilder.report;
import static org.opentestsystem.rdw.reporting.processor.stream.FetchStudents.CompletedChunk;
import static org.opentestsystem.rdw.reporting.processor.stream.FetchStudents.TotalChunk;

@RunWith(SpringRunner.class)
@RepositoryIT
@ContextConfiguration(
        classes = {
                ITDataSourceConfiguration.class,
                JdbcReportRepository.class,
                JacksonAutoConfiguration.class
        })
public class JdbcReportRepositoryIT {

    @Autowired
    private ReportRepository repository;

    @Autowired
    private NamedParameterJdbcTemplate template;

    @Test
    public void itShouldInsertAReport() {
        final UserReport report = report();
        assertThat(report.getId()).isNull();

        final UserReport inserted = repository.create(report);
        assertThat(inserted.getId()).isGreaterThan(0);
        assertThat(inserted.getUser()).isEqualTo(report.getUser());
        assertThat(inserted.getLabel()).isEqualTo(report.getLabel());
        assertThat(inserted.getCreated()).isEqualTo(report.getCreated());
        assertThat(inserted.getReportResourceUri()).isEqualTo(report.getReportResourceUri());
        assertThat(inserted.getStatus()).isEqualTo(report.getStatus());
        assertThat(((SchoolGradePrintableReportQuery) inserted.getQuery()).getSchoolYear())
                .isEqualTo(((SchoolGradePrintableReportQuery) report.getQuery()).getSchoolYear());

        final String reportType = template.queryForObject(
                "SELECT report_type FROM user_report WHERE id = :id",
                new MapSqlParameterSource("id", inserted.getId()),
                String.class);
        assertThat(reportType).isEqualTo(report.getQuery().getType().name());
    }

    @Test
    public void itShouldUpdateAReport() {
        final UserReport original = repository.create(report());
        final UserReport modified = UserReport.builder()
                .copy(original)
                .label("Some New Label")
                .build();

        final UserReport updated = repository.update(modified);
        assertThat(updated.getLabel()).isEqualTo(modified.getLabel());

        final UserReport fetched = repository.findById(original.getId());
        assertThat(fetched.getLabel()).isEqualTo(modified.getLabel());
    }

    @Test
    public void itShouldFindOneById() {
        final UserReport original = repository.create(report());

        final UserReport fetched = repository.findById(original.getId());
        assertThat(fetched.getId()).isEqualTo(original.getId());
        assertThat(fetched.getCreated()).isEqualTo(original.getCreated());
        assertThat(fetched.getLabel()).isEqualTo(original.getLabel());
        assertThat(fetched.getUser()).isEqualTo(original.getUser());
        assertThat(fetched.getStatus()).isEqualTo(original.getStatus());
        assertThat(fetched.getReportResourceUri()).isEqualTo(original.getReportResourceUri());
        assertThat(((SchoolGradePrintableReportQuery) fetched.getQuery()).getSchoolYear())
                .isEqualTo(((SchoolGradePrintableReportQuery) original.getQuery()).getSchoolYear());
    }

    @Test
    public void itShouldHandleAMissingReportById() {
        assertThat(repository.findById(123L)).isNull();
    }

    @Test
    public void itShouldFindAllReportsForAUser() {
        final UserReport reportA = repository.create(report());
        final UserReport reportB = repository.create(report());
        repository.create(UserReport.builder()
                .copy(report())
                .user("another user")
                .build());

        final List<UserReport> userReports = repository.findByUserAndIds(reportA.getUser(), of());

        assertThat(userReports.stream().map(UserReport::getId))
                .hasSize(2)
                .containsOnly(reportA.getId(), reportB.getId());
    }

    @Test
    public void itShouldFindAllReportsForAUserFilteredByIds() {
        final UserReport reportA = repository.create(report());
        final UserReport reportB = repository.create(report());
        repository.create(report());
        repository.create(UserReport.builder()
                .copy(report())
                .user("another user")
                .build());

        final List<UserReport> userReports = repository
                .findByUserAndIds(reportA.getUser(), of(reportA.getId(), reportB.getId()));

        assertThat(userReports.stream().map(UserReport::getId))
                .hasSize(2)
                .containsOnly(reportA.getId(), reportB.getId());
    }

    @Test
    public void itShouldHandleNoReportsForAUser() {
        assertThat(repository.findByUserAndIds("user", of())).isEmpty();
    }

    @Test
    public void itShouldMarkChunksCompleted() {
        UserReport report = UserReport.builder()
                .copy(report())
                .metadata(TotalChunk, "10")
                .metadata(CompletedChunk, "0")
                .build();

        report = repository.create(report);
        report = repository.update(report);

        report = repository.completeChunk(report);
        int completedChunkCount = parseInt(report.getMetadata().get(CompletedChunk));
        assertThat(completedChunkCount).isEqualTo(1);

        report = repository.findById(report.getId());
        completedChunkCount = parseInt(report.getMetadata().get(CompletedChunk));
        assertThat(completedChunkCount).isEqualTo(1);

        report = repository.completeChunk(report);
        completedChunkCount = parseInt(report.getMetadata().get(CompletedChunk));
        assertThat(completedChunkCount).isEqualTo(2);

        report = repository.findById(report.getId());
        completedChunkCount = parseInt(report.getMetadata().get(CompletedChunk));
        assertThat(completedChunkCount).isEqualTo(2);
    }

    @Test
    public void itShouldFindZeroReportsFrom30DaysAgoWhenSingleNowReport() {
        repository.create(report());
        final List<UserReport> reports = repository.findAllOlderThanNumberOfDays(30);
        assertThat(reports).size().isEqualTo(0);
    }

    @Test
    public void itShouldFindReportFrom30DaysAgo() {
        final SchoolGradePrintableReportQuery query = SchoolGradePrintableReportQuery.builder()
                .gradeId(1)
                .schoolId(2L)
                .schoolYear(1997)
                .build();
        UserReport report = UserReport.builder()
                .id(123L)
                .created(Instant.now().minusSeconds(31L * 60L * 60L * 24L))
                .user("user")
                .label("label")
                .reportResourceUri(URI.create("/reports/123"))
                .status(PENDING)
                .query(query)
                .build();
        report = repository.create(report);
        final List<UserReport> reports = repository.findAllOlderThanNumberOfDays(30);
        assertThat(reports).size().isEqualTo(1);
        assertThat(reports.get(0).getId()).isEqualTo(report.getId());
        repository.deleteIds(newHashSet(123L));
        final UserReport found = repository.findById(123L);
        assertThat(found).isNull();
    }

    @Test
    public void itShouldUpsertMetadataOnReportUpdate() {
        final UserReport original = repository.create(report());
        UserReport updateSrc = original.copy()
                .metadata("some_metadata", "some_value")
                .build();
        repository.update(updateSrc);
        UserReport updateResult = repository.findById(original.getId());
        assertThat(updateResult.getMetadata().size()).isEqualTo(1);
        assertThat(updateResult.getMetadata().get("some_metadata")).isEqualTo("some_value");

        updateSrc = updateResult.copy()
                .metadata("some_metadata", "new_value")
                .metadata("new_metadata", "another_value")
                .build();
        repository.update(updateSrc);
        updateResult = repository.findById(original.getId());
        assertThat(updateResult.getMetadata().size()).isEqualTo(2);
        assertThat(updateResult.getMetadata().get("some_metadata")).isEqualTo("new_value");
        assertThat(updateResult.getMetadata().get("new_metadata")).isEqualTo("another_value");
    }

    @Test
    public void itShouldDeleteMetadataWhenDeletingAReport() {
        final UserReport original = repository.create(report());
        original.getMetadata().put("some_metadata", "some_value");
        repository.update(original);

        int metadataCount = template.queryForObject("SELECT count(*) FROM user_report_metadata",
                new MapSqlParameterSource(),
                Integer.class);
        assertThat(metadataCount).isEqualTo(1);

        repository.deleteIds(Collections.singleton(original.getId()));

        metadataCount = template.queryForObject("SELECT count(*) FROM user_report_metadata",
                new MapSqlParameterSource(),
                Integer.class);
        assertThat(metadataCount).isEqualTo(0);
    }

}