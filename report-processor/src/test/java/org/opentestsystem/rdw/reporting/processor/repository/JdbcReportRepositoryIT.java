package org.opentestsystem.rdw.reporting.processor.repository;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.opentestsystem.rdw.reporting.common.test.ITDataSourceConfiguration;
import org.opentestsystem.rdw.reporting.common.test.RepositoryIT;
import org.opentestsystem.rdw.reporting.processor.model.Report;
import org.opentestsystem.rdw.reporting.processor.model.SchoolGradeExamReportRequest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringRunner;

import java.net.URI;
import java.time.Instant;
import java.util.Collections;
import java.util.List;

import static com.google.common.collect.ImmutableList.of;
import static com.google.common.collect.Sets.newHashSet;
import static java.lang.Integer.parseInt;
import static org.assertj.core.api.Assertions.assertThat;
import static org.opentestsystem.rdw.reporting.common.model.ReportStatus.PENDING;
import static org.opentestsystem.rdw.reporting.processor.MockBuilder.report;
import static org.opentestsystem.rdw.reporting.processor.stream.FetchStudents.CompletedChunk;
import static org.opentestsystem.rdw.reporting.processor.stream.FetchStudents.TotalChunk;

@RunWith(SpringRunner.class)
@RepositoryIT
@ContextConfiguration(
        classes = {
                ITDataSourceConfiguration.class,
                JdbcReportRepository.class,
                JacksonAutoConfiguration.class
        })
public class JdbcReportRepositoryIT {

    @Autowired
    private JdbcReportRepository repository;

    @Autowired
    private NamedParameterJdbcTemplate template;

    @Test
    public void itShouldInsertAReport() throws Exception {
        final Report report = report();
        assertThat(report.getId()).isNull();

        final Report inserted = repository.create(report);
        assertThat(inserted.getId()).isGreaterThan(0);
        assertThat(inserted.getUser()).isEqualTo(report.getUser());
        assertThat(inserted.getLabel()).isEqualTo(report.getLabel());
        assertThat(inserted.getCreated()).isEqualTo(report.getCreated());
        assertThat(inserted.getReportResourceUri()).isEqualTo(report.getReportResourceUri());
        assertThat(inserted.getStatus()).isEqualTo(report.getStatus());
        assertThat(inserted.getReportRequest().getSchoolYear()).isEqualTo(report.getReportRequest().getSchoolYear());
    }

    @Test
    public void itShouldUpdateAReport() throws Exception {
        final Report original = repository.create(report());
        final Report modified = Report.builder()
                .copy(original)
                .label("Some New Label")
                .build();

        final Report updated = repository.update(modified);
        assertThat(updated.getLabel()).isEqualTo(modified.getLabel());

        final Report fetched = repository.findById(original.getId());
        assertThat(fetched.getLabel()).isEqualTo(modified.getLabel());
    }

    @Test
    public void itShouldFindOneById() throws Exception {
        final Report original = repository.create(report());

        final Report fetched = repository.findById(original.getId());
        assertThat(fetched.getId()).isEqualTo(original.getId());
        assertThat(fetched.getCreated()).isEqualTo(original.getCreated());
        assertThat(fetched.getLabel()).isEqualTo(original.getLabel());
        assertThat(fetched.getUser()).isEqualTo(original.getUser());
        assertThat(fetched.getStatus()).isEqualTo(original.getStatus());
        assertThat(fetched.getReportResourceUri()).isEqualTo(original.getReportResourceUri());
        assertThat(fetched.getReportRequest().getSchoolYear()).isEqualTo(original.getReportRequest().getSchoolYear());
    }

    @Test
    public void itShouldHandleAMissingReportById() throws Exception {
        assertThat(repository.findById(123L)).isNull();
    }

    @Test
    public void itShouldFindAllReportsForAUser() throws Exception {
        final Report reportA = repository.create(report());
        final Report reportB = repository.create(report());
        repository.create(Report.builder()
                .copy(report())
                .user("another user")
                .build());

        final List<Report> userReports = repository.findByUserAndIds(reportA.getUser(), of());

        assertThat(userReports.stream().map(Report::getId))
                .hasSize(2)
                .containsOnly(reportA.getId(), reportB.getId());
    }

    @Test
    public void itShouldFindAllReportsForAUserFilteredByIds() throws Exception {
        final Report reportA = repository.create(report());
        final Report reportB = repository.create(report());
        repository.create(report());
        repository.create(Report.builder()
                .copy(report())
                .user("another user")
                .build());

        final List<Report> userReports = repository
                .findByUserAndIds(reportA.getUser(), of(reportA.getId(), reportB.getId()));

        assertThat(userReports.stream().map(Report::getId))
                .hasSize(2)
                .containsOnly(reportA.getId(), reportB.getId());
    }

    @Test
    public void itShouldHandleNoReportsForAUser() throws Exception {
        assertThat(repository.findByUserAndIds("user", of())).isEmpty();
    }

    @Test
    public void itShouldMarkChunksCompleted() {
        Report report = Report.builder()
                .copy(report())
                .metadata(TotalChunk, "10")
                .metadata(CompletedChunk, "0")
                .build();

        report = repository.create(report);
        report = repository.update(report);

        report = repository.completeChunk(report);
        int completedChunkCount = parseInt(report.getMetadata().get(CompletedChunk));
        assertThat(completedChunkCount).isEqualTo(1);

        report = repository.findById(report.getId());
        completedChunkCount = parseInt(report.getMetadata().get(CompletedChunk));
        assertThat(completedChunkCount).isEqualTo(1);

        report = repository.completeChunk(report);
        completedChunkCount = parseInt(report.getMetadata().get(CompletedChunk));
        assertThat(completedChunkCount).isEqualTo(2);

        report = repository.findById(report.getId());
        completedChunkCount = parseInt(report.getMetadata().get(CompletedChunk));
        assertThat(completedChunkCount).isEqualTo(2);
    }

    @Test
    public void itShouldFindZeroReportsFrom30DaysAgoWhenSingleNowReport() {
        final Report report = repository.create(report());
        final List<Report> reports = repository.findAllOlderThanNumberOfDays(30);
        assertThat(reports).size().isEqualTo(0);
    }

    @Test
    public void itShouldFindReportFrom30DaysAgo() {
        final SchoolGradeExamReportRequest reportRequest = SchoolGradeExamReportRequest.builder()
                .gradeId(1)
                .schoolId(2L)
                .schoolYear(1997)
                .build();
        Report report = Report.builder()
                .id(123L)
                .created(Instant.now().minusSeconds(31L * 60L * 60L * 24L))
                .user("user")
                .label("label")
                .reportResourceUri(URI.create("/reports/123"))
                .status(PENDING)
                .reportRequest(reportRequest)
                .build();
        report = repository.create(report);
        final List<Report> reports = repository.findAllOlderThanNumberOfDays(30);
        assertThat(reports).size().isEqualTo(1);
        assertThat(reports.get(0).getId()).isEqualTo(report.getId());
        repository.deleteIds(newHashSet(123L));
        final Report found = repository.findById(123L);
        assertThat(found).isNull();
    }

    @Test
    public void itShouldUpsertMetadataOnReportUpdate() {
        final Report original = repository.create(report());
        Report updateSrc = original.copy()
                .metadata("some_metadata", "some_value")
                .build();
        repository.update(updateSrc);
        Report updateResult = repository.findById(original.getId());
        assertThat(updateResult.getMetadata().size()).isEqualTo(1);
        assertThat(updateResult.getMetadata().get("some_metadata")).isEqualTo("some_value");

        updateSrc = updateResult.copy()
                .metadata("some_metadata", "new_value")
                .metadata("new_metadata", "another_value")
                .build();
        repository.update(updateSrc);
        updateResult = repository.findById(original.getId());
        assertThat(updateResult.getMetadata().size()).isEqualTo(2);
        assertThat(updateResult.getMetadata().get("some_metadata")).isEqualTo("new_value");
        assertThat(updateResult.getMetadata().get("new_metadata")).isEqualTo("another_value");
    }

    @Test
    public void itShouldDeleteMetadataWhenDeletingAReport() {
        final Report original = repository.create(report());
        original.getMetadata().put("some_metadata", "some_value");
        repository.update(original);

        int metadataCount = template.queryForObject("SELECT count(*) from user_report_metadata",
                new MapSqlParameterSource(),
                Integer.class);
        assertThat(metadataCount).isEqualTo(1);

        repository.deleteIds(Collections.singleton(original.getId()));

        metadataCount = template.queryForObject("SELECT count(*) from user_report_metadata",
                new MapSqlParameterSource(),
                Integer.class);
        assertThat(metadataCount).isEqualTo(0);
    }

}