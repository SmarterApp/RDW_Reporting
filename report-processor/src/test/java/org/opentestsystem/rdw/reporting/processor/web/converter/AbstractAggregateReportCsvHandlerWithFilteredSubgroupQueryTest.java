package org.opentestsystem.rdw.reporting.processor.web.converter;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterators;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.opentestsystem.rdw.reporting.common.model.*;
import org.opentestsystem.rdw.reporting.processor.model.AggregateReportRequest;
import org.opentestsystem.rdw.reporting.processor.model.UserReport;
import org.opentestsystem.rdw.reporting.processor.model.SchoolGradeExamReportRequest;
import org.opentestsystem.rdw.reporting.processor.web.ReportContentResource;
import org.springframework.context.MessageSource;
import org.springframework.http.HttpHeaders;
import org.springframework.mock.http.MockHttpOutputMessage;

import java.io.ByteArrayInputStream;
import java.io.StringReader;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;
import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.reporting.common.util.MediaTypes.TEXT_CSV_UTF8;
import static org.springframework.http.MediaType.APPLICATION_JSON;

abstract class AbstractAggregateReportCsvHandlerWithFilteredSubgroupQueryTest<R extends AggregateRow, A extends AbstractSubgroupedAggregateReportQuery, B extends AbstractSubgroupedAggregateReportQuery.Builder<A, B>> extends AbstractAggregateReportCsvHandlerTest {

    @Mock
    private MessageSource messageSource;

    @Mock
    private ReportContentResource resource;

    private MockHttpOutputMessage outputMessage;
    private byte[] reportPayload;
    private UserReport report;
    private AbstractAggregateReportCsvHandler handler;

    protected abstract R reportRow(String subgroupKey, Organization organization);

    protected abstract AbstractAggregateReportCsvHandler createHandlerUnderTest(MessageSource messageSource, ObjectMapper objectMapper);

    protected abstract B getQueryBuilder();

    protected abstract int getHeadersCount();

    @Before
    public void setup() throws Exception {
        final ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);
        outputMessage = new MockHttpOutputMessage();

        when(messageSource.getMessage(anyString(), any(Object[].class), any(Locale.class)))
                .thenAnswer(invocationOnMock -> invocationOnMock.getArgument(0));

        final Map<String, StudentFilters> subgroups = newHashMap();
        subgroups.put("overall", StudentFilters.builder()
                .build());
        subgroups.put("subgroupA", StudentFilters.builder()
                .genderCodes(ImmutableSet.of("Male"))
                .build());
        subgroups.put("subgroupB", StudentFilters.builder()
                .genderCodes(ImmutableSet.of("Female"))
                .build());

        final AbstractSubgroupedAggregateReportQuery query = getQueryBuilder()
                .subgroups(subgroups)
                .build();

        final List<R> data = newArrayList();
        final List<District> districts = newArrayList(district(), district());

        // 3 subgroups, 1 state, 2 districts, 2 schools per district => 3 * (1 + 2 + 2*2) = 21 rows
        for (final String subgroupKey : query.getSubgroups().keySet()) {
            data.add(reportRow(subgroupKey, state()));
            districts.forEach(district -> {
                data.add(reportRow(subgroupKey, district));
                data.add(reportRow(subgroupKey, school(district.getId())));
                data.add(reportRow(subgroupKey, school(district.getId())));
            });
        }
        reportPayload = objectMapper.writeValueAsBytes(data);

        report = spy(UserReport.builder()
                .status(ReportStatus.COMPLETED)
                .query(query)
                .label("my report")
                .build());
        when(resource.getReport()).thenAnswer(invocation -> report);
        when(resource.getInputStream()).thenAnswer(invocation -> new ByteArrayInputStream(reportPayload));

        handler = createHandlerUnderTest(messageSource, objectMapper);
    }

    @Test
    public void itShouldHandleAggregateReportPayloads() {
        assertThat(handler.accept(resource, null)).isTrue();
    }

    @Test
    public void itShouldNotHandleAggregateReportPayloadsIfJsonIsRequested() {
        assertThat(handler.accept(resource, APPLICATION_JSON)).isFalse();
    }

    @Test
    public void itShouldOnlyHandleAggregateReportPayloads() {
        final SchoolGradePrintableReportQuery query = SchoolGradePrintableReportQuery.builder().build();
        when(report.getQuery()).thenReturn(query);
        assertThat(handler.accept(resource, null)).isFalse();
    }

    @Test
    public void itShouldWriteHtmlHeaders() throws Exception {
        handler.writeResource(resource, outputMessage);

        final HttpHeaders headers = outputMessage.getHeaders();
        assertThat(headers.getContentType()).isEqualTo(TEXT_CSV_UTF8);
        assertThat(headers.getFirst(HttpHeaders.CONTENT_DISPOSITION)).contains("my_report");
    }

    @Test
    public void itShouldWriteJsonAsCsv() throws Exception {
        handler.writeResource(resource, outputMessage);

        try (final StringReader reader = new StringReader(outputMessage.getBodyAsString())) {
            final CSVParser parser = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()
                    .parse(reader);

            assertThat(parser.getHeaderMap()).hasSize(getHeadersCount());
            final List<CSVRecord> rows = parser.getRecords();
            assertThat(rows).hasSize(21);
        }
    }

    @Test
    public void itShouldWriteFiltersAsAttributes() throws Exception {
        when(report.getQuery()).thenReturn(
                getQueryBuilder()
                        .completenessCodes(ImmutableSet.of("Complete"))
                        .build()
        );

        handler.writeResource(resource, outputMessage);

        try (final StringReader reader = new StringReader(outputMessage.getBodyAsString())) {
            final CSVParser parser = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()
                    .parse(reader);
            final List<CSVRecord> rows = parser.getRecords();
            final String attributes = Iterators.getLast(rows.get(0).iterator());
            assertThat(attributes).contains("ReportDate");
            assertThat(attributes).contains("Completeness: Complete");
        }
    }
}