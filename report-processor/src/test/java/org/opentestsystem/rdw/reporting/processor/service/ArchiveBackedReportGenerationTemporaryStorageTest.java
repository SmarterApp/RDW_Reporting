package org.opentestsystem.rdw.reporting.processor.service;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.rdw.archive.ArchiveService;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Supplier;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.reporting.processor.service.ArchiveBackedReportGenerationTemporaryStorage.BasePath;

@RunWith(MockitoJUnitRunner.class)
public class ArchiveBackedReportGenerationTemporaryStorageTest {

    @Mock
    private ArchiveService archiveService;

    private ArchiveBackedReportGenerationTemporaryStorage storage;

    @Before
    public void setup() {
        storage = new ArchiveBackedReportGenerationTemporaryStorage(archiveService);
    }

    @Test
    public void itShouldWriteAnInputStream() throws Exception {
        final InputStream data = mock(InputStream.class);
        storage.writeChunk(123L, 2, data);
        verify(archiveService).writeResource(BasePath + "123/2.pdf", data, null);
    }

    @Test
    public void itShouldRetrieveChunkContents() {
        final Pattern pathMatcher = Pattern.compile(".*([^/]+)\\.pdf");
        final List<InputStream> data = new ArrayList<>();
        final InputStream chunk0 = mock(InputStream.class);
        final InputStream chunk1 = mock(InputStream.class);
        final InputStream chunk2 = mock(InputStream.class);
        data.add(chunk0);
        data.add(chunk1);
        data.add(chunk2);
        when(archiveService.openResource(anyString())).thenAnswer(invocation -> {
            final Matcher matcher = pathMatcher.matcher(invocation.getArgumentAt(0, String.class));
            assertThat(matcher.matches()).isTrue();
            final int chunkIdx = Integer.parseInt(matcher.group(1));
            return data.get(chunkIdx);
        });

        final List<Supplier<InputStream>> chunkData = storage.getChunks(123L, 3);
        assertThat(chunkData.stream().map(Supplier::get))
                .hasSameElementsAs(data);
    }

    @Test
    public void itShouldCleanUpResources() {
        storage.cleanup(123L);
        verify(archiveService).delete(BasePath + "123");
    }

}