package org.opentestsystem.rdw.reporting.processor.stream;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.opentestsystem.rdw.reporting.processor.model.ExportExamReportRequest;
import org.opentestsystem.rdw.reporting.processor.model.Report;
import org.opentestsystem.rdw.reporting.processor.model.ReportRequestMessage;
import org.opentestsystem.rdw.reporting.processor.model.ReportStatus;
import org.opentestsystem.rdw.reporting.processor.service.ExamExportService;
import org.opentestsystem.rdw.reporting.processor.service.ReportService;
import org.opentestsystem.rdw.reporting.processor.test.support.UserTestBuilder;

import java.net.URI;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class ExportExamsTest {

    private ExportExams component;

    @Mock
    private ExamExportService exportService;

    @Mock
    private ReportService reportService;

    private final ReportRequestMessage message = ReportRequestMessage
            .builder()
            .reportId(1L)
            .user(UserTestBuilder.user())
            .build();

    private final Report report = Report
            .builder()
            .id(1L)
            .status(ReportStatus.PENDING)
            .reportRequest(new ExportExamReportRequest())
            .build();

    @Before
    public void setup() {
        component = new ExportExams(exportService, reportService);
    }

    @Test
    public void itShouldUpdateReportLocationUriAfterExport() {
        final URI exportUri = URI.create("EXPORT/EXAMS/test.csv");

        when(exportService.exportExam(any(User.class), any(ExportExamReportRequest.class), anyInt()))
                .thenAnswer(x -> exportUri);

        when(reportService.findOneById(1L))
                .thenAnswer(x -> Optional.of(report));

        final ArgumentCaptor<Report> reportCaptor = ArgumentCaptor.forClass(Report.class);
        when(reportService.update(reportCaptor.capture())).thenReturn(new Report());

        component.exportExams(message);

        final Report actual = reportCaptor.getValue();

        assertThat(actual.getStatus()).isEqualTo(ReportStatus.COMPLETED);
        assertThat(actual.getReportResourceUri()).isEqualTo(exportUri);
    }

    @Test
    public void itShouldNotTouchAFailedReport() {
        when(reportService.findOneById(1L))
                .thenAnswer(x -> Optional.of(Report.builder().status(ReportStatus.FAILED).build()));

        component.exportExams(message);
        verify(reportService, times(0)).update(any(Report.class));
    }

    @Test(expected=IllegalArgumentException.class)
    public void itShouldThrowIfReportIsNull() {
        when(reportService.findOneById(1L))
                .thenAnswer(x -> Optional.empty());

        component.exportExams(message);
    }
}
