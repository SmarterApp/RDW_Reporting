package org.opentestsystem.rdw.reporting.processor.stream;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.opentestsystem.rdw.reporting.common.model.DistrictSchoolExportReportQuery;
import org.opentestsystem.rdw.reporting.common.model.ReportStatus;
import org.opentestsystem.rdw.reporting.common.stream.MessageSecurityService;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.opentestsystem.rdw.reporting.processor.model.UserReport;
import org.opentestsystem.rdw.reporting.processor.model.ReportRequestMessage;
import org.opentestsystem.rdw.reporting.processor.service.ExamExportService;
import org.opentestsystem.rdw.reporting.processor.service.UserReportService;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.support.MessageBuilder;

import java.net.URI;
import java.util.Collections;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class ExportExamsTest {

    private ExportExams component;

    @Mock
    private ExamExportService exportService;

    @Mock
    private UserReportService userReportService;

    @Mock
    private MessageSecurityService messageSecurityService;

    private final ReportRequestMessage payload = ReportRequestMessage
            .builder()
            .reportId(1L)
            .build();

    private final Message<ReportRequestMessage> message = MessageBuilder
            .createMessage(payload, new MessageHeaders(Collections.emptyMap()));

    private final UserReport report = UserReport
            .builder()
            .id(1L)
            .status(ReportStatus.PENDING)
            .query(new DistrictSchoolExportReportQuery())
            .build();

    @Before
    public void setup() {
        final User mockUser = mock(User.class);
        when(messageSecurityService.getUser(any(Message.class))).thenReturn(mockUser);
        component = new ExportExams(exportService, userReportService, messageSecurityService);
    }

    @Test
    public void itShouldUpdateReportLocationUriAfterExport() {
        final URI exportUri = URI.create("EXPORT/EXAMS/test.csv");

        when(exportService.exportExams(any(User.class), any(DistrictSchoolExportReportQuery.class), anyLong()))
                .thenAnswer(x -> exportUri);

        when(userReportService.findOneById(1L))
                .thenAnswer(x -> Optional.of(report));

        final ArgumentCaptor<UserReport> reportCaptor = ArgumentCaptor.forClass(UserReport.class);
        when(userReportService.update(reportCaptor.capture())).thenReturn(new UserReport());

        component.exportExams(message);

        final UserReport actual = reportCaptor.getValue();

        assertThat(actual.getStatus()).isEqualTo(ReportStatus.COMPLETED);
        assertThat(actual.getReportResourceUri()).isEqualTo(exportUri);
    }

    @Test
    public void itShouldNotTouchAFailedReport() {
        when(userReportService.findOneById(1L))
                .thenAnswer(x -> Optional.of(UserReport.builder().status(ReportStatus.FAILED).build()));

        component.exportExams(message);
        verify(userReportService, times(0)).update(any(UserReport.class));
    }

    @Test(expected=IllegalArgumentException.class)
    public void itShouldThrowIfReportIsNull() {
        when(userReportService.findOneById(1L))
                .thenAnswer(x -> Optional.empty());

        component.exportExams(message);
    }
}
