package org.opentestsystem.rdw.reporting.processor.service;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.opentestsystem.rdw.reporting.common.repository.DataSourceConfiguration;
import org.opentestsystem.rdw.reporting.common.test.ITDataSourceConfiguration;
import org.opentestsystem.rdw.reporting.processor.configuration.JacksonConfiguration;
import org.opentestsystem.rdw.reporting.processor.model.UserReport;
import org.opentestsystem.rdw.reporting.processor.repository.JdbcUserReportRepository;
import org.opentestsystem.rdw.reporting.processor.repository.ReportQueryMapper;
import org.opentestsystem.rdw.utils.YamlPropertiesConfigurator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringRunner;

import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

import static java.lang.Integer.parseInt;
import static org.assertj.core.api.Assertions.assertThat;
import static org.opentestsystem.rdw.reporting.processor.MockBuilder.report;
import static org.opentestsystem.rdw.reporting.processor.stream.FetchStudents.CompletedChunk;
import static org.opentestsystem.rdw.reporting.processor.stream.FetchStudents.TotalChunk;

@ContextConfiguration(classes = TestConfiguration.class)
@SpringBootTest(classes = {
        DataSourceAutoConfiguration.class,
        ITDataSourceConfiguration.class,
        YamlPropertiesConfigurator.class,
        DefaultUserReportService.class,
        JdbcUserReportRepository.class,
        JacksonAutoConfiguration.class,
        JacksonConfiguration.class,
        ReportQueryMapper.class
})
@ActiveProfiles("test")
@RunWith(SpringRunner.class)
public class DefaultUserReportServiceIT {
    private final static int chunkCount = 10;

    @Autowired
    public UserReportService service;

    @Autowired
    public NamedParameterJdbcTemplate template;

    private ExecutorService executorService;

    private Long reportId;

    @Before
    public void setup() {
        executorService = Executors.newFixedThreadPool(chunkCount);
    }

    @After
    public void tearDown() {
        executorService.shutdownNow();
        if (reportId != null) {
            template.update(
                    "DELETE FROM user_report WHERE id = :report_id;",
                    new MapSqlParameterSource().addValue("report_id", reportId));
        }
    }

    @Test
    public void itShouldOnlyReturnChunksCompletedOnce() throws Exception {
        final UserReport report = service.create(UserReport.builder()
                .copy(report())
                .metadata(TotalChunk, String.valueOf(chunkCount))
                .metadata(CompletedChunk, "0")
                .build());
        service.update(report);
        reportId = report.getId();

        final Semaphore startSemaphore = new Semaphore(0);
        final Semaphore endSemaphore = new Semaphore(0);
        final CopyOnWriteArrayList<Boolean> isLastChunkResults = new CopyOnWriteArrayList<>();
        final CopyOnWriteArrayList<Integer> completeCount = new CopyOnWriteArrayList<>();

        for (int i = 0; i < chunkCount; i++) {
            final int chunkIdx = i;
            executorService.execute(() -> {
                try {
                    startSemaphore.tryAcquire(30, TimeUnit.SECONDS);
                    final UserReport updated = service.completeChunk(report);
                    final int totalChunkCount = parseInt(updated.getMetadata().get(TotalChunk));
                    final int completedChunkCount = parseInt(updated.getMetadata().get(CompletedChunk));
                    isLastChunkResults.add(totalChunkCount == completedChunkCount);
                    completeCount.add(completedChunkCount);
                    endSemaphore.release(1);
                } catch (final InterruptedException e) {
                    throw new RuntimeException("Failed to acquire chunk permit", e);
                }
            });
        }
        startSemaphore.release(chunkCount);
        endSemaphore.tryAcquire(chunkCount, 30, TimeUnit.SECONDS);

        assertThat(isLastChunkResults.stream().filter((x) -> x)).hasSize(1);
        for (int i = 1; i <= chunkCount; i++) {
            assertThat(completeCount).contains(i);
        }
    }
}