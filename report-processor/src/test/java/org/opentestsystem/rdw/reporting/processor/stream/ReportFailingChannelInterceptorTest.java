package org.opentestsystem.rdw.reporting.processor.stream;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.collect.ImmutableList;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.opentestsystem.rdw.reporting.common.model.ReportStatus;
import org.opentestsystem.rdw.reporting.common.model.Student;
import org.opentestsystem.rdw.reporting.processor.model.ProcessStudentChunkMessage;
import org.opentestsystem.rdw.reporting.processor.model.UserReport;
import org.opentestsystem.rdw.reporting.processor.service.ReportService;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.support.MessageBuilder;

import java.util.HashMap;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.reporting.processor.MockBuilder.report;

@RunWith(MockitoJUnitRunner.class)
public class ReportFailingChannelInterceptorTest {

    private static final Long ReportId = 123L;

    @Mock
    private ReportService service;

    @Mock
    private MessageChannel channel;

    private Message<?> message;
    private ReportFailingChannelInterceptor interceptor;

    @Before
    public void setup() throws Exception {
        final ObjectMapper objectMapper = new Jackson2ObjectMapperBuilder().failOnUnknownProperties(false).build();

        interceptor = new ReportFailingChannelInterceptor(service, objectMapper);

        final ProcessStudentChunkMessage reportMessage = ProcessStudentChunkMessage.builder()
                .reportId(ReportId)
                .index(0)
                .students(ImmutableList.of(Student.builder().id(123).ssid("123").build()))
                .build();
        message = MessageBuilder.createMessage(objectMapper.writeValueAsString(reportMessage), new MessageHeaders(new HashMap<>()));

        final UserReport report = report(ReportId);
        when(service.findOneById(ReportId)).thenReturn(Optional.of(report));
    }

    @Test
    public void itShouldIgnoreNonExceptionalMessages() {
        interceptor.afterReceiveCompletion(message, channel, null);
        interceptor.afterSendCompletion(message, channel, true,null);
        verifyZeroInteractions(service);
    }

    @Test
    public void itShouldFailReportOnFailureToSend() {
        interceptor.afterSendCompletion(message, channel, false, new RuntimeException("Bad Juju"));

        final ArgumentCaptor<UserReport> reportCaptor = ArgumentCaptor.forClass(UserReport.class);
        verify(service).update(reportCaptor.capture());
        assertThat(reportCaptor.getValue().getStatus()).isEqualTo(ReportStatus.FAILED);
    }

    @Test
    public void itShouldFailReportOnFailureToReceive() {
        interceptor.afterReceiveCompletion(message, channel, new RuntimeException("Bad Juju"));

        final ArgumentCaptor<UserReport> reportCaptor = ArgumentCaptor.forClass(UserReport.class);
        verify(service).update(reportCaptor.capture());
        assertThat(reportCaptor.getValue().getStatus()).isEqualTo(ReportStatus.FAILED);
    }
}