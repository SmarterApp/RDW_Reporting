package org.opentestsystem.rdw.reporting.processor.stream;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.rdw.reporting.processor.model.Report;
import org.opentestsystem.rdw.reporting.processor.model.ReportStatus;
import org.opentestsystem.rdw.reporting.processor.model.ReportRequestMessage;
import org.opentestsystem.rdw.reporting.processor.service.ReportService;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.support.MessageBuilder;

import java.util.HashMap;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.reporting.processor.MockBuilder.report;

@RunWith(MockitoJUnitRunner.class)
public class ReportFailingChannelInterceptorTest {

    private static final Long ReportId = 123L;

    @Mock
    private ReportService service;

    @Mock
    private MessageChannel channel;

    private Message<ReportRequestMessage> message;
    private ReportFailingChannelInterceptor interceptor;

    @Before
    public void setup() {
        interceptor = new ReportFailingChannelInterceptor(service);

        final ReportRequestMessage reportMessage = ReportRequestMessage.builder()
                .reportId(ReportId)
                .build();
        message = MessageBuilder.createMessage(reportMessage, new MessageHeaders(new HashMap<>()));

        final Report report = report(ReportId);
        when(service.findOneById(ReportId)).thenReturn(Optional.of(report));
    }

    @Test
    public void itShouldIgnoreNonExceptionalMessages() {
        interceptor.afterReceiveCompletion(message, channel, null);
        interceptor.afterSendCompletion(message, channel, true,null);
        verifyZeroInteractions(service);
    }

    @Test
    public void itShouldFailReportOnFailureToSend() {
        interceptor.afterSendCompletion(message, channel, false, new RuntimeException("Bad Juju"));

        final ArgumentCaptor<Report> reportCaptor = ArgumentCaptor.forClass(Report.class);
        verify(service).update(reportCaptor.capture());
        assertThat(reportCaptor.getValue().getStatus()).isEqualTo(ReportStatus.FAILED);
    }

    @Test
    public void itShouldFailReportOnFailureToReceive() {
        interceptor.afterReceiveCompletion(message, channel, new RuntimeException("Bad Juju"));

        final ArgumentCaptor<Report> reportCaptor = ArgumentCaptor.forClass(Report.class);
        verify(service).update(reportCaptor.capture());
        assertThat(reportCaptor.getValue().getStatus()).isEqualTo(ReportStatus.FAILED);
    }
}