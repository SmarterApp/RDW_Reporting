package org.opentestsystem.rdw.reporting.processor.repository;

import com.google.common.collect.MapDifference;
import com.google.common.collect.MapDifference.ValueDifference;
import com.google.common.collect.Maps;
import org.opentestsystem.rdw.reporting.common.model.ReportStatus;
import org.opentestsystem.rdw.reporting.processor.model.UserReport;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.RowCallbackHandler;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.net.URI;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static org.apache.http.util.TextUtils.isBlank;
import static org.opentestsystem.rdw.reporting.processor.stream.FetchStudents.CompletedChunk;

/**
 * A JDBC implementation of a UserReportRepository.
 */
@Repository
public class JdbcUserReportRepository implements UserReportRepository {

    @Value("${sql.user-report.create}")
    private String create;

    @Value("${sql.user-report.update}")
    private String update;

    @Value("${sql.user-report.deleteByIds}")
    private String deleteByIds;

    @Value("${sql.user-report.deleteByUserAndId}")
    private String deleteByUserAndId;

    @Value("${sql.user-report.findAllByUser}")
    private String findAllByUser;

    @Value("${sql.user-report.findAllByUserAndId}")
    private String findAllByUserAndId;

    @Value("${sql.user-report.findById}")
    private String findById;

    @Value("${sql.user-report.findAllOlderThanNumberOfDays}")
    private String findAllOlderThanNumberOfDays;

    @Value("${sql.user-report.completeChunk}")
    private String completeChunk;

    @Value("${sql.user-report.findMetadataForReports}")
    private String findMetadataForReports;

    @Value("${sql.user-report.deleteMetadataForReport}")
    private String deleteMetadataForReport;

    @Value("${sql.user-report.insertMetadataForReport}")
    private String insertMetadataForReport;

    private final NamedParameterJdbcTemplate template;
    private final ReportQueryMapper mapper;

    @Autowired
    public JdbcUserReportRepository(final NamedParameterJdbcTemplate template,
                                    final ReportQueryMapper mapper) {
        this.template = template;
        this.mapper = mapper;
    }

    @Override
    @Transactional
    public UserReport create(final UserReport report) {
        final GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
        final int insertCount = this.template.update(create,
                new MapSqlParameterSource()
                        .addValue("user_login", report.getUser())
                        .addValue("status", report.getStatus().id())
                        .addValue("report_resource_uri", asStringOrNull(report.getReportResourceUri()))
                        .addValue("label", report.getLabel())
                        .addValue("report_request", mapper.safeSerialize(report.getQuery()))
                        .addValue("report_type", report.getQuery().getType().name())
                        .addValue("created", Timestamp.from(report.getCreated())),
                keyHolder);

        if (insertCount != 1) {
            throw new IllegalStateException("Unable to create report");
        }
        return UserReport.builder()
                .copy(report)
                .id(keyHolder.getKey().longValue())
                .build();
    }

    @Override
    @Transactional
    public UserReport update(final UserReport report) {
        final long reportId = report.getId();
        final int updated = this.template.update(update,
                new MapSqlParameterSource()
                        .addValue("id", reportId)
                        .addValue("user_login", report.getUser())
                        .addValue("status", report.getStatus().id())
                        .addValue("report_resource_uri", asStringOrNull(report.getReportResourceUri()))
                        .addValue("label", report.getLabel())
                        .addValue("report_request", mapper.safeSerialize(report.getQuery()))
                        .addValue("created", Timestamp.from(report.getCreated())));

        if (updated != 1) {
            throw new IllegalStateException("Unable to update report: " + reportId);
        }

        final Map<Long, Map<String, String>> metadataByReportId = getMetadataForReports(newArrayList(reportId));
        final Map<String, String> existingMetadata = metadataByReportId.containsKey(reportId) ? metadataByReportId.get(reportId) : newHashMap();

        final MapDifference<String, String> metadataDiff = Maps.difference(existingMetadata, report.getMetadata());

        executeMetadataForReportChanges(reportId, combineWithRightValue(metadataDiff.entriesOnlyOnLeft(), metadataDiff.entriesDiffering()), deleteMetadataForReport);
        executeMetadataForReportChanges(reportId, combineWithRightValue(metadataDiff.entriesOnlyOnRight(), metadataDiff.entriesDiffering()), insertMetadataForReport);

        return findById(reportId);
    }

    @Override
    public List<UserReport> findByUserAndIds(final String user, final Collection<Long> reportIds) {
        final String query = reportIds.isEmpty() ? findAllByUser : findAllByUserAndId;

        return saturateMetadata(template.query(query,
                new MapSqlParameterSource()
                        .addValue("user", user)
                        .addValue("report_ids", reportIds),
                (row, num) -> asReport(row)
        ));
    }

    @Override
    public UserReport findById(final long reportId) {
        return saturateMetadata(template.query(findById,
                new MapSqlParameterSource()
                        .addValue("report_id", reportId),
                (row, num) -> asReport(row)
        )).stream().findFirst().orElse(null);
    }

    @Override
    public List<UserReport> findAllOlderThanNumberOfDays(final int numberOfDays) {
        return saturateMetadata(template.query(findAllOlderThanNumberOfDays,
                new MapSqlParameterSource("number_of_days", numberOfDays),
                (row, num) -> asReport(row)
        ));
    }

    @Override
    public void deleteIds(final Collection<Long> ids) {
        template.update(
                deleteByIds,
                new MapSqlParameterSource("ids", ids)
        );
    }

    @Override
    public void deleteByUserAndId(String user, long id) {
        final int updatedCount = template.update(
                deleteByUserAndId,
                new MapSqlParameterSource()
                .addValue("user_login", user)
                .addValue("id", id)
        );
        if (updatedCount != 1) {
            throw new NoSuchElementException("Unable to delete report");
        }
    }

    @Override
    @Transactional
    public UserReport completeChunk(final UserReport report) {
        final GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
        final int updatedCount = this.template.update(completeChunk,
                new MapSqlParameterSource()
                        .addValue("report_id", report.getId()),
                keyHolder);

        if (updatedCount != 1) {
            throw new IllegalStateException("Unable to update report");
        }
        return UserReport.builder()
                .copy(report)
                .metadata(CompletedChunk, String.valueOf(keyHolder.getKey().intValue()))
                .build();
    }

    private void executeMetadataForReportChanges(final long reportId, final Map<String, String> valuesByName, final String sql) {
        if (!valuesByName.isEmpty()) {
            final List<SqlParameterSource> batchParameters = newArrayList();
            for (final String name : valuesByName.keySet()) {
                batchParameters.add(new MapSqlParameterSource("name", name).addValue("value", valuesByName.get(name)).addValue("report_id", reportId));
            }

            template.batchUpdate(sql, batchParameters.toArray(new SqlParameterSource[0]));
        }
    }

    private static Map<String, String> combineWithRightValue(final Map<String, String> one, final Map<String, ValueDifference<String>> another) {
        final Map<String, String> combined = newHashMap(one);
        for (final String key : another.keySet()) {
            combined.put(key, another.get(key).rightValue());
        }
        return combined;
    }

    private Map<Long, Map<String, String>> getMetadataForReports(final Collection<Long> reportIds) {
        if (reportIds.isEmpty()) return Collections.emptyMap();

        final Map<Long, Map<String, String>> metadata = new HashMap<>();

        template.query(findMetadataForReports,
                new MapSqlParameterSource("report_ids", reportIds),
                asReportMetadata(metadata)
        );
        return metadata;
    }

    private List<UserReport> saturateMetadata(final Collection<UserReport> reports) {
        final Map<Long, Map<String, String>> metadata = getMetadataForReports(reports.stream()
                .map(UserReport::getId)
                .collect(Collectors.toSet()));

        return reports.stream()
                .map((report) -> {
                    final Map<String, String> reportMetadata = metadata.get(report.getId());
                    if (reportMetadata == null) {
                        return report;
                    }

                    return report.copy()
                            .metadata(reportMetadata)
                            .build();
                })
                .collect(Collectors.toList());
    }

    private UserReport asReport(final ResultSet row) throws SQLException {
        return UserReport.builder()
                .id(row.getLong("id"))
                .user(row.getString("user_login"))
                .status(ReportStatus.valueOf(row.getInt("status")))
                .reportResourceUri(asUriOrNull(row.getString("report_resource_uri")))
                .label(row.getString("label"))
                .query(mapper.safeDeserialize(row.getString("report_request")))
                .created(row.getTimestamp("created").toInstant())
                .build();
    }

    private static RowCallbackHandler asReportMetadata(final Map<Long, Map<String, String>> metadata) {
        return (row) -> {
            final Long reportId = row.getLong("report_id");
            final Map<String, String> reportMetadata = metadata.computeIfAbsent(reportId, (id) -> new HashMap<>());
            reportMetadata.put(
                    row.getString("name"),
                    row.getString("value")
            );
        };
    }

    private static URI asUriOrNull(final String value) {
        if (isBlank(value)) return null;
        return URI.create(value);
    }

    private static String asStringOrNull(final URI value) {
        if (value == null) return null;
        return value.toASCIIString();
    }
}
