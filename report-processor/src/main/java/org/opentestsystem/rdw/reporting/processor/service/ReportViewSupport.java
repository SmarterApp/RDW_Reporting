package org.opentestsystem.rdw.reporting.processor.service;

import com.google.common.collect.ImmutableList;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.reporting.common.model.Assessment;
import org.opentestsystem.rdw.reporting.common.model.Exam;
import org.opentestsystem.rdw.reporting.processor.model.ScaleScoreView;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.MessageSource;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Locale;

import static com.google.common.collect.Lists.newArrayList;
import static java.lang.Math.toIntExact;
import static java.util.stream.Collectors.toList;

/**
 * Holds utility methods to help render the exam reports
 */
@Component
public class ReportViewSupport {

    private final MessageSource messageSource;

    @Autowired
    public ReportViewSupport(final MessageSource messageSource) {
        this.messageSource = messageSource;
    }

    /**
     * Gets a sorted list of accommodation names for the given exam and language
     *
     * @param exam   the exam for which the accommodations were available
     * @param locale the language to display the accommodations in
     * @return accommodation names sorted in natural order
     */
    public List<String> getSortedAccommodationNames(final Exam exam, final Locale locale) {
        return exam.getAccommodationCodes().stream()
                .map(value -> messageSource.getMessage(value, null, locale))
                .sorted()
                .collect(toList());
    }

    /**
     * Gets the last two digits of the given integer
     * If the given integer has two or less digits the given integer will be returned as a string
     *
     * @param value the integer to get the last two digits from
     * @return the last two digits of the given integer
     */
    public String getLastTwoDigits(final int value) {
        final String valueAsString = Integer.toString(value);
        if (valueAsString.length() <= 2) {
            return valueAsString;
        }
        return valueAsString.substring(valueAsString.length() - 2);
    }

    /**
     * Gets the result of {@link Math#round(double)} on the given value converted to string
     *
     * @param value the value to round
     * @return returns the result of {@link Math#round(double)} on the given value converted to string
     */
    public String round(final float value) {
        return Integer.toString(Math.round(value));
    }

    /**
     * Gets the position and width attributes necessary for rendering a scale score graph
     *
     * @param exam       the exam to use for computing the scale score position
     * @param assessment the assessment to use for computing the cut point bar attributes
     * @return the position and width attributes necessary for rendering a scale score graph
     */
    public ScaleScoreView getScaleScoreView(final Exam exam, final Assessment assessment) {

        final int minimumScore = assessment.getCutPoints().get(0);
        final int maximumScore = assessment.getCutPoints().get(assessment.getCutPoints().size() - 1);

        final List<Integer> cutPoints = assessment.getType() == AssessmentType.ICA
                ? assessment.getCutPoints()
                // Process IAB cut points for use in display
                : newArrayList(
                minimumScore,
                // The second and third cut point are the middle cut point +/- the product of the individual exam
                // result scale score standard error and 1.5
                // this value must be clamped to be within the bounds of the minimum and maximum score
                clamp(toIntExact(assessment.getCutPoints().get(2) - Math.round(exam.getScaleScore().getStandardError() * 1.5)), minimumScore, maximumScore),
                clamp(toIntExact(assessment.getCutPoints().get(2) + Math.round(exam.getScaleScore().getStandardError() * 1.5)), minimumScore, maximumScore),
                maximumScore
        );

        final int scaleScore = exam.getScaleScore().getValue();

        final int length = maximumScore - minimumScore;

        // the whole percent of the scale score position along the length of the graph
        final int position = getPercentRoundedWithinBounds(scaleScore - minimumScore, length);

        final List<ScaleScoreView.Level> levels = newArrayList();
        for (int i = 1; i < cutPoints.size(); i++) {
            final int previous = cutPoints.get(i - 1) - minimumScore;
            final int current = cutPoints.get(i) - minimumScore;
            final int sumOfWidth = levels.stream().mapToInt(ScaleScoreView.Level::getWidth).sum();

            final int width = i < cutPoints.size() - 1
                    ? getPercentRoundedWithinBounds(current - previous, length)
                    // The last bar should be the remaining percent width of the graph
                    // This will avoid rounding errors and the graph width not adding to 100 percent
                    : 100 - sumOfWidth;

            levels.add(new ScaleScoreView.Level(sumOfWidth, width));

        }
        return new ScaleScoreView(position, ImmutableList.copyOf(levels));
    }

    /**
     * Gets the percent distance covered by the given position along the given length (0f - 100f)
     * If the given value is less than <code>0</code> then <code>0</code> will be returned
     * If the given value is greater than the length <code>100</code> will be returned
     *
     * @param position the position along the length
     * @param length   the distance
     * @return the percent distance covered by the given position along the given length
     */
    private float getPercentWithinBounds(final float position, final float length) {
        if (position < 0) {
            return 0;
        }
        if (position > length) {
            return 100;
        }
        return (position / length) * 100f;
    }

    /**
     * Gets the percent distance covered by the given position along the given length in whole percent (1 - 100)
     * If the given value is less than <code>1</code> then <code>1</code> will be returned
     * If the given value is greater than the length <code>100</code> will be returned
     *
     * @param position the position along the length
     * @param length   the distance
     * @return the percent distance covered by the given position along the given length in whole percent (1 - 100)
     */
    private int getPercentRoundedWithinBounds(final float position, final float length) {
        return clamp(Math.round(getPercentWithinBounds(position, length)), 1, 100);
    }

    /**
     * Use clamp to insure that a value always falls within an allowed range.
     * This method returns the supplied value if between the given minimum and maximum value.
     * If smaller than the minimum value, the minimum value will be returned.
     * If larger than the maximum value, the maximum value will be returned.
     *
     * @param value the value to clamp
     * @param min   the minimum possible value
     * @param max   the maximum possible value
     * @return the value if between min and max, min if less than min, max if greater than max
     */
    private int clamp(final int value, final int min, final int max) {
        if (value < min) {
            return min;
        }
        if (value > max) {
            return max;
        }
        return value;
    }

}
