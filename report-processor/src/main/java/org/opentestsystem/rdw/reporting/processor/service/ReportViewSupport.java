package org.opentestsystem.rdw.reporting.processor.service;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Ordering;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.reporting.common.model.Assessment;
import org.opentestsystem.rdw.reporting.common.model.Exam;
import org.opentestsystem.rdw.reporting.common.model.WritingTraitScores;
import org.opentestsystem.rdw.reporting.processor.model.AbstractExamReport;
import org.opentestsystem.rdw.reporting.processor.model.ScaleScoreView;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.MessageSource;
import org.springframework.stereotype.Component;

import java.util.Comparator;
import java.util.List;
import java.util.Locale;
import java.util.Objects;

import static com.google.common.collect.Lists.newArrayList;
import static java.lang.Math.toIntExact;
import static java.util.stream.Collectors.toList;

/**
 * Holds utility methods to help render the exam reports
 */
@Component
public class ReportViewSupport {

    private final MessageSource messageSource;

    @Autowired
    public ReportViewSupport(final MessageSource messageSource) {
        this.messageSource = messageSource;
    }

    /**
     * Gets a sorted list of accommodation names for the given exam and language
     *
     * @param exam   the exam for which the accommodations were available
     * @param locale the language to display the accommodations in
     * @return accommodation names sorted in natural order
     */
    public List<String> getSortedAccommodationNames(final Exam exam, final Locale locale) {
        return exam.getAccommodationCodes().stream()
                .map(value -> value + "." + exam.getSchoolYear())
                .map(value -> messageSource.getMessage(value, null, locale))
                .sorted()
                .collect(toList());
    }

    /**
     * Gets the last two digits of the given integer
     * If the given integer has two or less digits the given integer will be returned as a string
     *
     * @param value the integer to get the last two digits from
     * @return the last two digits of the given integer
     */
    public String getLastTwoDigits(final int value) {
        final String valueAsString = Integer.toString(value);
        if (valueAsString.length() <= 2) {
            return valueAsString;
        }
        return valueAsString.substring(valueAsString.length() - 2);
    }

    /**
     * Gets the result of {@link Math#round(double)} on the given value converted to string
     *
     * @param value the value to round
     * @return returns the result of {@link Math#round(double)} on the given value converted to string
     */
    public String round(final float value) {
        return Integer.toString(Math.round(value));
    }

    /**
     * Gets the result of {@link Math#floor(double)} on the given value converted to string
     *
     * @param value the value to floor
     * @return returns the result of {@link Math#floor(double)} on the given value converted to string
     */
    public String floor(final float value) {
        return Integer.toString((int) Math.floor(value));
    }

    /**
     * Gets the result of {@link Math#ceil(double)} on the given value converted to string
     *
     * @param value the value to ceil
     * @return returns the result of {@link Math#ceil(double)} on the given value converted to string
     */
    public String ceil(final float value) {
        return Integer.toString((int) Math.ceil(value));
    }

    /**
     * Gets the position and non-zero width attributes necessary for rendering a scale score graph
     *
     * @param exam       the exam to use for computing the scale score position
     * @param assessment the assessment to use for computing the cut point bar attributes
     * @return the position and width attributes necessary for rendering a scale score graph
     */
    public ScaleScoreView getScaleScoreView(final Exam exam, final Assessment assessment) {

        final List<Integer> cutPoints = AssessmentType.IAB.code().equals(assessment.getTypeCode())
                // Process IAB cut points for use in display
                ? getIabCutPoints(exam, assessment)
                // for ICA and Summative
                : assessment.getCutPoints();

        final int scaleScore = exam.getScaleScore().getValue();

        final int minimumScore = assessment.getCutPoints().get(0);
        final int maximumScore = assessment.getCutPoints().get(assessment.getCutPoints().size() - 1);

        final int length = maximumScore - minimumScore;

        // the whole percent of the scale score position along the length of the graph. This is independent of separators
        final int position = getPercentRoundedWithinBounds(scaleScore - minimumScore, length, 0);

        final List<ScaleScoreView.Level> levels = getScaleScoreViewLevels(cutPoints, length);

        return new ScaleScoreView(position, ImmutableList.copyOf(levels));
    }

    /**
     * For ICA and Summative the Writing Claim must be last for the PDF Report so that Writing Trait Scores
     * are displayed next to the Writing Claim. This method uses the defined display order of the claims
     * and then forces the writing claim to the end.
     *
     * @return Comparator used for sorting claim codes in the ICA and Summative PDF report template
     */
    public Comparator<String> getClaimCodeComparator(final AbstractExamReport report) {
        final List<String> claims = newArrayList(report.getSubjectDefinition().getScorableClaims());
        if (claims.remove("2-W")) claims.add("2-W");
        return Ordering.explicit(claims);
    }

    /**
     * Determines if this is the last claim and there are writing trait scores to display.
     * Used in the ICA and Summative PDF report templates
     *
     * @param isLast <code>true</code> if this is the last claim
     * @param writingTraitScores the writing trait scores object
     * @return <code>true</code> if this is the last claim and there are writing trait scores to display
     */
    public boolean isWritingTraitScoreClaim(boolean isLast, WritingTraitScores writingTraitScores) {
        return isLast && writingTraitScores != null;
    }

    /**
     * Gets the list of levels for the scale scores
     *
     * @param cutPoints the cut points
     * @param length    the maximumScore - minimumScore of the cut points
     * @return the list of levels
     */
    private List<ScaleScoreView.Level> getScaleScoreViewLevels(final List<Integer> cutPoints, final int length) {
        final List<Integer> filteredCutpoints = cutPoints.stream().filter(Objects::nonNull).collect(toList());

        final List<ScaleScoreView.Level> levels = newArrayList();
        for (int i = 1; i < filteredCutpoints.size(); i++) {
            final int previous = filteredCutpoints.get(i - 1);
            final int current = filteredCutpoints.get(i);

            final int sumOfWidth = levels.stream().mapToInt(ScaleScoreView.Level::getWidth).sum();

            final int width = i < filteredCutpoints.size() - 1
                    // This allows for all cut points to occupy at least 1% of the bar.
                    // For example, when we are at the first cut point, we set the subtrahend to 3, which makes the maximum percentage 97.
                    // At the second cut point, the subtrahend is 2, making the maxiumum percentage 98
                    ? getPercentRoundedWithinBounds(current - previous, length, filteredCutpoints.size() - i)
                    // The last bar should be the remaining non-zero percent width of the graph
                    // This will avoid rounding errors and the graph width not adding to 100 percent
                    : clamp(100 - sumOfWidth, 1, 100);

            levels.add(new ScaleScoreView.Level(sumOfWidth, width));

        }
        return levels;
    }

    /**
     * Gets the list of cut points for IAB assessments
     *
     * @param exam       the exam
     * @param assessment the IAB assessment
     * @return the list of cut point values
     */
    private List<Integer> getIabCutPoints(final Exam exam, final Assessment assessment) {
        final int minimumScore = assessment.getCutPoints().get(0);
        final int maximumScore = assessment.getCutPoints().get(assessment.getCutPoints().size() - 1);
        return newArrayList(
                minimumScore,
                // The second and third cut point are the middle cut point +/- the product of the individual exam
                // result scale score standard error and 1.5
                // this value must be clamped to be within the bounds of the minimum and maximum score
                clamp(toIntExact(assessment.getCutPoints().get(2) - Math.round(exam.getScaleScore().getStandardError() * 1.5)), minimumScore, maximumScore),
                clamp(toIntExact(assessment.getCutPoints().get(2) + Math.round(exam.getScaleScore().getStandardError() * 1.5)), minimumScore, maximumScore),
                maximumScore);
    }

    /**
     * Gets the percent distance covered by the given position along the given length (0f - 100f).
     * If the given position is less than <code>0</code> then <code>0</code> will be returned.
     * If the given position is greater than the length <code>100</code> will be returned.
     *
     * @param position the position along the length
     * @param length   the distance
     * @return the percent distance covered by the given position along the given length
     */
    private float getPercentWithinBounds(final float position, final float length) {
        if (position < 0) {
            return 0;
        }
        if (position > length) {
            return 100;
        }
        return (position / length) * 100f;
    }

    /**
     * Gets the percent distance covered by the given position along the given length in whole percent (1 - <code>100 - subtrahend</code>).
     * If the response from {@link #getPercentWithinBounds(float, float)} is less than <code>1</code> then <code>1</code> will be returned.
     * If the response from {@link #getPercentWithinBounds(float, float)} is greater than <code>100 - subtrahend</code> then <code>100 - subtrahend</code> will be returned.
     *
     * @param position   the position along the length
     * @param length     the distance
     * @param subtrahend the amount to subtract from 100
     * @return the percent distance covered by the given position along the given length in whole percent (1 - <code>100 - subtrahend</code>)
     */
    private int getPercentRoundedWithinBounds(final float position, final float length, final int subtrahend) {
        return clamp(Math.round(getPercentWithinBounds(position, length)), 1, 100 - subtrahend);
    }

    /**
     * Use clamp to ensure that a value always falls within an allowed range.
     * This method returns the supplied value if between the given minimum and maximum value.
     * If smaller than the minimum value, the minimum value will be returned.
     * If larger than the maximum value, the maximum value will be returned.
     *
     * @param value the value to clamp
     * @param min   the minimum possible value
     * @param max   the maximum possible value
     * @return the value if between min and max, min if less than min, max if greater than max
     */
    private int clamp(final int value, final int min, final int max) {
        if (value < min) {
            return min;
        }
        if (value > max) {
            return max;
        }
        return value;
    }

}
