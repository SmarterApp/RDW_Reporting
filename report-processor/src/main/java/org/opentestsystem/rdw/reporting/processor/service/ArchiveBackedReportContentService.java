package org.opentestsystem.rdw.reporting.processor.service;

import com.amazonaws.services.s3.Headers;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.opentestsystem.rdw.reporting.processor.model.UserReport;
import org.opentestsystem.rdw.reporting.processor.web.ReportContentResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;

import java.io.InputStream;
import java.net.URI;
import java.util.HashSet;
import java.util.Properties;
import java.util.Set;

import static org.opentestsystem.rdw.reporting.common.util.MediaTypes.APPLICATION_PDF_UTF8;
import static org.opentestsystem.rdw.reporting.common.util.MediaTypes.getExtension;
import static org.springframework.http.MediaType.APPLICATION_OCTET_STREAM;
import static org.springframework.util.StringUtils.isEmpty;

/**
 * This implementation of a ReportContentService is backed by an ArchiveService.
 */
@Service
public class ArchiveBackedReportContentService implements ReportContentService {
    private static final Logger logger = LoggerFactory.getLogger(ArchiveBackedReportContentService.class);
    final static String BasePath = "REPORTS/USER/";

    private final ArchiveService archiveService;
    private final ReportService reportService;

    @Autowired
    public ArchiveBackedReportContentService(final ArchiveService archiveService,
                                             final ReportService reportService) {
        this.archiveService = archiveService;
        this.reportService = reportService;
    }

    @Override
    public UserReport writeContent(final UserReport report,
                                   final InputStream content,
                                   final long contentLength,
                                   final MediaType mediaType) {
        final URI uri = createUri(report, mediaType);
        final Properties properties = new Properties();
        properties.put(Headers.CONTENT_LENGTH, contentLength);
        properties.put(Headers.CONTENT_TYPE, mediaType.toString());

        archiveService.writeResource(uri.toASCIIString(), content, properties);

        return reportService.update(report.copy()
                .reportResourceUri(uri)
                .build());
    }

    @Override
    public ReportContentResource openContent(final UserReport report) {
        final URI uri = report.getReportResourceUri();
        if (uri == null) {
            throw new IllegalArgumentException("UserReport has no content URI: " + report.getId());
        }

        final String location = uri.toASCIIString();
        final Properties reportProperties = archiveService.readProperties(location);
        if (!reportProperties.containsKey(Headers.CONTENT_LENGTH)) return null;

        final MediaType mediaType = parseMediaType(reportProperties.getProperty(Headers.CONTENT_TYPE));
        final long reportLength = (Long) reportProperties.get(Headers.CONTENT_LENGTH);
        return new ReportContentResource(() -> archiveService.openResource(location), reportLength, mediaType, report);
    }

    @Override
    public Set<UserReport> deleteContents(final Iterable<UserReport> reports) {
        final Set<UserReport> successfulDeletes = new HashSet<>();
        for (final UserReport report : reports) {
            final UserReport deletedReport = deleteContent(report);
            if (deletedReport != null) {
                successfulDeletes.add(deletedReport);
            }
        }
        return successfulDeletes;
    }

    @Override
    public Properties readProperties(final UserReport report, final MediaType mediaType) {
        final URI uri = createUri(report, mediaType);
        return archiveService.readProperties(uri.toASCIIString());
    }

    @Override
    public URI createUri(final UserReport report, final MediaType mediaType) {
        return URI.create(BasePath + report.getId() + "." + getExtension(mediaType));
    }

    /**
     * Determine the content media type.
     * NOTE: Old V1 PDF reports are stored with the S3-default content type of
     * 'application/octet-stream' This assumes any resource with the S3-default
     * content type is actually 'application/pdf'
     * TODO: Remove APPLICATION_PDF assumption once we no longer need to support V1 PDF reports
     *
     * @param contentType The resource content-type
     * @return The parsed media type
     */
    private MediaType parseMediaType(final String contentType) {
        if (isEmpty(contentType)) {
            return APPLICATION_PDF_UTF8;
        }

        final MediaType parsedMediaType = MediaType.parseMediaType(contentType);
        return APPLICATION_OCTET_STREAM.isCompatibleWith(parsedMediaType)
                ? APPLICATION_PDF_UTF8
                : parsedMediaType;
    }

    private UserReport deleteContent(final UserReport report) {
        final URI uri = report.getReportResourceUri();
        if (uri != null) {
            final String location = uri.toASCIIString();
            try {
                archiveService.delete(location);
            } catch (final RuntimeException e) {
                logger.warn("failed to delete location {}", location, e);
                return null;
            }
        }
        return report;
    }
}
