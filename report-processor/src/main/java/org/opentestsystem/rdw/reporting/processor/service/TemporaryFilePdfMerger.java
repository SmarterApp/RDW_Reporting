package org.opentestsystem.rdw.reporting.processor.service;

import org.apache.commons.io.IOUtils;
import org.apache.pdfbox.io.MemoryUsageSetting;
import org.apache.pdfbox.multipdf.PDFMergerUtility;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.opentestsystem.rdw.reporting.common.model.Report;
import org.opentestsystem.rdw.reporting.processor.configuration.ReportGenerationProperties;
import org.opentestsystem.rdw.reporting.processor.model.MergedReport;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.util.List;
import java.util.function.Supplier;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import static com.google.common.collect.Lists.newArrayList;
import static org.opentestsystem.rdw.reporting.processor.util.MediaTypes.APPLICATION_PDF_UTF8;
import static org.opentestsystem.rdw.reporting.processor.util.MediaTypes.APPLICATION_ZIP;

/**
 * This ReportMergeService implementation uses a temporary file
 * to provide streaming PDF merging.
 */
@Service
public class TemporaryFilePdfMerger implements ReportMergeService {
    private final static Logger logger = LoggerFactory.getLogger(TemporaryFilePdfMerger.class);

    private final ReportGenerationProperties reportGenerationProperties;

    public TemporaryFilePdfMerger(final ReportGenerationProperties reportGenerationProperties) {
        this.reportGenerationProperties = reportGenerationProperties;
    }

    @Override
    public MergedReport mergePdfs(final Report report,
                                  final List<Supplier<InputStream>> sourcePdfs) throws IOException {
        final String label = report.getLabel().replaceAll("\\s", "_");
        final List<File> reportPdfs = merge(sourcePdfs);
        if (reportPdfs.size() == 1) {
            return new MergedReport(reportPdfs.get(0), APPLICATION_PDF_UTF8);
        }

        final File zipFile = createZipFile(reportPdfs, label);
        return new MergedReport(zipFile, APPLICATION_ZIP);
    }

    private List<File> merge(final List<Supplier<InputStream>> sourcePdfs) {
        final List<File> pdfFiles = newArrayList();

        try {
            final MemoryUsageSetting memoryUsage = MemoryUsageSetting.setupTempFileOnly();
            PDDocument destinationDocument = new PDDocument(memoryUsage);

            final PDFMergerUtility mergerUtility = new PDFMergerUtility();
            for (final Supplier<InputStream> supplier : sourcePdfs) {
                if (destinationDocument.getNumberOfPages() > reportGenerationProperties.getPdfPageCutoff()) {
                    writeDocument(appendTempFile(pdfFiles), destinationDocument);
                    destinationDocument = new PDDocument(memoryUsage);
                }

                try (final InputStream sourceStream = supplier.get()) {
                    final PDDocument srcDocument = PDDocument.load(sourceStream, memoryUsage);
                    mergerUtility.appendDocument(destinationDocument, srcDocument);
                    srcDocument.close();
                }
            }
            writeDocument(appendTempFile(pdfFiles), destinationDocument);
            return pdfFiles;
        } catch (final IOException e) {
            throw new RuntimeException("Unable to merge PDFs", e);
        }
    }

    private File createZipFile(final List<File> pdfFiles, final String label) {
        try {
            final File zipFile = Files.createTempFile("mergedPdf", ".pdf").toFile();
            try (final ZipOutputStream zipOut = new ZipOutputStream(new FileOutputStream(zipFile))) {
                int index = 1;
                for (final File pdfFile : pdfFiles) {
                    try (final FileInputStream pdfStream = new FileInputStream(pdfFile)) {
                        final ZipEntry entry = new ZipEntry(label + "_" + index++ + ".pdf");
                        zipOut.putNextEntry(entry);
                        IOUtils.copy(pdfStream, zipOut);
                    }
                    if (!pdfFile.delete()) {
                        logger.warn("Unable to delete temporary PDF report file: {}", pdfFile.getPath());
                    }
                }
            }
            return zipFile;
        } catch (final IOException e) {
            throw new RuntimeException("Unable to create zip file", e);
        }
    }

    private void writeDocument(final File targetFile, final PDDocument document) throws IOException {
        document.save(targetFile);
        document.close();
    }

    private File appendTempFile(final List<File> files) throws IOException {
        final File tempFile = Files.createTempFile("mergedPdf", ".pdf").toFile();
        files.add(tempFile);
        return tempFile;
    }
}
