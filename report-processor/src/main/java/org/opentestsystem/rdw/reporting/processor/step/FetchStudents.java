package org.opentestsystem.rdw.reporting.processor.step;

import com.google.common.collect.Lists;
import com.google.common.collect.Ordering;
import org.opentestsystem.rdw.reporting.common.model.Report;
import org.opentestsystem.rdw.reporting.common.model.Student;
import org.opentestsystem.rdw.reporting.common.report.AbstractBatchExamReportRequest;
import org.opentestsystem.rdw.reporting.common.report.AbstractExamReportRequest;
import org.opentestsystem.rdw.reporting.common.report.ExamQueryParams;
import org.opentestsystem.rdw.reporting.common.report.ExamReportOrder;
import org.opentestsystem.rdw.reporting.common.security.PermissionScope;
import org.opentestsystem.rdw.reporting.processor.configuration.ReportGenerationProperties;
import org.opentestsystem.rdw.reporting.processor.model.StudentChunk;
import org.opentestsystem.rdw.reporting.processor.repository.StudentRepository;
import org.opentestsystem.rdw.reporting.processor.requesthandler.ExamQueryParamsParser;
import org.opentestsystem.rdw.reporting.processor.service.ReportGenerationJobParameterProvider;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.BlockingQueue;

/**
 * This Spring Batch tasklet is responsible for fetching, ordering,
 * and chunking students within the context of a Job's
 * {@link org.opentestsystem.rdw.reporting.common.report.AbstractExamReportRequest}
 */
@Component
public class FetchStudents implements Tasklet {

    private static final Ordering<Student> StudentSSIDOrdering = Ordering.natural()
            .onResultOf(Student::getSsid);

    private static final Ordering<Student> StudentNameOrdering = Ordering.natural()
            .onResultOf(student -> student.getLastName() + " " + student.getFirstName());

    private final BlockingQueue<StudentChunk> studentChunks;
    private final Set<ExamQueryParamsParser> queryParamsParsers;
    private final ReportGenerationJobParameterProvider parameterProvider;
    private final StudentRepository studentRepository;
    private final ReportGenerationProperties reportGenerationProperties;

    @Autowired
    public FetchStudents(final BlockingQueue<StudentChunk> studentChunks,
                         final Set<ExamQueryParamsParser> queryParamsParsers,
                         final ReportGenerationJobParameterProvider parameterProvider,
                         final StudentRepository studentRepository,
                         final ReportGenerationProperties reportGenerationProperties) {
        this.studentChunks = studentChunks;
        this.queryParamsParsers = queryParamsParsers;
        this.parameterProvider = parameterProvider;
        this.studentRepository = studentRepository;
        this.reportGenerationProperties = reportGenerationProperties;
    }

    @Override
    public RepeatStatus execute(final StepContribution contribution, final ChunkContext chunkContext) throws Exception {
        final Map<String, Object> jobParams = chunkContext.getStepContext().getJobParameters();
        final PermissionScope permissionScope = parameterProvider.permissionScopeFromParameters(jobParams);
        final Report report = parameterProvider.reportFromParameters(jobParams);

        //Find a registered ExamQueryParamsParser that can handle the request.
        final ExamQueryParamsParser parser = queryParamsParsers.stream()
                .filter(idFetcher -> idFetcher.accept(report.getReportRequest()))
                .findFirst()
                .orElseThrow(() -> new IllegalStateException("Unable to find ExamQueryParamsParser for Report: " + report.getId()));
        final ExamQueryParams queryParams = parser.parseQueryParams(report.getReportRequest());

        //Find the report's students
        final Collection<Student> students = studentRepository.findStudentsByExamQueryParams(
                permissionScope,
                queryParams);

        //Break the students into ordered chunks
        final List<Student> orderedStudents = getOrdering(report.getReportRequest()).sortedCopy(students);
        final List<List<Student>> chunks = Lists.partition(orderedStudents, reportGenerationProperties.getChunkSize());
        for (int chunkIdx = 0; chunkIdx < chunks.size(); chunkIdx++) {
            studentChunks.add(StudentChunk.builder()
                    .index(chunkIdx)
                    .students(chunks.get(chunkIdx))
                    .build());
        }

        return RepeatStatus.FINISHED;
    }

    private Ordering<Student> getOrdering(final AbstractExamReportRequest reportRequest) {
        ExamReportOrder order = null;
        if (reportRequest instanceof AbstractBatchExamReportRequest) {
            order = ((AbstractBatchExamReportRequest) reportRequest).getOrder();
        }
        if (order == null) {
            order = ExamReportOrder.STUDENT_NAME;
        }

        switch(order) {
            case STUDENT_SSID:
                return StudentSSIDOrdering;
            case STUDENT_NAME:
            default:
                return StudentNameOrdering;
        }
    }
}
