package org.opentestsystem.rdw.reporting.processor.repository;

import com.google.common.collect.Multimap;
import com.google.common.collect.MultimapBuilder;
import org.opentestsystem.rdw.reporting.common.configuration.ReportingSystemProperties;
import org.opentestsystem.rdw.reporting.common.jdbc.Assessments;
import org.opentestsystem.rdw.reporting.common.jdbc.Exams;
import org.opentestsystem.rdw.reporting.common.jdbc.SecurityParameterProvider;
import org.opentestsystem.rdw.reporting.common.jdbc.Students;
import org.opentestsystem.rdw.reporting.common.jdbc.TraitScores;
import org.opentestsystem.rdw.reporting.common.model.Assessment;
import org.opentestsystem.rdw.reporting.common.model.ExamWithPercentile;
import org.opentestsystem.rdw.reporting.common.model.Student;
import org.opentestsystem.rdw.reporting.common.model.UserGroupType;
import org.opentestsystem.rdw.reporting.common.security.User;
import org.opentestsystem.rdw.reporting.common.sqlbuilder.UserGroupSqlProvider;
import org.opentestsystem.rdw.reporting.processor.model.ExamQueryParams;
import org.opentestsystem.rdw.reporting.processor.model.IabReport;
import org.opentestsystem.rdw.reporting.processor.util.StudentEnrollments;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;

import javax.validation.constraints.NotNull;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

import static com.google.common.collect.Maps.newHashMap;
import static java.util.Comparator.comparing;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.getNullable;
import static org.opentestsystem.rdw.reporting.processor.util.ReportProcessorUtils.getExamFilterParameters;

@Repository
class JdbcIabReportRepository implements IabReportRepository {

    private final NamedParameterJdbcTemplate template;
    private final SecurityParameterProvider securityParameterProvider;
    private final ReportingSystemProperties reportingSystemProperties;

    private final String findAllIabsByStudentIdsAndQueryParamsUnknownPermissions;

    private final String findAllIabsForTeacherGroupByStudentIdsAndQueryParamsGroupPermissions;
    private final String findAllIabsForAdminGroupByStudentIdsAndQueryParamsGroupPermissions;
    private final String findItemLevelTraitScoresByExamIds;


    @Autowired
    JdbcIabReportRepository(final NamedParameterJdbcTemplate template,
                            final UserGroupSqlProvider userGroupSqlProvider,
                            final SecurityParameterProvider securityParameterProvider,
                            @Qualifier("reportingSystemPropertiesResolver") final ReportingSystemProperties reportingSystemProperties,
                            @Value("${sql.exam.findAllIabsByStudentIdsAndQueryParamsUnknownPermissions}") final String findAllIabsByStudentIdsAndQueryParamsUnknownPermissions,
                            @Value("${sql.exam.findAllIabsByStudentIdsAndQueryParamsGroupPermissions}") final String findAllIabsByStudentIdsAndQueryParamsGroupPermissions,
                            @Value("${sql.exam.findItemLevelTraitScoresByExamIds}") final String findItemLevelTraitScoresByExamIds) {
        this.template = template;
        this.securityParameterProvider = securityParameterProvider;
        this.reportingSystemProperties = reportingSystemProperties;

        this.findAllIabsByStudentIdsAndQueryParamsUnknownPermissions = findAllIabsByStudentIdsAndQueryParamsUnknownPermissions;

        this.findAllIabsForTeacherGroupByStudentIdsAndQueryParamsGroupPermissions = userGroupSqlProvider.getSqlForGroupOfType(findAllIabsByStudentIdsAndQueryParamsGroupPermissions, UserGroupType.Teacher);
        this.findAllIabsForAdminGroupByStudentIdsAndQueryParamsGroupPermissions = userGroupSqlProvider.getSqlForGroupOfType(findAllIabsByStudentIdsAndQueryParamsGroupPermissions, UserGroupType.Admin);
        this.findItemLevelTraitScoresByExamIds = findItemLevelTraitScoresByExamIds;
    }

    @Override
    public Map<Long, Collection<IabReport>> findAllForStudentsByExamFilter(
            @NotNull final User user,
            final Collection<Long> studentIds,
            final ExamQueryParams examQueryParams) {

        // map of student id to map of subject to report builder
        // (groups reports by subject and student)
        final Map<Long, Map<String, IabReport.Builder>> studentReportBuilders = newHashMap();

        // map of student id to map of subject to assessment/exam multimap
        final Map<Long, Map<String, Multimap<Assessment, ExamWithPercentile.Builder>>> studentReportAssessments = new HashMap<>();

        // temporary map of exam id to exam builder, a convenience for the second query
        final Map<Long, ExamWithPercentile.Builder> examBuildersById = new HashMap<>();

        // gather all the exams, grouping them by assessment, subject, and student
        // the exams and reports remain as builders for subsequent work
        template.query(getExamFilterQuery(examQueryParams),
                new MapSqlParameterSource()
                        .addValues(securityParameterProvider.getSecurityParameters(user, examQueryParams.isDisableTransferAccess()))
                        .addValues(getExamFilterParameters(examQueryParams))
                        .addValue("student_ids", studentIds),
                (row) -> {
                    // This builder depends on the exams being sorted in order of latest to oldest completion date
                    // Only in this sort order will the first row contain the most recent student enrollment information
                    // Only in this sort order will the exams associated with assessments be sorted correctly when inserting into the multimap

                    final long studentId = row.getLong("student_id");
                    final Assessment assessment = Assessments.mapWithCutPoints(row, Assessment.builder(), "asmt_").build();
                    final String subject = row.getString("asmt_subject_code");

                    studentReportBuilders
                            .computeIfAbsent(studentId, (id) -> new HashMap<>())
                            .computeIfAbsent(subject, (sub) -> {
                                try {
                                    return IabReport.builder()
                                            .assessmentType(assessment.getTypeCode())
                                            .subject(assessment.getSubjectCode())
                                            .student(Students.map(row, Student.builder(), "student_").build())
                                            .studentEnrollment(StudentEnrollments.map(row, reportingSystemProperties.getState().getCode()));
                                } catch (final SQLException e) {
                                    throw new RuntimeException(e);
                                }
                            });

                    final ExamWithPercentile.Builder examBuilder = Exams.map(row, ExamWithPercentile.builder())
                            .percentileMean(getNullable(row, row.getInt("percentile_mean")))
                            .percentileRank(getNullable(row, row.getInt("percentile_rank")));

                    final Multimap<Assessment, ExamWithPercentile.Builder> examBuildersByAssessment = studentReportAssessments
                            .computeIfAbsent(studentId, (id) -> new HashMap<>())
                            .computeIfAbsent(subject, (subj) -> MultimapBuilder
                                    .treeKeys(comparing(Assessment::getLabel))
                                    .arrayListValues()
                                    .build());
                    examBuildersByAssessment.put(assessment, examBuilder);
                    examBuildersById.put(examBuilder.getId(), examBuilder); // save reference for trait score query
                }
        );

        final Map<Long, Collection<IabReport>> reportsByStudent = new HashMap<>();

        // if there aren't any exams, we can quit working and return an empty map
        if (examBuildersById.isEmpty()) {
            return reportsByStudent;
        }

        // this query gathers the trait scores for all the exams
        template.query(findItemLevelTraitScoresByExamIds,
            new MapSqlParameterSource("exam_ids", examBuildersById.keySet()),
            (row) -> {
                examBuildersById.get(row.getLong("exam_id")).traitScore(TraitScores.map(row));
            }
        );

        // Collate the assessments/exams into reports
        studentReportBuilders.forEach((key, value) -> {
            final long studentId = key;
            final Map<String, Multimap<Assessment, ExamWithPercentile.Builder>> studentAssessments = studentReportAssessments.get(studentId);
            if (studentAssessments == null || studentAssessments.isEmpty()) return;

            value.forEach((subject, builder) -> {
                final Multimap<Assessment, ExamWithPercentile.Builder> subjectAssessments = studentAssessments.get(subject);
                if (subjectAssessments == null || subjectAssessments.isEmpty()) return;

                // we need to transform the collections of exam builders into collections of exams
                final Map<Assessment, Collection<ExamWithPercentile>> examMap =
                    subjectAssessments.asMap().entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, entry ->
                        entry.getValue().stream().map(ExamWithPercentile.Builder::build).collect(Collectors.toList())));

                reportsByStudent
                        .computeIfAbsent(studentId, (id) -> new ArrayList<>())
                        .add(builder.examsByAssessment(examMap).build());
            });
        });

        return reportsByStudent;
    }

    private String getExamFilterQuery(final ExamQueryParams examQueryParams) {
        switch (examQueryParams.getQueryPermissionType()) {
            case Unknown:
            case Individual:
                return findAllIabsByStudentIdsAndQueryParamsUnknownPermissions;
            case Group:
                return examQueryParams.getGroupId().getType() == UserGroupType.Admin ?
                        findAllIabsForAdminGroupByStudentIdsAndQueryParamsGroupPermissions :
                        findAllIabsForTeacherGroupByStudentIdsAndQueryParamsGroupPermissions;
            default:
                throw new IllegalArgumentException("Unknown query permission type: " + examQueryParams.getQueryPermissionType());
        }
    }

}
