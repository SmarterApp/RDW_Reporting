package org.opentestsystem.rdw.reporting.processor.web.converter;

import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.opentestsystem.rdw.reporting.common.model.DimensionType;
import org.opentestsystem.rdw.reporting.common.model.FilteredSubgroupReportQuery;
import org.opentestsystem.rdw.reporting.common.model.FilteredSubgroupRow;
import org.opentestsystem.rdw.reporting.common.model.StudentFilters;
import org.opentestsystem.rdw.reporting.processor.model.AbstractExamReportRequest;
import org.opentestsystem.rdw.reporting.processor.model.AggregateReportRequest;
import org.opentestsystem.rdw.reporting.processor.model.ReportType;
import org.opentestsystem.rdw.reporting.processor.web.ReportContentResource;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.MessageSource;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.Iterator;
import java.util.List;

import static com.google.common.collect.Lists.newArrayList;
import static org.apache.commons.lang.StringUtils.isNotEmpty;
import static org.opentestsystem.rdw.reporting.common.model.AggregateQueryType.FilteredSubgroup;
import static org.springframework.http.MediaType.APPLICATION_JSON;

/**
 * This handler is responsible for transforming the JSON response for an
 * {@link AggregateReportRequest} containing a {@link FilteredSubgroupReportQuery} into a CSV.
 *
 * The response JSON contains an array of {@link FilteredSubgroupRow} instances that should each be converted
 * into a CSV row in the response payload using codes for values and data model identifiers for headers
 * where applicable.
 * If completeness/administrative condition filters have been applied to the query, they are printed in the first row,
 * last column of the response under the header of "Attributes."
 *
 * Note that this handler will only be applied if the user has not explicitly requested a JSON response payload.
 */
@Component
public class FilteredSubgroupReportCsvHandler extends AggregateReportCsvHandler<FilteredSubgroupReportQuery, FilteredSubgroupRow> {

    @Autowired
    public FilteredSubgroupReportCsvHandler(final MessageSource messageSource,
                                            final ObjectMapper objectMapper) {
        super(messageSource, objectMapper);
    }

    @Override
    public boolean accept(final ReportContentResource resource, final MediaType requestedMediaType) {
        final AbstractExamReportRequest request = resource.getReport().getReportRequest();
        return !APPLICATION_JSON.isCompatibleWith(requestedMediaType) &&
                request.getReportType() == ReportType.AggregateReportRequest &&
                ((AggregateReportRequest) request).getQuery().getQueryType() == FilteredSubgroup;
    }

    @Override
    protected List<String> getHeaders(final FilteredSubgroupReportQuery query) {
        final List<String> headers = super.getHeaders(query);
        headers.add(7, getMessage("report.aggregate.export.header.dimension"));

        return headers;
    }

    @Override
    protected List<String> getRowValues(final CsvContext context, final FilteredSubgroupRow result) {
        final List<String> rowValues = super.getRowValues(context, result);

        rowValues.add(7, getSubgroup(context, result.getSubgroupKey()));
        return rowValues;
    }

    @Override
    protected Iterator<FilteredSubgroupRow> asReportRowIterator(final JsonParser parser, final ReportContentResource resource) {
        return new Iterator<FilteredSubgroupRow>() {
            @Override
            public boolean hasNext() {
                return parser.currentToken() == JsonToken.START_OBJECT;
            }

            @Override
            public FilteredSubgroupRow next() {
                try {
                    final JsonNode node = getMapper().readTree(parser);
                    parser.nextToken();
                    return getMapper().treeToValue(node, FilteredSubgroupRow.class);
                } catch (final IOException e) {
                    throw new IllegalStateException("Unable to parse json payload for aggregate report: " + resource.getReport().getId(), e);
                }
            }
        };
    }

    private String getSubgroup(final CsvContext context, final String subgroupKey) {
        if (isNotEmpty(context.get(subgroupKey, String.class))) {
            return context.get(subgroupKey, String.class);
        }

        final StudentFilters rowFilters = context.getQuery().getSubgroups().get(subgroupKey);
        if (rowFilters == null) {
            throw new IllegalStateException("Unknown subgroup referenced by FilteredSubgroup report result: " + subgroupKey);
        }

        final List<String> filterAttributes = newArrayList();
        appendAttribute(filterAttributes, "Sex", rowFilters.getGenderCodes());
        appendAttribute(filterAttributes, "Ethnicity", rowFilters.getEthnicityCodes());
        appendAttribute(filterAttributes, "LEPStatus", rowFilters.getLepCodes());
        appendAttribute(filterAttributes, "MigrantStatus", rowFilters.getMigrantStatusCodes());
        appendAttribute(filterAttributes, "Section504Status", rowFilters.getSection504Codes());
        appendAttribute(filterAttributes, "IDEAIndicator", rowFilters.getIepCodes());
        appendAttribute(filterAttributes, "EconomicDisadvantageStatus", rowFilters.getEconomicDisadvantageCodes());

        final String subgroupAttributes = filterAttributes.isEmpty() ? DimensionType.Overall.code() : AttributeJoiner.join(filterAttributes);
        context.put(subgroupKey, subgroupAttributes);
        return subgroupAttributes;
    }
}
