package org.opentestsystem.rdw.reporting.processor.service;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import org.opentestsystem.rdw.reporting.common.model.ReportQuery;
import org.opentestsystem.rdw.reporting.common.model.ReportQueryType;
import org.opentestsystem.rdw.reporting.common.security.User;
import org.opentestsystem.rdw.reporting.processor.model.UserReport;
import org.opentestsystem.rdw.reporting.processor.web.ReportContentResource;
import org.opentestsystem.rdw.security.Permission;
import org.springframework.stereotype.Service;

import javax.validation.constraints.NotNull;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;

import static org.opentestsystem.rdw.reporting.common.model.ReportQueryType.Claim;
import static org.opentestsystem.rdw.reporting.common.model.ReportQueryType.CustomAggregate;
import static org.opentestsystem.rdw.reporting.common.model.ReportQueryType.DistrictSchoolExport;
import static org.opentestsystem.rdw.reporting.common.model.ReportQueryType.Group;
import static org.opentestsystem.rdw.reporting.common.model.ReportQueryType.Longitudinal;
import static org.opentestsystem.rdw.reporting.common.model.ReportQueryType.SchoolGrade;
import static org.opentestsystem.rdw.reporting.common.model.ReportQueryType.Student;
import static org.opentestsystem.rdw.reporting.common.model.ReportQueryType.Target;
import static org.opentestsystem.rdw.reporting.common.security.ReportingPermission.GroupPiiRead;
import static org.opentestsystem.rdw.reporting.common.security.ReportingPermission.IndividualPiiRead;


@Service
class DefaultExamReportService implements ExamReportService {

    private static final Map<ReportQueryType, Set<String>> RequiredPermissionsByReportQueryType = ImmutableMap.<ReportQueryType, Set<String>>builder()
            .put(Student, ImmutableSet.of(IndividualPiiRead, GroupPiiRead))
            .put(Group, ImmutableSet.of(GroupPiiRead))
            .put(SchoolGrade, ImmutableSet.of(IndividualPiiRead))
            .put(DistrictSchoolExport, ImmutableSet.of(IndividualPiiRead))
            .put(CustomAggregate, ImmutableSet.of("CUSTOM_AGGREGATE_READ"))
            .put(Longitudinal, ImmutableSet.of("CUSTOM_AGGREGATE_READ"))
            .put(Claim, ImmutableSet.of("CUSTOM_AGGREGATE_READ"))
            .put(Target, ImmutableSet.of("CUSTOM_AGGREGATE_READ"))
            .build();

    private final ReportGenerator generator;
    private final UserReportService service;
    private final ReportContentService contentService;

    DefaultExamReportService(final ReportGenerator generator,
                             final UserReportService service,
                             final ReportContentService contentService) {
        this.generator = generator;
        this.service = service;
        this.contentService = contentService;
    }

    @Override
    public List<UserReport> getReports(@NotNull final User user) {
        return service.findAllByUserAndId(user.getUsername(), ImmutableSet.of());
    }

    @Override
    public List<UserReport> getReports(@NotNull final User user, final Iterable<Long> reportIds) {
        return service.findAllByUserAndId(user.getUsername(), reportIds != null ? ImmutableSet.copyOf(reportIds) : ImmutableSet.of());
    }

    @Override
    public ReportContentResource openReportContent(@NotNull final User user, final long reportId) {

        final UserReport report = service.findOneById(reportId)
                .orElseThrow(NoSuchElementException::new);

        if (!report.getUser().equals(user.getUsername())) {
            throw new NoSuchElementException();
        }

        return contentService.openContent(report);
    }

    @Override
    public UserReport createReport(
            @NotNull final User user,
            @NotNull final ReportQuery query) {
        checkPermissions(user.getPermissionsById(), query.getType());
        return generator.generateReport(query, user);
    }

    @Override
    public void delete(final User user, final long id) {
        service.delete(user.getUsername(), id);
    }

    private void checkPermissions(
            @NotNull final Map<String, Permission> permissionsById,
            @NotNull final ReportQueryType type) {

        final Set<String> requiredPermissions = RequiredPermissionsByReportQueryType.get(type);
        if (requiredPermissions != null
                && !requiredPermissions.isEmpty()
                && requiredPermissions.stream().noneMatch(permissionsById::containsKey)) {
            throw new RuntimeException(String.format(
                    "User needs any of permissions (%s) to create reports of type \"%s\"",
                    requiredPermissions, type
            ));
        }
    }

}
