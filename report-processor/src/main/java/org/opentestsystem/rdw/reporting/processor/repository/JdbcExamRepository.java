package org.opentestsystem.rdw.reporting.processor.repository;

import com.google.common.collect.ImmutableMap;
import com.mysql.jdbc.ResultSetImpl;
import org.opentestsystem.rdw.reporting.common.jdbc.SecurityParameterProvider;
import org.opentestsystem.rdw.reporting.processor.model.ExportExamReportRequest;
import org.opentestsystem.rdw.reporting.processor.model.FileDetail;
import org.opentestsystem.rdw.security.PermissionScope;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;

import java.sql.ResultSet;
import java.util.Map;

import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.UNMATCHABLE_IDS;
import static org.opentestsystem.rdw.reporting.common.jdbc.QueryUtils.nullOrEmptyToDefault;

@Repository
public class JdbcExamRepository implements ExamRepository {

    private static final String ExportDestination = "::EXPORT_DESTINATION::";

    @Value("${sql.export.exam}")
    private String exportExam;

    private final NamedParameterJdbcTemplate template;
    private final SecurityParameterProvider securityParameterProvider;

    @Autowired
    JdbcExamRepository(final NamedParameterJdbcTemplate template,
                       final SecurityParameterProvider securityParameterProvider) {
        this.template = template;
        this.securityParameterProvider = securityParameterProvider;
    }

    @Override
    public FileDetail export(final PermissionScope permissionScope, final ExportExamReportRequest request, final String uriLocation) {
        final boolean isDestinationS3 = uriLocation.toLowerCase().startsWith("s3");

        final boolean hasResults = template.execute(
                exportExam.replace(ExportDestination, isDestinationS3 ? "S3" : ""),
                ImmutableMap.<String, Object>builder()
                        .putAll(securityParameterProvider.getSecurityParameters(permissionScope))
                        .putAll(getQueryParameters(request))
                        .put("export_location", uriLocation)
                        .build(),
                (ps) -> {
                    final ResultSet resultSet = ps.executeQuery();
                    if (resultSet instanceof ResultSetImpl) {
                        // Headers are one row. So, we have results if we have more than one row.
                        return ((ResultSetImpl) resultSet).getUpdateCount() > 1;
                    }
                    return false;
                }
        );

        // The SELECT INTO OUTFILE S3 feature appends a part number to the file.
        return FileDetail.builder().relativePath(isDestinationS3 ? uriLocation + ".part_00000" : uriLocation).hasResults(hasResults).build();
    }

    private Map<String, Object> getQueryParameters(final ExportExamReportRequest request) {
        final String prefix = "query_";

        return ImmutableMap.<String, Object>builder()
                .put(prefix + "district_group_ids", nullOrEmptyToDefault(request.getDistrictGroupIds(), UNMATCHABLE_IDS))
                .put(prefix + "district_ids", nullOrEmptyToDefault(request.getDistrictIds(), UNMATCHABLE_IDS))
                .put(prefix + "school_group_ids", nullOrEmptyToDefault(request.getSchoolGroupIds(), UNMATCHABLE_IDS))
                .put(prefix + "school_ids", nullOrEmptyToDefault(request.getSchoolIds(), UNMATCHABLE_IDS))
                .put("school_year", request.getSchoolYear())
                .put("disable_transfer_access", request.isDisableTransferAccess())
                .build();
    }

}
