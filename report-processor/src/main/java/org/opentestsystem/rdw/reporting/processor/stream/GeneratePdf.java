package org.opentestsystem.rdw.reporting.processor.stream;

import org.opentestsystem.rdw.reporting.common.model.ReportStatus;
import org.opentestsystem.rdw.reporting.processor.model.MergedReport;
import org.opentestsystem.rdw.reporting.processor.model.UserReport;
import org.opentestsystem.rdw.reporting.processor.model.ReportRequestMessage;
import org.opentestsystem.rdw.reporting.processor.service.ReportContentService;
import org.opentestsystem.rdw.reporting.processor.service.ReportGenerationTemporaryStorage;
import org.opentestsystem.rdw.reporting.processor.service.ReportMergeService;
import org.opentestsystem.rdw.reporting.processor.service.ReportService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.stereotype.Component;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.function.Supplier;

import static java.lang.Integer.parseInt;
import static org.opentestsystem.rdw.reporting.processor.stream.PdfReportProcessor.ReportCollateIn;

/**
 * This component is responsible for generating a combined report PDF,
 * merging all of the report's PDF chunks into a single report file.
 * If the final UserReport PDF is too large, it will be be broken into multiple
 * PDFs and a multiple-PDF ZIP file will be associated with the report.
 */
@Component
public class GeneratePdf {
    private static final Logger logger = LoggerFactory.getLogger(GeneratePdf.class);

    private final ReportContentService reportContentService;
    private final ReportGenerationTemporaryStorage reportGenerationTemporaryStorage;
    private final ReportMergeService pdfMerger;
    private final ReportService reportService;

    @Autowired
    public GeneratePdf(final ReportContentService reportContentService,
                       final ReportGenerationTemporaryStorage reportGenerationTemporaryStorage,
                       final ReportMergeService pdfMerger,
                       final ReportService reportService) {
        this.reportContentService = reportContentService;
        this.reportGenerationTemporaryStorage = reportGenerationTemporaryStorage;
        this.pdfMerger = pdfMerger;
        this.reportService = reportService;
    }

    @StreamListener(ReportCollateIn)
    public void collateReportPdf(final ReportRequestMessage message) {
        logger.debug("Received report collation message for report: {}", message.getReportId());

        final UserReport report = reportService.findOneById(message.getReportId())
                .orElseThrow(() -> new IllegalArgumentException("Unknown UserReport ID: " + message.getReportId()));
        if (report.getStatus() == ReportStatus.FAILED) return;

        try {
            final List<Supplier<InputStream>> chunkPdfs = reportGenerationTemporaryStorage.getChunks(
                    report.getId(),
                    parseInt(report.getMetadata().get(FetchStudents.TotalChunk)));
            final MergedReport mergedReport = pdfMerger.mergePdfs(report, chunkPdfs);

            logger.debug("Merged UserReport: {}", message.getReportId());
            try (final FileInputStream pdfStream = new FileInputStream(mergedReport.getFile())) {
                //Store PDF contents
                final UserReport writtenReport = reportContentService.writeContent(
                        report,
                        pdfStream,
                        mergedReport.getFile().length(),
                        mergedReport.getMediaType());

                final UserReport completed = UserReport.builder()
                        .copy(writtenReport)
                        .status(ReportStatus.COMPLETED)
                        .build();
                reportService.update(completed);
            }

            if (!mergedReport.getFile().delete()) {
                logger.warn("Unable to remove temporary merged report PDF file: {}", mergedReport);
            }

            reportGenerationTemporaryStorage.cleanup(message.getReportId());
            logger.debug("UserReport: {} complete", message.getReportId());
        } catch (final IOException e) {
            throw new IllegalStateException("Unable to collate report: " + message.getReportId(), e);
        }
    }
}
