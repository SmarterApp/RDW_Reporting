package org.opentestsystem.rdw.reporting.processor.stream;

import org.opentestsystem.rdw.reporting.common.model.Report;
import org.opentestsystem.rdw.reporting.common.model.ReportStatus;
import org.opentestsystem.rdw.reporting.processor.model.ReportRequestMessage;
import org.opentestsystem.rdw.reporting.processor.service.PdfMergeService;
import org.opentestsystem.rdw.reporting.processor.service.ReportContentService;
import org.opentestsystem.rdw.reporting.processor.service.ReportGenerationTemporaryStorage;
import org.opentestsystem.rdw.reporting.processor.service.ReportService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.integration.annotation.ServiceActivator;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.function.Supplier;

import static org.opentestsystem.rdw.reporting.processor.stream.GenerateStudentsReportProcessor.ReportCollate;

/**
 * This component is responsible for generating a combined report PDF,
 * merging all of the report's PDF chunks into a single PDF.
 */
@Component
public class GeneratePdf {
    private static final Logger logger = LoggerFactory.getLogger(GeneratePdf.class);

    private final ReportContentService reportContentService;
    private final ReportGenerationTemporaryStorage reportGenerationTemporaryStorage;
    private final PdfMergeService pdfMerger;
    private final ReportService reportService;

    @Autowired
    public GeneratePdf(final ReportContentService reportContentService,
                       final ReportGenerationTemporaryStorage reportGenerationTemporaryStorage,
                       final PdfMergeService pdfMerger,
                       final ReportService reportService) {
        this.reportContentService = reportContentService;
        this.reportGenerationTemporaryStorage = reportGenerationTemporaryStorage;
        this.pdfMerger = pdfMerger;
        this.reportService = reportService;
    }

    @ServiceActivator(inputChannel = ReportCollate)
    public void collateReportPdf(final ReportRequestMessage message) {
        logger.debug("Received report collation message for report: {}", message.getReportId());
        final Report report = reportService.findOneById(message.getReportId())
                .orElseThrow(() -> new IllegalArgumentException("Unknown Report ID: " + message.getReportId()));
        if (report.getStatus() == ReportStatus.FAILED) return;

        try {
            final List<Supplier<InputStream>> chunkPdfs = reportGenerationTemporaryStorage.getChunks(report.getId(), report.getTotalChunkCount());
            final File mergedPdf = pdfMerger.mergePdfs(chunkPdfs);

            logger.debug("Merged Report: {}", message.getReportId());
            try (final FileInputStream pdfStream = new FileInputStream(mergedPdf)) {
                //Store PDF contents
                final Report writtenReport = reportContentService.writeContent(report, pdfStream, mergedPdf.length());

                if (!mergedPdf.delete()) {
                    logger.warn("Unable to remove temporary merged report PDF file: {}", mergedPdf);
                }

                final Report completed = Report.builder()
                        .copy(writtenReport)
                        .status(ReportStatus.COMPLETED)
                        .build();
                reportService.update(completed);

                reportGenerationTemporaryStorage.cleanup(message.getReportId());
                logger.debug("Report: {} complete", message.getReportId());
            }
        } catch (final IOException e) {
            throw new IllegalStateException("Unable to collate report: " + message.getReportId(), e);
        }
    }
}
