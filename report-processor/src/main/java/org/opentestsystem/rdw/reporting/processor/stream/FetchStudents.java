package org.opentestsystem.rdw.reporting.processor.stream;

import com.google.common.collect.Lists;
import com.google.common.collect.Ordering;
import org.opentestsystem.rdw.reporting.common.model.Report;
import org.opentestsystem.rdw.reporting.common.model.ReportStatus;
import org.opentestsystem.rdw.reporting.common.model.Student;
import org.opentestsystem.rdw.reporting.common.report.AbstractBatchExamReportRequest;
import org.opentestsystem.rdw.reporting.common.report.AbstractExamReportRequest;
import org.opentestsystem.rdw.reporting.common.report.ExamReportOrder;
import org.opentestsystem.rdw.reporting.common.report.UserPermissions;
import org.opentestsystem.rdw.reporting.processor.configuration.ReportGenerationProperties;
import org.opentestsystem.rdw.reporting.processor.model.ExamQueryParams;
import org.opentestsystem.rdw.reporting.processor.model.ProcessStudentChunkMessage;
import org.opentestsystem.rdw.reporting.processor.model.ReportRequestMessage;
import org.opentestsystem.rdw.reporting.processor.repository.StudentRepository;
import org.opentestsystem.rdw.reporting.processor.requesthandler.ExamQueryParamsParser;
import org.opentestsystem.rdw.reporting.processor.service.ReportService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.integration.annotation.ServiceActivator;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Set;

import static org.opentestsystem.rdw.reporting.processor.stream.FetchStudentsSource.ReportFetchStudents;

/**
 * This component is responsible for fetching, ordering,
 * and chunking students within the context of a report.
 */
@Component
public class FetchStudents {
    private final static Logger logger = LoggerFactory.getLogger(FetchStudents.class);

    private static final Ordering<Student> StudentSSIDOrdering = Ordering.natural()
            .onResultOf(Student::getSsid);

    private static final Ordering<Student> StudentNameOrdering = Ordering.natural()
            .onResultOf(student -> student.getLastName() + " " + student.getFirstName());

    private final Set<ExamQueryParamsParser> queryParamsParsers;
    private final StudentRepository studentRepository;
    private final ReportService reportService;
    private final ReportGenerationProperties reportGenerationProperties;
    private final FetchStudentsProcessor processor;

    @Autowired
    public FetchStudents(final Set<ExamQueryParamsParser> queryParamsParsers,
                         final StudentRepository studentRepository,
                         final ReportService reportService,
                         final ReportGenerationProperties reportGenerationProperties,
                         final FetchStudentsProcessor processor) {
        this.queryParamsParsers = queryParamsParsers;
        this.studentRepository = studentRepository;
        this.reportService = reportService;
        this.reportGenerationProperties = reportGenerationProperties;
        this.processor = processor;
    }

    @ServiceActivator(inputChannel = ReportFetchStudents)
    public void fetchAndPublishStudents(final ReportRequestMessage message) {
        logger.debug("Fetching students for report request: {}", message.getReportId());
        final UserPermissions userPermissions = message.getUserPermissions();
        final Report report = reportService.findOneById(message.getReportId())
                .orElseThrow(() -> new IllegalArgumentException("Unknown Report: " + message.getReportId()));
        if (report.getStatus() == ReportStatus.FAILED) return;

        //Find a registered ExamQueryParamsParser that can handle the request.
        final ExamQueryParamsParser parser = queryParamsParsers.stream()
                .filter(idFetcher -> idFetcher.accept(report.getReportRequest()))
                .findFirst()
                .orElseThrow(() -> new IllegalStateException("Unable to find ExamQueryParamsParser for Report: " + report.getId()));
        final ExamQueryParams queryParams = parser.parseQueryParams(report.getReportRequest());

        //Find the report's students
        final Collection<Student> students = studentRepository.findStudentsByExamQueryParams(
                userPermissions,
                queryParams);

        //Break the students into ordered chunks
        final List<Student> orderedStudents = getOrdering(report.getReportRequest()).sortedCopy(students);
        final List<List<Student>> chunks = Lists.partition(orderedStudents, reportGenerationProperties.getChunkSize());
        final Report updated = Report.builder()
                .copy(report)
                .totalChunkCount(chunks.size())
                .build();
        reportService.update(updated);

        for (int chunkIdx = 0; chunkIdx < chunks.size(); chunkIdx++) {
            publishProcessingMessage(userPermissions, message.getReportId(), chunkIdx, chunks.get(chunkIdx));
        }
        logger.debug("Dispatched chunks for processing: {}", message.getReportId());
    }

    private Ordering<Student> getOrdering(final AbstractExamReportRequest reportRequest) {
        ExamReportOrder order = null;
        if (reportRequest instanceof AbstractBatchExamReportRequest) {
            order = ((AbstractBatchExamReportRequest) reportRequest).getOrder();
        }
        if (order == null) {
            order = ExamReportOrder.STUDENT_NAME;
        }

        switch(order) {
            case STUDENT_SSID:
                return StudentSSIDOrdering;
            case STUDENT_NAME:
            default:
                return StudentNameOrdering;
        }
    }

    private void publishProcessingMessage(final UserPermissions userPermissions,
                                          final long reportId,
                                          final int chunkIdx,
                                          final List<Student> students) {
        final ProcessStudentChunkMessage payload = ProcessStudentChunkMessage.builder()
                .reportId(reportId)
                .userPermissions(userPermissions)
                .index(chunkIdx)
                .students(students)
                .build();
        final Message<ProcessStudentChunkMessage> message = MessageBuilder.createMessage(payload, new MessageHeaders(new HashMap<>()));
        processor.generateStudentReport().send(message);
    }
}
