package org.opentestsystem.rdw.reporting.processor.stream;

import com.google.common.collect.Lists;
import com.google.common.collect.Ordering;
import org.opentestsystem.rdw.reporting.common.model.AbstractBatchPrintableReportQuery;
import org.opentestsystem.rdw.reporting.common.model.PrintableReportOrder;
import org.opentestsystem.rdw.reporting.common.model.ReportQuery;
import org.opentestsystem.rdw.reporting.common.model.ReportStatus;
import org.opentestsystem.rdw.reporting.common.model.Student;
import org.opentestsystem.rdw.reporting.common.stream.MessageSecurityService;
import org.opentestsystem.rdw.reporting.common.security.User;
import org.opentestsystem.rdw.reporting.processor.configuration.ReportGenerationProperties;
import org.opentestsystem.rdw.reporting.processor.model.ExamQueryParams;
import org.opentestsystem.rdw.reporting.processor.model.ProcessStudentChunkMessage;
import org.opentestsystem.rdw.reporting.processor.model.ReportRequestMessage;
import org.opentestsystem.rdw.reporting.processor.model.UserReport;
import org.opentestsystem.rdw.reporting.processor.repository.StudentRepository;
import org.opentestsystem.rdw.reporting.processor.requesthandler.ExamQueryParamsParser;
import org.opentestsystem.rdw.reporting.processor.service.UserReportService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Set;

import static org.opentestsystem.rdw.reporting.common.model.PrintableReportOrder.StudentName;
import static org.opentestsystem.rdw.reporting.processor.stream.PdfReportProcessor.ReportFetchStudentsIn;

/**
 * This component is responsible for fetching, ordering,
 * and chunking students within the context of a report.
 */
@Component
public class FetchStudents {
    private final static Logger logger = LoggerFactory.getLogger(FetchStudents.class);

    public final static String TotalChunk = "total_chunk_count";
    public final static String CompletedChunk = "completed_chunk_count";

    private static final Ordering<Student> StudentSSIDOrdering = Ordering.natural()
            .onResultOf(Student::getSsid);

    private static final Ordering<Student> StudentNameOrdering = Ordering.natural()
            .onResultOf(student -> student.getLastName() + " " + student.getFirstName());

    private final Set<ExamQueryParamsParser> queryParamsParsers;
    private final StudentRepository studentRepository;
    private final UserReportService userReportService;
    private final ReportGenerationProperties reportGenerationProperties;
    private final PdfReportProcessor processor;
    private final MessageSecurityService messageSecurityService;

    @Autowired
    public FetchStudents(final Set<ExamQueryParamsParser> queryParamsParsers,
                         final StudentRepository studentRepository,
                         final UserReportService userReportService,
                         final ReportGenerationProperties reportGenerationProperties,
                         final PdfReportProcessor processor,
                         final MessageSecurityService messageSecurityService) {
        this.queryParamsParsers = queryParamsParsers;
        this.studentRepository = studentRepository;
        this.userReportService = userReportService;
        this.reportGenerationProperties = reportGenerationProperties;
        this.processor = processor;
        this.messageSecurityService = messageSecurityService;
    }

    @StreamListener(ReportFetchStudentsIn)
    public void fetchAndPublishStudents(final Message<ReportRequestMessage> message) {
        logger.debug("Fetching students for report request: {}", message.getPayload().getReportId());
        final User user = messageSecurityService.getUser(message);

        final UserReport report = userReportService.findOneById(message.getPayload().getReportId())
                .orElseThrow(() -> new IllegalArgumentException("Unknown UserReport: " + message.getPayload().getReportId()));
        if (report.getStatus() == ReportStatus.FAILED) return;

        //Find a registered ExamQueryParamsParser that can handle the request.
        final ExamQueryParamsParser parser = queryParamsParsers.stream()
                .filter(idFetcher -> idFetcher.accept(report.getQuery()))
                .findFirst()
                .orElseThrow(() -> new IllegalStateException("Unable to find ExamQueryParamsParser for UserReport: " + report.getId()));
        final ExamQueryParams queryParams = parser.parseQueryParams(report.getQuery());

        //Find the report's students
        final Collection<Student> students = studentRepository.findStudentsByExamQueryParams(
                user,
                queryParams);
        if (students.isEmpty()) {
            setNoContent(report);
            return;
        }

        //Break the students into ordered chunks
        final List<Student> orderedStudents = getOrdering(report.getQuery()).sortedCopy(students);
        final List<List<Student>> chunks = Lists.partition(orderedStudents, reportGenerationProperties.getChunkSize());
        final UserReport updated = UserReport.builder()
                .copy(report)
                .metadata(TotalChunk, String.valueOf(chunks.size()))
                .metadata(CompletedChunk, "0")
                .build();
        userReportService.update(updated);

        for (int chunkIdx = 0; chunkIdx < chunks.size(); chunkIdx++) {
            publishProcessingMessage(user, message.getPayload().getReportId(), chunkIdx, chunks.get(chunkIdx));
        }
        logger.debug("Dispatched chunks for processing: {}", message.getPayload().getReportId());
    }

    private Ordering<Student> getOrdering(final ReportQuery query) {
        final PrintableReportOrder order = query instanceof AbstractBatchPrintableReportQuery
                ? ((AbstractBatchPrintableReportQuery) query).getOrder()
                : StudentName;
        switch (order) {
            case StudentSSID:
                return StudentSSIDOrdering;
            case StudentName:
            default:
                return StudentNameOrdering;
        }
    }

    private void publishProcessingMessage(final User user,
                                          final long reportId,
                                          final int chunkIdx,
                                          final List<Student> students) {
        final ProcessStudentChunkMessage payload = ProcessStudentChunkMessage.builder()
                .reportId(reportId)
                .index(chunkIdx)
                .students(students)
                .build();
        final Message<ProcessStudentChunkMessage> message = messageSecurityService.withUser(
                MessageBuilder.createMessage(payload, new MessageHeaders(new HashMap<>())),
                user);
        processor.generateStudentReportOut().send(message);
    }

    private void setNoContent(final UserReport report) {
        userReportService.update(UserReport.builder()
                .copy(report)
                .status(ReportStatus.NO_RESULTS)
                .build());
    }
}
