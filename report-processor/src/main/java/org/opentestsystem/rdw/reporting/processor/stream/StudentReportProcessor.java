package org.opentestsystem.rdw.reporting.processor.stream;

import com.google.common.collect.ImmutableMap;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.common.model.Subject;
import org.opentestsystem.rdw.reporting.common.model.Exam;
import org.opentestsystem.rdw.reporting.common.model.PerformanceWritingExamItem;
import org.opentestsystem.rdw.reporting.common.model.ReportStatus;
import org.opentestsystem.rdw.reporting.common.model.Student;
import org.opentestsystem.rdw.reporting.common.stream.MessageSecurityService;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.opentestsystem.rdw.reporting.processor.model.AbstractExamReportRequest;
import org.opentestsystem.rdw.reporting.processor.model.ExamQueryParams;
import org.opentestsystem.rdw.reporting.processor.model.IabReport;
import org.opentestsystem.rdw.reporting.processor.model.IcaReport;
import org.opentestsystem.rdw.reporting.processor.model.PrintOptions;
import org.opentestsystem.rdw.reporting.processor.model.ProcessStudentChunkMessage;
import org.opentestsystem.rdw.reporting.processor.model.Report;
import org.opentestsystem.rdw.reporting.processor.model.ReportRequestMessage;
import org.opentestsystem.rdw.reporting.processor.model.StudentCompositeReport;
import org.opentestsystem.rdw.reporting.processor.repository.IabReportItemRepository;
import org.opentestsystem.rdw.reporting.processor.repository.IabReportRepository;
import org.opentestsystem.rdw.reporting.processor.repository.IcaReportRepository;
import org.opentestsystem.rdw.reporting.processor.requesthandler.ExamQueryParamsParser;
import org.opentestsystem.rdw.reporting.processor.service.HtmlToPdfProcessor;
import org.opentestsystem.rdw.reporting.processor.service.ReportGenerationTemporaryStorage;
import org.opentestsystem.rdw.reporting.processor.service.ReportService;
import org.opentestsystem.rdw.reporting.processor.service.ReportViewSupport;
import org.opentestsystem.rdw.reporting.processor.service.TemplateProcessor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.retry.RetryCallback;
import org.springframework.retry.support.RetryTemplate;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;
import static java.lang.Integer.parseInt;
import static org.opentestsystem.rdw.common.model.AssessmentType.IAB;
import static org.opentestsystem.rdw.common.model.AssessmentType.ICA;
import static org.opentestsystem.rdw.common.model.Subject.ELA;
import static org.opentestsystem.rdw.common.model.Subject.MATH;
import static org.opentestsystem.rdw.reporting.processor.stream.FetchStudents.CompletedChunk;
import static org.opentestsystem.rdw.reporting.processor.stream.FetchStudents.TotalChunk;
import static org.opentestsystem.rdw.reporting.processor.stream.PdfReportProcessor.ReportGenerateForStudentsIn;

/**
 * This writer is responsible for delegating to the appropriate ExamQueryParamsParser
 * for the Report's request, retrieving
 * the report data for the given student chunk, and writing the report into
 * temporary storage.
 * If this is the last chunk to be processed for a report, a report collation message
 * is published.
 */
@Component
public class StudentReportProcessor {
    private final static Logger logger = LoggerFactory.getLogger(StudentReportProcessor.class);
    private static Collection writingAssessment = newArrayList("WER");

    private final Set<ExamQueryParamsParser> queryParamsParsers;
    private final IabReportItemRepository iabReportItemRepository;
    private final IabReportRepository iabReportRepository;
    private final IcaReportRepository icaReportRepository;
    private final ReportService reportService;
    private final ReportGenerationTemporaryStorage temporaryStorage;
    private final ReportViewSupport support;
    private final TemplateProcessor templateProcessor;
    private final HtmlToPdfProcessor htmlToPdfProcessor;
    private final RetryTemplate retryTemplate;
    private final PdfReportProcessor processor;
    private final MessageSecurityService messageSecurityService;

    @Autowired
    public StudentReportProcessor(final Set<ExamQueryParamsParser> queryParamsParsers,
                                  final IabReportItemRepository iabReportItemRepository,
                                  final IabReportRepository iabReportRepository,
                                  final IcaReportRepository icaReportRepository,
                                  final ReportService reportService,
                                  final ReportGenerationTemporaryStorage temporaryStorage,
                                  final ReportViewSupport support,
                                  final TemplateProcessor templateProcessor,
                                  final HtmlToPdfProcessor htmlToPdfProcessor,
                                  final RetryTemplate retryTemplate,
                                  final PdfReportProcessor processor,
                                  final MessageSecurityService messageSecurityService) {
        this.queryParamsParsers = queryParamsParsers;
        this.iabReportItemRepository = iabReportItemRepository;
        this.iabReportRepository = iabReportRepository;
        this.icaReportRepository = icaReportRepository;
        this.reportService = reportService;
        this.temporaryStorage = temporaryStorage;
        this.support = support;
        this.templateProcessor = templateProcessor;
        this.htmlToPdfProcessor = htmlToPdfProcessor;
        this.retryTemplate = retryTemplate;
        this.processor = processor;
        this.messageSecurityService = messageSecurityService;
    }

    @StreamListener(ReportGenerateForStudentsIn)
    public void generateStudentChunkReport(final Message<ProcessStudentChunkMessage> message) {
        final ProcessStudentChunkMessage payload = message.getPayload();
        logger.debug("Received chunk report generation message for reportId: {} chunk: {}",
                payload.getReportId(),
                payload.getIndex());


        final Report report = reportService.findOneById(payload.getReportId())
                .orElseThrow(() -> new IllegalArgumentException("Unknown report: " + payload.getReportId()));
        if (report.getStatus() == ReportStatus.FAILED) return;

        final User user = messageSecurityService.getUser(message);

        final Map<Long, StudentCompositeReport> studentReports = payload.getStudents().stream()
                .collect(Collectors.toMap(
                        Student::getId,
                        student -> StudentCompositeReport.builder()
                                .student(student)
                                .build()
                ));

        final ExamQueryParams queryParams = getQueryParams(payload.getReportId(), report.getReportRequest());

        if (includeReports(IAB, queryParams)) {
            appendIABReports(studentReports, user, studentReports.keySet(), queryParams);
            appendWritingTraitScore(studentReports);
        }
        if (includeReports(ICA, queryParams)) {
            appendICAReports(studentReports, user, studentReports.keySet(), queryParams);
        }
        //TODO Append Summative Reports

        final List<StudentCompositeReport> orderedReports = payload.getStudents().stream()
                .map(student -> studentReports.get(student.getId()))
                .collect(Collectors.toList());

        logger.debug("Processing report: {} chunk: {} writing html", report.getId(), payload.getIndex());
        final byte[] html = writeReportHtml(orderedReports, report.getReportRequest());

        try {
            retryTemplate.execute((RetryCallback<Void, IOException>) retryContext -> {
                try (final InputStream pdfStream = htmlToPdfProcessor.process(html, (PrintOptions) report.getReportRequest().getOptions())) {
                    //Store chunk PDF contents
                    logger.debug("Processing report: {} chunk: {} writing pdf bytes", report.getId(), payload.getIndex());
                    temporaryStorage.writeChunk(payload.getReportId(), payload.getIndex(), pdfStream);
                }
                return null;
            }, retryContext -> {
                logger.warn("Unable to convert report chunk HTML to PDF report: {} chunk: {}",
                        report.getId(),
                        payload.getIndex(),
                        retryContext.getLastThrowable());
                throw new IllegalStateException("Unable to convert report chunk HTML to PDF");
            });

            logger.debug("Report: {} Chunk: {} complete", report.getId(), payload.getIndex());
        } catch (final IOException e) {
            throw new RuntimeException(
                    "Failed to generate report chunk. ReportId: " + payload.getReportId() +
                            " ChunkIdx: " + payload.getIndex(),
                    e);
        }

        final Report completed = reportService.completeChunk(report);
        final Map<String, String> metadata = completed.getMetadata();
        final int totalChunkCount = metadata.get(TotalChunk) == null
                ? 0
                : parseInt(completed.getMetadata().get(TotalChunk));
        final int completedChunkCount = metadata.get(CompletedChunk) == null
                ? 0
                : parseInt(metadata.get(CompletedChunk));
        if (completedChunkCount == totalChunkCount) {
            publishCollationMessage(completed, user);
            logger.debug("Report: {} all chunks complete", payload.getReportId());
        }
    }

    private void appendWritingTraitScore(final Map<Long, StudentCompositeReport> compositeReports) {
        final List<Long> examIds = new ArrayList<>();
        compositeReports.forEach((key, report) -> {
            report.getIabEla().getExamsByAssessment().forEach((assessment, exams) -> {
                // First exam is most recent
                Optional<Exam> exam = exams.stream().findFirst();
                if (exam.isPresent()) {
                    examIds.add(exam.get().getId());
                }
            });
        });

        List<PerformanceWritingExamItem> examItems = iabReportItemRepository.findWritingTraitExamItems(examIds);
        if (examItems.size() > 0) {
            compositeReports.forEach((key, report) -> {
                report.getIabEla().getExamsByAssessment().forEach((assessment, exams) -> {
                    // First exam is most recent
                    Optional<Exam> exam = exams.stream().findFirst();
                    if (exam.isPresent()) {
                        Optional<PerformanceWritingExamItem> examItem = examItems.stream().filter(examItem1 -> examItem1.getExamItem().getExamId() == exam.get().getId()).findFirst();
                        if (examItem.isPresent()) {
                            exam.get().setWritingTraitScores(examItem.get().getExamItem().getWritingTraitScores());
                            exam.get().setPerformanceWritingType(examItem.get().getPerformanceWritingType());
                        }
                    }
                });
            });
        }
    }

    private void appendIABReports(final Map<Long, StudentCompositeReport> compositeReports,
                                  final User user,
                                  final Collection<Long> studentIds,
                                  final ExamQueryParams examQueryParams) {
        final Map<Long, Map<Subject, IabReport>> iabReports = iabReportRepository
                .findAllForStudentsByExamFilter(
                        user,
                        studentIds,
                        examQueryParams);


        iabReports.forEach((key, value) -> compositeReports.computeIfPresent(key, (id, compositeReport) -> {
                    return StudentCompositeReport.builder()
                            .copy(compositeReport)
                            .iabEla(value.get(ELA))
                            .iabMath(value.get(MATH))
                            .build();
                }

        ));
    }

    private void appendICAReports(final Map<Long, StudentCompositeReport> compositeReports,
                                  final User user,
                                  final Collection<Long> studentIds,
                                  final ExamQueryParams examQueryParams) {
        final Map<Long, Map<Subject, IcaReport>> icaReports = icaReportRepository
                .findAllForStudentsByExamFilter(
                        user,
                        studentIds,
                        examQueryParams);

        icaReports.forEach((key, value) -> compositeReports.computeIfPresent(key, (id, compositeReport) -> StudentCompositeReport.builder()
                .copy(compositeReport)
                .icaEla(value.get(ELA))
                .icaMath(value.get(MATH))
                .build()
        ));
    }

    private byte[] writeReportHtml(final List<StudentCompositeReport> orderedReports,
                                   final AbstractExamReportRequest request) {
        final Map<String, Object> model = ImmutableMap.of(
                "studentCompositeReports", orderedReports,
                "request", request,
                "support", support);

        return templateProcessor.process(
                "batch-reports",
                model,
                request.getLanguage());
    }

    private ExamQueryParams getQueryParams(final long reportId, final AbstractExamReportRequest request) {
        //Find a registered ExamQueryParamsParser that can handle the request.
        final ExamQueryParamsParser parser = queryParamsParsers.stream()
                .filter(idFetcher -> idFetcher.accept(request))
                .findFirst()
                .orElseThrow(() -> new IllegalStateException("Unable to find ExamQueryParamsParser for Report: " + reportId));
        return parser.parseQueryParams(request);
    }

    private void publishCollationMessage(final Report report, final User user) {
        final ReportRequestMessage payload = ReportRequestMessage.builder()
                .reportId(report.getId())
                .build();
        final Message<ReportRequestMessage> message = messageSecurityService.withUser(
                MessageBuilder.createMessage(payload, new MessageHeaders(new HashMap<>())),
                user);
        processor.collateStudentReportsOut().send(message);
    }

    private boolean includeReports(final AssessmentType testType, final ExamQueryParams params) {
        return params.getAssessmentType() == null || params.getAssessmentType() == testType;
    }
}
