package org.opentestsystem.rdw.reporting.processor.stream;

import com.google.common.collect.ImmutableMap;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.common.model.Subject;
import org.opentestsystem.rdw.reporting.common.model.Student;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.opentestsystem.rdw.reporting.processor.model.AbstractExamReportRequest;
import org.opentestsystem.rdw.reporting.processor.model.ExamQueryParams;
import org.opentestsystem.rdw.reporting.processor.model.IabReport;
import org.opentestsystem.rdw.reporting.processor.model.IcaReport;
import org.opentestsystem.rdw.reporting.processor.model.PrintOptions;
import org.opentestsystem.rdw.reporting.processor.model.ProcessStudentChunkMessage;
import org.opentestsystem.rdw.reporting.processor.model.Report;
import org.opentestsystem.rdw.reporting.processor.model.ReportRequestMessage;
import org.opentestsystem.rdw.reporting.processor.model.ReportStatus;
import org.opentestsystem.rdw.reporting.processor.model.StudentCompositeReport;
import org.opentestsystem.rdw.reporting.processor.repository.IabReportRepository;
import org.opentestsystem.rdw.reporting.processor.repository.IcaReportRepository;
import org.opentestsystem.rdw.reporting.processor.requesthandler.ExamQueryParamsParser;
import org.opentestsystem.rdw.reporting.processor.service.HtmlToPdfProcessor;
import org.opentestsystem.rdw.reporting.processor.service.ReportGenerationTemporaryStorage;
import org.opentestsystem.rdw.reporting.processor.service.ReportService;
import org.opentestsystem.rdw.reporting.processor.service.ReportViewSupport;
import org.opentestsystem.rdw.reporting.processor.service.TemplateProcessor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.retry.RetryCallback;
import org.springframework.retry.support.RetryTemplate;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.io.InputStream;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import static org.opentestsystem.rdw.common.model.AssessmentType.IAB;
import static org.opentestsystem.rdw.common.model.AssessmentType.ICA;
import static org.opentestsystem.rdw.common.model.Subject.ELA;
import static org.opentestsystem.rdw.common.model.Subject.MATH;
import static org.opentestsystem.rdw.reporting.processor.stream.FetchStudentsProcessor.ReportGenerateForStudents;

/**
 * This writer is responsible for delegating to the appropriate ExamQueryParamsParser
 * for the Report's request, retrieving
 * the report data for the given student chunk, and writing the report into
 * temporary storage.
 * If this is the last chunk to be processed for a report, a report collation message
 * is published.
 */
@Component
public class StudentReportProcessor {
    private final static Logger logger = LoggerFactory.getLogger(StudentReportProcessor.class);

    private final Set<ExamQueryParamsParser> queryParamsParsers;
    private final IabReportRepository iabReportRepository;
    private final IcaReportRepository icaReportRepository;
    private final ReportService reportService;
    private final ReportGenerationTemporaryStorage temporaryStorage;
    private final ReportViewSupport support;
    private final TemplateProcessor templateProcessor;
    private final HtmlToPdfProcessor htmlToPdfProcessor;
    private final RetryTemplate retryTemplate;
    private final GenerateStudentsReportProcessor processor;

    @Autowired
    public StudentReportProcessor(final Set<ExamQueryParamsParser> queryParamsParsers,
                                  final IabReportRepository iabReportRepository,
                                  final IcaReportRepository icaReportRepository,
                                  final ReportService reportService,
                                  final ReportGenerationTemporaryStorage temporaryStorage,
                                  final ReportViewSupport support,
                                  final TemplateProcessor templateProcessor,
                                  final HtmlToPdfProcessor htmlToPdfProcessor,
                                  final RetryTemplate retryTemplate,
                                  final GenerateStudentsReportProcessor processor) {
        this.queryParamsParsers = queryParamsParsers;
        this.iabReportRepository = iabReportRepository;
        this.icaReportRepository = icaReportRepository;
        this.reportService = reportService;
        this.temporaryStorage = temporaryStorage;
        this.support = support;
        this.templateProcessor = templateProcessor;
        this.htmlToPdfProcessor = htmlToPdfProcessor;
        this.retryTemplate = retryTemplate;
        this.processor = processor;
    }

    @StreamListener(ReportGenerateForStudents)
    public void generateStudentChunkReport(final ProcessStudentChunkMessage message) {
        logger.debug("Received chunk report generation message for reportId: {} chunk: {}",
                message.getReportId(),
                message.getIndex());
        final Report report = reportService.findOneById(message.getReportId())
                .orElseThrow(() -> new IllegalArgumentException("Unknown report: " + message.getReportId()));
        if (report.getStatus() == ReportStatus.FAILED) return;

        final Map<Long, StudentCompositeReport> studentReports = message.getStudents().stream()
                .collect(Collectors.toMap(
                        Student::getId,
                        student -> StudentCompositeReport.builder()
                                .student(student)
                                .build()
                ));

        final ExamQueryParams queryParams = getQueryParams(message.getReportId(), report.getReportRequest());

        if (includeReports(IAB, queryParams)) {
            appendIABReports(studentReports, message.getUser(), studentReports.keySet(), queryParams);
        }
        if (includeReports(ICA, queryParams)) {
            appendICAReports(studentReports, message.getUser(), studentReports.keySet(), queryParams);
        }
        //TODO Append Summative Reports

        final List<StudentCompositeReport> orderedReports = message.getStudents().stream()
                .map(student -> studentReports.get(student.getId()))
                .collect(Collectors.toList());

        logger.debug("Processing report: {} chunk: {} writing html", report.getId(), message.getIndex());
        final byte[] html = writeReportHtml(orderedReports, report.getReportRequest());

        try {
            retryTemplate.execute((RetryCallback<Void, IOException>) retryContext -> {
                try (final InputStream pdfStream = htmlToPdfProcessor.process(html, (PrintOptions) report.getReportRequest().getOptions())) {
                    //Store chunk PDF contents
                    logger.debug("Processing report: {} chunk: {} writing pdf bytes", report.getId(), message.getIndex());
                    temporaryStorage.writeChunk(message.getReportId(), message.getIndex(), pdfStream);
                }
                return null;
            }, retryContext -> {
                logger.warn("Unable to convert report chunk HTML to PDF report: {} chunk: {}",
                        report.getId(),
                        message.getIndex(),
                        retryContext.getLastThrowable());
                throw new IllegalStateException("Unable to convert report chunk HTML to PDF");
            });

            logger.debug("Report: {} Chunk: {} complete", report.getId(), message.getIndex());
        } catch (final IOException e) {
            throw new RuntimeException(
                    "Failed to generate report chunk. ReportId: " + message.getReportId() +
                            " ChunkIdx: " + message.getIndex(),
                    e);
        }

        final Report completed = reportService.completeChunk(report);
        if (completed.getTotalChunkCount() == completed.getCompleteChunkCount()) {
            publishCollationMessage(completed);
            logger.debug("Report: {} all chunks complete", message.getReportId());
        }
    }

    private void appendIABReports(final Map<Long, StudentCompositeReport> compositeReports,
                                  final User user,
                                  final Collection<Long> studentIds,
                                  final ExamQueryParams examQueryParams) {
        final Map<Long, Map<Subject, IabReport>> iabReports = iabReportRepository
                .findAllForStudentsByExamFilter(
                        user,
                        studentIds,
                        examQueryParams);

        iabReports.forEach((key, value) -> compositeReports.computeIfPresent(key, (id, compositeReport) -> StudentCompositeReport.builder()
                .copy(compositeReport)
                .iabEla(value.get(ELA))
                .iabMath(value.get(MATH))
                .build()
        ));
    }

    private void appendICAReports(final Map<Long, StudentCompositeReport> compositeReports,
                                  final User user,
                                  final Collection<Long> studentIds,
                                  final ExamQueryParams examQueryParams) {
        final Map<Long, Map<Subject, IcaReport>> icaReports = icaReportRepository
                .findAllForStudentsByExamFilter(
                        user,
                        studentIds,
                        examQueryParams);

        icaReports.forEach((key, value) -> compositeReports.computeIfPresent(key, (id, compositeReport) -> StudentCompositeReport.builder()
                .copy(compositeReport)
                .icaEla(value.get(ELA))
                .icaMath(value.get(MATH))
                .build()
        ));
    }

    private byte[] writeReportHtml(final List<StudentCompositeReport> orderedReports,
                                   final AbstractExamReportRequest request) {
        final Map<String, Object> model = ImmutableMap.of(
                "studentCompositeReports", orderedReports,
                "request", request,
                "support", support);

        return templateProcessor.process(
                "batch-reports",
                model,
                request.getLanguage());
    }

    private ExamQueryParams getQueryParams(final long reportId, final AbstractExamReportRequest request) {
        //Find a registered ExamQueryParamsParser that can handle the request.
        final ExamQueryParamsParser parser = queryParamsParsers.stream()
                .filter(idFetcher -> idFetcher.accept(request))
                .findFirst()
                .orElseThrow(() -> new IllegalStateException("Unable to find ExamQueryParamsParser for Report: " + reportId));
        return parser.parseQueryParams(request);
    }

    private void publishCollationMessage(final Report report) {
        final ReportRequestMessage payload = ReportRequestMessage.builder()
                .reportId(report.getId())
                .build();
        final Message<ReportRequestMessage> message = MessageBuilder.createMessage(payload, new MessageHeaders(new HashMap<>()));
        processor.collateStudentReportsOutput().send(message);
    }

    private boolean includeReports(final AssessmentType testType, final ExamQueryParams params) {
        return params.getAssessmentType() == null || params.getAssessmentType() == testType;
    }
}
