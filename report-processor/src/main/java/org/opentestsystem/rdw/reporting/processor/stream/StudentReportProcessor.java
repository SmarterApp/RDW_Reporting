package org.opentestsystem.rdw.reporting.processor.stream;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Ordering;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.reporting.common.model.ReportStatus;
import org.opentestsystem.rdw.reporting.common.model.Student;
import org.opentestsystem.rdw.reporting.common.model.SubjectDefinition;
import org.opentestsystem.rdw.reporting.common.service.SubjectDefinitionService;
import org.opentestsystem.rdw.reporting.common.stream.MessageSecurityService;
import org.opentestsystem.rdw.reporting.common.web.security.User;
import org.opentestsystem.rdw.reporting.processor.model.*;
import org.opentestsystem.rdw.reporting.processor.model.UserReport;
import org.opentestsystem.rdw.reporting.processor.repository.IabReportRepository;
import org.opentestsystem.rdw.reporting.processor.repository.IcaSummativeReportRepository;
import org.opentestsystem.rdw.reporting.processor.repository.SubjectRepository;
import org.opentestsystem.rdw.reporting.processor.requesthandler.ExamQueryParamsParser;
import org.opentestsystem.rdw.reporting.processor.service.HtmlToPdfProcessor;
import org.opentestsystem.rdw.reporting.processor.service.ReportGenerationTemporaryStorage;
import org.opentestsystem.rdw.reporting.processor.service.ReportService;
import org.opentestsystem.rdw.reporting.processor.service.ReportViewSupport;
import org.opentestsystem.rdw.reporting.processor.service.TemplateProcessor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.retry.RetryCallback;
import org.springframework.retry.support.RetryTemplate;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.io.InputStream;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import static java.lang.Integer.parseInt;
import static org.opentestsystem.rdw.reporting.processor.stream.FetchStudents.CompletedChunk;
import static org.opentestsystem.rdw.reporting.processor.stream.FetchStudents.TotalChunk;
import static org.opentestsystem.rdw.reporting.processor.stream.PdfReportProcessor.ReportGenerateForStudentsIn;

/**
 * This writer is responsible for delegating to the appropriate ExamQueryParamsParser
 * for the UserReport's request, retrieving
 * the report data for the given student chunk, and writing the report into
 * temporary storage.
 * If this is the last chunk to be processed for a report, a report collation message
 * is published.
 */
@Component
public class StudentReportProcessor {
    private final static Logger logger = LoggerFactory.getLogger(StudentReportProcessor.class);

    private final Set<ExamQueryParamsParser> queryParamsParsers;
    private final IabReportRepository iabReportRepository;
    private final IcaSummativeReportRepository icaSummativeReportRepository;
    private final ReportService reportService;
    private final ReportGenerationTemporaryStorage temporaryStorage;
    private final ReportViewSupport support;
    private final TemplateProcessor templateProcessor;
    private final HtmlToPdfProcessor htmlToPdfProcessor;
    private final RetryTemplate retryTemplate;
    private final PdfReportProcessor processor;
    private final MessageSecurityService messageSecurityService;
    private final SubjectRepository subjectRepository;
    private final SubjectDefinitionService subjectDefinitionService;

    @Autowired
    public StudentReportProcessor(final Set<ExamQueryParamsParser> queryParamsParsers,
                                  final IabReportRepository iabReportRepository,
                                  final IcaSummativeReportRepository icaSummativeReportRepository,
                                  final ReportService reportService,
                                  final ReportGenerationTemporaryStorage temporaryStorage,
                                  final ReportViewSupport support,
                                  final TemplateProcessor templateProcessor,
                                  final HtmlToPdfProcessor htmlToPdfProcessor,
                                  final RetryTemplate retryTemplate,
                                  final PdfReportProcessor processor,
                                  final MessageSecurityService messageSecurityService,
                                  final SubjectRepository subjectRepository,
                                  final SubjectDefinitionService subjectDefinitionService) {
        this.queryParamsParsers = queryParamsParsers;
        this.iabReportRepository = iabReportRepository;
        this.icaSummativeReportRepository = icaSummativeReportRepository;
        this.reportService = reportService;
        this.temporaryStorage = temporaryStorage;
        this.support = support;
        this.templateProcessor = templateProcessor;
        this.htmlToPdfProcessor = htmlToPdfProcessor;
        this.retryTemplate = retryTemplate;
        this.processor = processor;
        this.messageSecurityService = messageSecurityService;
        this.subjectRepository = subjectRepository;
        this.subjectDefinitionService = subjectDefinitionService;
    }

    @StreamListener(ReportGenerateForStudentsIn)
    public void generateStudentChunkReport(final Message<ProcessStudentChunkMessage> message) {
        final ProcessStudentChunkMessage payload = message.getPayload();
        logger.debug("Received chunk report generation message for reportId: {} chunk: {}",
                payload.getReportId(),
                payload.getIndex());


        final UserReport report = reportService.findOneById(payload.getReportId())
                .orElseThrow(() -> new IllegalArgumentException("Unknown report: " + payload.getReportId()));
        if (report.getStatus() == ReportStatus.FAILED) return;

        final User user = messageSecurityService.getUser(message);

        final Map<Long, StudentCompositeReport> studentReports = payload.getStudents().stream()
                .collect(Collectors.toMap(
                        Student::getId,
                        student -> StudentCompositeReport.builder()
                                .student(student)
                                .build()
                ));

        final ExamQueryParams queryParams = getQueryParams(payload.getReportId(), report.getReportRequest());

        if (includeReports(AssessmentType.IAB.code(), queryParams)) {
            appendIABReports(studentReports, user, studentReports.keySet(), queryParams);
        }
        if (includeReports(AssessmentType.ICA.code(), queryParams)) {
            appendICAReports(studentReports, user, studentReports.keySet(), queryParams);
        }
        if (includeReports(AssessmentType.SUMMATIVE.code(), queryParams)) {
            appendSummativeReports(studentReports, user, studentReports.keySet(), queryParams);
        }

        final List<StudentCompositeReport> orderedReports = payload.getStudents().stream()
                .map(student -> studentReports.get(student.getId()))
                .collect(Collectors.toList());

        logger.debug("Processing report: {} chunk: {} writing html", report.getId(), payload.getIndex());
        final byte[] html = writeReportHtml(orderedReports, report.getReportRequest());

        try {
            retryTemplate.execute((RetryCallback<Void, IOException>) retryContext -> {
                try (final InputStream pdfStream = htmlToPdfProcessor.process(html)) {
                    //Store chunk PDF contents
                    logger.debug("Processing report: {} chunk: {} writing pdf bytes", report.getId(), payload.getIndex());
                    temporaryStorage.writeChunk(payload.getReportId(), payload.getIndex(), pdfStream);
                }
                return null;
            }, retryContext -> {
                logger.warn("Unable to convert report chunk HTML to PDF report: {} chunk: {}",
                        report.getId(),
                        payload.getIndex(),
                        retryContext.getLastThrowable());
                throw new IllegalStateException("Unable to convert report chunk HTML to PDF");
            });

            logger.debug("UserReport: {} Chunk: {} complete", report.getId(), payload.getIndex());
        } catch (final IOException e) {
            throw new RuntimeException(
                    "Failed to generate report chunk. ReportId: " + payload.getReportId() +
                            " ChunkIdx: " + payload.getIndex(),
                    e);
        }

        final UserReport completed = reportService.completeChunk(report);
        final Map<String, String> metadata = completed.getMetadata();
        final int totalChunkCount = metadata.get(TotalChunk) == null
                ? 0
                : parseInt(completed.getMetadata().get(TotalChunk));
        final int completedChunkCount = metadata.get(CompletedChunk) == null
                ? 0
                : parseInt(metadata.get(CompletedChunk));
        if (completedChunkCount == totalChunkCount) {
            publishCollationMessage(completed, user);
            logger.debug("UserReport: {} all chunks complete", payload.getReportId());
        }
    }


    private void appendIABReports(final Map<Long, StudentCompositeReport> compositeReports,
                                  final User user,
                                  final Collection<Long> studentIds,
                                  final ExamQueryParams examQueryParams) {
        final Map<Long, Collection<IabReport>> iabReports = iabReportRepository
                .findAllForStudentsByExamFilter(
                        user,
                        studentIds,
                        examQueryParams);


        iabReports.forEach((key, value) -> compositeReports.computeIfPresent(key, (id, compositeReport) -> StudentCompositeReport.builder()
                .copy(compositeReport)
                .addReports(getSubjectOrdering().sortedCopy(value.stream()
                        .map(report -> report.copy().subjectDefinition(getSubjectDefinition(report)).build())
                        .collect(Collectors.toList())))
                .build()
        ));
    }

    private void appendICAReports(final Map<Long, StudentCompositeReport> compositeReports,
                                  final User user,
                                  final Collection<Long> studentIds,
                                  final ExamQueryParams examQueryParams) {
        final ExamQueryParams icaQueryParams = ExamQueryParams.builder()
                .copy(examQueryParams)
                .assessmentTypeCode(AssessmentType.ICA.code())
                .build();

        final Map<Long, Collection<IcaSummativeReport>> icaReports = icaSummativeReportRepository
                .findAllForStudentsByExamFilter(
                        user,
                        studentIds,
                        icaQueryParams);

        icaReports.forEach((key, value) -> compositeReports.computeIfPresent(key, (id, compositeReport) -> StudentCompositeReport.builder()
                .copy(compositeReport)
                .addReports(getSubjectOrdering().sortedCopy(value.stream()
                        .map(report -> {
                            return report.copy().subjectDefinition(getSubjectDefinition(report)).build();
                        })
                        .collect(Collectors.toList())))
                .build()
        ));
    }

    private void appendSummativeReports(final Map<Long, StudentCompositeReport> compositeReports,
                                        final User user,
                                        final Collection<Long> studentIds,
                                        final ExamQueryParams examQueryParams) {
        final ExamQueryParams sumQueryParams = ExamQueryParams.builder()
                .copy(examQueryParams)
                .assessmentTypeCode(AssessmentType.SUMMATIVE.code())
                .build();

        final Map<Long, Collection<IcaSummativeReport>> summativeReports = icaSummativeReportRepository
                .findAllForStudentsByExamFilter(
                        user,
                        studentIds,
                        sumQueryParams);

        summativeReports.forEach((key, value) -> compositeReports.computeIfPresent(key, (id, compositeReport) -> StudentCompositeReport.builder()
                .copy(compositeReport)
                .addReports(getSubjectOrdering().sortedCopy(value.stream()
                        .map(report -> report.copy().subjectDefinition(getSubjectDefinition(report)).build())
                        .collect(Collectors.toList())))
                .build()
        ));
    }

    private byte[] writeReportHtml(final List<StudentCompositeReport> orderedReports,
                                   final AbstractExamReportRequest request) {
        final Map<String, Object> model = ImmutableMap.of(
                "studentCompositeReports", orderedReports,
                "request", request,
                "support", support);

        return templateProcessor.process(
                "batch-reports",
                model,
                request.getLanguage());
    }

    private ExamQueryParams getQueryParams(final long reportId, final AbstractExamReportRequest request) {
        //Find a registered ExamQueryParamsParser that can handle the request.
        final ExamQueryParamsParser parser = queryParamsParsers.stream()
                .filter(idFetcher -> idFetcher.accept(request))
                .findFirst()
                .orElseThrow(() -> new IllegalStateException("Unable to find ExamQueryParamsParser for UserReport: " + reportId));
        return parser.parseQueryParams(request);
    }

    private void publishCollationMessage(final UserReport report, final User user) {
        final ReportRequestMessage payload = ReportRequestMessage.builder()
                .reportId(report.getId())
                .build();
        final Message<ReportRequestMessage> message = messageSecurityService.withUser(
                MessageBuilder.createMessage(payload, new MessageHeaders(new HashMap<>())),
                user);
        processor.collateStudentReportsOut().send(message);
    }

    private boolean includeReports(final String testType, final ExamQueryParams params) {
        return params.getAssessmentTypeCode() == null || params.getAssessmentTypeCode().equals(testType);
    }

    private Ordering<AbstractExamReport> getSubjectOrdering() {
        return Ordering.explicit(subjectRepository.findAll())
                .onResultOf(AbstractExamReport::getSubject);
    }

    private SubjectDefinition getSubjectDefinition(final AbstractExamReport report) {
        return this.subjectDefinitionService.findAll().stream()
                .filter(definition -> definition.getSubjectCode().equals(report.getSubject())
                        && definition.getAsmtTypeCode().equals(report.getAssessmentType()))
                .findFirst()
                .orElseThrow(() -> new IllegalStateException("Cannot find subject definition for subject: " + report.getSubject() +
                        " assessment type: " + report.getAssessmentType()));
    }
}
