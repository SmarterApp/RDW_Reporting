package org.opentestsystem.rdw.reporting.processor.thymeleaf;

import org.apache.commons.io.IOUtils;
import org.opentestsystem.rdw.reporting.common.repository.ReportTemplateRepository;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.thymeleaf.IEngineConfiguration;
import org.thymeleaf.templateresolver.AbstractConfigurableTemplateResolver;
import org.thymeleaf.templateresource.ITemplateResource;
import org.thymeleaf.templateresource.StringTemplateResource;

import java.io.IOException;
import java.util.Map;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static java.nio.charset.StandardCharsets.UTF_8;

/**
 * A Thymeleaf template resolver that knows about dynamically configured templates.
 * <p>
 * It is expecting the template to be named using the pattern subject_asmttype, for
 * example "Math_sum". If it doesn't match that pattern, it will return null, passing
 * the request to the next resolver. If it matches that pattern but there isn't a
 * matching template available, it will return the default template. NOTE: there are
 * two default templates: it will look in the repository for a template named
 * "default.html" and there is an embedded default.html as the final fallback.
 * </p>
 * <p>
 * The knowledge of the template naming rules is used here, in the batch-reports.html
 * wrapper template, and in the DefaultTemplateService.
 * </p>
 * <p>
 * As a safety net for upgrades, the resolver will fallback to legacy report templates
 * if configured templates are not found for them. For the subjects "Math" and "ELA"
 * the appropriate embedded template, "iab-body.html", "ica-body.html", or "sum-body.html"
 * will be returned instead of "default.html".
 * </p>
 */
public class ReportTemplateResolver extends AbstractConfigurableTemplateResolver {
    public static final String DefaultTemplateName = "default.html";

    private static final Pattern templatePattern = Pattern.compile("(.*)_(iab|ica|sum)");

    private final ReportTemplateRepository repository;
    private final ResourceLoader resourceLoader;

    public ReportTemplateResolver(final ReportTemplateRepository repository,
                                  final ResourceLoader resourceLoader) {
        this.repository = repository;
        this.resourceLoader = resourceLoader;
        setSuffix(".html");
    }

    @Override
    protected ITemplateResource computeTemplateResource(final IEngineConfiguration configuration,
                                                        final String ownerTemplate,
                                                        final String template,
                                                        final String resourceName,
                                                        final String characterEncoding,
                                                        final Map<String, Object> templateResolutionAttributes) {
        // When this method is called, the "template" param will be whatever is generated
        // as the fragment templatename in the parent template, e.g. "Math_sum". Because
        // this resolver is configured to have an .html suffix, the resourceName will have
        // that appended, e.g. "Math_sum.html".

        // Sanity check: don't waste time looking up unknowable templates.
        // Removing this check would allow arbitrary fragment templates to be loaded.
        // This might be useful, although those templates would have to be manually
        // added to the template repository.
        final Matcher matcher = templatePattern.matcher(template);
        if (!matcher.matches()) return null;

        // load template contents from repository
        Optional<String> contents = repository.getAsString(resourceName);

        if (!contents.isPresent()) {
            contents = getLegacyContents(template);
            if (!contents.isPresent()) {
                contents = getDefaultContents();
            }
        }

        // when it gets here, contents will never be empty (but have to code for it)
        return contents.map(StringTemplateResource::new).orElse(null);
    }

    /**
     * Return the default contents. This checks for a configured template with the
     * name "default.html" (an undocumented feature) and returns its contents. If
     * that isn't found, it returns the contents of the embedded default template.
     *
     * @return default template contents, will never be empty
     */
    private Optional<String> getDefaultContents() {
        Optional<String> contents = repository.getAsString(DefaultTemplateName);
        if (!contents.isPresent()) {
            contents = getTemplatesResourceAsString(DefaultTemplateName);
        }
        return contents;
    }

    /**
     * Before configurable ISR templates, there were three hard-coded, embedded reports.
     * These were used for SmarterBalanced Math and ELA assessments. To make upgrades
     * less error-prone, this resolver will map the new template specification to these
     * legacy reports.
     *
     * @param template requested template, e.g. "Math_sum"
     * @return legacy report contents or empty if no match
     */
    private Optional<String> getLegacyContents(final String template) {
        final Matcher matcher = templatePattern.matcher(template);
        if (matcher.matches()) {
            final String subjectCode = matcher.group(1);
            if (subjectCode.equals("Math") || subjectCode.equals("ELA")) {
                final String asmtType = matcher.group(2);
                final String resourceName = asmtType + "-body.html";
                return getTemplatesResourceAsString(resourceName);
            }
        }
        return Optional.empty();
    }

    private Optional<String> getTemplatesResourceAsString(final String resourceName) {
        final Resource resource = resourceLoader.getResource("classpath:templates/" + resourceName);
        if (resource == null || !resource.exists()) {
            return Optional.empty();
        }

        try {
            return Optional.of(IOUtils.toString(resource.getInputStream(), UTF_8));
        } catch (IOException e) {
            // this should never happen so just propagate the exception
            throw new RuntimeException("Error loading default template", e);
        }
    }
}
