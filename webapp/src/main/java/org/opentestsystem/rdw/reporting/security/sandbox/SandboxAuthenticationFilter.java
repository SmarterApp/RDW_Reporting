package org.opentestsystem.rdw.reporting.security.sandbox;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;

import static org.apache.commons.lang.StringUtils.isBlank;

/**
 * Responsible for identifying requests that wish to login to a sandbox
 * <p>
 * This filter checks requests for specific parameters and then places a {@link SandboxAuthenticationToken}
 * in the {@link org.springframework.security.core.context.SecurityContext} if the request is for a sandbox
 */
public class SandboxAuthenticationFilter extends AbstractAuthenticationProcessingFilter {

    private static final String SandboxKeyParameter = "sandbox";
    private static final String SandboxUsernameParameter = "username";
    private static final String SandboxRoleParameter = "role";
    private static final String SandboxUserIdParameter = "userId";
    private static final String SandboxLockedParameter = "sandboxLocked";
    private final String logoutSuccessUrl;

    protected SandboxAuthenticationFilter(
            final String processingUrl,
            final String logoutSuccessUrl) {
        super(processingUrl);
        this.logoutSuccessUrl = logoutSuccessUrl;
    }

    @Override
    protected boolean requiresAuthentication(
            final HttpServletRequest request,
            final HttpServletResponse response) {

        // This will accept GET requests which is fine
        // because there are no credentials to protect
        return super.requiresAuthentication(request, response)
                && isValid(request);
    }

    @Override
    public Authentication attemptAuthentication(
            final HttpServletRequest request,
            final HttpServletResponse response) throws AuthenticationException {

        return this.getAuthenticationManager().authenticate(
                createAuthenticationRequestToken(request)
        );
    }

    private boolean isValid(final HttpServletRequest request) {
        return !isBlank(request.getParameter(SandboxKeyParameter))
                && !isBlank(request.getParameter(SandboxUsernameParameter))
                && !isBlank(request.getParameter(SandboxRoleParameter));
    }

    private SandboxAuthenticationToken createAuthenticationRequestToken(final HttpServletRequest request) {
        final String sandboxKey = request.getParameter(SandboxKeyParameter);
        final boolean sandboxLocked = Boolean.parseBoolean(request.getParameter(SandboxLockedParameter));
        return SandboxAuthenticationToken.builder()
                .sandboxKey(sandboxKey)
                .username(request.getParameter(SandboxUsernameParameter))
                .role(request.getParameter(SandboxRoleParameter))
                .userId(request.getParameter(SandboxUserIdParameter))
                .sessionRefreshUrl(getFullURL(request))
                .logoutSuccessUrl(createLogoutSuccessUrl(sandboxKey, sandboxLocked))
                .build();
    }

    private String createLogoutSuccessUrl(final String sandboxKey, final boolean sandboxLocked) {
        if (sandboxLocked) {
            try {
                return this.logoutSuccessUrl + "?sandbox=" + URLEncoder.encode(sandboxKey, "UTF-8");
            } catch (final UnsupportedEncodingException exception) {
                // ignore
            }
        }
        return this.logoutSuccessUrl;
    }

    private static String getFullURL(final HttpServletRequest request) {
        final String requestURL = request.getRequestURL().toString();
        final String queryString = request.getQueryString();
        return queryString != null
                ? requestURL + "?" + queryString
                : requestURL;
    }

}
