package org.opentestsystem.rdw.reporting.exam;

import com.google.common.io.ByteStreams;
import org.opentestsystem.rdw.reporting.assessment.artifact.ArtifactRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import javax.validation.constraints.NotNull;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import java.io.IOException;
import java.io.InputStream;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

// TODO: Implement authorization
@Service
public class DefaultExamItemService implements ExamItemService {

    private static final Logger logger = LoggerFactory.getLogger(DefaultExamItemService.class);
    private ArtifactRepository artifactRepository;

    private DocumentBuilder documentBuilder;
    private XPathExpression rubricListPath;
    private XPathExpression answerKeyPath;
    private XPathExpression rubricPath;
    private XPathExpression primarySampleListPath;
    private XPathExpression secondarySampleListPath;
    private XPathExpression namePath;
    private XPathExpression valuePath;
    private XPathExpression descriptionPath;
    private XPathExpression scorePointPath;
    private XPathExpression sampleContentPath;
    private XPathExpression formatPath;

    @Autowired
    public DefaultExamItemService(@NotNull final ArtifactRepository artifactRepository) throws XPathExpressionException, ParserConfigurationException {
        this.artifactRepository = artifactRepository;

        final DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
        documentBuilderFactory.setValidating(false);
        documentBuilderFactory.setIgnoringComments(false);
        documentBuilderFactory.setIgnoringElementContentWhitespace(true);
        documentBuilderFactory.setNamespaceAware(true);
        this.documentBuilder = documentBuilderFactory.newDocumentBuilder();

        final XPath xPath = XPathFactory.newInstance().newXPath();
        this.rubricListPath = xPath.compile("/itemrelease/item/content/rubriclist");
        this.answerKeyPath = xPath.compile("/itemrelease/item/attriblist/attrib[@attid=\"itm_att_Answer Key\"]");
        this.rubricPath = xPath.compile("./rubric");
        this.primarySampleListPath = xPath.compile("./samplelist");
        this.secondarySampleListPath = xPath.compile("./samplelist/sample");
        this.namePath = xPath.compile("./name");
        this.valuePath = xPath.compile("./val");
        this.descriptionPath = xPath.compile("./desc");
        this.scorePointPath = xPath.compile("./@scorepoint");
        this.sampleContentPath = xPath.compile("./samplecontent");
        this.formatPath = xPath.compile("/itemrelease/item/@format");
    }

    @Override
    public ExamItemScoringGuide getScoringGuide(final String itemNumber) {
        try {
            return getExamItemSolution(getXmlDocument(itemNumber), itemNumber);
        } catch (IOException exception) {
            final String message = "Error reading the item xml for item number: " + itemNumber;
            logger.warn(message, exception);
            throw new NoSuchElementException(message);
        } catch (SAXException exception) {
            final String message = "Error parsing the item xml for item number: " + itemNumber;
            logger.error(message, exception);
            throw new NoSuchElementException(message);
        }
    }

    private Document getXmlDocument(final String id) throws IOException, SAXException {
        final InputStream fileStream = artifactRepository.getItemXml(id);
        return documentBuilder.parse(fileStream);
    }

    private ExamItemScoringGuide getExamItemSolution(final Document document, final String id) {
        try {
            final Node rubricListNode = (Node) rubricListPath
                    .evaluate(document, XPathConstants.NODE);

            return ExamItemScoringGuide.builder()
                    .answerKey(getAnswerKey(document))
                    .rubrics(getRubrics(id, rubricListNode))
                    .exemplars(getExemplars(id, rubricListNode))
                    .build();

        } catch (XPathExpressionException exception) {
            // This exception is already pretty well guarded against in the helper methods,
            // it would be surprising if it happened here.
            logger.warn("Error while parsing item xml.", exception);
            throw new RuntimeException("Error parsing xml for id: " + id, exception);
        }
    }

    private AnswerKey getAnswerKey(final Document document) {
        try {
            if (!itemFormatIsValidToHaveAnswerKey(document)) {
                return null;
            }

            final Node answerKeyNode = (Node) answerKeyPath.evaluate(document, XPathConstants.NODE);

            if (answerKeyNode == null) {
                return null;
            }

            return AnswerKey.builder()
                    .name(getXmlValue(namePath, answerKeyNode))
                    .value(getXmlValue(valuePath, answerKeyNode))
                    .description(getXmlValue(descriptionPath, answerKeyNode))
                    .build();

        } catch (XPathExpressionException e) {
            // No answer key attribute found.
            return null;
        }
    }

    private boolean itemFormatIsValidToHaveAnswerKey(final Document document) {
        final String format = getXmlValue(formatPath, document).toUpperCase();
        return format.equals("EBSR") || format.equals("MS") || format.equals("MC");
    }

    private List<ScoringCriterion> getRubrics(final String id, final Node rubricListNode) {
        if (rubricListNode == null)
            return new ArrayList<>();

        try {
            final NodeList rubricNodes = (NodeList) rubricPath
                    .evaluate(rubricListNode, XPathConstants.NODESET);

            return IntStream
                    .range(0, rubricNodes.getLength())
                    .mapToObj(rubricNodes::item)
                    .map(node -> getRubric(node, id))
                    .collect(Collectors.toList());

        } catch (XPathExpressionException exception) {
            logger.warn("Item xml contained a rubriclist element but no rubrics for id: " + id, exception);
            return new ArrayList<>();
        }
    }

    private List<ScoringCriterion> getExemplars(final String id, final Node rubricListNode) {
        if (rubricListNode == null)
            return new ArrayList<>();

        NodeList sampleList;
        try {
            sampleList = (NodeList) primarySampleListPath
                    .evaluate(rubricListNode, XPathConstants.NODESET);

            if (sampleList == null || sampleList.getLength() == 0)
                return new ArrayList<>();

            NodeList sampleNodes = (NodeList) secondarySampleListPath
                    .evaluate(rubricListNode, XPathConstants.NODESET);

            return IntStream
                    .range(0, sampleNodes.getLength())
                    .mapToObj(sampleNodes::item)
                    .map(node -> getExemplar(node, id))
                    .collect(Collectors.toList());

        } catch (XPathExpressionException exception) {
            logger.warn("Item xml contained a samplelist element but no samples for id: " + id, exception);
            return new ArrayList<>();
        }
    }

    private ScoringCriterion getRubric(final Node node, final String id) {
        return ScoringCriterion.builder()
                .name(getXmlValue(namePath, node))
                .scorepoint(getXmlValue(scorePointPath, node))
                .template(encodeImages(getXmlValue(valuePath, node), id))
                .build();
    }

    private ScoringCriterion getExemplar(final Node node, final String id) {
        return ScoringCriterion.builder()
                .name(getXmlValue(namePath, node))
                .scorepoint(getXmlValue(scorePointPath, node))
                .template(encodeImages(getXmlValue(sampleContentPath, node), id))
                .build();
    }

    private String getXmlValue(final XPathExpression expression, final Node node) {
        try {
            final Node valueNode = (Node) expression.evaluate(node, XPathConstants.NODE);

            if (valueNode == null)
                return "";

            return valueNode.getNodeType() == Node.ATTRIBUTE_NODE
                    ? valueNode.getNodeValue()
                    : valueNode.getTextContent();
        } catch (XPathExpressionException e) {
            // This exception is already pretty well guarded against since we are checking if
            // the node exists before going to get the value.

            logger.warn("Error parsing xml expression: " + expression, e);
            return "";
        }
    }

    private String encodeImages(final String html, final String itemNumber) {
        final String imgRegex = "<img[^>]+src\\s*=\\s*['\"]([^'\"]+)['\"][^>]*>";
        String result = html;

        final Matcher matcher = Pattern.compile(imgRegex).matcher(html);

        while (matcher.find()) {
            String imageFileName = matcher.group(1);
            try {
                InputStream imageStream = artifactRepository.getArtifactFromItemDirectory(itemNumber, imageFileName);
                String encoding = Base64
                        .getEncoder()
                        .encodeToString(ByteStreams.toByteArray(imageStream));

                String mimeType = URLConnection.guessContentTypeFromName(imageFileName);
                result = result.replace(imageFileName, "data:" + mimeType + ";base64," + encoding);
            } catch (IOException e) {
                logger.warn("Unable to find referenced image({}) for item number: {}", imageFileName, itemNumber, e.getMessage());
            }

            matcher.end();
        }

        return result;
    }
}
