package org.opentestsystem.rdw.reporting.search.exam;

import com.google.common.collect.ImmutableMap;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.reporting.exam.Exam;
import org.opentestsystem.rdw.reporting.exam.ScaleScore;
import org.opentestsystem.rdw.reporting.exam.Student;
import org.opentestsystem.rdw.reporting.exam.StudentContext;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import javax.validation.constraints.NotNull;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static com.google.common.collect.Sets.newHashSet;
import static org.opentestsystem.rdw.reporting.jdbc.QueryUtils.getNullable;


public abstract class AbstractGroupExamRepository {

    private static final ClaimScaleScoreColumn[] CLAIM_SCALE_SCORE_COLUMNS = {
        new ClaimScaleScoreColumn("claim1_score_code", "claim1_category", "claim1_scale_score", "claim1_scale_score_std_err"),
        new ClaimScaleScoreColumn("claim2_score_code", "claim2_category", "claim2_scale_score", "claim2_scale_score_std_err"),
        new ClaimScaleScoreColumn("claim3_score_code", "claim3_category", "claim3_scale_score", "claim3_scale_score_std_err"),
        new ClaimScaleScoreColumn("claim4_score_code", "claim4_category", "claim4_scale_score", "claim4_scale_score_std_err")
    };

    protected final NamedParameterJdbcTemplate template;

    @Value("${sql.ethnicity.findAll}")
    private String findAllEthnicitiesQuery;

    @Value("${sql.ethnicity.findEthnicityIdsForStudentIds}")
    private String findEthnicityIdsForStudentIdsQuery;


    @Autowired
    public AbstractGroupExamRepository(@NotNull final NamedParameterJdbcTemplate template) {
        this.template = template;
    }

    protected List<Exam> findAllForAssessment(final String query, final Map<String, Object> parameters) {
        return template.query(query, parameters, this::buildExams);
    }

    private List<Exam> buildExams(final ResultSet row) throws SQLException {

        final List<Exam> exams = newArrayList();
        final List<Exam.Builder> examBuilders = newArrayList();
        final Set<Long> studentIds = newHashSet();

        while (row.next()) {

            final Integer scaleScoreLevel = getNullable(row, row.getInt("performance_level"));
            final ScaleScore scaleScore = scaleScoreLevel == null ? null : ScaleScore.builder()
                    .level(scaleScoreLevel)
                    .value(row.getInt("scale_score"))
                    .standardError(row.getDouble("scale_score_std_err"))
                    .build();

            final Exam.Builder examBuilder = Exam.builder()
                    .id(row.getLong("id"))
                    .sessionId(row.getString("session_id"))
                    .dateTime(row.getTimestamp("completed_at").toInstant())
                    .opportunity(row.getLong("opportunity"))
                    .completenessId(row.getInt("completeness_id"))
                    .administrativeConditionId(row.getInt("administration_condition_id"))
                    .scaleScore(scaleScore)
                    .studentContext(StudentContext.builder()
                            .schoolYear(row.getInt("school_year"))
                            .gradeId(row.getInt("grade_id"))
                            .iep(row.getBoolean("iep"))
                            .lep(row.getBoolean("lep"))
                            .section504(row.getBoolean("section504"))
                            .economicDisadvantage(row.getBoolean("economic_disadvantage"))
                            .migrantStatus(getNullable(row, row.getBoolean("migrant_status")))
                            .build()
                    );

            // Collects claim scores for ICA and Summative exams.
            // If a single claim is unscored a null entry will be put in the list to represent the unscored claim
            if (AssessmentType.valueOf(row.getInt("type_id")) != AssessmentType.IAB) {
                final List<ScaleScore> claimScaleScores = newArrayList();
                for (ClaimScaleScoreColumn colum : CLAIM_SCALE_SCORE_COLUMNS) {
                    final String claimCode = getNullable(row, row.getString(colum.code));
                    final ScaleScore claimScaleScore = claimCode == null ? null : ScaleScore.builder()
                            .level(row.getInt(colum.level))
                            .value(row.getInt(colum.value))
                            .standardError(row.getDouble(colum.standardError))
                            .build();

                    claimScaleScores.add(claimScaleScore);
                }
                examBuilder.claimScaleScores(Collections.unmodifiableList(claimScaleScores));
            }

            examBuilders.add(examBuilder);
            studentIds.add(row.getLong("student_id"));

        }

        final Map<Long, Set<String>> ethnicityCodesByStudentId = findEthnicityCodesForStudentIds(studentIds);

        row.beforeFirst();
        for (int i = 0; row.next(); i++) {
            final Exam.Builder examBuilder = examBuilders.get(i);
            final long studentId = row.getLong("student_id");
            final Set<String> ethnicityCodes = ethnicityCodesByStudentId.get(studentId);
            examBuilder.student(Student.builder()
                    .id(studentId)
                    .firstName(row.getString("student_first_name"))
                    .lastName(row.getString("student_last_name"))
                    .genderId(row.getLong("student_gender_id"))
                    .ethnicityCodes(ethnicityCodes)
                    .build()
            );
            exams.add(examBuilder.build());
        }

        return exams;
    }

    private Map<Long, Set<String>> findEthnicityCodesForStudentIds(final Collection<Long> studentIds) {
        if (studentIds == null || studentIds.isEmpty()) {
            return newHashMap();
        }
        final Map<Long, String> ethnicityCodesById = findAll();
        final Map<Long, Set<String>> ethnicityCodesByStudentId = newHashMap();
        template.query(
                findEthnicityIdsForStudentIdsQuery,
                new MapSqlParameterSource("student_ids", studentIds),
                row -> {
                    final long studentId = row.getLong("student_id");
                    final String ethnicityCode = ethnicityCodesById.get(row.getLong("ethnicity_id"));

                    final Set<String> studentEthnicityCodes = ethnicityCodesByStudentId.get(studentId);
                    if (studentEthnicityCodes == null) {
                        ethnicityCodesByStudentId.put(studentId, newHashSet(ethnicityCode));
                    } else {
                        studentEthnicityCodes.add(ethnicityCode);
                    }
                });
        return ethnicityCodesByStudentId;
    }

    // TODO: remove when ethnicity relationship table "student_ethnicity" is denormalized
    private Map<Long, String> findAll() {
        final ImmutableMap.Builder<Long, String> builder = ImmutableMap.builder();
        try {
            template.query(findAllEthnicitiesQuery, row -> {
                builder.put(row.getLong("id"), row.getString("code"));
            });
        } catch (EmptyResultDataAccessException ignored) {

        }
        return builder.build();
    }

    private static final class ClaimScaleScoreColumn {

        private final String code;
        private final String level;
        private final String value;
        private final String standardError;

        private ClaimScaleScoreColumn(
                final String code,
                final String level,
                final String value,
                final String standardError) {
            this.code = code;
            this.level = level;
            this.value = value;
            this.standardError = standardError;
        }

    }

}
