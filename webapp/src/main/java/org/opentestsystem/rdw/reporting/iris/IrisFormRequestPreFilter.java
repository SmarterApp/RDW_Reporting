package org.opentestsystem.rdw.reporting.iris;

import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.http.HttpServletRequestWrapper;
import com.netflix.zuul.http.ServletInputStreamWrapper;
import org.springframework.cloud.netflix.zuul.filters.pre.FormBodyWrapperFilter;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpOutputMessage;
import org.springframework.http.MediaType;
import org.springframework.http.converter.StringHttpMessageConverter;
import org.springframework.util.AntPathMatcher;
import org.springframework.util.Assert;
import org.springframework.util.ReflectionUtils;
import org.springframework.util.StringUtils;

import javax.servlet.ServletInputStream;
import javax.servlet.ServletRequest;
import javax.servlet.ServletRequestWrapper;
import javax.servlet.http.HttpServletRequest;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Field;
import java.util.HashSet;
import java.util.Set;

import static com.google.common.base.Charsets.UTF_8;
import static org.apache.commons.lang3.StringUtils.EMPTY;

/**
 * This class is mostly taken from {@link FormBodyWrapperFilter} which is responsible for
 * converting a client request with content-type MediaType.APPLICATION_FORM_URLENCODED or
 * MediaType.MULTIPART_FORM_DATA into a forwarded request to the proxied service. That
 * filter is disabled in this application and this one is replacing it to deal with IRiS.
 * <p>
 * This class is responsible for being aware that IRIS requests are malformed and, although
 * they advertise a content-type of MediaType.APPLICATION_FORM_URLENCODED, the content actually
 * consists of JSON.  This class re-interprets the form key of: {"items":[{"id":"I-xxx-xxxxx"}]}
 * with an empty-string value as a JSON payload and wraps the client request in a suitable
 * RequestWrapper.
 * </p>
 * <p>
 * Unfortunately FormBodyWrapperFilter isn't designed to be extended or overridden. So there is
 * a lot of duplication - probably means we're doing this the wrong way but ...
 * </p>
 */
public class IrisFormRequestPreFilter extends FormBodyWrapperFilter {

    private static final AntPathMatcher PathMatcher = new AntPathMatcher();
    private static final String IrisPathPattern = "/iris/**";

    private final Field requestField;
    private final Field servletRequestField;

    public IrisFormRequestPreFilter() {
        this.requestField = ReflectionUtils.findField(HttpServletRequestWrapper.class, "req", HttpServletRequest.class);
        this.servletRequestField = ReflectionUtils.findField(ServletRequestWrapper.class, "request", ServletRequest.class);
        Assert.notNull(this.requestField, "HttpServletRequestWrapper.req field not found");
        Assert.notNull(this.servletRequestField, "ServletRequestWrapper.request field not found");
        this.requestField.setAccessible(true);
        this.servletRequestField.setAccessible(true);
    }

    @Override
    public Object run() {
        final RequestContext context = RequestContext.getCurrentContext();
        final HttpServletRequest request = context.getRequest();
        final String contentType = request.getContentType();
        // we only care about POSTs to IRiS so punt to the base implementation for everything else
        if (contentType == null || !PathMatcher.match(IrisPathPattern, request.getRequestURI())) {
            return super.run();
        }

        // if the request has already been wrapped, then rewrap it with IRiS fixer-upper
        final IrisFormBodyRequestWrapper wrapper;
        if (request instanceof HttpServletRequestWrapper) {
            final HttpServletRequest wrapped = (HttpServletRequest) ReflectionUtils.getField(this.requestField, request);
            wrapper = new IrisFormBodyRequestWrapper(wrapped);
            ReflectionUtils.setField(this.requestField, request, wrapper);
            ReflectionUtils.setField(this.servletRequestField, request, wrapper);
        } else {
            wrapper = new IrisFormBodyRequestWrapper(request);
            context.setRequest(wrapper);
        }
        context.getZuulRequestHeaders().put("content-type", wrapper.getContentType());

        return null;
    }

    static class IrisFormBodyRequestWrapper extends HttpServletRequestWrapper {
        private static final StringHttpMessageConverter converter = new StringHttpMessageConverter(UTF_8);

        private final HttpServletRequest request;
        private byte[] contentData;
        private MediaType contentType;
        private int contentLength;

        IrisFormBodyRequestWrapper(final HttpServletRequest request) {
            super(request);
            this.request = request;
        }

        /**
         * There is an issue in zuul where HttpServletRequestWrapper.getRequest
         * returns a wrapped request rather than the raw one.
         *
         * @return the original HttpServletRequest
         */
        @Override
        public HttpServletRequest getRequest() {
            return this.request;
        }

        @Override
        public String getContentType() {
            if (this.contentData == null) {
                buildContentData();
            }
            return this.contentType.toString();
        }

        @Override
        public int getContentLength() {
            if (super.getContentLength() <= 0) {
                return super.getContentLength();
            }
            if (this.contentData == null) {
                buildContentData();
            }
            return this.contentLength;
        }

        public long getContentLengthLong() {
            return getContentLength();
        }

        @Override
        public ServletInputStream getInputStream() {
            if (this.contentData == null) {
                buildContentData();
            }
            return new ServletInputStreamWrapper(this.contentData);
        }

        private synchronized void buildContentData() {
            try {
                // this finds the query param that is really the item id json
                final Set<String> queryParams = findQueryParams(this.request.getQueryString());
                final String payload = request.getParameterMap().keySet().stream()
                        .filter(key -> !queryParams.contains(key))
                        .findFirst().orElse(EMPTY);

                final FormHttpOutputMessage data = new FormHttpOutputMessage();
                this.contentType = MediaType.valueOf(this.request.getContentType());
                data.getHeaders().setContentType(this.contentType);
                converter.write(payload, this.contentType, data);
                // copy new content type including multipart boundary
                this.contentType = data.getHeaders().getContentType();
                this.contentData = data.getInput();
                this.contentLength = this.contentData.length;
            }
            catch (final Exception e) {
                throw new IllegalStateException("Cannot convert json-as-form data", e);
            }
        }

        private static Set<String> findQueryParams(final String query) {
            final Set<String> result = new HashSet<>();
            if (query != null) {
                for (String value : StringUtils.tokenizeToStringArray(query, "&")) {
                    if (value.contains("=")) {
                        value = value.substring(0, value.indexOf("="));
                    }
                    result.add(value);
                }
            }
            return result;
        }

        private static class FormHttpOutputMessage implements HttpOutputMessage {
            private final HttpHeaders headers = new HttpHeaders();
            private final ByteArrayOutputStream output = new ByteArrayOutputStream();

            @Override
            public HttpHeaders getHeaders() {
                return this.headers;
            }

            @Override
            public OutputStream getBody() {
                return this.output;
            }

            public byte[] getInput() throws IOException {
                this.output.flush();
                return this.output.toByteArray();
            }
        }
    }
}
