package org.opentestsystem.rdw.reporting.report.client;

import com.google.common.base.Joiner;
import org.apache.commons.io.IOUtils;
import org.opentestsystem.rdw.reporting.common.model.Report;
import org.opentestsystem.rdw.reporting.common.report.BatchExamReportRequestHolder;
import org.opentestsystem.rdw.reporting.configuration.ApplicationProperties;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.client.ClientHttpResponse;
import org.springframework.stereotype.Service;
import org.springframework.web.client.ResponseExtractor;
import org.springframework.web.client.RestTemplate;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.stream.StreamSupport;


@Service
class DefaultReportWebServiceClient implements ReportWebServiceClient {

    private final ApplicationProperties.ReportServiceProperties reportProperties;
    private final RestTemplate template;

    @Autowired
    DefaultReportWebServiceClient(
            final ApplicationProperties applicationProperties,
            @Qualifier("pdfAcceptingRestTemplate") final RestTemplate template) {
        this.reportProperties = applicationProperties.getReportservice();
        this.template = template;
    }

    @Override
    public List<Report> getReports(final String userId) {
        final ResponseEntity<List<Report>> response = template.exchange(
                "{url}/api/reports?user={userId}", HttpMethod.GET, null,
                new ParameterizedTypeReference<List<Report>>() {}, reportProperties.getUrl(), userId);
        return checkSuccess(response).getBody();
    }

    @Override
    public List<Report> getReports(final String userId, final Iterable<Long> reportIds) {
        final String expandedReportIds = StreamSupport.stream(reportIds.spliterator(), false)
                .map(a -> "&id=" + a.toString()).reduce("", String::concat);
        final ResponseEntity<List<Report>> response = template.exchange(
                reportProperties.getUrl() + "/api/reports?user={userId}" + expandedReportIds, HttpMethod.GET, null,
                new ParameterizedTypeReference<List<Report>>() {}, userId);
        return checkSuccess(response).getBody();
    }

    @Override
    public void streamReport(final String userId, final long reportId, final HttpServletResponse response) {
        template.execute("{url}/api/reports/{reportId}/content?user={userId}",
                HttpMethod.GET, request -> {}, new StreamExtractor(response), reportProperties.getUrl(), reportId, userId);
    }

    @Override
    public Report createReport(final BatchExamReportRequestHolder request) {
        final ResponseEntity<Report> response = template.exchange(
                "{url}/api/reports", HttpMethod.POST, new HttpEntity<>(request), Report.class, reportProperties.getUrl());

        checkNotFound(response);
        return checkSuccess(response).getBody();
    }

    private <T> ResponseEntity<T> checkNotFound(final ResponseEntity<T> response) {
        if (response.getStatusCode() == HttpStatus.NOT_FOUND) {
            throw new NoSuchElementException("There were no test results matching the search criteria");
        }
        return response;
    }

    private <T> ResponseEntity<T> checkSuccess(final ResponseEntity<T> response) {
        if (!response.getStatusCode().is2xxSuccessful()) {
            throw new RuntimeException(String.format(
                    "The report service responded with an unsuccessful status: \"%s %s\"",
                    response.getStatusCode().value(), response.getBody()));
        }
        return response;
    }

    /**
     * Directly writes rest template response body to output stream to avoid reading it into memory before writing it
     */
    private class StreamExtractor implements ResponseExtractor<Void> {

        private final Joiner HEADER_VALUE_JOINER = Joiner.on(",");
        private final HttpServletResponse response;

        StreamExtractor(final HttpServletResponse response) {
            this.response = response;
        }

        @Override
        public Void extractData(final ClientHttpResponse response) throws IOException {
            for (final Map.Entry<String, List<String>> entry : response.getHeaders().entrySet()) {
                this.response.setHeader(entry.getKey(), HEADER_VALUE_JOINER.join(entry.getValue()));
            }
            if (!response.getStatusCode().is2xxSuccessful()) {
                throw new RuntimeException(String.format(
                        "The report service responded with an unsuccessful status: \"%s %s\"",
                        response.getStatusCode(), response.getStatusText()));
            }
            IOUtils.copy(response.getBody(), this.response.getOutputStream());
            return null;
        }

    }

}
