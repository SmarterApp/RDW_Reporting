package org.opentestsystem.rdw.reporting.security.saml;

import com.google.common.collect.Maps;
import org.apache.commons.lang.StringUtils;
import org.opentestsystem.rdw.multitenant.TenantContextHolder;
import org.opentestsystem.rdw.multitenant.TenantProperties;
import org.opentestsystem.rdw.reporting.common.security.User;
import org.opentestsystem.rdw.reporting.common.security.UserTenant;
import org.opentestsystem.rdw.reporting.security.authority.Authority;
import org.opentestsystem.rdw.reporting.security.authority.AuthorityService;
import org.opentestsystem.rdw.security.Permission;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.saml.SAMLCredential;
import org.springframework.security.saml.userdetails.SAMLUserDetailsService;
import org.springframework.stereotype.Service;

import javax.validation.constraints.NotNull;
import java.util.Set;

import static java.util.stream.Collectors.toSet;
import static org.apache.commons.lang3.StringUtils.isBlank;
import static org.apache.commons.lang3.StringUtils.isNotBlank;
import static org.opentestsystem.rdw.reporting.common.web.security.GrantedAuthorities.toGrantedAuthorities;

@Service
public class SamlUserDetailsService implements SAMLUserDetailsService {

    private static final Logger logger = LoggerFactory.getLogger(SamlUserDetailsService.class);
    private final AuthorityService authorityService;
    private final TenantProperties tenantProperties;

    @Value("${reporting.logout-redirect-url:}")
    private String logoutRedirectUrl;

    @Autowired
    public SamlUserDetailsService(
            @NotNull final AuthorityService authorityService,
            @NotNull final TenantProperties tenantProperties) {
        this.authorityService = authorityService;
        this.tenantProperties = tenantProperties;
    }

    public Object loadUserBySAML(final SAMLCredential credential) throws UsernameNotFoundException {

        final String id = credential.getAttributeAsString("sbacUUID");
        final String firstName = credential.getAttributeAsString("givenName");
        final String lastName = credential.getAttributeAsString("sn");
        final String email = credential.getAttributeAsString("mail");
        final String[] encodedGrants = credential.getAttributeAsStringArray("sbacTenancyChain");

        // Redirect URL used for Okta integration. If set, also assume we're not doing single logout.
        final String landingPage = isBlank(logoutRedirectUrl) ? "/landing" : logoutRedirectUrl;
        final String logoutUrl = "/saml/logout?local=" + isNotBlank(logoutRedirectUrl);

        // for SmarterBalanced SSO the user lookup value (aka username aka login) is configured to be "mail"
        final String username = email;

        // it may lead to confusion if the user's mail doesn't match their NameID
        // RDW doesn't directly care but log an info message to help diagnose issues in the field
        if (!username.equals(credential.getNameID().getValue())) {
            logger.info("User's login (mail:{}) does not match their name id (NameID:{})", username, credential.getNameID().getValue());
        }

        // the user must have reporting grants with a state so we can determine tenant id
        final Set<Authority> authorities = authorityService.getAuthorities(encodedGrants);

        final String stateId = authorities.stream()
                .map(Authority::getStateId)
                .filter(StringUtils::isNotBlank)
                .findFirst()
                .orElse(null);

        final String tenantName = stateId != null
                ? tenantProperties.getTenants().get(stateId).getName()
                : null;

        final User.Builder user = User.builderExt()
                .id(id)
                .firstName(firstName)
                .lastName(lastName)
                .email(email)
                .username(username)
                .tenant(
                        UserTenant.builder()
                                .id(stateId)
                                .name(tenantName)
                                .sandbox(false)
                                .logoutUrl(logoutUrl)
                                .logoutSuccessUrl(landingPage)
                                .build()
                )
                .password("[REDACTED]")
                .enabled(true)
                .credentialsNonExpired(true)
                .accountNonExpired(true)
                .accountNonLocked(true);

        // Secures the application by returning a user without any permissions, authorities, or groups.
        if (authorities.isEmpty()) {
            logger.warn("Grants do not permit access to tenant for user \"{}\"", username);
            return user.build();
        }

        // set tenant in thread local context during user info lookup
        try {
            TenantContextHolder.setTenantId(stateId);
            final Set<Permission> permissions = authorityService.getPermissions(authorities);

            user.permissionsById(Maps.uniqueIndex(permissions, Permission::getId))
                    .authorities(
                            toGrantedAuthorities(
                                    authorities.stream().map(Authority::getRole).collect(toSet()),
                                    permissions.stream().map(Permission::getId).collect(toSet())
                            )
                    );
        } finally {
            TenantContextHolder.clear();
        }
        return user.build();
    }

}
