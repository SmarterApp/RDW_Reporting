package org.opentestsystem.rdw.reporting.security.session;

import org.opensaml.ws.message.decoder.MessageDecodingException;
import org.opensaml.ws.message.encoder.MessageEncodingException;
import org.opensaml.xml.XMLObject;
import org.opensaml.xml.util.XMLHelper;
import org.springframework.security.saml.parser.SAMLBase;
import org.springframework.security.saml.util.SAMLUtil;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.StringReader;

/**
 * This class replaces the Spring SAML library {@link org.springframework.security.saml.parser.SAMLObject}
 * class to allow for serializing very large SAML response payloads.
 * (For example, users with more than 400 distinctly-granted rights.)
 */
public class LargeSamlObject<T extends XMLObject> extends SAMLBase<T, T> {

    /**
     * Default constructor.
     *
     * @param object object to wrap with serialization logic
     */
    public LargeSamlObject(final T object) {
        super(object);
    }

    @Override
    public T getObject() {
        if (object == null) { // Lazy parse
            parse();
        }
        return super.getObject();
    }

    /**
     * Custom serialization logic which transform XMLObject into String.
     *
     * @param out output stream
     * @throws java.io.IOException error performing XMLObject serialization
     */
    private void writeObject(final ObjectOutputStream out) throws IOException {
        try {
            if (serializedObject == null) {
                serializedObject = XMLHelper.nodeToString(SAMLUtil.marshallMessage(getObject()));
            }
            out.writeObject(serializedObject);
        } catch (final MessageEncodingException e) {
            log.error("Error serializing SAML object", e);
            throw new IOException("Error serializing SAML object: " + e.getMessage());
        }
    }

    /**
     * Deserializes XMLObject from the stream. Parsing of the content is done lazily upon access
     * to the object. The reason for this is the fact that parser pool may not be initialized during system startup
     * and the object may be stored in a serialized session.
     *
     * @param in input stream contaiing XMLObject as String
     * @throws IOException            error deserializing String to XMLObject
     * @throws ClassNotFoundException class not found
     */
    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {
        serializedObject = (String) in.readObject();
    }

    /**
     * Lazily parsers serialized data.
     */
    private void parse() {
        try {
            if (serializedObject != null) {
                object = unmarshallMessage(new StringReader((String) serializedObject));
            }
        } catch (final MessageDecodingException e) {
            log.error("Error de-serializing SAML object", e);
            throw new RuntimeException("Error de-serializing SAML object: " + e.getMessage());
        }
    }
}
