package org.opentestsystem.rdw.reporting.security.auth;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Multimap;
import com.google.common.collect.Multimaps;
import org.opentestsystem.rdw.reporting.common.security.GroupGrant;
import org.opentestsystem.rdw.reporting.common.security.Permission;
import org.opentestsystem.rdw.reporting.common.security.PermissionScope;
import org.opentestsystem.rdw.reporting.security.Authorities;
import org.opentestsystem.rdw.security.Grant;
import org.opentestsystem.rdw.security.service.PermissionService;
import org.opentestsystem.rdw.security.service.PermissionServiceException;
import org.opentestsystem.rdw.security.support.Grants;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.stereotype.Service;

import javax.validation.constraints.NotNull;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static com.google.common.collect.ImmutableSet.toImmutableSet;
import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static com.google.common.collect.Sets.newLinkedHashSet;
import static org.opentestsystem.rdw.reporting.common.security.ReportingRoles.GroupPiiRead;
import static org.opentestsystem.rdw.security.Grant.EntityLevel.DISTRICT;
import static org.opentestsystem.rdw.security.Grant.EntityLevel.INSTITUTION;
import static org.opentestsystem.rdw.security.Grant.EntityLevel.STATE;

@Service
public class DefaultAuthorizationService implements AuthorizationService {

    private final Logger logger = LoggerFactory.getLogger(getClass());
    private final String stateCode;
    private final PermissionService permissionService;
    private final DistrictRepository districtRepository;
    private final InstitutionRepository institutionRepository;
    private final GroupGrantRepository groupMembershipRepository;

    @Autowired
    public DefaultAuthorizationService(
            final @NotNull @Value("${app.state.code}") String stateCode,
            final @NotNull @Qualifier("cachingPermissionService") PermissionService permissionService,
            final @NotNull DistrictRepository districtRepository,
            final @NotNull InstitutionRepository institutionRepository,
            final @NotNull GroupGrantRepository groupMembershipRepository) {
        this.stateCode = stateCode;
        this.permissionService = permissionService;
        this.districtRepository = districtRepository;
        this.institutionRepository = institutionRepository;
        this.groupMembershipRepository = groupMembershipRepository;
    }

    @Override
    public Set<Grant> getGrants(final String[] encodedGrants) {
        final ImmutableSet.Builder<Grant> grants = ImmutableSet.builder();
        for (String encodedGrant : encodedGrants) {
            try {
                final Grant grant = Grants.from(encodedGrant);

                // Only add grants for the application's configured state
                if (stateCode.equals(grant.getStateId())) {
                    grants.add(grant);
                }
            } catch (final IllegalArgumentException exception) {

                // Ignore grants with unexpected entity levels or unexpected formatting
                logger.debug("invalid grant: {}", encodedGrant);
            }
        }
        return grants.build();
    }

    // A Grant is a role granted for a state or organization identified by its natural id.
    // A Permission is a permission and collection of organizations identified by their internal ids.
    // This method maps the grant roles to the associated permissions, collects and dedups the
    // organizations that share that permission, and resolves natural ids to internal ids.
    @Override
    public Set<Permission> getPermissions(final Collection<Grant> grants) {

        // Groups grants by role to later combine their districts and institutions into a single scope
        // This is to cover the case of multiple non-intersecting grants being given
        // (e.g. roleA,stateA,districtA and roleA,stateA,districtB)
        final Multimap<String, Grant> grantsByRole = Multimaps.index(grants, Grant::getRole);
        final Map<String, Collection<String>> permissionsByRole = getPermissionsByRole();

        // TODO: consider deferring lookup and resolution of organization IDs since statewide permission scope
        // can override other organization level scopes and make this lookup unnecessary

        // prepare natural ID to entity ID maps
        final Set<String> districtNaturalIds = newLinkedHashSet();
        final Set<String> institutionNaturalIds = newLinkedHashSet();
        for (Grant grant : grants) {
            if (grant.getEntityLevel() == DISTRICT) {
                districtNaturalIds.add(grant.getEntityId());
            } else if (grant.getEntityLevel() == INSTITUTION) {
                institutionNaturalIds.add(grant.getEntityId());
            }
        }
        final Map<String, Long> districtIdsByNaturalId = districtRepository.findAllIds(districtNaturalIds);
        final Map<String, Long> schoolIdsByNaturalId = institutionRepository.findAllIds(institutionNaturalIds);

        // Identify and store the permissions associated with the role
        final Map<String, PermissionScopeBuilder> permissionScopeBuildersByPermissionId = newHashMap();
        for (Map.Entry<String, Grant> entry : grantsByRole.entries()) {

            final Collection<String> permissionIds = permissionsByRole.get(entry.getKey());

            // The user may be granted roles that are not registered to this application in the permission configuration.
            // These roles should be ignored as they do not apply to our application
            if (permissionIds == null) continue;

            final Grant grant = entry.getValue();
            for (String permissionId : permissionIds) {

                final PermissionScopeBuilder permissionScopeBuilder = permissionScopeBuildersByPermissionId
                        .computeIfAbsent(permissionId, (key) -> new PermissionScopeBuilder());

                if (grant.getEntityLevel() == STATE) {
                    permissionScopeBuilder.statewide(true);
                } else if (grant.getEntityLevel() == DISTRICT) {
                    addDistrict(permissionScopeBuilder, grant.getEntityId(), districtIdsByNaturalId);
                } else if (grant.getEntityLevel() == INSTITUTION) {
                    addSchool(permissionScopeBuilder, grant.getEntityId(), schoolIdsByNaturalId);
                }
            }
        }

        return permissionScopeBuildersByPermissionId.entrySet().stream()
                // missing IDs in the natural ID to entity ID map can result in an invalid permission scope builder
                // that is neither statewide nor containing any schools and districts so this will filter those out
                .filter(entry -> entry.getValue().isValid())
                .map(entry -> new Permission(entry.getKey(), entry.getValue().build()))
                .collect(toImmutableSet());
    }

    @Override
    public Set<GrantedAuthority> getAuthorities(final Collection<Grant> grants) {
        final Map<String, Collection<String>> permissionsByRole = getPermissionsByRole();
        final ImmutableSet.Builder<GrantedAuthority> authorities = ImmutableSet.builder();
        for (Grant grant : grants) {
            if (permissionsByRole.containsKey(grant.getRole())) {
                authorities.add(Authorities.createRole(grant.getRole()));
                final Collection<String> permissionIds = permissionsByRole.get(grant.getRole());
                if (permissionIds != null) {
                    for (String permission : permissionIds) {
                        authorities.add(Authorities.createPermission(permission));
                    }
                }
            }
        }
        return authorities.build();
    }

    @Override
    public Set<GroupGrant> getGroups(final Collection<Permission> permissions, final String username) {
        // only lookup groups for those with the group PII permission
        if (permissions.stream().noneMatch(permission -> permission.getId().equals(GroupPiiRead))) {
            return ImmutableSet.of();
        }
        return ImmutableSet.copyOf(groupMembershipRepository.findAllForUsername(username));
    }

    private Map<String, Collection<String>> getPermissionsByRole() {
        try {
            return permissionService.getPermissionsByRole();
        } catch (PermissionServiceException exception) {
            throw new RuntimeException("Failed to get permissions", exception);
        }
    }

    private void addDistrict(final PermissionScopeBuilder builder, final String entityId, final Map<String, Long> idsByNaturalId) {
        final Long id = idsByNaturalId.get(entityId);
        if (id != null) {
            builder.addDistrictId(id);
        } else {
            logger.warn("grant district with natural ID \"{}\" not found", entityId);
        }
    }

    private void addSchool(final PermissionScopeBuilder builder, final String entityId, final Map<String, Long> idsByNaturalId) {
        final Long id = idsByNaturalId.get(entityId);
        if (id != null) {
            builder.addSchoolId(id);
        } else {
            logger.warn("grant school with natural ID \"{}\" not found", entityId);
        }
    }

    private static class PermissionScopeBuilder {

        private boolean statewide;
        private List<Long> districtIds;
        private List<Long> schoolIds;

        private PermissionScopeBuilder() {
        }

        public PermissionScopeBuilder statewide(final boolean statewide) {
            this.statewide = statewide;
            return this;
        }

        public PermissionScopeBuilder addDistrictId(final long id) {
            if (this.districtIds == null) {
                this.districtIds = newArrayList();
            }
            this.districtIds.add(id);
            return this;
        }

        public PermissionScopeBuilder addSchoolId(final long id) {
            if (this.schoolIds == null) {
                this.schoolIds = newArrayList();
            }
            this.schoolIds.add(id);
            return this;
        }

        /**
         * @return <code>true</code> if the permission scope is statewide or has any districts or schools
         */
        public boolean isValid() {
            return statewide
                    || (districtIds != null && !districtIds.isEmpty())
                    || (schoolIds != null && !schoolIds.isEmpty());
        }

        public PermissionScope build() {
            if (statewide) {
                return PermissionScope.STATEWIDE;
            }
            return new PermissionScope(districtIds, schoolIds);
        }

    }

}
