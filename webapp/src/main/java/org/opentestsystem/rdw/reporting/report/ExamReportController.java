package org.opentestsystem.rdw.reporting.report;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.DeserializationConfig;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.opentestsystem.rdw.reporting.common.model.Report;
import org.opentestsystem.rdw.reporting.common.report.GroupExamReportRequest;
import org.opentestsystem.rdw.reporting.common.report.SchoolGradeExamReportRequest;
import org.opentestsystem.rdw.reporting.security.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

import static com.fasterxml.jackson.databind.MapperFeature.USE_ANNOTATIONS;

@RestController
public class ExamReportController {

    private final ExamReportService service;
    private final ObjectMapper mapper;

    @Autowired
    ExamReportController(final ExamReportService service) {
        this.service = service;

        // Report service depends on the same classes {@link GroupExamReportRequest} {@link SchoolGradeExamReportRequest}
        // And needs Jackson annotations to work around polymorphism issues
        // This allows this controller to not require the @class encoded type info in the body of the objects when posted
        final ObjectMapper mapper = new ObjectMapper();
        mapper.configure(USE_ANNOTATIONS, false);
        this.mapper = mapper;
    }

    @GetMapping("/api/reports")
    public List<Report> getReports(@AuthenticationPrincipal final User user) {
        return service.getReports(user);
    }

    @GetMapping("/api/reports/{reportId}")
    public void getReport(
            @AuthenticationPrincipal final User user,
            @PathVariable final long reportId,
            final HttpServletResponse response) throws IOException {

        service.streamReport(user, reportId, response.getOutputStream());
    }

    @PostMapping("/api/schools/{schoolId}/assessmentGrades/{gradeId}/reports")
    @ResponseStatus(HttpStatus.CREATED)
    public Report createReport(
            @AuthenticationPrincipal final User user,
            @RequestBody final String requestBody) throws IOException {

        // TODO: move to argument resolver
        final SchoolGradeExamReportRequest request = mapper.reader()
                .forType(new TypeReference<SchoolGradeExamReportRequest>(){})
                .readValue(requestBody);

        return service.createReport(user, request);
    }

    @PostMapping("/api/groups/{groupId}/reports")
    @ResponseStatus(HttpStatus.CREATED)
    public Report createReport(
            @PathVariable long groupId,
            @AuthenticationPrincipal final User user,
            @RequestBody final String requestBody) throws IOException {

        final GroupExamReportRequest request = mapper.reader()
                .forType(new TypeReference<GroupExamReportRequest>(){})
                .readValue(requestBody);

        // TODO: move this to argument resolver
        // copies user's group grant into the request object
        final GroupExamReportRequest requestWithGroup = GroupExamReportRequest.builder()
                .groupGrant(user.getGroupsById().get(groupId))
                .schoolYear(request.getSchoolYear())
                .assessmentType(request.getAssessmentType())
                .subject(request.getSubject())
                .order(request.getOrder())
                .language(request.getLanguage())
                .options(request.getOptions())
                .build();

        return service.createReport(user, requestWithGroup);
    }

}
