package org.opentestsystem.rdw.reporting.report;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.opentestsystem.rdw.reporting.common.model.Report;
import org.opentestsystem.rdw.reporting.common.report.AbstractExamReportRequest;
import org.opentestsystem.rdw.reporting.common.report.GroupExamReportRequest;
import org.opentestsystem.rdw.reporting.common.report.SchoolGradeExamReportRequest;
import org.opentestsystem.rdw.reporting.security.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

import static com.fasterxml.jackson.databind.MapperFeature.USE_ANNOTATIONS;

@RestController
public class ExamReportController {

    private final ExamReportService service;
    private final AnnotationIgnoringObjectMapper mapper;

    @Autowired
    ExamReportController(final ExamReportService service) {
        this.service = service;
        this.mapper = new AnnotationIgnoringObjectMapper();
    }

    @GetMapping("/api/reports")
    public List<Report> getReports(@AuthenticationPrincipal final User user) {
        return service.getReports(user);
    }

    @GetMapping("/api/reports/{reportId}")
    public void getReport(
            @AuthenticationPrincipal final User user,
            @PathVariable final long reportId,
            final HttpServletResponse response) throws IOException {

        service.streamReport(user, reportId, response.getOutputStream());
    }

    @PostMapping("/api/schools/{schoolId}/assessmentGrades/{gradeId}/reports")
    @ResponseStatus(HttpStatus.CREATED)
    public Report createReport(
            @AuthenticationPrincipal final User user,
            @RequestBody final String requestBody) throws IOException {

        // TODO: move to argument resolver
        final SchoolGradeExamReportRequest request = mapper.readSchoolGradeRequest(requestBody);

        return service.createReport(user, request);
    }

    @PostMapping("/api/groups/{groupId}/reports")
    @ResponseStatus(HttpStatus.CREATED)
    public Report createReport(
            @PathVariable long groupId,
            @AuthenticationPrincipal final User user,
            @RequestBody final String requestBody) throws IOException {

        final GroupExamReportRequest request = mapper.readGroupRequest(requestBody);

        // TODO: move this to argument resolver
        // copies user's group grant into the request object
        final GroupExamReportRequest requestWithGroup = GroupExamReportRequest.builder()
                .groupGrant(user.getGroupsById().get(groupId))
                .schoolYear(request.getSchoolYear())
                .assessmentType(request.getAssessmentType())
                .subject(request.getSubject())
                .order(request.getOrder())
                .language(request.getLanguage())
                .options(request.getOptions())
                .build();

        return service.createReport(user, requestWithGroup);
    }

    /**
     * The Report Service also depends on the classes {@link GroupExamReportRequest} {@link SchoolGradeExamReportRequest}
     * which go through an endpoint that needs to know the qualified class name of the object to instantiate it.
     *
     * This was solved by adding @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property="@class")
     * to {@link AbstractExamReportRequest}
     *
     * However, that annotation forces the controller's default object mapper to expect @class property in the incoming JSON
     * and will throw an exception when it does not find it
     *
     * TODO: find a better solution
     */
    private static class AnnotationIgnoringObjectMapper extends ObjectMapper {

        private static final TypeReference<GroupExamReportRequest> GROUP_REQUEST_TYPE = new TypeReference<GroupExamReportRequest>() {};
        private static final TypeReference<SchoolGradeExamReportRequest> SCHOOL_GRADE_REQUEST_TYPE = new TypeReference<SchoolGradeExamReportRequest>() {};

        AnnotationIgnoringObjectMapper(){
            configure(USE_ANNOTATIONS, false);
        }

        GroupExamReportRequest readGroupRequest(final String body) throws IOException {
            return reader().forType(GROUP_REQUEST_TYPE).readValue(body);
        }

        SchoolGradeExamReportRequest readSchoolGradeRequest(final String body) throws IOException {
            return reader().forType(SCHOOL_GRADE_REQUEST_TYPE).readValue(body);
        }

    }

}
