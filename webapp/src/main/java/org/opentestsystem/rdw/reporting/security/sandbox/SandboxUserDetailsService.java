package org.opentestsystem.rdw.reporting.security.sandbox;

import com.google.common.collect.Maps;
import org.apache.commons.lang.StringUtils;
import org.opentestsystem.rdw.multitenant.TenantContextHolder;
import org.opentestsystem.rdw.reporting.common.sandbox.SandboxRole;
import org.opentestsystem.rdw.reporting.common.sandbox.SandboxRoleRepository;
import org.opentestsystem.rdw.reporting.common.security.ReportingPermission;
import org.opentestsystem.rdw.reporting.common.security.User;
import org.opentestsystem.rdw.reporting.common.security.UserTenant;
import org.opentestsystem.rdw.reporting.security.authority.Authority;
import org.opentestsystem.rdw.reporting.security.authority.AuthorityService;
import org.opentestsystem.rdw.security.Permission;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.userdetails.AuthenticationUserDetailsService;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UsernameNotFoundException;

import java.util.Map;
import java.util.Set;
import java.util.UUID;

import static java.util.stream.Collectors.toSet;
import static org.opentestsystem.rdw.reporting.common.web.security.GrantedAuthorities.toGrantedAuthorities;

class SandboxUserDetailsService implements AuthenticationUserDetailsService<SandboxAuthenticationToken> {

    private final AuthorityService authorityService;
    private final SandboxRoleRepository sandboxRoleRepository;
    private final SandboxUserGroupRepository groupRepository;

    SandboxUserDetailsService(
            final AuthorityService authorityService,
            final SandboxRoleRepository sandboxRoleRepository,
            final SandboxUserGroupRepository groupRepository) {
        this.authorityService = authorityService;
        this.sandboxRoleRepository = sandboxRoleRepository;
        this.groupRepository = groupRepository;
    }

    @Override
    public UserDetails loadUserDetails(final SandboxAuthenticationToken token) throws UsernameNotFoundException {

        // TODO allow way to log back in again with same key through extra param?
        final String usernameAndId = UUID.randomUUID().toString();

        final SandboxRole role = sandboxRoleRepository.findById(token.getRole());
        if (role == null) {
            throw new AccessDeniedException(String.format(
                    "Sandbox role \"%s\" not found",
                    token.getRole()
            ));
        }

        final Set<Authority> authorities = authorityService.getAuthorities(role);
        final String stateId = authorities.stream()
                .map(Authority::getStateId)
                .filter(StringUtils::isNotBlank)
                .findFirst()
                .orElse(null);

        TenantContextHolder.setTenantId(stateId);
        final Set<Permission> permissions = authorityService.getPermissions(authorities);
        TenantContextHolder.clear();

        final Map<String, Permission> permissionsById = Maps.uniqueIndex(permissions, Permission::getId);
        if (permissionsById.containsKey(ReportingPermission.GroupPiiRead)) {
            // This needs to match data generator output to correctly associate the assigned group
            final String conventionalGroupName = String.format(
                    "%s (%s)",
                    role.getOrganization().getName(),
                    role.getGradeCode()
            );
            groupRepository.create(
                    usernameAndId,
                    conventionalGroupName
            );
        }

        return User.builderExt()
                .tenant(
                        UserTenant.builder()
                                .id(token.getSandboxKey())
                                .sandbox(true)
                                .build()
                )
                .id(usernameAndId)
                .username(usernameAndId)
                .password("N/A")
                .firstName(token.getUsername().trim())
                .lastName("")
                .permissionsById(permissionsById)
                .enabled(true)
                .credentialsNonExpired(true)
                .accountNonExpired(true)
                .accountNonLocked(true)
                .authorities(
                        toGrantedAuthorities(
                                authorities.stream().map(Authority::getRole).collect(toSet()),
                                permissions.stream().map(Permission::getId).collect(toSet())
                        )
                )
                .build();
    }

}
