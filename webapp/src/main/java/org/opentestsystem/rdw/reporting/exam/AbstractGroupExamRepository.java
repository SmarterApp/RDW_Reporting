package org.opentestsystem.rdw.reporting.exam;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.common.model.Subject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import javax.validation.constraints.NotNull;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.MessageFormat;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static com.google.common.collect.Sets.newHashSet;
import static org.opentestsystem.rdw.reporting.jdbc.QueryUtils.getNullable;


public abstract class AbstractGroupExamRepository {

    protected final NamedParameterJdbcTemplate template;

    @Value("${sql.ethnicity.findAll}")
    private String findAllEthnicitiesQuery;

    @Value("${sql.ethnicity.findEthnicityIdsForStudentIds}")
    private String findEthnicityIdsForStudentIdsQuery;


    @Autowired
    public AbstractGroupExamRepository(@NotNull final NamedParameterJdbcTemplate template) {
        this.template = template;
    }

    protected GroupExam findLatest(final String query, final Map<String, Object> parameters) {
        try {
            return template.queryForObject(query, parameters, this::buildGroupExam);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
    }

    protected List<Assessment> findAllAssessments(final String query, final Map<String, Object> parameters) {
        return template.query(query, parameters, this::buildAssessment);
    }

    protected List<Exam> findAllForAssessment(final String query, final Map<String, Object> parameters) {
        return template.query(query, parameters, this::buildExams);
    }

    private GroupExam buildGroupExam(final ResultSet row, final int index) throws SQLException {
        return new GroupExam(
                buildAssessment(row, index),
                ImmutableList.of()
        );
    }

    private Assessment buildAssessment(final ResultSet row, final int index) throws SQLException {

        final AssessmentType type = AssessmentType.valueOf(row.getInt("type_id"));

        final Assessment.Builder builder = Assessment.builder()
                .id(row.getLong("id"))
                .name(row.getString("label"))
                .gradeId(row.getInt("grade_id"))
                .type(type)
                .subject(Subject.valueOf(row.getInt("subject_id")))
                .schoolYear(row.getInt("school_year"));


        if (type == AssessmentType.IAB) {
            builder.cutPoints(ImmutableList.of(
                    row.getLong("min_score"),
                    row.getLong("cut_point_2"),
                    row.getLong("max_score")
            ));
        } else {
            builder.cutPoints(ImmutableList.of(
                    row.getLong("min_score"),
                    row.getLong("cut_point_1"),
                    row.getLong("cut_point_2"),
                    row.getLong("cut_point_3"),
                    row.getLong("max_score")
            ));
        }

        return builder.build();
    }

    private List<Exam> buildExams(final ResultSet row) throws SQLException {

        final List<Exam> exams = newArrayList();
        final List<Exam.Builder> examBuilders = newArrayList();
        final Set<Long> studentIds = newHashSet();

        while (row.next()) {

            final AssessmentType type = AssessmentType.valueOf(row.getInt("type_id"));

            final Exam.Builder examBuilder = Exam.builder()
                    .id(row.getLong("id"))
                    .type(type)
                    .sessionId(row.getString("session_id"))
                    .dateTime(row.getTimestamp("completed_at").toInstant())
                    .opportunity(row.getLong("opportunity"))
                    .completenessId(row.getInt("completeness_id"))
                    .administrativeConditionId(row.getInt("administration_condition_id"))
                    .scaleScore(ScaleScore.builder()
                            .level(getNullable(row, row.getLong("performance_level")))
                            .value(getNullable(row, row.getLong("scale_score")))
                            .standardError(getNullable(row, row.getDouble("scale_score_std_err")))
                            .build()
                    )
                    .studentContext(StudentContext.builder()
                            .schoolYear(row.getInt("school_year"))
                            .gradeId(row.getInt("grade_id"))
                            .iep(row.getBoolean("iep"))
                            .lep(row.getBoolean("lep"))
                            .section504(row.getBoolean("section504"))
                            .economicDisadvantage(row.getBoolean("economic_disadvantage"))
                            .migrantStatus(getNullable(row, row.getBoolean("migrant_status")))
                            .build()
                    );
            //.student() set in post process

            if (type.hasClaims()) {
                final ImmutableList.Builder<ScaleScore> claimScaleScores = ImmutableList.builder();

                // MATH exams only have 3 claims, ELA have 4
                final int endIndex = row.getObject("claim4_category", Integer.class) != null ? 4 : 3;
                for (int i = 1; i <= endIndex; i++) {
                    claimScaleScores.add(ScaleScore.builder()
                            .level(getNullable(row, row.getLong(MessageFormat.format("claim{0}_category", i))))
                            .value(getNullable(row, row.getLong(MessageFormat.format("claim{0}_scale_score", i))))
                            .standardError(getNullable(row, row.getDouble(MessageFormat.format("claim{0}_scale_score_std_err", i))))
                            .build()
                    );
                }
                examBuilder.claimScaleScores(claimScaleScores.build());
            }

            examBuilders.add(examBuilder);
            studentIds.add(row.getLong("student_id"));

        }

        final Map<Long, Set<String>> ethnicityCodesByStudentId = findEthnicityCodesForStudentIds(studentIds);

        row.beforeFirst();
        for (int i = 0; row.next(); i++) {
            final Exam.Builder examBuilder = examBuilders.get(i);
            final long studentId = row.getLong("student_id");
            final Set<String> ethnicityCodes = ethnicityCodesByStudentId.get(studentId);
            examBuilder.student(Student.builder()
                    .id(studentId)
                    .firstName(row.getString("student_first_name"))
                    .lastName(row.getString("student_last_name"))
                    .genderId(row.getLong("student_gender_id"))
                    .ethnicityCodes(ethnicityCodes)
                    .build()
            );
            exams.add(examBuilder.build());
        }

        return exams;
    }

    private Map<Long, Set<String>> findEthnicityCodesForStudentIds(final Collection<Long> studentIds) {
        if (studentIds == null || studentIds.isEmpty()) {
            return newHashMap();
        }
        final Map<Long, String> ethnicityCodesById = findAll();
        final Map<Long, Set<String>> ethnicityCodesByStudentId = newHashMap();
        template.query(
                findEthnicityIdsForStudentIdsQuery,
                new MapSqlParameterSource("student_ids", studentIds),
                row -> {
                    final long studentId = row.getLong("student_id");
                    final String ethnicityCode = ethnicityCodesById.get(row.getLong("ethnicity_id"));

                    final Set<String> studentEthnicityCodes = ethnicityCodesByStudentId.get(studentId);
                    if (studentEthnicityCodes == null) {
                        ethnicityCodesByStudentId.put(studentId, newHashSet(ethnicityCode));
                    } else {
                        studentEthnicityCodes.add(ethnicityCode);
                    }
                });
        return ethnicityCodesByStudentId;
    }

    // TODO: remove when ethnicity relationship table "student_ethnicity" is denormalized
    private Map<Long, String> findAll() {
        final ImmutableMap.Builder<Long, String> builder = ImmutableMap.builder();
        try {
            template.query(findAllEthnicitiesQuery, row -> {
                builder.put(row.getLong("id"), row.getString("code"));
            });
        } catch (EmptyResultDataAccessException ignored) {

        }
        return builder.build();
    }

}
