package org.opentestsystem.rdw.reporting.service.impl;

import com.google.common.io.ByteStreams;
import org.opentestsystem.rdw.reporting.model.AnswerKey;
import org.opentestsystem.rdw.reporting.model.ExamItemScoringGuide;
import org.opentestsystem.rdw.reporting.model.ScoringCriterion;
import org.opentestsystem.rdw.reporting.repository.ArtifactRepository;
import org.opentestsystem.rdw.reporting.service.ExamItemService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import java.io.IOException;
import java.io.InputStream;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

// TODO: Implement authorization
@Service
public class DefaultExamItemService implements ExamItemService {

    private static final Logger logger = LoggerFactory.getLogger(DefaultExamItemService.class);
    private ArtifactRepository artifactRepository;

    @Autowired
    public DefaultExamItemService(final ArtifactRepository artifactRepository) {
        this.artifactRepository = artifactRepository;
    }

    @Override
    public ExamItemScoringGuide getScoringGuide(final String itemNumber) {
        try {
            final Document xmlDoc = getXmlDocument(itemNumber);

            final XPath xPath = XPathFactory
                    .newInstance()
                    .newXPath();

            return getExamItemSolution(xPath, xmlDoc, itemNumber);
        } catch (IOException e) {
            String message = "Error reading the item xml for item number: " + itemNumber;

            logger.warn(message, e);
            throw new NoSuchElementException(message);
        } catch (SAXException | ParserConfigurationException e) {
            String message = "Error parsing the item xml for item number: " + itemNumber;

            logger.error(message, e);
            throw new NoSuchElementException(message);
        }
    }

    private Document getXmlDocument(final String id) throws IOException, SAXException, ParserConfigurationException {
        final DocumentBuilderFactory builder = DocumentBuilderFactory.newInstance();
        builder.setValidating(false);
        builder.setIgnoringComments(false);
        builder.setIgnoringElementContentWhitespace(true);
        builder.setNamespaceAware(true);

        final InputStream fileStream = artifactRepository.getItemXml(id);
        return builder
                .newDocumentBuilder()
                .parse(fileStream);
    }

    private ExamItemScoringGuide getExamItemSolution(final XPath xPath, final Document xmlDoc, final String id) {
        try {
            final Node rubriclistNode = (Node) xPath
                    .compile("/itemrelease/item/content/rubriclist")
                    .evaluate(xmlDoc, XPathConstants.NODE);

            return ExamItemScoringGuide
                    .builder()
                    .answerKey(getAnswerKey(xPath, xmlDoc))
                    .rubrics(getRubrics(xPath, id, rubriclistNode))
                    .exemplars(getExemplars(xPath, id, rubriclistNode))
                    .build();

        } catch (XPathExpressionException e) {
            // This exception is already pretty well guarded against in the helper methods,
            // it would be surprising if it happened here.

            logger.warn("Error while parsing item xml.", e);
            throw new RuntimeException("Error parsing xml for id: " + id, e);
        }
    }

    private AnswerKey getAnswerKey(final XPath xPath, final Document xmlDoc) {
        try {
            if (!itemFormatIsValidToHaveAnswerKey(xPath, xmlDoc)) {
                return null;
            }

            final Node answerKeyNode = (Node) xPath
                    .compile("/itemrelease/item/attriblist/attrib[@attid=\"itm_att_Answer Key\"]")
                    .evaluate(xmlDoc, XPathConstants.NODE);

            if (answerKeyNode == null) {
                return null;
            }

            return AnswerKey
                    .builder()
                    .name(getXmlValue("./name", xPath, answerKeyNode))
                    .value(getXmlValue("./val", xPath, answerKeyNode))
                    .description(getXmlValue("./desc", xPath, answerKeyNode))
                    .build();
        } catch (XPathExpressionException e) {
            // No answer key attribute found.
            return null;
        }
    }

    private boolean itemFormatIsValidToHaveAnswerKey(final XPath xPath, final Document xmlDoc) {
        final String format = getXmlValue("/itemrelease/item/@format", xPath, xmlDoc).toUpperCase();
        return format.equals("EBSR") || format.equals("MS") || format.equals("MC");
    }

    private List<ScoringCriterion> getRubrics(final XPath xPath, final String id, final Node rubriclistNode) {
        if (rubriclistNode == null)
            return new ArrayList<>();

        try {
            final NodeList rubricNodes = (NodeList) xPath
                    .compile("./rubric")
                    .evaluate(rubriclistNode, XPathConstants.NODESET);

            return IntStream
                    .range(0, rubricNodes.getLength())
                    .mapToObj(rubricNodes::item)
                    .map(node -> getRubric(xPath, node, id))
                    .collect(Collectors.toList());

        } catch (XPathExpressionException e) {
            logger.warn("Item xml contained a rubriclist element but no rubrics for id: " + id, e);
            return new ArrayList<>();
        }
    }

    private List<ScoringCriterion> getExemplars(final XPath xPath, final String id, final Node rubriclistNode) {
        if (rubriclistNode == null)
            return new ArrayList<>();

        NodeList sampleList = null;
        try {
            sampleList = (NodeList) xPath
                    .compile("./samplelist")
                    .evaluate(rubriclistNode, XPathConstants.NODESET);

            if (sampleList == null || sampleList.getLength() == 0)
                return new ArrayList<>();

            NodeList sampleNodes = (NodeList) xPath
                    .compile("./samplelist/sample")
                    .evaluate(rubriclistNode, XPathConstants.NODESET);

            return IntStream
                    .range(0, sampleNodes.getLength())
                    .mapToObj(sampleNodes::item)
                    .map(node -> getExemplar(xPath, node, id))
                    .collect(Collectors.toList());
        } catch (XPathExpressionException e) {
            logger.warn("Item xml contained a samplelist element but no samples for id: " + id, e);
            return new ArrayList<>();
        }
    }

    private ScoringCriterion getRubric(final XPath xPath, final Node node, final String id) {
        return ScoringCriterion
                .builder()
                .name(getXmlValue("./name", xPath, node))
                .scorepoint(getXmlValue("./@scorepoint", xPath, node))
                .template(encodeImages(getXmlValue("./val", xPath, node), id))
                .build();
    }

    private ScoringCriterion getExemplar(final XPath xPath, final Node node, final String id) {
        return ScoringCriterion
                .builder()
                .name(getXmlValue("./name", xPath, node))
                .scorepoint(getXmlValue("./@scorepoint", xPath, node))
                .template(encodeImages(getXmlValue("./samplecontent", xPath, node), id))
                .build();
    }

    private String getXmlValue(final String expression, final XPath xPath, final Node node) {
        try {
            final Node valueNode = (Node) xPath
                    .compile(expression)
                    .evaluate(node, XPathConstants.NODE);

            if (valueNode == null)
                return "";

            return valueNode.getNodeType() == Node.ATTRIBUTE_NODE
                    ? valueNode.getNodeValue()
                    : valueNode.getTextContent();
        } catch (XPathExpressionException e) {
            // This exception is already pretty well guarded against since we are checking if
            // the node exists before going to get the value.

            logger.warn("Error parsing xml expression: " + expression, e);
            return "";
        }
    }

    private String encodeImages(final String html, final String itemNumber) {
        final String imgRegex = "<img[^>]+src\\s*=\\s*['\"]([^'\"]+)['\"][^>]*>";
        String result = html;

        final Matcher matcher = Pattern.compile(imgRegex).matcher(html);

        while (matcher.find()) {
            String imageFileName = matcher.group(1);
            try {
                InputStream imageStream = artifactRepository.getArtifactFromItemDirectory(itemNumber, imageFileName);
                String encoding = Base64
                        .getEncoder()
                        .encodeToString(ByteStreams.toByteArray(imageStream));

                String mimeType = URLConnection.guessContentTypeFromName(imageFileName);
                result = result.replace(imageFileName, "data:" + mimeType + ";base64," + encoding);
            } catch (IOException e) {
                logger.warn("Unable to find referenced image({}) for item number: {}", imageFileName, itemNumber, e.getMessage());
            }

            matcher.end();
        }

        return result;
    }
}
