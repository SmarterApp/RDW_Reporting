package org.opentestsystem.rdw.reporting.security.authority;

import com.google.common.collect.Multimap;
import com.google.common.collect.Multimaps;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import org.opentestsystem.rdw.multitenant.TenantProperties;
import org.opentestsystem.rdw.reporting.common.security.ReportingPermission;
import org.opentestsystem.rdw.reporting.common.security.ReportingRole;
import org.opentestsystem.rdw.reporting.sandbox.SandboxRole;
import org.opentestsystem.rdw.security.Permission;
import org.opentestsystem.rdw.security.PermissionScope;
import org.opentestsystem.rdw.security.repository.OrganizationRepository;
import org.opentestsystem.rdw.security.service.PermissionService;
import org.opentestsystem.rdw.security.service.PermissionServiceException;
import org.opentestsystem.rdw.utils.Grant;

import static com.google.common.collect.Maps.newHashMap;
import static com.google.common.collect.Sets.newHashSet;
import static java.util.Collections.emptySet;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toSet;
import static org.apache.commons.lang.StringUtils.isBlank;
import static org.opentestsystem.rdw.reporting.common.security.ReportingRole.ReportingRoles;
import static org.opentestsystem.rdw.reporting.security.authority.Authorities.toAuthority;
import static org.opentestsystem.rdw.utils.Grant.Level.CLIENT;
import static org.opentestsystem.rdw.utils.Grant.Level.DISTRICT;
import static org.opentestsystem.rdw.utils.Grant.Level.DISTRICT_GROUP;
import static org.opentestsystem.rdw.utils.Grant.Level.INSTITUTION;
import static org.opentestsystem.rdw.utils.Grant.Level.INSTITUTION_GROUP;

@Service
class DefaultAuthorityService implements AuthorityService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultAuthorityService.class);

    private final TenantProperties tenantProperties;
    private final PermissionService permissionService;
    private final OrganizationRepository organizationRepository;

    @Autowired
    DefaultAuthorityService(
            final TenantProperties tenantProperties,
            final @Qualifier("cachingPermissionService") PermissionService permissionService,
            final OrganizationRepository organizationRepository) {
        this.tenantProperties = tenantProperties;
        this.permissionService = permissionService;
        this.organizationRepository = organizationRepository;
    }

    @Override
    public Set<Authority> getAuthorities(final SandboxRole role) {
        final String organizationId = role.getOrganization().getNaturalId();
        switch (role.getType()) {
            case DistrictAdministrator:
                return createAuthorities(
                        organizationId,
                        DISTRICT,
                        ReportingRole.SandboxDistrictAdmin
                );
            case SchoolAdministrator:
                return createAuthorities(
                        organizationId,
                        INSTITUTION,
                        ReportingRole.SandboxSchoolAdmin
                );
            case Teacher:
                return createAuthorities(
                        organizationId,
                        INSTITUTION,
                        ReportingRole.SandboxTeacher
                );
        }
        return emptySet();
    }

    @Override
    public Set<Authority> getAuthorities(final String[] encodedGrants) {

        final List<Authority> authorities = Arrays.stream(encodedGrants)
                // convert to grants
                .map(DefaultAuthorityService::toGrant)
                // remove invalid grants that failed conversion
                .filter(Optional::isPresent)
                // convert to authorities
                .map(grant -> toAuthority(grant.get()))
                // the system is only concerned with roles that are a part of this system
                .filter(authority -> ReportingRoles.contains(authority.getRole()))
                .collect(toList());

        // Get the first valid tenant/state ID
        final Optional<String> firstTenantId = authorities.stream()
                .map(Authority::getStateId)
                // only count state IDs for which there are configured tenants
                .filter(stateId ->
                        !isBlank(stateId)
                                && tenantProperties.findTenantById(stateId).isPresent()
                )
                .findFirst();

        return authorities.stream()
                // keep the authority if it is at the client level
                // OR if it matches the first tenant ID found
                .filter(authority ->
                        authority.getLevel() == CLIENT
                                || (
                                firstTenantId.isPresent()
                                        && firstTenantId.get().equals(authority.getStateId())

                        )
                ).collect(toSet());
    }

    // A Grant is a role granted for a state or organization identified by its natural id.
    // A Permission is a permission and collection of organizations identified by their internal ids.
    // This method maps the grant roles to the associated permissions, collects and dedups the
    // organizations that share that permission, and resolves natural ids to internal ids.
    @Override
    public Set<Permission> getPermissions(final Collection<Authority> authorities) {

        // Groups grants by role to later combine their districts and institutions into a single scope
        // This is to cover the case of multiple non-intersecting grants being given
        // (e.g. roleA,stateA,districtA and roleA,stateA,districtB)
        final Multimap<String, Authority> authoritiesByRole = Multimaps.index(authorities, Authority::getRole);
        final Map<String, Collection<String>> permissionsByRole = getPermissionsByRole();

        final Map<String, Long> districtGroupIdsByNaturalId = organizationRepository.findAllDistrictGroupIds(authorities.stream()
                .filter(grant -> grant.getLevel() == DISTRICT_GROUP)
                .map(Authority::getEntityId).collect(toSet()));
        final Map<String, Long> districtIdsByNaturalId = organizationRepository.findAllDistrictIds(authorities.stream()
                .filter(grant -> grant.getLevel() == DISTRICT)
                .map(Authority::getEntityId).collect(toSet()));
        final Map<String, Long> schoolGroupIdsByNaturalId = organizationRepository.findAllSchoolGroupIds(authorities.stream()
                .filter(grant -> grant.getLevel() == INSTITUTION_GROUP)
                .map(Authority::getEntityId).collect(toSet()));
        final Map<String, Long> schoolIdsByNaturalId = organizationRepository.findAllSchoolIds(authorities.stream()
                .filter(grant -> grant.getLevel() == INSTITUTION)
                .map(Authority::getEntityId).collect(toSet()));

        // Identify and store the permissions associated with the role
        final Map<String, PermissionScope.Builder> permissionScopeBuildersByPermissionId = newHashMap();
        for (Map.Entry<String, Authority> entry : authoritiesByRole.entries()) {

            final Collection<String> permissionIds = permissionsByRole.get(entry.getKey());

            // The user may be granted roles that are not registered to this application in the permission configuration.
            // These roles should be ignored as they do not apply to our application
            if (permissionIds == null) continue;

            final Authority authority = entry.getValue();
            for (final String permissionId : permissionIds) {
                final PermissionScope.Builder permissionScopeBuilder = permissionScopeBuildersByPermissionId
                        .computeIfAbsent(permissionId, (key) -> PermissionScope.builder());

                switch (authority.getLevel()) {
                    case CLIENT:
                    case STATE_GROUP:
                    case STATE:
                        permissionScopeBuilder.statewide(true);
                        break;
                    case DISTRICT_GROUP:
                        addDistrictGroup(permissionScopeBuilder, authority.getEntityId(), districtGroupIdsByNaturalId);
                        break;
                    case DISTRICT:
                        addDistrict(permissionScopeBuilder, authority.getEntityId(), districtIdsByNaturalId);
                        break;
                    case INSTITUTION_GROUP:
                        addSchoolGroup(permissionScopeBuilder, authority.getEntityId(), schoolGroupIdsByNaturalId);
                        break;
                    case INSTITUTION:
                        addSchool(permissionScopeBuilder, authority.getEntityId(), schoolIdsByNaturalId);
                        break;
                    default:
                        break;
                }
            }
        }

        final Set<Permission> permissions = permissionScopeBuildersByPermissionId.entrySet().stream()
                // missing IDs in the natural ID to entity ID map can result in an invalid permission scope builder
                // that is neither statewide nor containing any schools and districts so this will filter those out
                .filter(entry -> entry.getValue().isValid())
                .map(entry -> new Permission(entry.getKey(), entry.getValue().build()))
                .collect(toSet());


        // add the teacher group permissions if the user qualifies for them
        final Set<PermissionScope> teacherGroupPermissionScopes = teacherGroupPermissionScopes(permissions);
        if (!teacherGroupPermissionScopes.isEmpty()) {
            permissions.addAll(teacherGroupPermissions(
                    mergePermissionScopes(teacherGroupPermissionScopes)
            ));
        }

        return permissions;
    }

    private Map<String, Collection<String>> getPermissionsByRole() {
        try {
            return permissionService.getPermissionsByRole();
        } catch (PermissionServiceException exception) {
            throw new RuntimeException("Failed to get permissions", exception);
        }
    }

    private void addDistrictGroup(final PermissionScope.Builder builder, final String entityId, final Map<String, Long> idsByNaturalId) {
        final Long id = idsByNaturalId.get(entityId);
        if (id != null) {
            builder.addDistrictGroupId(id);
        } else {
            logger.warn("grant district group with natural ID \"{}\" not found", entityId);
        }
    }

    private void addDistrict(final PermissionScope.Builder builder, final String entityId, final Map<String, Long> idsByNaturalId) {
        final Long id = idsByNaturalId.get(entityId);
        if (id != null) {
            builder.addDistrictId(id);
        } else {
            logger.warn("grant district with natural ID \"{}\" not found", entityId);
        }
    }

    private void addSchoolGroup(final PermissionScope.Builder builder, final String entityId, final Map<String, Long> idsByNaturalId) {
        final Long id = idsByNaturalId.get(entityId);
        if (id != null) {
            builder.addSchoolGroupId(id);
        } else {
            logger.warn("grant school group with natural ID \"{}\" not found", entityId);
        }
    }

    private void addSchool(final PermissionScope.Builder builder, final String entityId, final Map<String, Long> idsByNaturalId) {
        final Long id = idsByNaturalId.get(entityId);
        if (id != null) {
            builder.addSchoolId(id);
        } else {
            logger.warn("grant school with natural ID \"{}\" not found", entityId);
        }
    }

    private Set<Authority> createAuthorities(
            final String entityId,
            final Grant.Level level,
            final String... reportingRoles) {
        return Arrays.stream(reportingRoles)
                .map(role ->
                        Authority.builder()
                                .role(role)
                                .level(level)
                                .entityId(entityId)
                                .build()
                )
                .collect(toSet());
    }

    private static Optional<Grant> toGrant(final String encodedGrant) {
        try {
            return Optional.of(Grant.fromString(encodedGrant));
        } catch (final IllegalArgumentException exception) {
            // in a well-behaved and properly configured ecosystem this should never happen
            // so log a WARN level message so the log may be monitored
            logger.warn("invalid grant: {}", encodedGrant);
            return Optional.empty();
        }
    }

    /**
     * Checks if the provided permission scope is limited to school level access
     *
     * @param permissionScope the permission scope to check
     * @return <code>true</code> if the permission scope is limited to schools
     */
    private boolean isSchoolLevel(final PermissionScope permissionScope) {
        return !permissionScope.isStatewide()
                && permissionScope.getDistrictGroupIds().isEmpty()
                && permissionScope.getDistrictIds().isEmpty()
                && permissionScope.getInstitutionGroupIds().isEmpty()
                && !permissionScope.getInstitutionIds().isEmpty();
    }

    private PermissionScope mergePermissionScopes(final Iterable<PermissionScope> scopes) {
        final PermissionScope.Builder builder = PermissionScope.builder();
        for (final PermissionScope scope : scopes) {
            builder.addSchoolIds(scope.getInstitutionIds());
            builder.addSchoolGroupIds(scope.getInstitutionGroupIds());
            builder.addDistrictIds(scope.getDistrictIds());
            builder.addDistrictGroupIds(scope.getDistrictGroupIds());
        }
        return builder.build();
    }

    private Set<PermissionScope> teacherGroupPermissionScopes(final Collection<Permission> permissions) {
        return permissions.stream()
                .filter(permission -> ReportingPermission.GroupPiiRead.equals(permission.getId())
                || ReportingPermission.IndividualPiiRead.equals(permission.getId()))
                .map(Permission::getScope)
                .filter(this::isSchoolLevel)
                .collect(toSet());
    }

    private Set<Permission> teacherGroupPermissions(final PermissionScope scope) {
        return newHashSet(
                new Permission(ReportingPermission.TeacherGroupRead, scope),
                new Permission(ReportingPermission.TeacherGroupWrite, scope)
        );
    }

}
