package org.opentestsystem.rdw.reporting.security.session;

import org.junit.Test;
import org.opensaml.Configuration;
import org.opensaml.DefaultBootstrap;
import org.opensaml.saml2.core.Response;
import org.opensaml.xml.io.Unmarshaller;
import org.opensaml.xml.io.UnmarshallerFactory;
import org.opensaml.xml.parse.BasicParserPool;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.JdkSerializationRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializer;
import org.springframework.data.redis.serializer.SerializationException;
import org.springframework.security.saml.parser.SAMLObject;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

import java.io.InputStream;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * In production, there was a situation where a user had 400 role grants as part of their SAML configuration.
 * That produced a SAML response object that serialized to >64k causing an error. This test is an attempt to
 * reproduce the problem and play with possible solutions.<br/>
 *
 * The serialization happens inside a RedisTemplate which is configured by spring auto configuration to use
 * {@link JdkSerializationRedisSerializer}, which is the basic cause of the problem. This test tries a few other
 * serializers but none of them seem to work.
 */
public class RedisSerializationTest {

//    @Before
//    public void createRedisOps() {
//        final RedisTemplate<String, Object> template = new RedisTemplate<>();
//        template.setKeySerializer(new StringRedisSerializer());
//        template.setHashKeySerializer(new StringRedisSerializer());
//        template.setHashValueSerializer(new JdkSerializationRedisSerializer());
//    }

    @Test
    public void defaultCanSerializeAValue() {
        // a simple test to show that basic serialization works with the default serializer
        final RedisSerializer<Object> serializer = new JdkSerializationRedisSerializer();

        final String value = "test value";
        final byte[] data = serializer.serialize(value);
        assertThat(serializer.deserialize(data)).isEqualTo(value);
    }

    @Test(expected = SerializationException.class)
    public void defaultCannotSerializeALargeValue() throws Exception {
        // this is the situation where the SAML response is large and serialization fails
        // throws UTFDataFormatException because length of output is >64k
        serializeLargeSamlObjectResponse(new JdkSerializationRedisSerializer());
    }

    @Test(expected = SerializationException.class)
    public void genericCannotSerializeSamlResponse() throws Exception {
        // throws JsonMappingException because Node doesn't implement Type id handling
        // NOTE: this happens with or without SAMLObject wrapping (which seems odd to me)
        serializeLargeSamlObjectResponse(new GenericJackson2JsonRedisSerializer());
    }

    @Test(expected = SerializationException.class)
    public void jacksonCannotSerializeSamlResponse() throws Exception {
        // throws StackOverflowError; gets confused by Issuer perhaps because it occurs in two places in hierarchy (?)
        // NOTE: this happens with or without SAMLObject wrapping
        serializeLargeSamlObjectResponse(new Jackson2JsonRedisSerializer<>(SAMLObject.class));
    }

    private void serializeLargeSamlObjectResponse(final RedisSerializer<? super SAMLObject> serializer) throws Exception {
        final Response response = readResponseFromResource("/samlResponse.large.xml");
        assertThat(response).isNotNull();

        // this simulates what the RedisTemplate does, wrapping the non-serializable class in SAMLObject
        // NOTE: i had a test that skipped the wrapping but all the tests failed in the same way
        final SAMLObject<Response> object = new SAMLObject<>(response);
        final byte[] data = serializer.serialize(object);
        assertThat(data.length).isGreaterThan(65535);

        final SAMLObject<Response> out = (SAMLObject<Response>) serializer.deserialize(data);
        assertThat(out).isNotNull();
    }

    private Response readResponseFromResource(final String resource) throws Exception {
        try (final InputStream is = this.getClass().getResourceAsStream(resource)) {
            DefaultBootstrap.bootstrap();
            final BasicParserPool pool = new BasicParserPool();
            pool.setNamespaceAware(true);
            final Document document = pool.parse(is);
            final Element root = document.getDocumentElement();

            final UnmarshallerFactory unmarshallerFactory = Configuration.getUnmarshallerFactory();
            final Unmarshaller unmarshaller = unmarshallerFactory.getUnmarshaller(root);
            return (Response) unmarshaller.unmarshall(root);
        }
    }
}
