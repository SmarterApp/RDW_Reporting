package org.opentestsystem.rdw.reporting.security.auth;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.rdw.reporting.security.GroupGrant;
import org.opentestsystem.rdw.reporting.security.Permission;
import org.opentestsystem.rdw.reporting.security.PermissionScope;
import org.opentestsystem.rdw.security.Grant;
import org.opentestsystem.rdw.security.service.PermissionService;
import org.springframework.security.core.authority.SimpleGrantedAuthority;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

public class DefaultAuthorizationServiceTest {

    private final String stateA = "stateA";
    private final String stateB = "stateB";
    private PermissionService permissionService;
    private DistrictRepository districtRepository;
    private InstitutionRepository institutionRepository;
    private GroupGrantRepository groupMembershipRepository;
    private DefaultAuthorizationService authorizationService;

    @Before
    public void before() throws Exception {
        permissionService = mock(PermissionService.class);
        districtRepository = mock(DistrictRepository.class);
        institutionRepository = mock(InstitutionRepository.class);
        groupMembershipRepository = mock(GroupGrantRepository.class);
        authorizationService = new DefaultAuthorizationService(stateA, permissionService, districtRepository, institutionRepository, groupMembershipRepository);

        when(permissionService.getPermissionsByRole()).thenReturn(ImmutableMap.of(
                "a", ImmutableSet.of("a"),
                "b", ImmutableSet.of("b"),
                "c", ImmutableSet.of("c"),
                "d", ImmutableSet.of("d", "f"),
                "e", ImmutableSet.of()
        ));
        when(districtRepository.findAllIds(ImmutableSet.of("a"))).thenReturn(ImmutableMap.of("a", 1L));
        when(institutionRepository.findAllIds(ImmutableSet.of("a"))).thenReturn(ImmutableMap.of("a", 1L));
        when(groupMembershipRepository.findAllForUsername("a")).thenReturn(ImmutableList.of(new GroupGrant(1L, 1L)));
    }

    @Test
    public void getGrantsShouldOnlyIncludeGrantsForTheSpecifiedState() throws Exception {
        final String[] encodedGrants = {"|stateA|roleA|STATE|||||stateA||||||||||", "|stateB|roleA|STATE|||||stateB||||||||||"};
        assertThat(authorizationService.getGrants(encodedGrants))
                .containsExactlyInAnyOrder(
                        Grant.builder().entityId(stateA).role("roleA").entityLevel(Grant.EntityLevel.STATE).stateId(stateA).build()
                );
    }

    @Test
    public void getPermissionsShouldCorrectlyDerivePermissionsFromGrants() throws Exception {
        final List<Grant> grants = ImmutableList.of(
                Grant.builder().entityId("a").role("a").entityLevel(Grant.EntityLevel.STATE).stateId("a").build(),
                Grant.builder().entityId("a").role("b").entityLevel(Grant.EntityLevel.DISTRICT).stateId("a").districtId("a").build(),
                Grant.builder().entityId("a").role("c").entityLevel(Grant.EntityLevel.INSTITUTION).stateId("a").districtId("a").institutionId("a").build(),
                Grant.builder().entityId("a").role("d").entityLevel(Grant.EntityLevel.DISTRICT).stateId("a").districtId("a").build(),
                Grant.builder().entityId("a").role("d").entityLevel(Grant.EntityLevel.INSTITUTION).stateId("a").districtId("a").institutionId("a").build()
        );

        assertThat(authorizationService.getPermissions(grants))
                .usingRecursiveFieldByFieldElementComparator()
                .containsExactlyInAnyOrder(
                        new Permission("a", new PermissionScope(null, null)),
                        new Permission("b", new PermissionScope(ImmutableSet.of(1L), null)),
                        new Permission("c", new PermissionScope(null, ImmutableSet.of(1L))),
                        new Permission("d", new PermissionScope(ImmutableSet.of(1L), ImmutableSet.of(1L))),
                        new Permission("f", new PermissionScope(ImmutableSet.of(1L), ImmutableSet.of(1L)))
                );
    }

    @Test
    public void getAuthoritiesShouldOnlyReturnStateLevelRolesAndPermissions() throws Exception {
        assertThat(authorizationService.getAuthorities(ImmutableList.of(
                Grant.builder().entityId("a").role("a").entityLevel(Grant.EntityLevel.STATE).stateId("a").build(),
                Grant.builder().entityId("a").role("b").entityLevel(Grant.EntityLevel.DISTRICT).stateId("a").districtId("a").build(),
                Grant.builder().entityId("a").role("c").entityLevel(Grant.EntityLevel.INSTITUTION).stateId("a").districtId("a").institutionId("a").build()
        ))).containsExactlyInAnyOrder(
                new SimpleGrantedAuthority("ROLE_A"),
                new SimpleGrantedAuthority("PERM_A")
        );
    }

    @Test
    public void getAuthoritiesShouldIgnoreRolesNotProvidedByThePermissionService() throws Exception {
        assertThat(authorizationService.getAuthorities(ImmutableList.of(
                Grant.builder().entityId("a").role("z").entityLevel(Grant.EntityLevel.STATE).stateId("a").build()
        ))).isEmpty();
    }

    @Test
    public void getAuthoritiesShouldNotFailIfThereAreNoPermissionsForAGivenRole() throws Exception {
        assertThat(authorizationService.getAuthorities(ImmutableList.of(
                Grant.builder().entityId("a").role("e").entityLevel(Grant.EntityLevel.STATE).stateId("a").build()
        ))).containsExactlyInAnyOrder(
                new SimpleGrantedAuthority("ROLE_E")
        );
    }

    @Test
    public void getAuthoritiesShouldReturnAllStateLevelRolesAndPermissions() throws Exception {
        assertThat(authorizationService.getAuthorities(ImmutableList.of(
                Grant.builder().entityId("a").role("a").entityLevel(Grant.EntityLevel.STATE).stateId("a").build(),
                Grant.builder().entityId("a").role("b").entityLevel(Grant.EntityLevel.STATE).stateId("a").build(),
                Grant.builder().entityId("a").role("c").entityLevel(Grant.EntityLevel.STATE).stateId("a").build(),
                Grant.builder().entityId("a").role("d").entityLevel(Grant.EntityLevel.STATE).stateId("a").build()
        ))).containsExactlyInAnyOrder(
                new SimpleGrantedAuthority("ROLE_A"),
                new SimpleGrantedAuthority("PERM_A"),
                new SimpleGrantedAuthority("ROLE_B"),
                new SimpleGrantedAuthority("PERM_B"),
                new SimpleGrantedAuthority("ROLE_C"),
                new SimpleGrantedAuthority("PERM_C"),
                new SimpleGrantedAuthority("ROLE_D"),
                new SimpleGrantedAuthority("PERM_D"),
                new SimpleGrantedAuthority("PERM_F")
        );
    }

    @Test
    public void getGroupsByIdShouldReturnEmptyIfTheUserDoesNotHaveGroupPII() throws Exception {
        assertThat(authorizationService.getGroupsById(ImmutableSet.of(), "a")).isEmpty();
    }

    @Test
    public void getGroupsByIdShouldReturnAllOfTheGroupsAssociatedWithTheUsernameForUsersWithGroupPII() throws Exception {
        assertThat(authorizationService.getGroupsById(ImmutableSet.of(new Permission("GROUP_PII_READ", PermissionScope.STATEWIDE)), "a"))
                .isEqualTo(ImmutableMap.of(1L, new GroupGrant(1L, 1L)));
    }

}